--[[
╔═══════════════════════════════════════════════════════════════════════════════╗
║                                                                               ║
║   ███╗   ██╗███████╗██╗  ██╗██╗   ██╗███████╗██╗   ██╗██╗                     ║
║   ████╗  ██║██╔════╝╚██╗██╔╝██║   ██║██╔════╝██║   ██║██║                     ║
║   ██╔██╗ ██║█████╗   ╚███╔╝ ██║   ██║███████╗██║   ██║██║                     ║
║   ██║╚██╗██║██╔══╝   ██╔██╗ ██║   ██║╚════██║██║   ██║██║                     ║
║   ██║ ╚████║███████╗██╔╝ ██╗╚██████╔╝███████║╚██████╔╝██║                     ║
║   ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚══════╝ ╚═════╝ ╚═╝                     ║
║                                                                               ║
║   Premium UI Library for Roblox Executors                                     ║
║   Version: 1.0.0 | Compiled: 2026-01-19 21:05:21                          ║
║                                                                               ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║   Features:                                                                   ║
║   • 25+ Beautiful Themes with Liquid Glass Effects                            ║
║   • Advanced Animation Engine with Springs & Easing                           ║
║   • Comprehensive Component Library (50+ Components)                          ║
║   • Performance Monitoring (FPS, Memory, Network)                             ║
║   • ESP, Aimbot, and Executor-Specific Components                             ║
║   • Builder Patterns for Easy UI Creation                                     ║
║   • Sound System & Global Hotkey Management                                   ║
║   • Config Save/Load with Cloud Sync Support                                  ║
║                                                                               ║
║   Usage:                                                                      ║
║       local NexusUI = loadstring(game:HttpGet("URL"))()                       ║
║       local Window = NexusUI:CreateWindow({ Title = "My Script" })           ║
║                                                                               ║
╚═══════════════════════════════════════════════════════════════════════════════╝
--]]

-- ============================================================================
-- NexusUI Runtime Module System
-- ============================================================================

local NexusUI_Modules = {}
local NexusUI_Loaded = {}

local function NexusRequire(modulePath)
    -- Check if already loaded
    if NexusUI_Loaded[modulePath] then
        return NexusUI_Loaded[modulePath]
    end
    
    -- Check if module exists
    local moduleFunc = NexusUI_Modules[modulePath]
    if moduleFunc then
        local result = moduleFunc()
        NexusUI_Loaded[modulePath] = result
        return result
    end
    
    -- Module not found
    warn("[NexusUI] Module not found:", modulePath)
    return nil
end

-- Mock script object for module compatibility
local function CreateMockScript(modulePath)
    local parts = {}
    for part in modulePath:gmatch("[^/]+") do
        table.insert(parts, part)
    end
    
    local mock = {
        Name = parts[#parts]:gsub("%.lua$", ""),
    }
    
    -- Create Parent chain
    local current = mock
    for i = #parts - 1, 1, -1 do
        local parent = { Name = parts[i]:gsub("%.lua$", "") }
        current.Parent = parent
        current = parent
    end
    
    return mock
end


-- ============================================================================
-- Module: NexusUI/Core/Services
-- ============================================================================
NexusUI_Modules["NexusUI/Core/Services"] = function()
    local script = CreateMockScript("NexusUI/Core/Services")
    
    --[[
        NexusUI Services Module
        Cached access to Roblox services for optimal performance

        Features:
        - Lazy loading of services
        - Service caching
        - Safe service access
        - Service availability checking
        - Mock services for testing
    ]]

    --// Service Cache
    local ServiceCache = {}
    local ServiceAvailability = {}

    --// Service Definitions
    local ServiceDefinitions = {
        -- Core Services
        Players = "Players",
        RunService = "RunService",
        UserInputService = "UserInputService",
        TweenService = "TweenService",
        HttpService = "HttpService",
        ContentProvider = "ContentProvider",
        TextService = "TextService",
        GuiService = "GuiService",

        -- Storage Services
        ReplicatedStorage = "ReplicatedStorage",
        ServerStorage = "ServerStorage",
        ServerScriptService = "ServerScriptService",
        StarterGui = "StarterGui",
        StarterPlayer = "StarterPlayer",
        StarterPack = "StarterPack",

        -- Game Services
        Workspace = "Workspace",
        Lighting = "Lighting",
        SoundService = "SoundService",
        Chat = "Chat",
        Teams = "Teams",

        -- Player Services
        CoreGui = "CoreGui",
        LocalizationService = "LocalizationService",
        PolicyService = "PolicyService",

        -- Network Services
        NetworkClient = "NetworkClient",
        NetworkServer = "NetworkServer",

        -- Physics Services
        PhysicsService = "PhysicsService",

        -- Other Services
        MarketplaceService = "MarketplaceService",
        BadgeService = "BadgeService",
        GamePassService = "GamePassService",
        AssetService = "AssetService",
        InsertService = "InsertService",

        -- Social Services
        SocialService = "SocialService",
        FriendService = "FriendService",

        -- Input Services
        ContextActionService = "ContextActionService",
        HapticService = "HapticService",
        VRService = "VRService",

        -- Analytics Services
        AnalyticsService = "AnalyticsService",

        -- Memory Services
        MemoryStoreService = "MemoryStoreService",

        -- Messaging Services
        MessagingService = "MessagingService",

        -- DataStore Services
        DataStoreService = "DataStoreService",

        -- Collision Services
        CollectionService = "CollectionService",

        -- Debris Service
        Debris = "Debris",

        -- Path Services
        PathfindingService = "PathfindingService",

        -- Tele Services
        TeleportService = "TeleportService",

        -- Script Services
        ScriptContext = "ScriptContext",

        -- Log Services
        LogService = "LogService",

        -- Stats Services
        Stats = "Stats",

        -- Testing Services
        TestService = "TestService",

        -- Selection Service
        Selection = "Selection",

        -- Change History Service
        ChangeHistoryService = "ChangeHistoryService",

        -- Keyframe Sequence Provider
        KeyframeSequenceProvider = "KeyframeSequenceProvider",

        -- Animation Services
        AnimationClipProvider = "AnimationClipProvider",

        -- Proximity Services
        ProximityPromptService = "ProximityPromptService",

        -- Material Service
        MaterialService = "MaterialService",

        -- Dragger Service
        DraggerService = "DraggerService",

        -- Instance Provider
        InstanceAdornmentService = "InstanceAdornmentService",
    }

    --// Services Module
    local Services = {}
    Services.__index = Services

    --// Metatable for lazy loading
    setmetatable(Services, {
        __index = function(self, serviceName)
            return self:GetService(serviceName)
        end
    })

    --// Internal Functions
    local function SafeGetService(serviceName)
        local success, service = pcall(function()
            return game:GetService(serviceName)
        end)

        if success and service then
            ServiceAvailability[serviceName] = true
            return service
        else
            ServiceAvailability[serviceName] = false
            return nil
        end
    end

    --// Public Methods
    function Services:GetService(serviceName)
        -- Check cache first
        if ServiceCache[serviceName] then
            return ServiceCache[serviceName]
        end

        -- Get the actual service name from definitions
        local actualServiceName = ServiceDefinitions[serviceName] or serviceName

        -- Try to get the service
        local service = SafeGetService(actualServiceName)

        if service then
            ServiceCache[serviceName] = service
        end

        return service
    end

    function Services:IsServiceAvailable(serviceName)
        if ServiceAvailability[serviceName] ~= nil then
            return ServiceAvailability[serviceName]
        end

        -- Try to get the service to check availability
        local service = self:GetService(serviceName)
        return service ~= nil
    end

    function Services:GetAllServices()
        local services = {}

        for name, _ in pairs(ServiceDefinitions) do
            local service = self:GetService(name)
            if service then
                services[name] = service
            end
        end

        return services
    end

    function Services:GetAvailableServices()
        local available = {}

        for name, _ in pairs(ServiceDefinitions) do
            if self:IsServiceAvailable(name) then
                table.insert(available, name)
            end
        end

        return available
    end

    function Services:GetUnavailableServices()
        local unavailable = {}

        for name, _ in pairs(ServiceDefinitions) do
            if not self:IsServiceAvailable(name) then
                table.insert(unavailable, name)
            end
        end

        return unavailable
    end

    function Services:ClearCache()
        ServiceCache = {}
        ServiceAvailability = {}
    end

    function Services:PreloadServices(serviceNames)
        serviceNames = serviceNames or {}

        if #serviceNames == 0 then
            -- Preload common services
            serviceNames = {
                "Players",
                "RunService",
                "UserInputService",
                "TweenService",
                "HttpService",
                "TextService",
                "ContentProvider",
                "GuiService",
                "SoundService",
                "Workspace",
                "Lighting",
                "ReplicatedStorage",
                "CoreGui",
                "Debris",
                "CollectionService",
            }
        end

        for _, name in ipairs(serviceNames) do
            self:GetService(name)
        end
    end

    function Services:GetCacheStats()
        local cached = 0
        local available = 0
        local unavailable = 0

        for _, _ in pairs(ServiceCache) do
            cached = cached + 1
        end

        for _, isAvailable in pairs(ServiceAvailability) do
            if isAvailable then
                available = available + 1
            else
                unavailable = unavailable + 1
            end
        end

        return {
            Cached = cached,
            Available = available,
            Unavailable = unavailable,
            Total = cached + unavailable
        }
    end

    --// Quick Access Properties (commonly used services)
    Services.Players = nil
    Services.RunService = nil
    Services.UserInputService = nil
    Services.TweenService = nil
    Services.HttpService = nil
    Services.TextService = nil
    Services.ContentProvider = nil
    Services.GuiService = nil
    Services.SoundService = nil
    Services.Workspace = nil
    Services.Lighting = nil
    Services.ReplicatedStorage = nil
    Services.CoreGui = nil
    Services.StarterGui = nil
    Services.Debris = nil
    Services.CollectionService = nil

    --// Initialize quick access
    local function InitializeQuickAccess()
        local quickServices = {
            "Players",
            "RunService",
            "UserInputService",
            "TweenService",
            "HttpService",
            "TextService",
            "ContentProvider",
            "GuiService",
            "SoundService",
            "Workspace",
            "Lighting",
            "ReplicatedStorage",
            "CoreGui",
            "StarterGui",
            "Debris",
            "CollectionService",
        }

        for _, name in ipairs(quickServices) do
            rawset(Services, name, Services:GetService(name))
        end
    end

    -- Delay initialization slightly to ensure game is loaded
    task.defer(InitializeQuickAccess)

    --// Local Player Access
    function Services:GetLocalPlayer()
        local Players = self:GetService("Players")
        return Players and Players.LocalPlayer
    end

    function Services:GetPlayerGui()
        local player = self:GetLocalPlayer()
        return player and player:FindFirstChild("PlayerGui")
    end

    function Services:GetMouse()
        local player = self:GetLocalPlayer()
        return player and player:GetMouse()
    end

    function Services:GetCamera()
        local Workspace = self:GetService("Workspace")
        return Workspace and Workspace.CurrentCamera
    end

    function Services:GetCharacter()
        local player = self:GetLocalPlayer()
        return player and player.Character
    end

    function Services:GetHumanoid()
        local character = self:GetCharacter()
        return character and character:FindFirstChildOfClass("Humanoid")
    end

    function Services:GetRootPart()
        local character = self:GetCharacter()
        return character and character:FindFirstChild("HumanoidRootPart")
    end

    --// Utility Functions
    function Services:WaitForService(serviceName, timeout)
        timeout = timeout or 10
        local startTime = os.clock()

        while os.clock() - startTime < timeout do
            local service = self:GetService(serviceName)
            if service then
                return service
            end
            task.wait(0.1)
        end

        return nil
    end

    function Services:OnServiceReady(serviceName, callback)
        local service = self:GetService(serviceName)

        if service then
            callback(service)
            return
        end

        -- Poll for service
        task.spawn(function()
            local service = self:WaitForService(serviceName)
            if service then
                callback(service)
            end
        end)
    end

    return Services


end


-- ============================================================================
-- Module: NexusUI/Core/SignalClass
-- ============================================================================
NexusUI_Modules["NexusUI/Core/SignalClass"] = function()
    local script = CreateMockScript("NexusUI/Core/SignalClass")
    
    --[[
        NexusUI Signal Class
        A robust signal/event implementation for the UI library

        Features:
        - Signal creation and management
        - Connection handling with automatic cleanup
        - Once connections (fire once then disconnect)
        - Wait functionality with timeout
        - Priority-based firing
        - Connection throttling and debouncing
        - Error handling and logging
        - Memory leak prevention
    ]]

    --// Signal Connection Class
    local Connection = {}
    Connection.__index = Connection

    function Connection.new(signal, callback, options)
        options = options or {}

        local self = setmetatable({}, Connection)

        self._signal = signal
        self._callback = callback
        self._connected = true
        self._once = options.Once or false
        self._priority = options.Priority or 0
        self._throttle = options.Throttle or 0
        self._debounce = options.Debounce or 0
        self._lastFire = 0
        self._id = options.Id or tostring(os.clock()) .. "_" .. tostring(math.random(1000000))
        self._name = options.Name or "Connection"
        self._metadata = options.Metadata or {}

        -- Debounce state
        self._debounceScheduled = false
        self._debounceArgs = nil

        return self
    end

    function Connection:Disconnect()
        if not self._connected then
            return
        end

        self._connected = false

        if self._signal then
            self._signal:_removeConnection(self)
            self._signal = nil
        end

        self._callback = nil
    end

    function Connection:IsConnected()
        return self._connected
    end

    function Connection:GetPriority()
        return self._priority
    end

    function Connection:SetPriority(priority)
        self._priority = priority
        if self._signal then
            self._signal:_sortConnections()
        end
    end

    function Connection:GetId()
        return self._id
    end

    function Connection:GetName()
        return self._name
    end

    function Connection:GetMetadata()
        return self._metadata
    end

    function Connection:_fire(...)
        if not self._connected then
            return false
        end

        local now = os.clock()

        -- Throttle check
        if self._throttle > 0 then
            if now - self._lastFire < self._throttle then
                return false
            end
        end

        -- Debounce handling
        if self._debounce > 0 then
            self._debounceArgs = {...}

            if not self._debounceScheduled then
                self._debounceScheduled = true

                task.delay(self._debounce, function()
                    if self._connected and self._debounceArgs then
                        self:_executeCallback(unpack(self._debounceArgs))
                    end
                    self._debounceScheduled = false
                    self._debounceArgs = nil
                end)
            end

            return true
        end

        -- Direct execution
        self._lastFire = now
        self:_executeCallback(...)

        -- Handle once connections
        if self._once then
            self:Disconnect()
        end

        return true
    end

    function Connection:_executeCallback(...)
        if not self._callback then return end

        local success, err = pcall(self._callback, ...)

        if not success then
            warn(string.format("[NexusUI.Signal] Connection '%s' error: %s", self._name, tostring(err)))
        end
    end

    --// Signal Class
    local Signal = {}
    Signal.__index = Signal

    --// Signal Pool for reuse
    local SignalPool = {}
    local MaxPoolSize = 50

    function Signal.new(name)
        -- Try to get from pool
        local signal = table.remove(SignalPool)

        if signal then
            signal._name = name or "Signal"
            signal._destroyed = false
            return signal
        end

        -- Create new signal
        local self = setmetatable({}, Signal)

        self._name = name or "Signal"
        self._connections = {}
        self._connectionCount = 0
        self._destroyed = false
        self._firing = false
        self._fireCount = 0
        self._lastFireTime = 0
        self._waitingThreads = {}
        self._middleware = {}

        return self
    end

    function Signal:Connect(callback, options)
        if self._destroyed then
            warn(string.format("[NexusUI.Signal] Attempted to connect to destroyed signal '%s'", self._name))
            return nil
        end

        if type(callback) ~= "function" then
            warn("[NexusUI.Signal] Connect requires a function callback")
            return nil
        end

        options = options or {}

        local connection = Connection.new(self, callback, options)

        table.insert(self._connections, connection)
        self._connectionCount = self._connectionCount + 1

        -- Sort by priority if needed
        if options.Priority and options.Priority ~= 0 then
            self:_sortConnections()
        end

        return connection
    end

    function Signal:Once(callback, options)
        options = options or {}
        options.Once = true
        return self:Connect(callback, options)
    end

    function Signal:Wait(timeout)
        if self._destroyed then
            return nil
        end

        timeout = timeout or 30

        local thread = coroutine.running()
        local result = nil
        local timedOut = false

        -- Create waiting entry
        local waitEntry = {
            Thread = thread,
            StartTime = os.clock(),
            Timeout = timeout
        }

        table.insert(self._waitingThreads, waitEntry)

        -- Set up timeout
        local timeoutThread = task.delay(timeout, function()
            timedOut = true

            -- Remove from waiting threads
            for i, entry in ipairs(self._waitingThreads) do
                if entry == waitEntry then
                    table.remove(self._waitingThreads, i)
                    break
                end
            end

            -- Resume with nil
            if coroutine.status(thread) == "suspended" then
                task.spawn(thread)
            end
        end)

        -- Wait for signal
        result = {coroutine.yield()}

        -- Cancel timeout if not timed out
        if not timedOut then
            task.cancel(timeoutThread)
        end

        if timedOut then
            return nil
        end

        return unpack(result)
    end

    function Signal:Fire(...)
        if self._destroyed then
            return
        end

        -- Prevent recursive firing issues
        if self._firing then
            task.defer(function()
                self:Fire(...)
            end)
            return
        end

        self._firing = true
        self._fireCount = self._fireCount + 1
        self._lastFireTime = os.clock()

        -- Process middleware
        local args = {...}
        for _, middleware in ipairs(self._middleware) do
            local success, result = pcall(middleware, unpack(args))
            if success and result ~= nil then
                if type(result) == "table" then
                    args = result
                else
                    args = {result}
                end
            end
        end

        -- Fire to all connections
        local connectionsToFire = {}
        for _, connection in ipairs(self._connections) do
            table.insert(connectionsToFire, connection)
        end

        for _, connection in ipairs(connectionsToFire) do
            connection:_fire(unpack(args))
        end

        -- Resume waiting threads
        local threadsToResume = {}
        for _, entry in ipairs(self._waitingThreads) do
            table.insert(threadsToResume, entry)
        end
        self._waitingThreads = {}

        for _, entry in ipairs(threadsToResume) do
            if coroutine.status(entry.Thread) == "suspended" then
                task.spawn(entry.Thread, unpack(args))
            end
        end

        self._firing = false
    end

    function Signal:FireDeferred(...)
        task.defer(function(...)
            self:Fire(...)
        end, ...)
    end

    function Signal:FireDelayed(delay, ...)
        local args = {...}
        task.delay(delay, function()
            self:Fire(unpack(args))
        end)
    end

    function Signal:DisconnectAll()
        local connections = self._connections
        self._connections = {}
        self._connectionCount = 0

        for _, connection in ipairs(connections) do
            connection._connected = false
            connection._signal = nil
            connection._callback = nil
        end
    end

    function Signal:GetConnectionCount()
        return self._connectionCount
    end

    function Signal:GetFireCount()
        return self._fireCount
    end

    function Signal:GetLastFireTime()
        return self._lastFireTime
    end

    function Signal:GetName()
        return self._name
    end

    function Signal:IsDestroyed()
        return self._destroyed
    end

    function Signal:AddMiddleware(middleware)
        if type(middleware) ~= "function" then
            warn("[NexusUI.Signal] Middleware must be a function")
            return
        end

        table.insert(self._middleware, middleware)
    end

    function Signal:RemoveMiddleware(middleware)
        for i, mw in ipairs(self._middleware) do
            if mw == middleware then
                table.remove(self._middleware, i)
                return true
            end
        end
        return false
    end

    function Signal:ClearMiddleware()
        self._middleware = {}
    end

    function Signal:_removeConnection(connection)
        for i, conn in ipairs(self._connections) do
            if conn == connection then
                table.remove(self._connections, i)
                self._connectionCount = self._connectionCount - 1
                break
            end
        end
    end

    function Signal:_sortConnections()
        table.sort(self._connections, function(a, b)
            return a:GetPriority() > b:GetPriority()
        end)
    end

    function Signal:Destroy()
        if self._destroyed then
            return
        end

        self._destroyed = true

        -- Disconnect all connections
        self:DisconnectAll()

        -- Clear waiting threads
        for _, entry in ipairs(self._waitingThreads) do
            if coroutine.status(entry.Thread) == "suspended" then
                task.spawn(entry.Thread)
            end
        end
        self._waitingThreads = {}

        -- Clear middleware
        self._middleware = {}

        -- Return to pool if space available
        if #SignalPool < MaxPoolSize then
            table.insert(SignalPool, self)
        end
    end

    --// Signal Manager (for managing multiple signals)
    local SignalManager = {}
    SignalManager.__index = SignalManager

    function SignalManager.new()
        local self = setmetatable({}, SignalManager)

        self._signals = {}

        return self
    end

    function SignalManager:CreateSignal(name)
        if self._signals[name] then
            warn(string.format("[NexusUI.SignalManager] Signal '%s' already exists", name))
            return self._signals[name]
        end

        local signal = Signal.new(name)
        self._signals[name] = signal

        return signal
    end

    function SignalManager:GetSignal(name)
        return self._signals[name]
    end

    function SignalManager:RemoveSignal(name)
        local signal = self._signals[name]
        if signal then
            signal:Destroy()
            self._signals[name] = nil
            return true
        end
        return false
    end

    function SignalManager:GetAllSignals()
        local signals = {}
        for name, signal in pairs(self._signals) do
            signals[name] = signal
        end
        return signals
    end

    function SignalManager:GetSignalNames()
        local names = {}
        for name, _ in pairs(self._signals) do
            table.insert(names, name)
        end
        return names
    end

    function SignalManager:GetSignalCount()
        local count = 0
        for _ in pairs(self._signals) do
            count = count + 1
        end
        return count
    end

    function SignalManager:DestroyAll()
        for _, signal in pairs(self._signals) do
            signal:Destroy()
        end
        self._signals = {}
    end

    --// Export
    Signal.Connection = Connection
    Signal.Manager = SignalManager

    return Signal


end


-- ============================================================================
-- Module: NexusUI/Core/Maid
-- ============================================================================
NexusUI_Modules["NexusUI/Core/Maid"] = function()
    local script = CreateMockScript("NexusUI/Core/Maid")
    
    --[[
        NexusUI Maid Class
        Resource cleanup and lifecycle management utility

        Features:
        - Automatic cleanup of connections, instances, and functions
        - Nested maid support
        - Task scheduling with cleanup
        - Thread management
        - Promise cleanup
        - Memory leak prevention
        - Debug tracking
    ]]

    --// Maid Class
    local Maid = {}
    Maid.__index = Maid
    Maid.ClassName = "Maid"

    --// Debug Configuration
    local DEBUG_MODE = false
    local TRACK_TASKS = false
    local MAX_TASKS_WARNING = 1000

    --// Task Types
    local TaskType = {
        Connection = "Connection",
        Instance = "Instance",
        Function = "Function",
        Thread = "Thread",
        Promise = "Promise",
        Maid = "Maid",
        Signal = "Signal",
        Table = "Table",
        Unknown = "Unknown"
    }

    --// Utility Functions
    local function GetTaskType(task)
        if task == nil then
            return TaskType.Unknown
        end

        local taskType = typeof(task)

        if taskType == "RBXScriptConnection" then
            return TaskType.Connection
        elseif taskType == "Instance" then
            return TaskType.Instance
        elseif taskType == "function" then
            return TaskType.Function
        elseif taskType == "thread" then
            return TaskType.Thread
        elseif taskType == "table" then
            -- Check for specific table types
            if task.Destroy then
                if task.ClassName == "Maid" then
                    return TaskType.Maid
                elseif task._connections or task.Fire then
                    return TaskType.Signal
                end
                return TaskType.Instance
            elseif task.Disconnect then
                return TaskType.Connection
            elseif task.cancel or task.Cancel or task.andThen then
                return TaskType.Promise
            end
            return TaskType.Table
        end

        return TaskType.Unknown
    end

    local function CleanupTask(task, taskType)
        taskType = taskType or GetTaskType(task)

        local success, err = pcall(function()
            if taskType == TaskType.Connection then
                if task.Disconnect then
                    task:Disconnect()
                elseif task.disconnect then
                    task:disconnect()
                end
            elseif taskType == TaskType.Instance then
                if task.Destroy then
                    task:Destroy()
                end
            elseif taskType == TaskType.Function then
                task()
            elseif taskType == TaskType.Thread then
                if coroutine.status(task) ~= "dead" then
                    task.cancel(task)
                end
            elseif taskType == TaskType.Promise then
                if task.cancel then
                    task:cancel()
                elseif task.Cancel then
                    task:Cancel()
                end
            elseif taskType == TaskType.Maid then
                task:Destroy()
            elseif taskType == TaskType.Signal then
                if task.Destroy then
                    task:Destroy()
                elseif task.DisconnectAll then
                    task:DisconnectAll()
                end
            elseif taskType == TaskType.Table then
                if task.Destroy then
                    task:Destroy()
                elseif task.Disconnect then
                    task:Disconnect()
                elseif task.destroy then
                    task:destroy()
                end
            end
        end)

        if not success and DEBUG_MODE then
            warn(string.format("[NexusUI.Maid] Failed to cleanup task (%s): %s", taskType, tostring(err)))
        end

        return success
    end

    --// Constructor
    function Maid.new(name)
        local self = setmetatable({}, Maid)

        self._name = name or "Maid"
        self._tasks = {}
        self._taskCount = 0
        self._destroyed = false
        self._locked = false

        -- Debug tracking
        if TRACK_TASKS then
            self._taskHistory = {}
            self._cleanupHistory = {}
        end

        return self
    end

    --// Static Methods
    function Maid.IsMaid(value)
        return type(value) == "table" and value.ClassName == "Maid"
    end

    --// Task Management
    function Maid:GiveTask(task, key)
        if self._destroyed then
            -- Immediately cleanup if maid is destroyed
            CleanupTask(task)
            return nil
        end

        if self._locked then
            warn("[NexusUI.Maid] Cannot add tasks while maid is locked")
            return nil
        end

        if task == nil then
            return nil
        end

        -- Generate key if not provided
        if key == nil then
            self._taskCount = self._taskCount + 1
            key = self._taskCount
        end

        -- Cleanup existing task with same key
        local existingTask = self._tasks[key]
        if existingTask then
            CleanupTask(existingTask)
        end

        -- Store task
        self._tasks[key] = task

        -- Track task if enabled
        if TRACK_TASKS then
            table.insert(self._taskHistory, {
                Key = key,
                Type = GetTaskType(task),
                AddedAt = os.clock()
            })
        end

        -- Warning for too many tasks
        if self._taskCount > MAX_TASKS_WARNING and DEBUG_MODE then
            warn(string.format("[NexusUI.Maid] '%s' has %d tasks, consider cleanup", self._name, self._taskCount))
        end

        return key
    end

    function Maid:Give(...)
        local keys = {}
        for _, task in ipairs({...}) do
            local key = self:GiveTask(task)
            table.insert(keys, key)
        end
        return unpack(keys)
    end

    function Maid:__index(key)
        if Maid[key] then
            return Maid[key]
        end
        return self._tasks[key]
    end

    function Maid:__newindex(key, value)
        if Maid[key] then
            rawset(self, key, value)
            return
        end

        if value == nil then
            -- Remove and cleanup task
            local task = self._tasks[key]
            if task then
                CleanupTask(task)
                self._tasks[key] = nil
            end
        else
            self:GiveTask(value, key)
        end
    end

    function Maid:RemoveTask(key)
        local task = self._tasks[key]

        if task then
            CleanupTask(task)
            self._tasks[key] = nil

            if TRACK_TASKS then
                table.insert(self._cleanupHistory, {
                    Key = key,
                    CleanedAt = os.clock()
                })
            end

            return true
        end

        return false
    end

    function Maid:GetTask(key)
        return self._tasks[key]
    end

    function Maid:HasTask(key)
        return self._tasks[key] ~= nil
    end

    function Maid:GetTaskCount()
        local count = 0
        for _ in pairs(self._tasks) do
            count = count + 1
        end
        return count
    end

    function Maid:GetTaskKeys()
        local keys = {}
        for key, _ in pairs(self._tasks) do
            table.insert(keys, key)
        end
        return keys
    end

    --// Connection Shortcuts
    function Maid:Connect(signal, callback)
        if not signal or not signal.Connect then
            warn("[NexusUI.Maid] Invalid signal passed to Connect")
            return nil
        end

        local connection = signal:Connect(callback)
        return self:GiveTask(connection)
    end

    function Maid:Once(signal, callback)
        if not signal or not signal.Once then
            warn("[NexusUI.Maid] Invalid signal passed to Once")
            return nil
        end

        local connection = signal:Once(callback)
        return self:GiveTask(connection)
    end

    function Maid:BindToRenderStep(name, priority, callback)
        local RunService = game:GetService("RunService")
        RunService:BindToRenderStep(name, priority, callback)

        return self:GiveTask(function()
            RunService:UnbindFromRenderStep(name)
        end)
    end

    --// Thread Management
    function Maid:Spawn(callback, ...)
        local thread = task.spawn(callback, ...)
        return self:GiveTask(thread)
    end

    function Maid:Defer(callback, ...)
        local thread = task.defer(callback, ...)
        return self:GiveTask(thread)
    end

    function Maid:Delay(duration, callback, ...)
        local args = {...}
        local cancelled = false

        local thread = task.delay(duration, function()
            if not cancelled then
                callback(unpack(args))
            end
        end)

        return self:GiveTask(function()
            cancelled = true
            task.cancel(thread)
        end)
    end

    function Maid:Wait(duration)
        local thread = coroutine.running()

        self:Delay(duration, function()
            if coroutine.status(thread) == "suspended" then
                task.spawn(thread)
            end
        end)

        coroutine.yield()
    end

    --// Instance Shortcuts
    function Maid:WrapInstance(instance)
        if not instance or not instance:IsA("Instance") then
            warn("[NexusUI.Maid] Invalid instance passed to WrapInstance")
            return nil
        end

        -- Add the instance for cleanup
        local key = self:GiveTask(instance)

        -- Also cleanup when instance is destroyed externally
        local connection = instance.Destroying:Connect(function()
            self._tasks[key] = nil
        end)
        self:GiveTask(connection)

        return key
    end

    --// Nested Maid
    function Maid:CreateSubMaid(name)
        name = name or self._name .. ".SubMaid"
        local subMaid = Maid.new(name)
        self:GiveTask(subMaid)
        return subMaid
    end

    --// Locking
    function Maid:Lock()
        self._locked = true
    end

    function Maid:Unlock()
        self._locked = false
    end

    function Maid:IsLocked()
        return self._locked
    end

    --// Cleanup
    function Maid:Clean()
        self:DoCleaning()
    end

    function Maid:DoCleaning()
        if self._destroyed then
            return
        end

        local tasks = self._tasks
        self._tasks = {}
        self._taskCount = 0

        -- Cleanup all tasks
        for key, task in pairs(tasks) do
            CleanupTask(task)

            if TRACK_TASKS then
                table.insert(self._cleanupHistory, {
                    Key = key,
                    CleanedAt = os.clock()
                })
            end
        end
    end

    function Maid:Destroy()
        if self._destroyed then
            return
        end

        self._destroyed = true
        self:DoCleaning()
    end

    function Maid:IsDestroyed()
        return self._destroyed
    end

    --// Debug Methods
    function Maid:GetName()
        return self._name
    end

    function Maid:SetName(name)
        self._name = name
    end

    function Maid:GetTaskHistory()
        return self._taskHistory or {}
    end

    function Maid:GetCleanupHistory()
        return self._cleanupHistory or {}
    end

    function Maid:PrintTasks()
        print(string.format("=== Maid '%s' Tasks ===", self._name))

        for key, task in pairs(self._tasks) do
            local taskType = GetTaskType(task)
            print(string.format("  [%s] %s: %s", tostring(key), taskType, tostring(task)))
        end

        print(string.format("Total: %d tasks", self:GetTaskCount()))
    end

    --// Metamethods
    function Maid:__tostring()
        return string.format("Maid<%s>(%d tasks)", self._name, self:GetTaskCount())
    end

    --// Enable debug mode
    function Maid.EnableDebug(enabled)
        DEBUG_MODE = enabled
    end

    function Maid.EnableTaskTracking(enabled)
        TRACK_TASKS = enabled
    end

    function Maid.SetMaxTasksWarning(count)
        MAX_TASKS_WARNING = count
    end

    return Maid


end


-- ============================================================================
-- Module: NexusUI/Core/Promise
-- ============================================================================
NexusUI_Modules["NexusUI/Core/Promise"] = function()
    local script = CreateMockScript("NexusUI/Core/Promise")
    
    --[[
        NexusUI Promise Implementation
        A robust Promise/A+ compliant promise library

        Features:
        - Promise/A+ compliance
        - Chaining with then/catch/finally
        - Promise.all, Promise.race, Promise.allSettled
        - Timeout support
        - Retry functionality
        - Cancellation support
        - Progress tracking
        - Error handling and stack traces
    ]]

    --// Promise States
    local PromiseState = {
        Pending = "Pending",
        Fulfilled = "Fulfilled",
        Rejected = "Rejected",
        Cancelled = "Cancelled"
    }

    --// Promise Class
    local Promise = {}
    Promise.__index = Promise
    Promise.ClassName = "Promise"
    Promise.State = PromiseState

    --// Configuration
    local Config = {
        DebugMode = false,
        UnhandledRejectionWarning = true,
        DefaultTimeout = 30,
    }

    --// Utility Functions
    local function IsPromise(value)
        return type(value) == "table" and value.ClassName == "Promise"
    end

    local function IsThenable(value)
        return type(value) == "table" and type(value.andThen) == "function"
    end

    local function Pack(...)
        return {n = select("#", ...), ...}
    end

    local function Unpack(packed)
        return unpack(packed, 1, packed.n)
    end

    --// Constructor
    function Promise.new(executor)
        local self = setmetatable({}, Promise)

        self._state = PromiseState.Pending
        self._value = nil
        self._reason = nil
        self._onFulfilled = {}
        self._onRejected = {}
        self._onFinally = {}
        self._onProgress = {}
        self._cancelled = false
        self._cancellationCallbacks = {}
        self._parent = nil
        self._children = {}

        -- Execute the executor
        if executor then
            local function resolve(value)
                self:_resolve(value)
            end

            local function reject(reason)
                self:_reject(reason)
            end

            local function onCancel(callback)
                if self._cancelled then
                    callback()
                else
                    table.insert(self._cancellationCallbacks, callback)
                end
            end

            local function progress(value)
                self:_progress(value)
            end

            task.spawn(function()
                local success, err = pcall(executor, resolve, reject, onCancel, progress)

                if not success then
                    self:_reject(err)
                end
            end)
        end

        return self
    end

    --// Static Constructors
    function Promise.resolve(value)
        return Promise.new(function(resolve)
            resolve(value)
        end)
    end

    function Promise.reject(reason)
        return Promise.new(function(_, reject)
            reject(reason)
        end)
    end

    function Promise.try(callback, ...)
        local args = Pack(...)

        return Promise.new(function(resolve, reject)
            local success, result = pcall(callback, Unpack(args))

            if success then
                resolve(result)
            else
                reject(result)
            end
        end)
    end

    function Promise.defer()
        local resolve, reject
        local promise = Promise.new(function(res, rej)
            resolve = res
            reject = rej
        end)

        return promise, resolve, reject
    end

    --// Combinators
    function Promise.all(promises)
        return Promise.new(function(resolve, reject, onCancel)
            local results = {}
            local remaining = #promises
            local rejected = false

            if remaining == 0 then
                resolve(results)
                return
            end

            onCancel(function()
                for _, promise in ipairs(promises) do
                    if IsPromise(promise) and promise:IsPending() then
                        promise:Cancel()
                    end
                end
            end)

            for i, promise in ipairs(promises) do
                if not IsPromise(promise) then
                    promise = Promise.resolve(promise)
                end

                promise:andThen(function(value)
                    if rejected then return end

                    results[i] = value
                    remaining = remaining - 1

                    if remaining == 0 then
                        resolve(results)
                    end
                end):catch(function(reason)
                    if rejected then return end

                    rejected = true
                    reject(reason)
                end)
            end
        end)
    end

    function Promise.allSettled(promises)
        return Promise.new(function(resolve)
            local results = {}
            local remaining = #promises

            if remaining == 0 then
                resolve(results)
                return
            end

            for i, promise in ipairs(promises) do
                if not IsPromise(promise) then
                    promise = Promise.resolve(promise)
                end

                promise:andThen(function(value)
                    results[i] = { status = "fulfilled", value = value }
                    remaining = remaining - 1

                    if remaining == 0 then
                        resolve(results)
                    end
                end):catch(function(reason)
                    results[i] = { status = "rejected", reason = reason }
                    remaining = remaining - 1

                    if remaining == 0 then
                        resolve(results)
                    end
                end)
            end
        end)
    end

    function Promise.race(promises)
        return Promise.new(function(resolve, reject, onCancel)
            local settled = false

            onCancel(function()
                for _, promise in ipairs(promises) do
                    if IsPromise(promise) and promise:IsPending() then
                        promise:Cancel()
                    end
                end
            end)

            for _, promise in ipairs(promises) do
                if not IsPromise(promise) then
                    promise = Promise.resolve(promise)
                end

                promise:andThen(function(value)
                    if settled then return end
                    settled = true
                    resolve(value)
                end):catch(function(reason)
                    if settled then return end
                    settled = true
                    reject(reason)
                end)
            end
        end)
    end

    function Promise.any(promises)
        return Promise.new(function(resolve, reject, onCancel)
            local errors = {}
            local remaining = #promises
            local resolved = false

            if remaining == 0 then
                reject("No promises provided")
                return
            end

            onCancel(function()
                for _, promise in ipairs(promises) do
                    if IsPromise(promise) and promise:IsPending() then
                        promise:Cancel()
                    end
                end
            end)

            for i, promise in ipairs(promises) do
                if not IsPromise(promise) then
                    promise = Promise.resolve(promise)
                end

                promise:andThen(function(value)
                    if resolved then return end
                    resolved = true
                    resolve(value)
                end):catch(function(reason)
                    if resolved then return end

                    errors[i] = reason
                    remaining = remaining - 1

                    if remaining == 0 then
                        reject(errors)
                    end
                end)
            end
        end)
    end

    function Promise.delay(seconds, value)
        return Promise.new(function(resolve, _, onCancel)
            local thread = task.delay(seconds, function()
                resolve(value)
            end)

            onCancel(function()
                task.cancel(thread)
            end)
        end)
    end

    function Promise.fromEvent(event, predicate)
        return Promise.new(function(resolve, _, onCancel)
            local connection

            connection = event:Connect(function(...)
                if predicate then
                    local success, result = pcall(predicate, ...)
                    if not success or not result then
                        return
                    end
                end

                if connection then
                    connection:Disconnect()
                end

                resolve(...)
            end)

            onCancel(function()
                if connection then
                    connection:Disconnect()
                end
            end)
        end)
    end

    function Promise.retry(callback, maxAttempts, delay)
        maxAttempts = maxAttempts or 3
        delay = delay or 1

        return Promise.new(function(resolve, reject)
            local attempts = 0
            local lastError

            local function attempt()
                attempts = attempts + 1

                Promise.try(callback):andThen(function(value)
                    resolve(value)
                end):catch(function(reason)
                    lastError = reason

                    if attempts < maxAttempts then
                        task.delay(delay, attempt)
                    else
                        reject(lastError)
                    end
                end)
            end

            attempt()
        end)
    end

    --// Instance Methods
    function Promise:_resolve(value)
        if self._state ~= PromiseState.Pending then
            return
        end

        -- Handle promise resolution
        if value == self then
            self:_reject("Cannot resolve promise with itself")
            return
        end

        if IsPromise(value) then
            value:andThen(function(v)
                self:_resolve(v)
            end):catch(function(r)
                self:_reject(r)
            end)
            return
        end

        if IsThenable(value) then
            local called = false

            local success, err = pcall(function()
                value:andThen(function(v)
                    if called then return end
                    called = true
                    self:_resolve(v)
                end, function(r)
                    if called then return end
                    called = true
                    self:_reject(r)
                end)
            end)

            if not success and not called then
                self:_reject(err)
            end
            return
        end

        self._state = PromiseState.Fulfilled
        self._value = value

        -- Execute fulfilled callbacks
        for _, callback in ipairs(self._onFulfilled) do
            task.spawn(callback, value)
        end

        -- Execute finally callbacks
        for _, callback in ipairs(self._onFinally) do
            task.spawn(callback)
        end

        -- Clear callbacks
        self._onFulfilled = {}
        self._onRejected = {}
        self._onFinally = {}
    end

    function Promise:_reject(reason)
        if self._state ~= PromiseState.Pending then
            return
        end

        self._state = PromiseState.Rejected
        self._reason = reason

        -- Warning for unhandled rejections
        if Config.UnhandledRejectionWarning and #self._onRejected == 0 then
            task.defer(function()
                if #self._onRejected == 0 then
                    warn("[NexusUI.Promise] Unhandled rejection:", tostring(reason))
                end
            end)
        end

        -- Execute rejected callbacks
        for _, callback in ipairs(self._onRejected) do
            task.spawn(callback, reason)
        end

        -- Execute finally callbacks
        for _, callback in ipairs(self._onFinally) do
            task.spawn(callback)
        end

        -- Clear callbacks
        self._onFulfilled = {}
        self._onRejected = {}
        self._onFinally = {}
    end

    function Promise:_progress(value)
        for _, callback in ipairs(self._onProgress) do
            task.spawn(callback, value)
        end
    end

    function Promise:andThen(onFulfilled, onRejected)
        local child = Promise.new()
        child._parent = self
        table.insert(self._children, child)

        local function handleFulfilled(value)
            if type(onFulfilled) == "function" then
                local success, result = pcall(onFulfilled, value)
                if success then
                    child:_resolve(result)
                else
                    child:_reject(result)
                end
            else
                child:_resolve(value)
            end
        end

        local function handleRejected(reason)
            if type(onRejected) == "function" then
                local success, result = pcall(onRejected, reason)
                if success then
                    child:_resolve(result)
                else
                    child:_reject(result)
                end
            else
                child:_reject(reason)
            end
        end

        if self._state == PromiseState.Pending then
            table.insert(self._onFulfilled, handleFulfilled)
            table.insert(self._onRejected, handleRejected)
        elseif self._state == PromiseState.Fulfilled then
            task.spawn(handleFulfilled, self._value)
        elseif self._state == PromiseState.Rejected then
            task.spawn(handleRejected, self._reason)
        end

        return child
    end

    function Promise:catch(onRejected)
        return self:andThen(nil, onRejected)
    end

    function Promise:finally(callback)
        local child = Promise.new()

        local function handleFinally()
            local success, result = pcall(callback)

            if not success then
                child:_reject(result)
                return
            end

            if self._state == PromiseState.Fulfilled then
                child:_resolve(self._value)
            else
                child:_reject(self._reason)
            end
        end

        if self._state == PromiseState.Pending then
            table.insert(self._onFinally, handleFinally)
        else
            task.spawn(handleFinally)
        end

        return child
    end

    function Promise:progress(callback)
        if type(callback) == "function" then
            table.insert(self._onProgress, callback)
        end
        return self
    end

    function Promise:timeout(seconds, timeoutValue)
        return Promise.race({
            self,
            Promise.delay(seconds):andThen(function()
                if timeoutValue ~= nil then
                    return timeoutValue
                end
                error("Promise timed out after " .. seconds .. " seconds")
            end)
        })
    end

    function Promise:Cancel()
        if self._state ~= PromiseState.Pending then
            return
        end

        self._state = PromiseState.Cancelled
        self._cancelled = true

        -- Execute cancellation callbacks
        for _, callback in ipairs(self._cancellationCallbacks) do
            task.spawn(callback)
        end

        -- Cancel children
        for _, child in ipairs(self._children) do
            if child:IsPending() then
                child:Cancel()
            end
        end

        -- Clear callbacks
        self._onFulfilled = {}
        self._onRejected = {}
        self._onFinally = {}
        self._cancellationCallbacks = {}
    end

    function Promise:Await()
        if self._state == PromiseState.Fulfilled then
            return self._value
        elseif self._state == PromiseState.Rejected then
            error(self._reason)
        elseif self._state == PromiseState.Cancelled then
            error("Promise was cancelled")
        end

        local thread = coroutine.running()

        self:andThen(function(value)
            task.spawn(thread, true, value)
        end):catch(function(reason)
            task.spawn(thread, false, reason)
        end)

        local success, result = coroutine.yield()

        if success then
            return result
        else
            error(result)
        end
    end

    function Promise:Expect()
        return self:Await()
    end

    --// State Checking
    function Promise:IsPending()
        return self._state == PromiseState.Pending
    end

    function Promise:IsFulfilled()
        return self._state == PromiseState.Fulfilled
    end

    function Promise:IsRejected()
        return self._state == PromiseState.Rejected
    end

    function Promise:IsCancelled()
        return self._state == PromiseState.Cancelled
    end

    function Promise:GetState()
        return self._state
    end

    function Promise:GetValue()
        return self._value
    end

    function Promise:GetReason()
        return self._reason
    end

    --// Utility Methods
    function Promise:Tap(callback)
        return self:andThen(function(value)
            callback(value)
            return value
        end)
    end

    function Promise:TapError(callback)
        return self:catch(function(reason)
            callback(reason)
            error(reason)
        end)
    end

    --// Debug
    function Promise:__tostring()
        if self._state == PromiseState.Fulfilled then
            return string.format("Promise<Fulfilled>(%s)", tostring(self._value))
        elseif self._state == PromiseState.Rejected then
            return string.format("Promise<Rejected>(%s)", tostring(self._reason))
        elseif self._state == PromiseState.Cancelled then
            return "Promise<Cancelled>"
        else
            return "Promise<Pending>"
        end
    end

    --// Configuration
    function Promise.SetConfig(key, value)
        if Config[key] ~= nil then
            Config[key] = value
        end
    end

    function Promise.GetConfig(key)
        return Config[key]
    end

    return Promise


end


-- ============================================================================
-- Module: NexusUI/Core/EventSystem
-- ============================================================================
NexusUI_Modules["NexusUI/Core/EventSystem"] = function()
    local script = CreateMockScript("NexusUI/Core/EventSystem")
    
    --[[
        NexusUI Event System
        A comprehensive event dispatching and subscription system

        Features:
        - Named event channels
        - Priority-based event handling
        - Event filtering and transformation
        - Event history and replay
        - Wildcard subscriptions
        - Event namespacing
        - Throttling and debouncing
        - Async event handling
    ]]

    --// Dependencies
    local SignalClass = NexusRequire("NexusUI/SignalClass")
    local Maid = NexusRequire("NexusUI/Maid")

    --// Event System Class
    local EventSystem = {}
    EventSystem.__index = EventSystem
    EventSystem.ClassName = "EventSystem"

    --// Configuration
    local Config = {
        MaxHistorySize = 100,
        EnableHistory = true,
        DebugMode = false,
        WildcardCharacter = "*",
        NamespaceSeparator = ":",
        DefaultPriority = 0,
    }

    --// Singleton Instance
    local instance = nil

    --// Event Data Class
    local EventData = {}
    EventData.__index = EventData

    function EventData.new(name, data, metadata)
        local self = setmetatable({}, EventData)

        self.Name = name
        self.Data = data
        self.Metadata = metadata or {}
        self.Timestamp = os.clock()
        self.Id = tostring(os.clock()) .. "_" .. tostring(math.random(1000000))
        self.Propagating = true
        self.DefaultPrevented = false

        return self
    end

    function EventData:StopPropagation()
        self.Propagating = false
    end

    function EventData:PreventDefault()
        self.DefaultPrevented = true
    end

    function EventData:GetNamespace()
        local parts = string.split(self.Name, Config.NamespaceSeparator)
        if #parts > 1 then
            table.remove(parts, #parts)
            return table.concat(parts, Config.NamespaceSeparator)
        end
        return nil
    end

    function EventData:GetEventName()
        local parts = string.split(self.Name, Config.NamespaceSeparator)
        return parts[#parts]
    end

    --// Subscription Class
    local Subscription = {}
    Subscription.__index = Subscription

    function Subscription.new(eventName, callback, options)
        options = options or {}

        local self = setmetatable({}, Subscription)

        self.EventName = eventName
        self.Callback = callback
        self.Priority = options.Priority or Config.DefaultPriority
        self.Once = options.Once or false
        self.Filter = options.Filter or nil
        self.Transform = options.Transform or nil
        self.Throttle = options.Throttle or 0
        self.Debounce = options.Debounce or 0
        self.Async = options.Async or false
        self.Active = true
        self.Id = tostring(os.clock()) .. "_" .. tostring(math.random(1000000))

        -- Throttle/Debounce state
        self._lastCall = 0
        self._debounceScheduled = false
        self._debounceEvent = nil

        return self
    end

    function Subscription:Unsubscribe()
        self.Active = false
    end

    function Subscription:IsActive()
        return self.Active
    end

    function Subscription:CanHandle(eventData)
        if not self.Active then
            return false
        end

        -- Check filter
        if self.Filter and not self.Filter(eventData) then
            return false
        end

        return true
    end

    function Subscription:Handle(eventData)
        if not self:CanHandle(eventData) then
            return false
        end

        local now = os.clock()

        -- Throttle check
        if self.Throttle > 0 then
            if now - self._lastCall < self.Throttle then
                return false
            end
        end

        -- Debounce handling
        if self.Debounce > 0 then
            self._debounceEvent = eventData

            if not self._debounceScheduled then
                self._debounceScheduled = true

                task.delay(self.Debounce, function()
                    if self.Active and self._debounceEvent then
                        self:_execute(self._debounceEvent)
                    end
                    self._debounceScheduled = false
                    self._debounceEvent = nil
                end)
            end

            return true
        end

        -- Direct execution
        self._lastCall = now
        self:_execute(eventData)

        -- Handle once subscriptions
        if self.Once then
            self:Unsubscribe()
        end

        return true
    end

    function Subscription:_execute(eventData)
        local data = eventData.Data

        -- Apply transform
        if self.Transform then
            local success, result = pcall(self.Transform, data, eventData)
            if success then
                data = result
            end
        end

        -- Execute callback
        local executeCallback = function()
            local success, err = pcall(self.Callback, data, eventData)

            if not success and Config.DebugMode then
                warn(string.format("[NexusUI.EventSystem] Handler error for '%s': %s", eventData.Name, tostring(err)))
            end
        end

        if self.Async then
            task.spawn(executeCallback)
        else
            executeCallback()
        end
    end

    --// Event System Implementation
    function EventSystem.new()
        local self = setmetatable({}, EventSystem)

        self._subscriptions = {}
        self._namespaces = {}
        self._history = {}
        self._signals = {}
        self._maid = Maid.new("EventSystem")
        self._middlewares = {}
        self._interceptors = {}

        return self
    end

    function EventSystem.GetInstance()
        if not instance then
            instance = EventSystem.new()
        end
        return instance
    end

    --// Subscription Methods
    function EventSystem:Subscribe(eventName, callback, options)
        if type(eventName) ~= "string" then
            warn("[NexusUI.EventSystem] Event name must be a string")
            return nil
        end

        if type(callback) ~= "function" then
            warn("[NexusUI.EventSystem] Callback must be a function")
            return nil
        end

        local subscription = Subscription.new(eventName, callback, options)

        -- Initialize subscription list for event
        if not self._subscriptions[eventName] then
            self._subscriptions[eventName] = {}
        end

        table.insert(self._subscriptions[eventName], subscription)

        -- Sort by priority
        table.sort(self._subscriptions[eventName], function(a, b)
            return a.Priority > b.Priority
        end)

        -- Track namespace
        local namespace = EventData.new(eventName, nil):GetNamespace()
        if namespace then
            if not self._namespaces[namespace] then
                self._namespaces[namespace] = {}
            end
            self._namespaces[namespace][eventName] = true
        end

        return subscription
    end

    function EventSystem:Once(eventName, callback, options)
        options = options or {}
        options.Once = true
        return self:Subscribe(eventName, callback, options)
    end

    function EventSystem:Unsubscribe(subscription)
        if not subscription then return end

        subscription:Unsubscribe()

        -- Remove from subscription list
        local eventName = subscription.EventName
        local subs = self._subscriptions[eventName]

        if subs then
            for i, sub in ipairs(subs) do
                if sub == subscription then
                    table.remove(subs, i)
                    break
                end
            end

            -- Cleanup empty subscription lists
            if #subs == 0 then
                self._subscriptions[eventName] = nil
            end
        end
    end

    function EventSystem:UnsubscribeAll(eventName)
        if eventName then
            local subs = self._subscriptions[eventName]
            if subs then
                for _, sub in ipairs(subs) do
                    sub:Unsubscribe()
                end
                self._subscriptions[eventName] = nil
            end
        else
            for name, subs in pairs(self._subscriptions) do
                for _, sub in ipairs(subs) do
                    sub:Unsubscribe()
                end
            end
            self._subscriptions = {}
        end
    end

    --// Dispatch Methods
    function EventSystem:Dispatch(eventName, data, metadata)
        local eventData = EventData.new(eventName, data, metadata)

        -- Run interceptors
        for _, interceptor in ipairs(self._interceptors) do
            local success, result = pcall(interceptor, eventData)
            if success and result == false then
                return eventData -- Interceptor blocked the event
            end
        end

        -- Run middlewares
        for _, middleware in ipairs(self._middlewares) do
            local success, result = pcall(middleware, eventData)
            if success and result then
                eventData = result
            end
        end

        -- Add to history
        if Config.EnableHistory then
            table.insert(self._history, {
                Event = eventData,
                Time = os.clock()
            })

            -- Trim history
            while #self._history > Config.MaxHistorySize do
                table.remove(self._history, 1)
            end
        end

        -- Get matching subscriptions
        local matchingSubscriptions = self:_getMatchingSubscriptions(eventName)

        -- Execute subscriptions
        for _, subscription in ipairs(matchingSubscriptions) do
            if not eventData.Propagating then
                break
            end

            subscription:Handle(eventData)
        end

        return eventData
    end

    function EventSystem:DispatchAsync(eventName, data, metadata)
        return task.spawn(function()
            return self:Dispatch(eventName, data, metadata)
        end)
    end

    function EventSystem:DispatchDeferred(eventName, data, metadata)
        task.defer(function()
            self:Dispatch(eventName, data, metadata)
        end)
    end

    function EventSystem:DispatchDelayed(delay, eventName, data, metadata)
        task.delay(delay, function()
            self:Dispatch(eventName, data, metadata)
        end)
    end

    --// Wildcard and Pattern Matching
    function EventSystem:_getMatchingSubscriptions(eventName)
        local matching = {}

        -- Exact match
        local exactSubs = self._subscriptions[eventName]
        if exactSubs then
            for _, sub in ipairs(exactSubs) do
                if sub:IsActive() then
                    table.insert(matching, sub)
                end
            end
        end

        -- Wildcard matches
        for pattern, subs in pairs(self._subscriptions) do
            if pattern ~= eventName and self:_matchesPattern(eventName, pattern) then
                for _, sub in ipairs(subs) do
                    if sub:IsActive() then
                        table.insert(matching, sub)
                    end
                end
            end
        end

        -- Sort by priority
        table.sort(matching, function(a, b)
            return a.Priority > b.Priority
        end)

        return matching
    end

    function EventSystem:_matchesPattern(eventName, pattern)
        -- Handle wildcard character
        if string.find(pattern, Config.WildcardCharacter, 1, true) then
            local escaped = pattern:gsub("([%.%+%-%^%$%(%)%%])", "%%%1")
            local regex = escaped:gsub("%*", ".*")
            return string.match(eventName, "^" .. regex .. "$") ~= nil
        end

        return false
    end

    --// Middleware and Interceptors
    function EventSystem:AddMiddleware(middleware)
        if type(middleware) ~= "function" then
            warn("[NexusUI.EventSystem] Middleware must be a function")
            return
        end

        table.insert(self._middlewares, middleware)
    end

    function EventSystem:RemoveMiddleware(middleware)
        for i, mw in ipairs(self._middlewares) do
            if mw == middleware then
                table.remove(self._middlewares, i)
                return true
            end
        end
        return false
    end

    function EventSystem:AddInterceptor(interceptor)
        if type(interceptor) ~= "function" then
            warn("[NexusUI.EventSystem] Interceptor must be a function")
            return
        end

        table.insert(self._interceptors, interceptor)
    end

    function EventSystem:RemoveInterceptor(interceptor)
        for i, ic in ipairs(self._interceptors) do
            if ic == interceptor then
                table.remove(self._interceptors, i)
                return true
            end
        end
        return false
    end

    --// History Methods
    function EventSystem:GetHistory(eventName, limit)
        limit = limit or Config.MaxHistorySize
        local history = {}

        for i = #self._history, 1, -1 do
            local entry = self._history[i]

            if not eventName or entry.Event.Name == eventName then
                table.insert(history, entry)

                if #history >= limit then
                    break
                end
            end
        end

        return history
    end

    function EventSystem:ClearHistory(eventName)
        if eventName then
            local newHistory = {}
            for _, entry in ipairs(self._history) do
                if entry.Event.Name ~= eventName then
                    table.insert(newHistory, entry)
                end
            end
            self._history = newHistory
        else
            self._history = {}
        end
    end

    function EventSystem:ReplayHistory(eventName, limit)
        local history = self:GetHistory(eventName, limit)

        -- Replay in chronological order
        for i = #history, 1, -1 do
            local entry = history[i]
            self:Dispatch(entry.Event.Name, entry.Event.Data, entry.Event.Metadata)
        end
    end

    --// Namespace Methods
    function EventSystem:GetNamespaceEvents(namespace)
        return self._namespaces[namespace] or {}
    end

    function EventSystem:DispatchToNamespace(namespace, data, metadata)
        local events = self._namespaces[namespace]

        if events then
            for eventName, _ in pairs(events) do
                self:Dispatch(eventName, data, metadata)
            end
        end
    end

    function EventSystem:UnsubscribeNamespace(namespace)
        local events = self._namespaces[namespace]

        if events then
            for eventName, _ in pairs(events) do
                self:UnsubscribeAll(eventName)
            end
            self._namespaces[namespace] = nil
        end
    end

    --// Signal Bridge
    function EventSystem:GetSignal(eventName)
        if not self._signals[eventName] then
            self._signals[eventName] = SignalClass.new(eventName)

            -- Bridge signal to event system
            self:Subscribe(eventName, function(data)
                self._signals[eventName]:Fire(data)
            end)
        end

        return self._signals[eventName]
    end

    --// Wait Methods
    function EventSystem:Wait(eventName, timeout, predicate)
        timeout = timeout or 30

        local thread = coroutine.running()
        local result = nil
        local timedOut = false

        local subscription = self:Once(eventName, function(data, eventData)
            if predicate then
                if not predicate(data, eventData) then
                    return
                end
            end

            result = { Data = data, Event = eventData }

            if coroutine.status(thread) == "suspended" then
                task.spawn(thread)
            end
        end)

        local timeoutThread = task.delay(timeout, function()
            timedOut = true
            subscription:Unsubscribe()

            if coroutine.status(thread) == "suspended" then
                task.spawn(thread)
            end
        end)

        coroutine.yield()

        if not timedOut then
            task.cancel(timeoutThread)
        end

        if timedOut then
            return nil
        end

        return result
    end

    --// Utility Methods
    function EventSystem:HasSubscribers(eventName)
        local subs = self._subscriptions[eventName]
        return subs and #subs > 0
    end

    function EventSystem:GetSubscriberCount(eventName)
        if eventName then
            local subs = self._subscriptions[eventName]
            return subs and #subs or 0
        else
            local count = 0
            for _, subs in pairs(self._subscriptions) do
                count = count + #subs
            end
            return count
        end
    end

    function EventSystem:GetEventNames()
        local names = {}
        for name, _ in pairs(self._subscriptions) do
            table.insert(names, name)
        end
        return names
    end

    function EventSystem:GetNamespaces()
        local namespaces = {}
        for namespace, _ in pairs(self._namespaces) do
            table.insert(namespaces, namespace)
        end
        return namespaces
    end

    --// Configuration
    function EventSystem:SetConfig(key, value)
        if Config[key] ~= nil then
            Config[key] = value
        end
    end

    function EventSystem:GetConfig(key)
        return Config[key]
    end

    --// Cleanup
    function EventSystem:Destroy()
        self:UnsubscribeAll()

        for _, signal in pairs(self._signals) do
            signal:Destroy()
        end

        self._signals = {}
        self._history = {}
        self._middlewares = {}
        self._interceptors = {}
        self._namespaces = {}
        self._maid:Destroy()
    end

    --// Export singleton instance
    return EventSystem.GetInstance()


end


-- ============================================================================
-- Module: NexusUI/Core/StateManager
-- ============================================================================
NexusUI_Modules["NexusUI/Core/StateManager"] = function()
    local script = CreateMockScript("NexusUI/Core/StateManager")
    
    --[[
        NexusUI State Manager
        Centralized state management with reactive updates

        Features:
        - Global and scoped state management
        - Reactive state watching
        - State history and undo/redo
        - State persistence
        - Computed values
        - State validation
        - Batch updates
        - State snapshots
    ]]

    --// Dependencies
    local SignalClass = NexusRequire("NexusUI/SignalClass")

    --// State Manager Class
    local StateManager = {}
    StateManager.__index = StateManager
    StateManager.ClassName = "StateManager"

    --// Configuration
    local Config = {
        EnableHistory = true,
        MaxHistorySize = 50,
        EnableValidation = true,
        DebugMode = false,
        AutoPersist = false,
        PersistKey = "NexusUI_State",
    }

    --// Singleton Instance
    local instance = nil

    --// State Change Record
    local StateChange = {}
    StateChange.__index = StateChange

    function StateChange.new(key, oldValue, newValue, timestamp)
        local self = setmetatable({}, StateChange)

        self.Key = key
        self.OldValue = oldValue
        self.NewValue = newValue
        self.Timestamp = timestamp or os.clock()

        return self
    end

    --// Computed Value Class
    local ComputedValue = {}
    ComputedValue.__index = ComputedValue

    function ComputedValue.new(dependencies, computeFunc)
        local self = setmetatable({}, ComputedValue)

        self.Dependencies = dependencies
        self.ComputeFunc = computeFunc
        self.CachedValue = nil
        self.IsDirty = true

        return self
    end

    function ComputedValue:Get(stateManager)
        if self.IsDirty then
            local values = {}
            for _, dep in ipairs(self.Dependencies) do
                values[dep] = stateManager:Get(dep)
            end

            local success, result = pcall(self.ComputeFunc, values)
            if success then
                self.CachedValue = result
            else
                warn("[NexusUI.StateManager] Computed value error:", tostring(result))
            end

            self.IsDirty = false
        end

        return self.CachedValue
    end

    function ComputedValue:Invalidate()
        self.IsDirty = true
    end

    --// State Manager Implementation
    function StateManager.new()
        local self = setmetatable({}, StateManager)

        -- Core state storage
        self._state = {}
        self._defaultState = {}
        self._watchers = {}
        self._computed = {}
        self._validators = {}

        -- Signals
        self._signals = {
            StateChanged = SignalClass.new("StateChanged"),
            StateReset = SignalClass.new("StateReset"),
            BatchStart = SignalClass.new("BatchStart"),
            BatchEnd = SignalClass.new("BatchEnd"),
        }

        -- History for undo/redo
        self._history = {}
        self._historyIndex = 0
        self._batchMode = false
        self._batchChanges = {}

        -- Scoped states
        self._scopes = {}

        return self
    end

    function StateManager.GetInstance()
        if not instance then
            instance = StateManager.new()
        end
        return instance
    end

    --// Core State Operations
    function StateManager:Set(key, value, options)
        options = options or {}

        -- Validation
        if Config.EnableValidation and self._validators[key] then
            local isValid, errorMsg = self._validators[key](value)
            if not isValid then
                warn(string.format("[NexusUI.StateManager] Validation failed for '%s': %s", key, errorMsg or "Invalid value"))
                return false
            end
        end

        local oldValue = self._state[key]

        -- Skip if value hasn't changed
        if not options.Force and self:_deepEqual(oldValue, value) then
            return false
        end

        -- Store old value for history
        if Config.EnableHistory and not self._batchMode then
            self:_recordChange(key, oldValue, value)
        end

        -- Update state
        self._state[key] = value

        -- Invalidate computed values
        self:_invalidateComputed(key)

        -- Notify watchers
        if not options.Silent then
            self:_notifyWatchers(key, value, oldValue)
            self._signals.StateChanged:Fire(key, value, oldValue)
        end

        -- Batch collection
        if self._batchMode then
            table.insert(self._batchChanges, StateChange.new(key, oldValue, value))
        end

        -- Auto persist
        if Config.AutoPersist then
            self:Persist()
        end

        return true
    end

    function StateManager:Get(key, defaultValue)
        -- Check for computed value
        if self._computed[key] then
            return self._computed[key]:Get(self)
        end

        local value = self._state[key]

        if value == nil then
            return defaultValue or self._defaultState[key]
        end

        return value
    end

    function StateManager:Has(key)
        return self._state[key] ~= nil
    end

    function StateManager:Delete(key, options)
        options = options or {}

        if not self:Has(key) then
            return false
        end

        local oldValue = self._state[key]

        if Config.EnableHistory and not self._batchMode then
            self:_recordChange(key, oldValue, nil)
        end

        self._state[key] = nil

        if not options.Silent then
            self:_notifyWatchers(key, nil, oldValue)
            self._signals.StateChanged:Fire(key, nil, oldValue)
        end

        return true
    end

    function StateManager:SetMultiple(values, options)
        for key, value in pairs(values) do
            self:Set(key, value, options)
        end
    end

    function StateManager:GetMultiple(keys)
        local values = {}
        for _, key in ipairs(keys) do
            values[key] = self:Get(key)
        end
        return values
    end

    function StateManager:GetAll()
        local copy = {}
        for key, value in pairs(self._state) do
            copy[key] = self:_deepCopy(value)
        end
        return copy
    end

    function StateManager:Clear(options)
        options = options or {}

        local oldState = self:GetAll()
        self._state = {}

        if not options.Silent then
            for key, oldValue in pairs(oldState) do
                self:_notifyWatchers(key, nil, oldValue)
            end
            self._signals.StateReset:Fire()
        end
    end

    --// Watching State Changes
    function StateManager:Watch(key, callback, options)
        options = options or {}

        if not self._watchers[key] then
            self._watchers[key] = {}
        end

        local watcher = {
            Callback = callback,
            Priority = options.Priority or 0,
            Once = options.Once or false,
            Filter = options.Filter or nil,
            Active = true,
            Id = tostring(os.clock()) .. "_" .. tostring(math.random(1000000))
        }

        table.insert(self._watchers[key], watcher)

        -- Sort by priority
        table.sort(self._watchers[key], function(a, b)
            return a.Priority > b.Priority
        end)

        -- Fire immediately with current value if requested
        if options.Immediate and self:Has(key) then
            callback(self:Get(key), nil)
        end

        -- Return unwatch function
        return function()
            watcher.Active = false

            local watchers = self._watchers[key]
            if watchers then
                for i, w in ipairs(watchers) do
                    if w == watcher then
                        table.remove(watchers, i)
                        break
                    end
                end
            end
        end
    end

    function StateManager:WatchMultiple(keys, callback, options)
        options = options or {}

        local unwatchers = {}

        local function onAnyChange()
            local values = self:GetMultiple(keys)
            callback(values)
        end

        for _, key in ipairs(keys) do
            local unwatch = self:Watch(key, onAnyChange, {
                Priority = options.Priority
            })
            table.insert(unwatchers, unwatch)
        end

        -- Fire immediately if requested
        if options.Immediate then
            onAnyChange()
        end

        -- Return combined unwatch function
        return function()
            for _, unwatch in ipairs(unwatchers) do
                unwatch()
            end
        end
    end

    function StateManager:_notifyWatchers(key, newValue, oldValue)
        local watchers = self._watchers[key]
        if not watchers then return end

        local toRemove = {}

        for i, watcher in ipairs(watchers) do
            if watcher.Active then
                -- Check filter
                if watcher.Filter then
                    local pass, err = pcall(watcher.Filter, newValue, oldValue)
                    if not pass or not err then
                        continue
                    end
                end

                -- Execute callback
                local success, err = pcall(watcher.Callback, newValue, oldValue)

                if not success and Config.DebugMode then
                    warn(string.format("[NexusUI.StateManager] Watcher error for '%s': %s", key, tostring(err)))
                end

                -- Handle once watchers
                if watcher.Once then
                    table.insert(toRemove, i)
                end
            end
        end

        -- Remove once watchers
        for i = #toRemove, 1, -1 do
            table.remove(watchers, toRemove[i])
        end
    end

    --// Computed Values
    function StateManager:Computed(name, dependencies, computeFunc)
        local computed = ComputedValue.new(dependencies, computeFunc)
        self._computed[name] = computed

        -- Watch dependencies to invalidate computed value
        for _, dep in ipairs(dependencies) do
            self:Watch(dep, function()
                computed:Invalidate()
            end)
        end

        return computed
    end

    function StateManager:_invalidateComputed(changedKey)
        for _, computed in pairs(self._computed) do
            for _, dep in ipairs(computed.Dependencies) do
                if dep == changedKey then
                    computed:Invalidate()
                    break
                end
            end
        end
    end

    --// Validators
    function StateManager:SetValidator(key, validator)
        self._validators[key] = validator
    end

    function StateManager:RemoveValidator(key)
        self._validators[key] = nil
    end

    function StateManager:Validate(key, value)
        local validator = self._validators[key]
        if validator then
            return validator(value)
        end
        return true
    end

    --// Default Values
    function StateManager:SetDefault(key, value)
        self._defaultState[key] = value
    end

    function StateManager:SetDefaults(defaults)
        for key, value in pairs(defaults) do
            self._defaultState[key] = value
        end
    end

    function StateManager:ResetToDefaults(keys)
        if keys then
            for _, key in ipairs(keys) do
                local defaultValue = self._defaultState[key]
                if defaultValue ~= nil then
                    self:Set(key, self:_deepCopy(defaultValue))
                else
                    self:Delete(key)
                end
            end
        else
            self._state = self:_deepCopy(self._defaultState)
            self._signals.StateReset:Fire()
        end
    end

    --// Batch Updates
    function StateManager:BeginBatch()
        if self._batchMode then
            warn("[NexusUI.StateManager] Already in batch mode")
            return
        end

        self._batchMode = true
        self._batchChanges = {}
        self._signals.BatchStart:Fire()
    end

    function StateManager:EndBatch()
        if not self._batchMode then
            warn("[NexusUI.StateManager] Not in batch mode")
            return
        end

        self._batchMode = false

        -- Record batch to history
        if Config.EnableHistory and #self._batchChanges > 0 then
            self:_recordBatch(self._batchChanges)
        end

        self._batchChanges = {}
        self._signals.BatchEnd:Fire()
    end

    function StateManager:Batch(callback)
        self:BeginBatch()

        local success, err = pcall(callback)

        self:EndBatch()

        if not success then
            warn("[NexusUI.StateManager] Batch error:", tostring(err))
        end
    end

    --// History and Undo/Redo
    function StateManager:_recordChange(key, oldValue, newValue)
        -- Remove any redo history
        while #self._history > self._historyIndex do
            table.remove(self._history)
        end

        -- Add new change
        table.insert(self._history, {
            Type = "single",
            Changes = { StateChange.new(key, oldValue, newValue) }
        })
        self._historyIndex = #self._history

        -- Trim history
        while #self._history > Config.MaxHistorySize do
            table.remove(self._history, 1)
            self._historyIndex = self._historyIndex - 1
        end
    end

    function StateManager:_recordBatch(changes)
        while #self._history > self._historyIndex do
            table.remove(self._history)
        end

        table.insert(self._history, {
            Type = "batch",
            Changes = changes
        })
        self._historyIndex = #self._history

        while #self._history > Config.MaxHistorySize do
            table.remove(self._history, 1)
            self._historyIndex = self._historyIndex - 1
        end
    end

    function StateManager:CanUndo()
        return self._historyIndex > 0
    end

    function StateManager:CanRedo()
        return self._historyIndex < #self._history
    end

    function StateManager:Undo()
        if not self:CanUndo() then
            return false
        end

        local record = self._history[self._historyIndex]
        self._historyIndex = self._historyIndex - 1

        -- Apply reverse changes
        for _, change in ipairs(record.Changes) do
            self._state[change.Key] = change.OldValue
            self:_notifyWatchers(change.Key, change.OldValue, change.NewValue)
        end

        return true
    end

    function StateManager:Redo()
        if not self:CanRedo() then
            return false
        end

        self._historyIndex = self._historyIndex + 1
        local record = self._history[self._historyIndex]

        -- Apply changes
        for _, change in ipairs(record.Changes) do
            self._state[change.Key] = change.NewValue
            self:_notifyWatchers(change.Key, change.NewValue, change.OldValue)
        end

        return true
    end

    function StateManager:ClearHistory()
        self._history = {}
        self._historyIndex = 0
    end

    function StateManager:GetHistorySize()
        return #self._history
    end

    --// Snapshots
    function StateManager:CreateSnapshot(name)
        return {
            Name = name or "Snapshot",
            State = self:_deepCopy(self._state),
            Timestamp = os.clock()
        }
    end

    function StateManager:RestoreSnapshot(snapshot, options)
        options = options or {}

        if options.Merge then
            for key, value in pairs(snapshot.State) do
                self:Set(key, value, { Silent = options.Silent })
            end
        else
            self._state = self:_deepCopy(snapshot.State)

            if not options.Silent then
                self._signals.StateReset:Fire()
            end
        end
    end

    --// Scoped State
    function StateManager:CreateScope(scopeName)
        if self._scopes[scopeName] then
            return self._scopes[scopeName]
        end

        local scope = {
            _manager = self,
            _prefix = scopeName .. ".",
        }

        function scope:Set(key, value, options)
            return self._manager:Set(self._prefix .. key, value, options)
        end

        function scope:Get(key, defaultValue)
            return self._manager:Get(self._prefix .. key, defaultValue)
        end

        function scope:Has(key)
            return self._manager:Has(self._prefix .. key)
        end

        function scope:Delete(key, options)
            return self._manager:Delete(self._prefix .. key, options)
        end

        function scope:Watch(key, callback, options)
            return self._manager:Watch(self._prefix .. key, callback, options)
        end

        function scope:Clear()
            for key, _ in pairs(self._manager._state) do
                if string.sub(key, 1, #self._prefix) == self._prefix then
                    self._manager:Delete(key)
                end
            end
        end

        self._scopes[scopeName] = scope
        return scope
    end

    function StateManager:GetScope(scopeName)
        return self._scopes[scopeName]
    end

    function StateManager:DeleteScope(scopeName)
        local scope = self._scopes[scopeName]
        if scope then
            scope:Clear()
            self._scopes[scopeName] = nil
        end
    end

    --// Persistence
    function StateManager:Persist(key)
        key = key or Config.PersistKey

        local success = pcall(function()
            if writefile then
                local HttpService = game:GetService("HttpService")
                local json = HttpService:JSONEncode(self._state)
                writefile(key .. ".json", json)
            end
        end)

        return success
    end

    function StateManager:Restore(key)
        key = key or Config.PersistKey

        local success = pcall(function()
            if readfile and isfile then
                local path = key .. ".json"
                if isfile(path) then
                    local HttpService = game:GetService("HttpService")
                    local json = readfile(path)
                    local state = HttpService:JSONDecode(json)

                    for k, v in pairs(state) do
                        self:Set(k, v, { Silent = true })
                    end
                end
            end
        end)

        return success
    end

    --// Utility Methods
    function StateManager:_deepCopy(original)
        if type(original) ~= "table" then
            return original
        end

        local copy = {}
        for key, value in pairs(original) do
            copy[self:_deepCopy(key)] = self:_deepCopy(value)
        end

        return copy
    end

    function StateManager:_deepEqual(a, b)
        if type(a) ~= type(b) then
            return false
        end

        if type(a) ~= "table" then
            return a == b
        end

        for key, value in pairs(a) do
            if not self:_deepEqual(value, b[key]) then
                return false
            end
        end

        for key, value in pairs(b) do
            if a[key] == nil then
                return false
            end
        end

        return true
    end

    --// Signals
    function StateManager:OnStateChanged(callback)
        return self._signals.StateChanged:Connect(callback)
    end

    function StateManager:OnStateReset(callback)
        return self._signals.StateReset:Connect(callback)
    end

    --// Configuration
    function StateManager:SetConfig(key, value)
        if Config[key] ~= nil then
            Config[key] = value
        end
    end

    function StateManager:GetConfig(key)
        return Config[key]
    end

    --// Debug
    function StateManager:Debug()
        print("=== StateManager Debug ===")
        print("State:")
        for key, value in pairs(self._state) do
            print(string.format("  %s = %s", key, tostring(value)))
        end
        print(string.format("Watchers: %d", self:_countWatchers()))
        print(string.format("History: %d/%d", self._historyIndex, #self._history))
        print(string.format("Computed: %d", self:_countComputed()))
    end

    function StateManager:_countWatchers()
        local count = 0
        for _, watchers in pairs(self._watchers) do
            count = count + #watchers
        end
        return count
    end

    function StateManager:_countComputed()
        local count = 0
        for _ in pairs(self._computed) do
            count = count + 1
        end
        return count
    end

    --// Cleanup
    function StateManager:Destroy()
        self:Clear({ Silent = true })
        self._watchers = {}
        self._computed = {}
        self._validators = {}
        self._history = {}
        self._scopes = {}

        for _, signal in pairs(self._signals) do
            signal:Destroy()
        end
    end

    --// Export singleton instance
    return StateManager.GetInstance()


end


-- ============================================================================
-- Module: NexusUI/Core/Types
-- ============================================================================
NexusUI_Modules["NexusUI/Core/Types"] = function()
    local script = CreateMockScript("NexusUI/Core/Types")
    
    --[[
        NexusUI Type Definitions
        Comprehensive type system for the UI library

        Features:
        - Component property types
        - Theme type definitions
        - Event type definitions
        - Animation types
        - Layout types
        - Validation helpers
    ]]

    --// Types Module
    local Types = {}

    --// Base Types
    Types.Primitive = {
        String = "string",
        Number = "number",
        Boolean = "boolean",
        Table = "table",
        Function = "function",
        Nil = "nil",
        Thread = "thread",
        Userdata = "userdata",
    }

    --// Roblox Types
    Types.Roblox = {
        Instance = "Instance",
        Color3 = "Color3",
        Vector2 = "Vector2",
        Vector3 = "Vector3",
        UDim = "UDim",
        UDim2 = "UDim2",
        CFrame = "CFrame",
        Enum = "Enum",
        EnumItem = "EnumItem",
        NumberRange = "NumberRange",
        NumberSequence = "NumberSequence",
        ColorSequence = "ColorSequence",
        Rect = "Rect",
        Font = "Font",
        TweenInfo = "TweenInfo",
        RBXScriptConnection = "RBXScriptConnection",
        RBXScriptSignal = "RBXScriptSignal",
    }

    --// Component States
    Types.ComponentState = {
        Idle = "Idle",
        Hovered = "Hovered",
        Pressed = "Pressed",
        Focused = "Focused",
        Disabled = "Disabled",
        Loading = "Loading",
        Error = "Error",
        Success = "Success",
        Active = "Active",
        Selected = "Selected",
    }

    --// Component Variants
    Types.ButtonVariant = {
        Primary = "Primary",
        Secondary = "Secondary",
        Tertiary = "Tertiary",
        Ghost = "Ghost",
        Outline = "Outline",
        Link = "Link",
        Danger = "Danger",
        Success = "Success",
        Warning = "Warning",
        Info = "Info",
    }

    Types.InputVariant = {
        Default = "Default",
        Filled = "Filled",
        Outline = "Outline",
        Underline = "Underline",
        Ghost = "Ghost",
    }

    Types.Size = {
        XSmall = "XSmall",
        Small = "Small",
        Medium = "Medium",
        Large = "Large",
        XLarge = "XLarge",
        XXLarge = "XXLarge",
    }

    --// Theme Types
    Types.ThemeMode = {
        Light = "Light",
        Dark = "Dark",
        System = "System",
        Custom = "Custom",
    }

    Types.ThemeCategory = {
        Dark = "Dark",
        Light = "Light",
        Colorful = "Colorful",
        Glass = "Glass",
        Gaming = "Gaming",
    }

    --// Animation Types
    Types.EasingStyle = {
        Linear = "Linear",
        Sine = "Sine",
        Quad = "Quad",
        Cubic = "Cubic",
        Quart = "Quart",
        Quint = "Quint",
        Expo = "Expo",
        Circ = "Circ",
        Back = "Back",
        Elastic = "Elastic",
        Bounce = "Bounce",
        Spring = "Spring",
    }

    Types.EasingDirection = {
        In = "In",
        Out = "Out",
        InOut = "InOut",
        OutIn = "OutIn",
    }

    Types.AnimationState = {
        Idle = "Idle",
        Playing = "Playing",
        Paused = "Paused",
        Completed = "Completed",
        Cancelled = "Cancelled",
    }

    --// Layout Types
    Types.LayoutDirection = {
        Horizontal = "Horizontal",
        Vertical = "Vertical",
    }

    Types.Alignment = {
        Start = "Start",
        Center = "Center",
        End = "End",
        Stretch = "Stretch",
        SpaceBetween = "SpaceBetween",
        SpaceAround = "SpaceAround",
        SpaceEvenly = "SpaceEvenly",
    }

    Types.Position = {
        TopLeft = "TopLeft",
        TopCenter = "TopCenter",
        TopRight = "TopRight",
        CenterLeft = "CenterLeft",
        Center = "Center",
        CenterRight = "CenterRight",
        BottomLeft = "BottomLeft",
        BottomCenter = "BottomCenter",
        BottomRight = "BottomRight",
    }

    --// Notification Types
    Types.NotificationType = {
        Info = "Info",
        Success = "Success",
        Warning = "Warning",
        Error = "Error",
        Default = "Default",
    }

    Types.NotificationPosition = {
        TopLeft = "TopLeft",
        TopCenter = "TopCenter",
        TopRight = "TopRight",
        BottomLeft = "BottomLeft",
        BottomCenter = "BottomCenter",
        BottomRight = "BottomRight",
    }

    --// Input Types
    Types.InputType = {
        Text = "Text",
        Number = "Number",
        Password = "Password",
        Email = "Email",
        Search = "Search",
        Url = "Url",
        Tel = "Tel",
        Date = "Date",
        Time = "Time",
        DateTime = "DateTime",
        Color = "Color",
        File = "File",
        Range = "Range",
    }

    Types.KeyCode = Enum.KeyCode

    --// Effect Types
    Types.EffectType = {
        LiquidGlass = "LiquidGlass",
        Glassmorphism = "Glassmorphism",
        Acrylic = "Acrylic",
        Mica = "Mica",
        Neon = "Neon",
        Glow = "Glow",
        Shadow = "Shadow",
        Blur = "Blur",
        Gradient = "Gradient",
        Noise = "Noise",
        Particles = "Particles",
    }

    --// Sound Types
    Types.SoundType = {
        Click = "Click",
        Hover = "Hover",
        Toggle = "Toggle",
        Slide = "Slide",
        Open = "Open",
        Close = "Close",
        Success = "Success",
        Error = "Error",
        Warning = "Warning",
        Notification = "Notification",
        Type = "Type",
    }

    --// Type Definitions (for documentation/validation)
    Types.Definitions = {}

    --// Color Definition
    Types.Definitions.Color = {
        Primary = "Color3",
        Secondary = "Color3",
        Accent = "Color3",
        Background = "Color3",
        Surface = "Color3",
        Text = "Color3",
        TextMuted = "Color3",
        Border = "Color3",
        Success = "Color3",
        Warning = "Color3",
        Error = "Color3",
        Info = "Color3",
    }

    --// Theme Definition
    Types.Definitions.Theme = {
        Name = "string",
        Category = "ThemeCategory",
        Mode = "ThemeMode",
        Colors = "ColorDefinition",
        Typography = "TypographyDefinition",
        Spacing = "SpacingDefinition",
        Borders = "BorderDefinition",
        Shadows = "ShadowDefinition",
        Effects = "EffectDefinition",
        Animations = "AnimationDefinition",
    }

    --// Typography Definition
    Types.Definitions.Typography = {
        FontFamily = "Font",
        FontFamilyMono = "Font",
        FontSizeXS = "number",
        FontSizeSM = "number",
        FontSizeMD = "number",
        FontSizeLG = "number",
        FontSizeXL = "number",
        FontSizeXXL = "number",
        FontWeightLight = "Enum.FontWeight",
        FontWeightRegular = "Enum.FontWeight",
        FontWeightMedium = "Enum.FontWeight",
        FontWeightBold = "Enum.FontWeight",
        LineHeightTight = "number",
        LineHeightNormal = "number",
        LineHeightRelaxed = "number",
    }

    --// Spacing Definition
    Types.Definitions.Spacing = {
        XS = "number",
        SM = "number",
        MD = "number",
        LG = "number",
        XL = "number",
        XXL = "number",
    }

    --// Border Definition
    Types.Definitions.Border = {
        RadiusNone = "number",
        RadiusSM = "number",
        RadiusMD = "number",
        RadiusLG = "number",
        RadiusXL = "number",
        RadiusFull = "number",
        WidthNone = "number",
        WidthThin = "number",
        WidthMedium = "number",
        WidthThick = "number",
    }

    --// Shadow Definition
    Types.Definitions.Shadow = {
        None = "table",
        SM = "table",
        MD = "table",
        LG = "table",
        XL = "table",
        Inner = "table",
    }

    --// Component Props Definitions
    Types.Definitions.ButtonProps = {
        Text = "string",
        Icon = "string?",
        IconPosition = "string?",
        Variant = "ButtonVariant?",
        Size = "Size?",
        Disabled = "boolean?",
        Loading = "boolean?",
        FullWidth = "boolean?",
        Callback = "function?",
        Tooltip = "string?",
    }

    Types.Definitions.ToggleProps = {
        Value = "boolean?",
        DefaultValue = "boolean?",
        Disabled = "boolean?",
        Size = "Size?",
        Label = "string?",
        LabelPosition = "string?",
        Callback = "function?",
    }

    Types.Definitions.SliderProps = {
        Value = "number?",
        DefaultValue = "number?",
        Min = "number",
        Max = "number",
        Step = "number?",
        Disabled = "boolean?",
        ShowValue = "boolean?",
        ValueFormat = "string?",
        Callback = "function?",
    }

    Types.Definitions.TextInputProps = {
        Value = "string?",
        DefaultValue = "string?",
        Placeholder = "string?",
        Type = "InputType?",
        Disabled = "boolean?",
        ReadOnly = "boolean?",
        MaxLength = "number?",
        Pattern = "string?",
        Variant = "InputVariant?",
        Size = "Size?",
        Icon = "string?",
        IconPosition = "string?",
        ClearButton = "boolean?",
        Callback = "function?",
        OnFocus = "function?",
        OnBlur = "function?",
    }

    Types.Definitions.DropdownProps = {
        Value = "any?",
        DefaultValue = "any?",
        Options = "table",
        Placeholder = "string?",
        Disabled = "boolean?",
        Searchable = "boolean?",
        Clearable = "boolean?",
        Multi = "boolean?",
        MaxSelections = "number?",
        Callback = "function?",
    }

    Types.Definitions.WindowProps = {
        Title = "string",
        Subtitle = "string?",
        Icon = "string?",
        Size = "UDim2?",
        Position = "UDim2?",
        MinSize = "Vector2?",
        MaxSize = "Vector2?",
        Draggable = "boolean?",
        Resizable = "boolean?",
        Closeable = "boolean?",
        Minimizable = "boolean?",
        Theme = "string?",
        Keybind = "Enum.KeyCode?",
    }

    Types.Definitions.TabProps = {
        Title = "string",
        Icon = "string?",
        Disabled = "boolean?",
        Badge = "string?",
        Closeable = "boolean?",
    }

    --// Type Checking Utilities
    function Types.Is(value, typeName)
        local valueType = typeof(value)

        -- Direct type match
        if valueType == typeName then
            return true
        end

        -- Check primitive types
        if Types.Primitive[typeName] and type(value) == Types.Primitive[typeName] then
            return true
        end

        -- Check Roblox types
        if Types.Roblox[typeName] and valueType == typeName then
            return true
        end

        -- Check enum types
        if typeName:sub(1, 5) == "Enum." then
            local enumPath = typeName:split(".")
            local enum = Enum
            for i = 2, #enumPath do
                enum = enum[enumPath[i]]
            end

            if valueType == "EnumItem" then
                return value.EnumType == enum
            end
        end

        return false
    end

    function Types.IsOneOf(value, typeNames)
        for _, typeName in ipairs(typeNames) do
            if Types.Is(value, typeName) then
                return true
            end
        end
        return false
    end

    function Types.IsOptional(typeName)
        return typeName:sub(-1) == "?"
    end

    function Types.GetBaseType(typeName)
        if Types.IsOptional(typeName) then
            return typeName:sub(1, -2)
        end
        return typeName
    end

    function Types.Validate(value, typeName)
        if value == nil then
            if Types.IsOptional(typeName) then
                return true, nil
            else
                return false, "Value is required"
            end
        end

        local baseType = Types.GetBaseType(typeName)

        if not Types.Is(value, baseType) then
            return false, string.format("Expected %s, got %s", baseType, typeof(value))
        end

        return true, nil
    end

    function Types.ValidateProps(props, definition)
        local errors = {}

        for propName, typeName in pairs(definition) do
            local isValid, error = Types.Validate(props[propName], typeName)

            if not isValid then
                table.insert(errors, string.format("%s: %s", propName, error))
            end
        end

        return #errors == 0, errors
    end

    function Types.CreateValidator(definition)
        return function(props)
            return Types.ValidateProps(props, definition)
        end
    end

    --// Default Values
    Types.Defaults = {
        ButtonVariant = Types.ButtonVariant.Primary,
        InputVariant = Types.InputVariant.Default,
        Size = Types.Size.Medium,
        EasingStyle = Types.EasingStyle.Quad,
        EasingDirection = Types.EasingDirection.Out,
        NotificationType = Types.NotificationType.Info,
        NotificationPosition = Types.NotificationPosition.TopRight,
        ThemeMode = Types.ThemeMode.Dark,
        LayoutDirection = Types.LayoutDirection.Vertical,
        Alignment = Types.Alignment.Start,
    }

    --// Type Coercion
    function Types.Coerce(value, targetType)
        local currentType = typeof(value)

        if currentType == targetType then
            return value
        end

        -- String coercion
        if targetType == "string" then
            return tostring(value)
        end

        -- Number coercion
        if targetType == "number" then
            return tonumber(value)
        end

        -- Boolean coercion
        if targetType == "boolean" then
            if type(value) == "string" then
                return value:lower() == "true" or value == "1"
            end
            return value and true or false
        end

        -- Color3 coercion
        if targetType == "Color3" then
            if type(value) == "string" then
                -- Try hex conversion
                local hex = value:gsub("#", "")
                if #hex == 6 then
                    local r = tonumber(hex:sub(1, 2), 16) / 255
                    local g = tonumber(hex:sub(3, 4), 16) / 255
                    local b = tonumber(hex:sub(5, 6), 16) / 255
                    return Color3.new(r, g, b)
                end
            elseif type(value) == "table" then
                if value.R and value.G and value.B then
                    return Color3.new(value.R, value.G, value.B)
                elseif #value >= 3 then
                    return Color3.new(value[1], value[2], value[3])
                end
            end
        end

        -- UDim2 coercion
        if targetType == "UDim2" then
            if type(value) == "table" then
                if value.X and value.Y then
                    return UDim2.new(value.X.Scale or 0, value.X.Offset or 0, value.Y.Scale or 0, value.Y.Offset or 0)
                elseif #value >= 4 then
                    return UDim2.new(value[1], value[2], value[3], value[4])
                elseif #value >= 2 then
                    return UDim2.fromOffset(value[1], value[2])
                end
            elseif type(value) == "number" then
                return UDim2.fromOffset(value, value)
            end
        end

        -- Vector2 coercion
        if targetType == "Vector2" then
            if type(value) == "table" then
                if value.X and value.Y then
                    return Vector2.new(value.X, value.Y)
                elseif #value >= 2 then
                    return Vector2.new(value[1], value[2])
                end
            elseif type(value) == "number" then
                return Vector2.new(value, value)
            end
        end

        return value
    end

    --// Enum Helpers
    function Types.GetEnumValues(enumType)
        local values = {}
        for _, item in pairs(enumType) do
            table.insert(values, item)
        end
        return values
    end

    function Types.GetEnumNames(enumType)
        local names = {}
        for name, _ in pairs(enumType) do
            table.insert(names, name)
        end
        return names
    end

    function Types.EnumFromString(enumType, str)
        return enumType[str]
    end

    return Types


end


-- ============================================================================
-- Module: NexusUI/Core/Constants
-- ============================================================================
NexusUI_Modules["NexusUI/Core/Constants"] = function()
    local script = CreateMockScript("NexusUI/Core/Constants")
    
    --[[
        NexusUI Constants
        Central repository for all library constants

        Contains:
        - Library metadata
        - Default configurations
        - UI constants
        - Animation defaults
        - Theme defaults
        - Sound defaults
        - Layout constants
    ]]

    --// Constants Module
    local Constants = {}

    --// Library Info
    Constants.Library = {
        Name = "NexusUI",
        Version = "1.0.0",
        Build = 1000,
        Author = "NexusUI Team",
        Description = "Ultimate Roblox Executor UI Library",
        Repository = "github.com/nexusui/nexusui",
        Documentation = "docs.nexusui.dev",
    }

    --// Environment
    Constants.Environment = {
        IsStudio = game:GetService("RunService"):IsStudio(),
        IsClient = game:GetService("RunService"):IsClient(),
        IsServer = game:GetService("RunService"):IsServer(),
    }

    --// Z-Index Layers
    Constants.ZIndex = {
        Base = 1,
        Component = 10,
        Elevated = 100,
        Dropdown = 200,
        Popover = 300,
        Modal = 400,
        Toast = 500,
        Tooltip = 600,
        ContextMenu = 700,
        Overlay = 800,
        PerformanceMonitor = 900,
        Watermark = 950,
        Maximum = 999,
    }

    --// Timing
    Constants.Timing = {
        -- Animation durations (seconds)
        Instant = 0,
        Fast = 0.1,
        Normal = 0.2,
        Slow = 0.3,
        Slower = 0.5,
        Slowest = 1.0,

        -- Delays
        DebounceDelay = 0.1,
        ThrottleDelay = 0.05,
        TooltipDelay = 0.5,
        DoubleClickWindow = 0.3,
        LongPressDelay = 0.5,

        -- Timeouts
        DefaultTimeout = 30,
        NetworkTimeout = 10,
        AnimationTimeout = 5,
    }

    --// Sizes
    Constants.Sizes = {
        -- Component sizes
        XSmall = {
            Height = 24,
            Padding = 6,
            FontSize = 10,
            IconSize = 12,
            BorderRadius = 4,
        },
        Small = {
            Height = 32,
            Padding = 8,
            FontSize = 12,
            IconSize = 14,
            BorderRadius = 6,
        },
        Medium = {
            Height = 40,
            Padding = 12,
            FontSize = 14,
            IconSize = 16,
            BorderRadius = 8,
        },
        Large = {
            Height = 48,
            Padding = 16,
            FontSize = 16,
            IconSize = 20,
            BorderRadius = 10,
        },
        XLarge = {
            Height = 56,
            Padding = 20,
            FontSize = 18,
            IconSize = 24,
            BorderRadius = 12,
        },
        XXLarge = {
            Height = 64,
            Padding = 24,
            FontSize = 20,
            IconSize = 28,
            BorderRadius = 14,
        },
    }

    --// Spacing
    Constants.Spacing = {
        None = 0,
        XXS = 2,
        XS = 4,
        SM = 8,
        MD = 12,
        LG = 16,
        XL = 24,
        XXL = 32,
        XXXL = 48,
    }

    --// Typography
    Constants.Typography = {
        -- Font Families
        Fonts = {
            Default = Enum.Font.GothamMedium,
            Heading = Enum.Font.GothamBold,
            Body = Enum.Font.Gotham,
            Mono = Enum.Font.Code,
            Display = Enum.Font.GothamBlack,
        },

        -- Font Sizes
        FontSizes = {
            XS = 10,
            SM = 12,
            MD = 14,
            LG = 16,
            XL = 20,
            XXL = 24,
            XXXL = 32,
            Display = 48,
        },

        -- Font Weights
        FontWeights = {
            Light = Enum.FontWeight.Light,
            Regular = Enum.FontWeight.Regular,
            Medium = Enum.FontWeight.Medium,
            SemiBold = Enum.FontWeight.SemiBold,
            Bold = Enum.FontWeight.Bold,
            ExtraBold = Enum.FontWeight.ExtraBold,
        },

        -- Line Heights
        LineHeights = {
            Tight = 1.2,
            Normal = 1.5,
            Relaxed = 1.8,
        },
    }

    --// Borders
    Constants.Borders = {
        -- Border Radius
        Radius = {
            None = 0,
            XS = 2,
            SM = 4,
            MD = 8,
            LG = 12,
            XL = 16,
            XXL = 24,
            Full = 9999,
        },

        -- Border Width
        Width = {
            None = 0,
            Thin = 1,
            Medium = 2,
            Thick = 3,
        },
    }

    --// Shadows
    Constants.Shadows = {
        None = {
            Offset = Vector2.new(0, 0),
            Radius = 0,
            Color = Color3.new(0, 0, 0),
            Transparency = 1,
        },
        XS = {
            Offset = Vector2.new(0, 1),
            Radius = 2,
            Color = Color3.new(0, 0, 0),
            Transparency = 0.9,
        },
        SM = {
            Offset = Vector2.new(0, 2),
            Radius = 4,
            Color = Color3.new(0, 0, 0),
            Transparency = 0.85,
        },
        MD = {
            Offset = Vector2.new(0, 4),
            Radius = 8,
            Color = Color3.new(0, 0, 0),
            Transparency = 0.8,
        },
        LG = {
            Offset = Vector2.new(0, 8),
            Radius = 16,
            Color = Color3.new(0, 0, 0),
            Transparency = 0.75,
        },
        XL = {
            Offset = Vector2.new(0, 16),
            Radius = 32,
            Color = Color3.new(0, 0, 0),
            Transparency = 0.7,
        },
        Inner = {
            Offset = Vector2.new(0, 2),
            Radius = 4,
            Color = Color3.new(0, 0, 0),
            Transparency = 0.95,
            Inner = true,
        },
    }

    --// Animation Defaults
    Constants.Animation = {
        -- Default tween info
        DefaultDuration = 0.2,
        DefaultEasing = Enum.EasingStyle.Quad,
        DefaultDirection = Enum.EasingDirection.Out,

        -- Spring defaults
        SpringDamping = 0.8,
        SpringFrequency = 4,
        SpringMass = 1,

        -- Preset durations
        Durations = {
            Instant = 0,
            Fast = 0.1,
            Normal = 0.2,
            Slow = 0.3,
            Slower = 0.5,
        },

        -- Easing presets
        Easings = {
            Default = { Style = Enum.EasingStyle.Quad, Direction = Enum.EasingDirection.Out },
            Smooth = { Style = Enum.EasingStyle.Sine, Direction = Enum.EasingDirection.InOut },
            Bounce = { Style = Enum.EasingStyle.Bounce, Direction = Enum.EasingDirection.Out },
            Elastic = { Style = Enum.EasingStyle.Elastic, Direction = Enum.EasingDirection.Out },
            Sharp = { Style = Enum.EasingStyle.Expo, Direction = Enum.EasingDirection.Out },
        },
    }

    --// Window Defaults
    Constants.Window = {
        DefaultSize = UDim2.fromOffset(600, 450),
        MinSize = Vector2.new(400, 300),
        MaxSize = Vector2.new(1200, 900),
        DefaultPosition = UDim2.fromScale(0.5, 0.5),
        TitleBarHeight = 36,
        TabBarHeight = 32,
        StatusBarHeight = 24,
        ResizeHandleSize = 8,
        SnapThreshold = 20,
        SnapMargin = 10,
    }

    --// Component Defaults
    Constants.Components = {
        -- Button
        Button = {
            DefaultVariant = "Primary",
            DefaultSize = "Medium",
            MinWidth = 80,
            IconSpacing = 8,
        },

        -- Toggle
        Toggle = {
            Width = 44,
            Height = 24,
            HandleSize = 20,
            HandleMargin = 2,
        },

        -- Slider
        Slider = {
            TrackHeight = 4,
            HandleSize = 16,
            MinWidth = 100,
        },

        -- TextInput
        TextInput = {
            DefaultVariant = "Default",
            DefaultSize = "Medium",
            MinWidth = 120,
            MaxLength = 10000,
        },

        -- Dropdown
        Dropdown = {
            MaxVisibleItems = 8,
            ItemHeight = 36,
            MinWidth = 150,
            MaxHeight = 300,
        },

        -- Tooltip
        Tooltip = {
            MaxWidth = 250,
            ShowDelay = 500,
            HideDelay = 100,
            Offset = Vector2.new(12, 12),
        },

        -- Modal
        Modal = {
            DefaultWidth = 480,
            MinWidth = 320,
            MaxWidth = 800,
            OverlayTransparency = 0.5,
        },

        -- Toast
        Toast = {
            DefaultDuration = 5,
            MaxVisible = 5,
            Width = 350,
            MinHeight = 60,
            Spacing = 12,
        },

        -- ScrollFrame
        ScrollFrame = {
            ScrollbarWidth = 8,
            ScrollbarMinHeight = 40,
            ScrollSpeed = 50,
            ScrollSmoothing = 0.1,
        },

        -- Tabs
        Tabs = {
            MinTabWidth = 80,
            MaxTabWidth = 200,
            TabHeight = 32,
            TabSpacing = 4,
        },
    }

    --// Notification Positions
    Constants.NotificationPositions = {
        TopLeft = {
            AnchorPoint = Vector2.new(0, 0),
            Position = UDim2.fromOffset(20, 20),
            LayoutOrder = 1,
        },
        TopCenter = {
            AnchorPoint = Vector2.new(0.5, 0),
            Position = UDim2.new(0.5, 0, 0, 20),
            LayoutOrder = 1,
        },
        TopRight = {
            AnchorPoint = Vector2.new(1, 0),
            Position = UDim2.new(1, -20, 0, 20),
            LayoutOrder = 1,
        },
        BottomLeft = {
            AnchorPoint = Vector2.new(0, 1),
            Position = UDim2.new(0, 20, 1, -20),
            LayoutOrder = -1,
        },
        BottomCenter = {
            AnchorPoint = Vector2.new(0.5, 1),
            Position = UDim2.new(0.5, 0, 1, -20),
            LayoutOrder = -1,
        },
        BottomRight = {
            AnchorPoint = Vector2.new(1, 1),
            Position = UDim2.new(1, -20, 1, -20),
            LayoutOrder = -1,
        },
    }

    --// Keyboard Shortcuts
    Constants.Keybinds = {
        ToggleUI = Enum.KeyCode.RightControl,
        Close = Enum.KeyCode.Escape,
        Confirm = Enum.KeyCode.Return,
        SelectAll = { Enum.KeyCode.LeftControl, Enum.KeyCode.A },
        Copy = { Enum.KeyCode.LeftControl, Enum.KeyCode.C },
        Paste = { Enum.KeyCode.LeftControl, Enum.KeyCode.V },
        Cut = { Enum.KeyCode.LeftControl, Enum.KeyCode.X },
        Undo = { Enum.KeyCode.LeftControl, Enum.KeyCode.Z },
        Redo = { Enum.KeyCode.LeftControl, Enum.KeyCode.Y },
        Save = { Enum.KeyCode.LeftControl, Enum.KeyCode.S },
    }

    --// Sound IDs
    Constants.Sounds = {
        Click = "rbxassetid://6895079853",
        Hover = "rbxassetid://6895079853",
        Toggle = "rbxassetid://6895079853",
        Slide = "rbxassetid://6895079853",
        Open = "rbxassetid://6895079853",
        Close = "rbxassetid://6895079853",
        Success = "rbxassetid://6895079853",
        Error = "rbxassetid://6895079853",
        Warning = "rbxassetid://6895079853",
        Notification = "rbxassetid://6895079853",
    }

    --// Performance
    Constants.Performance = {
        -- FPS thresholds
        FPSGood = 60,
        FPSWarning = 30,
        FPSCritical = 15,

        -- Memory thresholds (MB)
        MemoryWarning = 500,
        MemoryCritical = 1000,

        -- Ping thresholds (ms)
        PingGood = 50,
        PingWarning = 100,
        PingCritical = 200,

        -- Object pooling
        PoolInitialSize = 10,
        PoolMaxSize = 100,
        PoolGrowthFactor = 2,
    }

    --// Color Palette (base colors)
    Constants.Colors = {
        -- Neutrals
        White = Color3.fromRGB(255, 255, 255),
        Black = Color3.fromRGB(0, 0, 0),
        Gray50 = Color3.fromRGB(250, 250, 250),
        Gray100 = Color3.fromRGB(245, 245, 245),
        Gray200 = Color3.fromRGB(229, 229, 229),
        Gray300 = Color3.fromRGB(212, 212, 212),
        Gray400 = Color3.fromRGB(163, 163, 163),
        Gray500 = Color3.fromRGB(115, 115, 115),
        Gray600 = Color3.fromRGB(82, 82, 82),
        Gray700 = Color3.fromRGB(64, 64, 64),
        Gray800 = Color3.fromRGB(38, 38, 38),
        Gray900 = Color3.fromRGB(23, 23, 23),
        Gray950 = Color3.fromRGB(10, 10, 10),

        -- Primary colors
        Red = Color3.fromRGB(239, 68, 68),
        Orange = Color3.fromRGB(249, 115, 22),
        Amber = Color3.fromRGB(245, 158, 11),
        Yellow = Color3.fromRGB(234, 179, 8),
        Lime = Color3.fromRGB(132, 204, 22),
        Green = Color3.fromRGB(34, 197, 94),
        Emerald = Color3.fromRGB(16, 185, 129),
        Teal = Color3.fromRGB(20, 184, 166),
        Cyan = Color3.fromRGB(6, 182, 212),
        Sky = Color3.fromRGB(14, 165, 233),
        Blue = Color3.fromRGB(59, 130, 246),
        Indigo = Color3.fromRGB(99, 102, 241),
        Violet = Color3.fromRGB(139, 92, 246),
        Purple = Color3.fromRGB(168, 85, 247),
        Fuchsia = Color3.fromRGB(217, 70, 239),
        Pink = Color3.fromRGB(236, 72, 153),
        Rose = Color3.fromRGB(244, 63, 94),

        -- Semantic colors
        Success = Color3.fromRGB(34, 197, 94),
        Warning = Color3.fromRGB(245, 158, 11),
        Error = Color3.fromRGB(239, 68, 68),
        Info = Color3.fromRGB(59, 130, 246),

        -- Special
        Transparent = Color3.new(0, 0, 0),
    }

    --// Regex Patterns
    Constants.Patterns = {
        Email = "^[%w._%+-]+@[%w.-]+%.[%w]+$",
        Url = "^https?://[%w.-]+%.[%w]+",
        Phone = "^%+?%d[%d%-%(%) ]+$",
        Hex = "^#?[%x]+$",
        Number = "^%-?%d+%.?%d*$",
        Integer = "^%-?%d+$",
        Alphanumeric = "^[%w]+$",
        NoSpecialChars = "^[%w%s]+$",
    }

    --// Asset Prefixes
    Constants.AssetPrefixes = {
        RbxAsset = "rbxassetid://",
        RbxThumb = "rbxthumb://",
        Https = "https://",
        Http = "http://",
    }

    --// Instance Pool Categories
    Constants.PoolCategories = {
        Frame = "Frame",
        TextLabel = "TextLabel",
        TextButton = "TextButton",
        TextBox = "TextBox",
        ImageLabel = "ImageLabel",
        ImageButton = "ImageButton",
        ScrollingFrame = "ScrollingFrame",
        UICorner = "UICorner",
        UIStroke = "UIStroke",
        UIPadding = "UIPadding",
        UIListLayout = "UIListLayout",
        UIGridLayout = "UIGridLayout",
        UIGradient = "UIGradient",
    }

    --// Error Messages
    Constants.Errors = {
        InvalidArgument = "Invalid argument: %s",
        MissingRequired = "Missing required parameter: %s",
        TypeMismatch = "Type mismatch: expected %s, got %s",
        NotInitialized = "NexusUI is not initialized",
        AlreadyDestroyed = "Object has already been destroyed",
        InvalidComponent = "Invalid component: %s",
        InvalidTheme = "Invalid theme: %s",
        LoadFailed = "Failed to load: %s",
    }

    --// Freeze all constant tables to prevent modification
    local function DeepFreeze(t)
        if type(t) ~= "table" then return t end

        for k, v in pairs(t) do
            if type(v) == "table" then
                DeepFreeze(v)
            end
        end

        return table.freeze(t)
    end

    -- Only freeze in production
    if not Constants.Environment.IsStudio then
        DeepFreeze(Constants)
    end

    return Constants


end


-- ============================================================================
-- Module: NexusUI/Core/InstancePool
-- ============================================================================
NexusUI_Modules["NexusUI/Core/InstancePool"] = function()
    local script = CreateMockScript("NexusUI/Core/InstancePool")
    
    --[[
        NexusUI Instance Pool
        Object pooling system for efficient instance reuse

        Features:
        - Pre-allocated instance pools
        - Automatic pool growth
        - Instance recycling
        - Pool statistics
        - Memory optimization
        - Multi-category support
        - Warm-up functionality
    ]]

    --// Dependencies
    local Constants = NexusRequire("NexusUI/Constants")

    --// Instance Pool Class
    local InstancePool = {}
    InstancePool.__index = InstancePool
    InstancePool.ClassName = "InstancePool"

    --// Configuration
    local Config = {
        InitialPoolSize = 10,
        MaxPoolSize = 200,
        GrowthFactor = 2,
        ShrinkThreshold = 0.25,
        ShrinkDelay = 30,
        DebugMode = false,
        WarmUpOnCreate = true,
    }

    --// Pool Statistics
    local Stats = {
        TotalCreated = 0,
        TotalRecycled = 0,
        TotalAcquired = 0,
        TotalReleased = 0,
        CacheHits = 0,
        CacheMisses = 0,
    }

    --// Singleton Instance
    local instance = nil

    --// Pool Entry Class
    local PoolEntry = {}
    PoolEntry.__index = PoolEntry

    function PoolEntry.new(category, createFunc)
        local self = setmetatable({}, PoolEntry)

        self.Category = category
        self.CreateFunc = createFunc
        self.Available = {}
        self.InUse = {}
        self.TotalCreated = 0
        self.MaxSize = Config.MaxPoolSize
        self.LastShrinkCheck = os.clock()

        return self
    end

    function PoolEntry:Create()
        local instance

        if self.CreateFunc then
            instance = self.CreateFunc()
        else
            instance = Instance.new(self.Category)
        end

        self.TotalCreated = self.TotalCreated + 1
        Stats.TotalCreated = Stats.TotalCreated + 1

        return instance
    end

    function PoolEntry:Acquire()
        local obj = table.remove(self.Available)

        if obj then
            Stats.CacheHits = Stats.CacheHits + 1
            Stats.TotalRecycled = Stats.TotalRecycled + 1
        else
            Stats.CacheMisses = Stats.CacheMisses + 1
            obj = self:Create()
        end

        self.InUse[obj] = true
        Stats.TotalAcquired = Stats.TotalAcquired + 1

        return obj
    end

    function PoolEntry:Release(obj)
        if not obj then return end

        -- Remove from in-use
        self.InUse[obj] = nil

        -- Reset instance
        self:ResetInstance(obj)

        -- Add to available if pool not full
        if #self.Available < self.MaxSize then
            table.insert(self.Available, obj)
        else
            -- Pool is full, destroy instance
            pcall(function()
                obj:Destroy()
            end)
        end

        Stats.TotalReleased = Stats.TotalReleased + 1
    end

    function PoolEntry:ResetInstance(obj)
        if not obj or not obj:IsA("Instance") then return end

        pcall(function()
            -- Remove from parent
            obj.Parent = nil

            -- Reset common properties based on class
            if obj:IsA("GuiObject") then
                obj.Visible = true
                obj.BackgroundTransparency = 0
                obj.Size = UDim2.new(0, 100, 0, 100)
                obj.Position = UDim2.new(0, 0, 0, 0)
                obj.AnchorPoint = Vector2.new(0, 0)
                obj.Rotation = 0
                obj.ZIndex = 1
                obj.LayoutOrder = 0
                obj.Name = obj.ClassName

                if obj:IsA("Frame") then
                    obj.BackgroundColor3 = Color3.new(1, 1, 1)
                end

                if obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox") then
                    obj.Text = ""
                    obj.TextColor3 = Color3.new(0, 0, 0)
                    obj.TextSize = 14
                    obj.Font = Enum.Font.SourceSans
                    obj.TextXAlignment = Enum.TextXAlignment.Center
                    obj.TextYAlignment = Enum.TextYAlignment.Center
                    obj.TextWrapped = false
                    obj.TextScaled = false
                    obj.RichText = false
                end

                if obj:IsA("ImageLabel") or obj:IsA("ImageButton") then
                    obj.Image = ""
                    obj.ImageColor3 = Color3.new(1, 1, 1)
                    obj.ImageTransparency = 0
                    obj.ScaleType = Enum.ScaleType.Stretch
                end

                if obj:IsA("ScrollingFrame") then
                    obj.ScrollBarThickness = 12
                    obj.ScrollingDirection = Enum.ScrollingDirection.XY
                    obj.ScrollingEnabled = true
                    obj.CanvasSize = UDim2.new(0, 0, 0, 0)
                    obj.CanvasPosition = Vector2.new(0, 0)
                end
            end

            -- Reset UI modifiers
            if obj:IsA("UICorner") then
                obj.CornerRadius = UDim.new(0, 8)
            end

            if obj:IsA("UIStroke") then
                obj.Color = Color3.new(0, 0, 0)
                obj.Thickness = 1
                obj.Transparency = 0
                obj.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
            end

            if obj:IsA("UIPadding") then
                obj.PaddingTop = UDim.new(0, 0)
                obj.PaddingBottom = UDim.new(0, 0)
                obj.PaddingLeft = UDim.new(0, 0)
                obj.PaddingRight = UDim.new(0, 0)
            end

            if obj:IsA("UIListLayout") then
                obj.Padding = UDim.new(0, 0)
                obj.FillDirection = Enum.FillDirection.Vertical
                obj.HorizontalAlignment = Enum.HorizontalAlignment.Left
                obj.VerticalAlignment = Enum.VerticalAlignment.Top
                obj.SortOrder = Enum.SortOrder.LayoutOrder
            end

            if obj:IsA("UIGridLayout") then
                obj.CellPadding = UDim2.new(0, 0, 0, 0)
                obj.CellSize = UDim2.new(0, 100, 0, 100)
                obj.FillDirection = Enum.FillDirection.Horizontal
                obj.FillDirectionMaxCells = 0
                obj.SortOrder = Enum.SortOrder.LayoutOrder
            end

            if obj:IsA("UIGradient") then
                obj.Color = ColorSequence.new(Color3.new(1, 1, 1))
                obj.Transparency = NumberSequence.new(0)
                obj.Rotation = 0
                obj.Offset = Vector2.new(0, 0)
            end

            -- Clear children (but keep UI modifiers for base instances)
            for _, child in ipairs(obj:GetChildren()) do
                child:Destroy()
            end

            -- Clear connections (would need external tracking)
        end)
    end

    function PoolEntry:Warm(count)
        count = count or Config.InitialPoolSize

        for i = 1, count do
            if #self.Available < self.MaxSize then
                local obj = self:Create()
                table.insert(self.Available, obj)
            end
        end
    end

    function PoolEntry:Shrink()
        local now = os.clock()

        if now - self.LastShrinkCheck < Config.ShrinkDelay then
            return
        end

        self.LastShrinkCheck = now

        local totalCount = #self.Available + self:GetInUseCount()
        local usageRatio = self:GetInUseCount() / math.max(totalCount, 1)

        if usageRatio < Config.ShrinkThreshold and #self.Available > Config.InitialPoolSize then
            local toRemove = math.floor(#self.Available / 2)

            for i = 1, toRemove do
                local obj = table.remove(self.Available)
                if obj then
                    pcall(function()
                        obj:Destroy()
                    end)
                end
            end

            if Config.DebugMode then
                print(string.format("[InstancePool] Shrunk pool '%s' by %d instances", self.Category, toRemove))
            end
        end
    end

    function PoolEntry:GetAvailableCount()
        return #self.Available
    end

    function PoolEntry:GetInUseCount()
        local count = 0
        for _ in pairs(self.InUse) do
            count = count + 1
        end
        return count
    end

    function PoolEntry:Clear()
        -- Destroy available instances
        for _, obj in ipairs(self.Available) do
            pcall(function()
                obj:Destroy()
            end)
        end
        self.Available = {}

        -- Clear in-use tracking (don't destroy - they're being used)
        self.InUse = {}
    end

    --// Instance Pool Implementation
    function InstancePool.new()
        local self = setmetatable({}, InstancePool)

        self._pools = {}
        self._customCreators = {}

        return self
    end

    function InstancePool.GetInstance()
        if not instance then
            instance = InstancePool.new()

            -- Initialize default pools
            if Config.WarmUpOnCreate then
                instance:InitializeDefaultPools()
            end
        end
        return instance
    end

    function InstancePool:InitializeDefaultPools()
        local categories = {
            "Frame",
            "TextLabel",
            "TextButton",
            "TextBox",
            "ImageLabel",
            "ImageButton",
            "ScrollingFrame",
            "UICorner",
            "UIStroke",
            "UIPadding",
            "UIListLayout",
            "UIGridLayout",
            "UIGradient",
        }

        for _, category in ipairs(categories) do
            self:CreatePool(category)
            self:Warm(category, Config.InitialPoolSize)
        end
    end

    function InstancePool:CreatePool(category, createFunc)
        if self._pools[category] then
            return self._pools[category]
        end

        local pool = PoolEntry.new(category, createFunc)
        self._pools[category] = pool

        return pool
    end

    function InstancePool:GetPool(category)
        return self._pools[category]
    end

    function InstancePool:HasPool(category)
        return self._pools[category] ~= nil
    end

    function InstancePool:Acquire(category, properties)
        local pool = self._pools[category]

        if not pool then
            pool = self:CreatePool(category)
        end

        local obj = pool:Acquire()

        -- Apply properties if provided
        if properties and obj then
            for prop, value in pairs(properties) do
                pcall(function()
                    if prop ~= "Parent" then
                        obj[prop] = value
                    end
                end)
            end

            -- Set parent last
            if properties.Parent then
                obj.Parent = properties.Parent
            end
        end

        return obj
    end

    function InstancePool:Release(obj)
        if not obj then return end

        local className = obj.ClassName
        local pool = self._pools[className]

        if pool then
            pool:Release(obj)
        else
            -- No pool for this type, just destroy
            pcall(function()
                obj:Destroy()
            end)
        end
    end

    function InstancePool:ReleaseAll(objects)
        for _, obj in ipairs(objects) do
            self:Release(obj)
        end
    end

    function InstancePool:Warm(category, count)
        local pool = self._pools[category]

        if not pool then
            pool = self:CreatePool(category)
        end

        pool:Warm(count)
    end

    function InstancePool:WarmAll(count)
        for _, pool in pairs(self._pools) do
            pool:Warm(count)
        end
    end

    function InstancePool:Shrink(category)
        if category then
            local pool = self._pools[category]
            if pool then
                pool:Shrink()
            end
        else
            for _, pool in pairs(self._pools) do
                pool:Shrink()
            end
        end
    end

    function InstancePool:Clear(category)
        if category then
            local pool = self._pools[category]
            if pool then
                pool:Clear()
            end
        else
            for _, pool in pairs(self._pools) do
                pool:Clear()
            end
        end
    end

    function InstancePool:SetCustomCreator(category, createFunc)
        self._customCreators[category] = createFunc

        local pool = self._pools[category]
        if pool then
            pool.CreateFunc = createFunc
        end
    end

    --// Statistics
    function InstancePool:GetStats()
        local poolStats = {}

        for category, pool in pairs(self._pools) do
            poolStats[category] = {
                Available = pool:GetAvailableCount(),
                InUse = pool:GetInUseCount(),
                TotalCreated = pool.TotalCreated,
            }
        end

        return {
            Global = {
                TotalCreated = Stats.TotalCreated,
                TotalRecycled = Stats.TotalRecycled,
                TotalAcquired = Stats.TotalAcquired,
                TotalReleased = Stats.TotalReleased,
                CacheHits = Stats.CacheHits,
                CacheMisses = Stats.CacheMisses,
                HitRate = Stats.CacheHits / math.max(Stats.CacheHits + Stats.CacheMisses, 1),
            },
            Pools = poolStats,
        }
    end

    function InstancePool:GetHitRate()
        local total = Stats.CacheHits + Stats.CacheMisses
        if total == 0 then return 1 end
        return Stats.CacheHits / total
    end

    function InstancePool:GetTotalAvailable()
        local total = 0
        for _, pool in pairs(self._pools) do
            total = total + pool:GetAvailableCount()
        end
        return total
    end

    function InstancePool:GetTotalInUse()
        local total = 0
        for _, pool in pairs(self._pools) do
            total = total + pool:GetInUseCount()
        end
        return total
    end

    function InstancePool:ResetStats()
        Stats.TotalCreated = 0
        Stats.TotalRecycled = 0
        Stats.TotalAcquired = 0
        Stats.TotalReleased = 0
        Stats.CacheHits = 0
        Stats.CacheMisses = 0
    end

    --// Configuration
    function InstancePool:SetConfig(key, value)
        if Config[key] ~= nil then
            Config[key] = value
        end
    end

    function InstancePool:GetConfig(key)
        return Config[key]
    end

    --// Debug
    function InstancePool:PrintStats()
        local stats = self:GetStats()

        print("=== Instance Pool Statistics ===")
        print(string.format("Total Created: %d", stats.Global.TotalCreated))
        print(string.format("Total Recycled: %d", stats.Global.TotalRecycled))
        print(string.format("Cache Hit Rate: %.2f%%", stats.Global.HitRate * 100))
        print("")
        print("Pool Breakdown:")

        for category, poolStats in pairs(stats.Pools) do
            print(string.format("  %s: %d available, %d in use, %d created",
                category,
                poolStats.Available,
                poolStats.InUse,
                poolStats.TotalCreated
            ))
        end
    end

    --// Cleanup
    function InstancePool:Destroy()
        self:Clear()
        self._pools = {}
        self._customCreators = {}
    end

    --// Convenience Methods (static-like access)
    function InstancePool.Get(category, properties)
        return InstancePool.GetInstance():Acquire(category, properties)
    end

    function InstancePool.Return(obj)
        return InstancePool.GetInstance():Release(obj)
    end

    --// Export singleton instance
    return InstancePool.GetInstance()


end


-- ============================================================================
-- Module: NexusUI/Core/ScreenGui
-- ============================================================================
NexusUI_Modules["NexusUI/Core/ScreenGui"] = function()
    local script = CreateMockScript("NexusUI/Core/ScreenGui")
    
    --[[
        NexusUI ScreenGui Manager
        Manages ScreenGui instances and container hierarchy

        Features:
        - Safe ScreenGui creation (CoreGui/PlayerGui fallback)
        - Layer management
        - Container organization
        - Display order management
        - Visibility control
        - Safe destruction
    ]]

    --// Services
    local Players = game:GetService("Players")
    local CoreGui = game:GetService("CoreGui")
    local RunService = game:GetService("RunService")

    --// Dependencies
    local Constants = NexusRequire("NexusUI/Constants")

    --// Local Player
    local LocalPlayer = Players.LocalPlayer
    local PlayerGui = LocalPlayer and LocalPlayer:WaitForChild("PlayerGui", 5)

    --// ScreenGui Manager Class
    local ScreenGuiManager = {}
    ScreenGuiManager.__index = ScreenGuiManager
    ScreenGuiManager.ClassName = "ScreenGuiManager"

    --// Configuration
    local Config = {
        LibraryName = "NexusUI",
        BaseDisplayOrder = 999999,
        UsesCoreGui = true,
        IgnoreGuiInset = true,
        ResetOnSpawn = false,
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
    }

    --// Container Definitions
    local ContainerDefinitions = {
        Main = {
            Name = "MainContainer",
            ZIndex = Constants.ZIndex.Base,
            Order = 1,
        },
        Windows = {
            Name = "WindowContainer",
            ZIndex = Constants.ZIndex.Component,
            Order = 2,
        },
        Dropdowns = {
            Name = "DropdownContainer",
            ZIndex = Constants.ZIndex.Dropdown,
            Order = 3,
        },
        Popovers = {
            Name = "PopoverContainer",
            ZIndex = Constants.ZIndex.Popover,
            Order = 4,
        },
        Modals = {
            Name = "ModalContainer",
            ZIndex = Constants.ZIndex.Modal,
            Order = 5,
        },
        Toasts = {
            Name = "ToastContainer",
            ZIndex = Constants.ZIndex.Toast,
            Order = 6,
        },
        Tooltips = {
            Name = "TooltipContainer",
            ZIndex = Constants.ZIndex.Tooltip,
            Order = 7,
        },
        ContextMenus = {
            Name = "ContextMenuContainer",
            ZIndex = Constants.ZIndex.ContextMenu,
            Order = 8,
        },
        Overlays = {
            Name = "OverlayContainer",
            ZIndex = Constants.ZIndex.Overlay,
            Order = 9,
        },
        Performance = {
            Name = "PerformanceContainer",
            ZIndex = Constants.ZIndex.PerformanceMonitor,
            Order = 10,
        },
        Watermarks = {
            Name = "WatermarkContainer",
            ZIndex = Constants.ZIndex.Watermark,
            Order = 11,
        },
        ESP = {
            Name = "ESPContainer",
            ZIndex = Constants.ZIndex.Maximum,
            Order = 12,
        },
    }

    --// Singleton Instance
    local instance = nil

    --// ScreenGui Manager Implementation
    function ScreenGuiManager.new()
        local self = setmetatable({}, ScreenGuiManager)

        self._screenGui = nil
        self._containers = {}
        self._visible = true
        self._destroyed = false
        self._parent = nil

        return self
    end

    function ScreenGuiManager.GetInstance()
        if not instance then
            instance = ScreenGuiManager.new()
        end
        return instance
    end

    --// Initialization
    function ScreenGuiManager:Initialize(config)
        if self._screenGui and self._screenGui.Parent then
            return self._screenGui
        end

        -- Apply config
        if config then
            for key, value in pairs(config) do
                if Config[key] ~= nil then
                    Config[key] = value
                end
            end
        end

        -- Create ScreenGui
        self._screenGui = self:_createScreenGui()

        -- Create containers
        self:_createContainers()

        return self._screenGui
    end

    function ScreenGuiManager:_createScreenGui()
        -- Clean up existing
        self:_cleanupExisting()

        -- Create new ScreenGui
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = Config.LibraryName
        screenGui.DisplayOrder = Config.BaseDisplayOrder
        screenGui.IgnoreGuiInset = Config.IgnoreGuiInset
        screenGui.ResetOnSpawn = Config.ResetOnSpawn
        screenGui.ZIndexBehavior = Config.ZIndexBehavior

        -- Try CoreGui first
        if Config.UsesCoreGui then
            local success = pcall(function()
                screenGui.Parent = CoreGui
            end)

            if success then
                self._parent = CoreGui
                return screenGui
            end
        end

        -- Fallback to PlayerGui
        if PlayerGui then
            screenGui.Parent = PlayerGui
            self._parent = PlayerGui
        else
            warn("[NexusUI.ScreenGui] Could not find suitable parent for ScreenGui")
        end

        return screenGui
    end

    function ScreenGuiManager:_cleanupExisting()
        -- Clean from CoreGui
        local existingCore = CoreGui:FindFirstChild(Config.LibraryName)
        if existingCore then
            pcall(function()
                existingCore:Destroy()
            end)
        end

        -- Clean from PlayerGui
        if PlayerGui then
            local existingPlayer = PlayerGui:FindFirstChild(Config.LibraryName)
            if existingPlayer then
                pcall(function()
                    existingPlayer:Destroy()
                end)
            end
        end
    end

    function ScreenGuiManager:_createContainers()
        if not self._screenGui then return end

        -- Sort by order
        local sortedDefs = {}
        for key, def in pairs(ContainerDefinitions) do
            table.insert(sortedDefs, { Key = key, Definition = def })
        end

        table.sort(sortedDefs, function(a, b)
            return a.Definition.Order < b.Definition.Order
        end)

        -- Create containers
        for _, entry in ipairs(sortedDefs) do
            local def = entry.Definition

            local container = Instance.new("Frame")
            container.Name = def.Name
            container.BackgroundTransparency = 1
            container.Size = UDim2.fromScale(1, 1)
            container.Position = UDim2.fromScale(0, 0)
            container.ZIndex = def.ZIndex
            container.Parent = self._screenGui

            self._containers[entry.Key] = container
        end
    end

    --// Container Access
    function ScreenGuiManager:GetContainer(containerName)
        return self._containers[containerName]
    end

    function ScreenGuiManager:GetMainContainer()
        return self._containers.Main
    end

    function ScreenGuiManager:GetWindowContainer()
        return self._containers.Windows
    end

    function ScreenGuiManager:GetDropdownContainer()
        return self._containers.Dropdowns
    end

    function ScreenGuiManager:GetPopoverContainer()
        return self._containers.Popovers
    end

    function ScreenGuiManager:GetModalContainer()
        return self._containers.Modals
    end

    function ScreenGuiManager:GetToastContainer()
        return self._containers.Toasts
    end

    function ScreenGuiManager:GetTooltipContainer()
        return self._containers.Tooltips
    end

    function ScreenGuiManager:GetContextMenuContainer()
        return self._containers.ContextMenus
    end

    function ScreenGuiManager:GetOverlayContainer()
        return self._containers.Overlays
    end

    function ScreenGuiManager:GetPerformanceContainer()
        return self._containers.Performance
    end

    function ScreenGuiManager:GetWatermarkContainer()
        return self._containers.Watermarks
    end

    function ScreenGuiManager:GetESPContainer()
        return self._containers.ESP
    end

    function ScreenGuiManager:GetAllContainers()
        local copy = {}
        for key, container in pairs(self._containers) do
            copy[key] = container
        end
        return copy
    end

    --// ScreenGui Access
    function ScreenGuiManager:GetScreenGui()
        return self._screenGui
    end

    function ScreenGuiManager:GetParent()
        return self._parent
    end

    function ScreenGuiManager:IsUsingCoreGui()
        return self._parent == CoreGui
    end

    --// Visibility Control
    function ScreenGuiManager:SetVisible(visible)
        self._visible = visible

        if self._screenGui then
            self._screenGui.Enabled = visible
        end
    end

    function ScreenGuiManager:IsVisible()
        return self._visible and self._screenGui and self._screenGui.Enabled
    end

    function ScreenGuiManager:Toggle()
        self:SetVisible(not self._visible)
        return self._visible
    end

    function ScreenGuiManager:Show()
        self:SetVisible(true)
    end

    function ScreenGuiManager:Hide()
        self:SetVisible(false)
    end

    --// Container Visibility
    function ScreenGuiManager:SetContainerVisible(containerName, visible)
        local container = self._containers[containerName]
        if container then
            container.Visible = visible
        end
    end

    function ScreenGuiManager:IsContainerVisible(containerName)
        local container = self._containers[containerName]
        return container and container.Visible
    end

    function ScreenGuiManager:ShowContainer(containerName)
        self:SetContainerVisible(containerName, true)
    end

    function ScreenGuiManager:HideContainer(containerName)
        self:SetContainerVisible(containerName, false)
    end

    --// Display Order
    function ScreenGuiManager:SetDisplayOrder(order)
        if self._screenGui then
            self._screenGui.DisplayOrder = order
        end
    end

    function ScreenGuiManager:GetDisplayOrder()
        return self._screenGui and self._screenGui.DisplayOrder or 0
    end

    function ScreenGuiManager:BringToFront()
        self:SetDisplayOrder(Config.BaseDisplayOrder + 1000)
    end

    --// ZIndex Management
    function ScreenGuiManager:SetContainerZIndex(containerName, zIndex)
        local container = self._containers[containerName]
        if container then
            container.ZIndex = zIndex
        end
    end

    function ScreenGuiManager:GetContainerZIndex(containerName)
        local container = self._containers[containerName]
        return container and container.ZIndex or 0
    end

    --// Screen Information
    function ScreenGuiManager:GetScreenSize()
        if self._screenGui then
            return self._screenGui.AbsoluteSize
        end

        local camera = workspace.CurrentCamera
        if camera then
            return camera.ViewportSize
        end

        return Vector2.new(1920, 1080)
    end

    function ScreenGuiManager:GetScreenCenter()
        local size = self:GetScreenSize()
        return Vector2.new(size.X / 2, size.Y / 2)
    end

    function ScreenGuiManager:GetGuiInset()
        local GuiService = game:GetService("GuiService")
        local inset, _ = GuiService:GetGuiInset()
        return inset
    end

    --// Safe Instance Creation
    function ScreenGuiManager:CreateInContainer(containerName, instanceType, properties)
        local container = self._containers[containerName]
        if not container then
            warn(string.format("[NexusUI.ScreenGui] Container '%s' not found", containerName))
            return nil
        end

        local instance = Instance.new(instanceType)

        if properties then
            for prop, value in pairs(properties) do
                if prop ~= "Parent" then
                    pcall(function()
                        instance[prop] = value
                    end)
                end
            end
        end

        instance.Parent = container

        return instance
    end

    --// Cleanup
    function ScreenGuiManager:ClearContainer(containerName)
        local container = self._containers[containerName]
        if container then
            for _, child in ipairs(container:GetChildren()) do
                pcall(function()
                    child:Destroy()
                end)
            end
        end
    end

    function ScreenGuiManager:ClearAllContainers()
        for containerName, _ in pairs(self._containers) do
            self:ClearContainer(containerName)
        end
    end

    function ScreenGuiManager:Destroy()
        if self._destroyed then return end

        self._destroyed = true

        -- Clear containers
        self:ClearAllContainers()
        self._containers = {}

        -- Destroy ScreenGui
        if self._screenGui then
            pcall(function()
                self._screenGui:Destroy()
            end)
            self._screenGui = nil
        end

        self._parent = nil
    end

    function ScreenGuiManager:IsDestroyed()
        return self._destroyed
    end

    --// Reinitialization
    function ScreenGuiManager:Reinitialize(config)
        self:Destroy()
        self._destroyed = false
        return self:Initialize(config)
    end

    --// Configuration
    function ScreenGuiManager:SetConfig(key, value)
        if Config[key] ~= nil then
            Config[key] = value
        end
    end

    function ScreenGuiManager:GetConfig(key)
        return Config[key]
    end

    --// Debug
    function ScreenGuiManager:PrintInfo()
        print("=== ScreenGui Manager Info ===")
        print(string.format("ScreenGui: %s", self._screenGui and self._screenGui.Name or "None"))
        print(string.format("Parent: %s", self._parent and self._parent.Name or "None"))
        print(string.format("Visible: %s", tostring(self._visible)))
        print(string.format("Display Order: %d", self:GetDisplayOrder()))
        print(string.format("Screen Size: %s", tostring(self:GetScreenSize())))
        print("")
        print("Containers:")
        for name, container in pairs(self._containers) do
            local childCount = #container:GetChildren()
            print(string.format("  %s: %d children, ZIndex %d, Visible %s",
                name, childCount, container.ZIndex, tostring(container.Visible)))
        end
    end

    --// Export singleton instance
    return ScreenGuiManager.GetInstance()


end


-- ============================================================================
-- Module: NexusUI/Core/Utility/Math
-- ============================================================================
NexusUI_Modules["NexusUI/Core/Utility/Math"] = function()
    local script = CreateMockScript("NexusUI/Core/Utility/Math")
    
    --[[
        NexusUI Math Utilities
        Advanced mathematical functions for UI calculations

        Features:
        - Basic math operations
        - Interpolation functions
        - Geometric calculations
        - Random number generation
        - Vector math
        - Statistical functions
    ]]

    --// Math Utility Module
    local MathUtil = {}

    --// Constants
    MathUtil.PI = math.pi
    MathUtil.TAU = math.pi * 2
    MathUtil.E = 2.718281828459045
    MathUtil.PHI = 1.618033988749895 -- Golden ratio
    MathUtil.EPSILON = 1e-10
    MathUtil.DEG_TO_RAD = math.pi / 180
    MathUtil.RAD_TO_DEG = 180 / math.pi

    --// Basic Operations
    function MathUtil.Clamp(value, min, max)
        return math.max(min, math.min(max, value))
    end

    function MathUtil.Round(value, decimals)
        decimals = decimals or 0
        local mult = 10 ^ decimals
        return math.floor(value * mult + 0.5) / mult
    end

    function MathUtil.Floor(value, decimals)
        decimals = decimals or 0
        local mult = 10 ^ decimals
        return math.floor(value * mult) / mult
    end

    function MathUtil.Ceil(value, decimals)
        decimals = decimals or 0
        local mult = 10 ^ decimals
        return math.ceil(value * mult) / mult
    end

    function MathUtil.Sign(value)
        if value > 0 then return 1
        elseif value < 0 then return -1
        else return 0 end
    end

    function MathUtil.Abs(value)
        return math.abs(value)
    end

    function MathUtil.Min(...)
        return math.min(...)
    end

    function MathUtil.Max(...)
        return math.max(...)
    end

    function MathUtil.Mod(a, b)
        return a % b
    end

    function MathUtil.Pow(base, exponent)
        return base ^ exponent
    end

    function MathUtil.Sqrt(value)
        return math.sqrt(value)
    end

    function MathUtil.Cbrt(value)
        return value ^ (1/3)
    end

    function MathUtil.Log(value, base)
        base = base or math.exp(1)
        return math.log(value) / math.log(base)
    end

    function MathUtil.Log10(value)
        return math.log10(value)
    end

    function MathUtil.Exp(value)
        return math.exp(value)
    end

    --// Interpolation
    function MathUtil.Lerp(a, b, t)
        return a + (b - a) * t
    end

    function MathUtil.InverseLerp(a, b, value)
        if a == b then return 0 end
        return (value - a) / (b - a)
    end

    function MathUtil.Map(value, inMin, inMax, outMin, outMax)
        return outMin + (value - inMin) * (outMax - outMin) / (inMax - inMin)
    end

    function MathUtil.MapClamped(value, inMin, inMax, outMin, outMax)
        local t = MathUtil.Clamp((value - inMin) / (inMax - inMin), 0, 1)
        return outMin + t * (outMax - outMin)
    end

    function MathUtil.SmoothStep(edge0, edge1, x)
        local t = MathUtil.Clamp((x - edge0) / (edge1 - edge0), 0, 1)
        return t * t * (3 - 2 * t)
    end

    function MathUtil.SmootherStep(edge0, edge1, x)
        local t = MathUtil.Clamp((x - edge0) / (edge1 - edge0), 0, 1)
        return t * t * t * (t * (t * 6 - 15) + 10)
    end

    function MathUtil.CosineInterpolate(a, b, t)
        local ft = t * MathUtil.PI
        local f = (1 - math.cos(ft)) * 0.5
        return a * (1 - f) + b * f
    end

    function MathUtil.CubicInterpolate(y0, y1, y2, y3, t)
        local t2 = t * t
        local a0 = y3 - y2 - y0 + y1
        local a1 = y0 - y1 - a0
        local a2 = y2 - y0
        local a3 = y1
        return a0 * t * t2 + a1 * t2 + a2 * t + a3
    end

    function MathUtil.Hermite(p0, p1, m0, m1, t)
        local t2 = t * t
        local t3 = t2 * t
        local h00 = 2*t3 - 3*t2 + 1
        local h10 = t3 - 2*t2 + t
        local h01 = -2*t3 + 3*t2
        local h11 = t3 - t2
        return h00*p0 + h10*m0 + h01*p1 + h11*m1
    end

    --// Angle Operations
    function MathUtil.DegToRad(degrees)
        return degrees * MathUtil.DEG_TO_RAD
    end

    function MathUtil.RadToDeg(radians)
        return radians * MathUtil.RAD_TO_DEG
    end

    function MathUtil.NormalizeAngle(angle)
        angle = angle % MathUtil.TAU
        if angle < 0 then
            angle = angle + MathUtil.TAU
        end
        return angle
    end

    function MathUtil.AngleDifference(a, b)
        local diff = (b - a) % MathUtil.TAU
        if diff > MathUtil.PI then
            diff = diff - MathUtil.TAU
        end
        return diff
    end

    function MathUtil.LerpAngle(a, b, t)
        local diff = MathUtil.AngleDifference(a, b)
        return a + diff * t
    end

    function MathUtil.Sin(angle)
        return math.sin(angle)
    end

    function MathUtil.Cos(angle)
        return math.cos(angle)
    end

    function MathUtil.Tan(angle)
        return math.tan(angle)
    end

    function MathUtil.Asin(value)
        return math.asin(value)
    end

    function MathUtil.Acos(value)
        return math.acos(value)
    end

    function MathUtil.Atan(value)
        return math.atan(value)
    end

    function MathUtil.Atan2(y, x)
        return math.atan2(y, x)
    end

    --// Random Numbers
    function MathUtil.Random(min, max)
        if min and max then
            return math.random() * (max - min) + min
        elseif min then
            return math.random() * min
        else
            return math.random()
        end
    end

    function MathUtil.RandomInt(min, max)
        return math.random(min, max)
    end

    function MathUtil.RandomBool(probability)
        probability = probability or 0.5
        return math.random() < probability
    end

    function MathUtil.RandomSign()
        return math.random() < 0.5 and -1 or 1
    end

    function MathUtil.RandomInRange(range)
        return MathUtil.Random(-range, range)
    end

    function MathUtil.RandomGaussian(mean, standardDeviation)
        mean = mean or 0
        standardDeviation = standardDeviation or 1

        -- Box-Muller transform
        local u1 = math.random()
        local u2 = math.random()
        local z0 = math.sqrt(-2 * math.log(u1)) * math.cos(MathUtil.TAU * u2)

        return mean + z0 * standardDeviation
    end

    function MathUtil.RandomFromArray(array)
        return array[math.random(#array)]
    end

    function MathUtil.RandomWeighted(weights)
        local total = 0
        for _, weight in pairs(weights) do
            total = total + weight
        end

        local random = math.random() * total
        local cumulative = 0

        for key, weight in pairs(weights) do
            cumulative = cumulative + weight
            if random <= cumulative then
                return key
            end
        end
    end

    --// Vector Operations (2D)
    function MathUtil.Vector2Length(x, y)
        return math.sqrt(x * x + y * y)
    end

    function MathUtil.Vector2LengthSquared(x, y)
        return x * x + y * y
    end

    function MathUtil.Vector2Normalize(x, y)
        local length = MathUtil.Vector2Length(x, y)
        if length == 0 then
            return 0, 0
        end
        return x / length, y / length
    end

    function MathUtil.Vector2Dot(x1, y1, x2, y2)
        return x1 * x2 + y1 * y2
    end

    function MathUtil.Vector2Cross(x1, y1, x2, y2)
        return x1 * y2 - y1 * x2
    end

    function MathUtil.Vector2Distance(x1, y1, x2, y2)
        local dx = x2 - x1
        local dy = y2 - y1
        return math.sqrt(dx * dx + dy * dy)
    end

    function MathUtil.Vector2DistanceSquared(x1, y1, x2, y2)
        local dx = x2 - x1
        local dy = y2 - y1
        return dx * dx + dy * dy
    end

    function MathUtil.Vector2Angle(x, y)
        return math.atan2(y, x)
    end

    function MathUtil.Vector2FromAngle(angle, length)
        length = length or 1
        return math.cos(angle) * length, math.sin(angle) * length
    end

    function MathUtil.Vector2Rotate(x, y, angle)
        local cos = math.cos(angle)
        local sin = math.sin(angle)
        return x * cos - y * sin, x * sin + y * cos
    end

    function MathUtil.Vector2Lerp(x1, y1, x2, y2, t)
        return MathUtil.Lerp(x1, x2, t), MathUtil.Lerp(y1, y2, t)
    end

    function MathUtil.Vector2Reflect(x, y, nx, ny)
        local dot = MathUtil.Vector2Dot(x, y, nx, ny)
        return x - 2 * dot * nx, y - 2 * dot * ny
    end

    --// Geometry
    function MathUtil.PointInRect(px, py, rx, ry, rw, rh)
        return px >= rx and px <= rx + rw and py >= ry and py <= ry + rh
    end

    function MathUtil.PointInCircle(px, py, cx, cy, radius)
        return MathUtil.Vector2DistanceSquared(px, py, cx, cy) <= radius * radius
    end

    function MathUtil.RectOverlap(r1x, r1y, r1w, r1h, r2x, r2y, r2w, r2h)
        return r1x < r2x + r2w and r1x + r1w > r2x and r1y < r2y + r2h and r1y + r1h > r2y
    end

    function MathUtil.CircleOverlap(c1x, c1y, r1, c2x, c2y, r2)
        local dist = MathUtil.Vector2Distance(c1x, c1y, c2x, c2y)
        return dist < r1 + r2
    end

    function MathUtil.LineIntersection(x1, y1, x2, y2, x3, y3, x4, y4)
        local d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)

        if math.abs(d) < MathUtil.EPSILON then
            return nil -- Lines are parallel
        end

        local t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / d
        local x = x1 + t * (x2 - x1)
        local y = y1 + t * (y2 - y1)

        return x, y
    end

    function MathUtil.ClosestPointOnLine(px, py, x1, y1, x2, y2)
        local dx = x2 - x1
        local dy = y2 - y1
        local lengthSquared = dx * dx + dy * dy

        if lengthSquared == 0 then
            return x1, y1
        end

        local t = MathUtil.Clamp(((px - x1) * dx + (py - y1) * dy) / lengthSquared, 0, 1)

        return x1 + t * dx, y1 + t * dy
    end

    --// Statistics
    function MathUtil.Sum(values)
        local sum = 0
        for _, v in ipairs(values) do
            sum = sum + v
        end
        return sum
    end

    function MathUtil.Mean(values)
        if #values == 0 then return 0 end
        return MathUtil.Sum(values) / #values
    end

    function MathUtil.Median(values)
        if #values == 0 then return 0 end

        local sorted = {}
        for _, v in ipairs(values) do
            table.insert(sorted, v)
        end
        table.sort(sorted)

        local mid = math.floor(#sorted / 2)

        if #sorted % 2 == 0 then
            return (sorted[mid] + sorted[mid + 1]) / 2
        else
            return sorted[mid + 1]
        end
    end

    function MathUtil.Mode(values)
        if #values == 0 then return nil end

        local counts = {}
        local maxCount = 0
        local mode = nil

        for _, v in ipairs(values) do
            counts[v] = (counts[v] or 0) + 1
            if counts[v] > maxCount then
                maxCount = counts[v]
                mode = v
            end
        end

        return mode
    end

    function MathUtil.Variance(values)
        if #values == 0 then return 0 end

        local mean = MathUtil.Mean(values)
        local sumSquares = 0

        for _, v in ipairs(values) do
            sumSquares = sumSquares + (v - mean) ^ 2
        end

        return sumSquares / #values
    end

    function MathUtil.StandardDeviation(values)
        return math.sqrt(MathUtil.Variance(values))
    end

    function MathUtil.Range(values)
        if #values == 0 then return 0 end

        local min, max = values[1], values[1]

        for _, v in ipairs(values) do
            if v < min then min = v end
            if v > max then max = v end
        end

        return max - min
    end

    --// Easing (basic)
    function MathUtil.EaseLinear(t)
        return t
    end

    function MathUtil.EaseInQuad(t)
        return t * t
    end

    function MathUtil.EaseOutQuad(t)
        return 1 - (1 - t) * (1 - t)
    end

    function MathUtil.EaseInOutQuad(t)
        if t < 0.5 then
            return 2 * t * t
        else
            return 1 - (-2 * t + 2) ^ 2 / 2
        end
    end

    function MathUtil.EaseInCubic(t)
        return t * t * t
    end

    function MathUtil.EaseOutCubic(t)
        return 1 - (1 - t) ^ 3
    end

    function MathUtil.EaseInOutCubic(t)
        if t < 0.5 then
            return 4 * t * t * t
        else
            return 1 - (-2 * t + 2) ^ 3 / 2
        end
    end

    --// Utility
    function MathUtil.IsNaN(value)
        return value ~= value
    end

    function MathUtil.IsInfinite(value)
        return value == math.huge or value == -math.huge
    end

    function MathUtil.IsFinite(value)
        return not MathUtil.IsNaN(value) and not MathUtil.IsInfinite(value)
    end

    function MathUtil.Approximately(a, b, epsilon)
        epsilon = epsilon or MathUtil.EPSILON
        return math.abs(a - b) <= epsilon
    end

    function MathUtil.Wrap(value, min, max)
        local range = max - min
        return ((value - min) % range) + min
    end

    function MathUtil.PingPong(value, length)
        local t = value % (length * 2)
        return length - math.abs(t - length)
    end

    return MathUtil


end


-- ============================================================================
-- Module: NexusUI/Core/Utility/String
-- ============================================================================
NexusUI_Modules["NexusUI/Core/Utility/String"] = function()
    local script = CreateMockScript("NexusUI/Core/Utility/String")
    
    --[[
        NexusUI String Utilities
        Comprehensive string manipulation functions

        Features:
        - Basic string operations
        - Formatting and templating
        - Parsing and extraction
        - Validation
        - Encoding utilities
    ]]

    --// String Utility Module
    local StringUtil = {}

    --// Basic Operations
    function StringUtil.Trim(str)
        return str:match("^%s*(.-)%s*$")
    end

    function StringUtil.TrimLeft(str)
        return str:match("^%s*(.-)$")
    end

    function StringUtil.TrimRight(str)
        return str:match("^(.-)%s*$")
    end

    function StringUtil.ToLower(str)
        return str:lower()
    end

    function StringUtil.ToUpper(str)
        return str:upper()
    end

    function StringUtil.Capitalize(str)
        return str:sub(1, 1):upper() .. str:sub(2):lower()
    end

    function StringUtil.CapitalizeWords(str)
        return str:gsub("(%a)([%w]*)", function(first, rest)
            return first:upper() .. rest:lower()
        end)
    end

    function StringUtil.Reverse(str)
        return str:reverse()
    end

    function StringUtil.Repeat(str, count)
        return str:rep(count)
    end

    function StringUtil.PadLeft(str, length, char)
        char = char or " "
        if #str >= length then return str end
        return string.rep(char, length - #str) .. str
    end

    function StringUtil.PadRight(str, length, char)
        char = char or " "
        if #str >= length then return str end
        return str .. string.rep(char, length - #str)
    end

    function StringUtil.PadCenter(str, length, char)
        char = char or " "
        if #str >= length then return str end

        local padding = length - #str
        local leftPad = math.floor(padding / 2)
        local rightPad = padding - leftPad

        return string.rep(char, leftPad) .. str .. string.rep(char, rightPad)
    end

    --// Splitting and Joining
    function StringUtil.Split(str, delimiter, limit)
        delimiter = delimiter or ","
        limit = limit or math.huge

        local result = {}
        local pattern = "([^" .. delimiter .. "]*)" .. delimiter .. "?"

        for match in str:gmatch(pattern) do
            table.insert(result, match)
            if #result >= limit then break end
        end

        -- Remove trailing empty string if present
        if result[#result] == "" and #result > 1 then
            table.remove(result)
        end

        return result
    end

    function StringUtil.SplitByPattern(str, pattern)
        local result = {}
        local lastEnd = 1

        for start, finish in function() return str:find(pattern, lastEnd) end do
            table.insert(result, str:sub(lastEnd, start - 1))
            lastEnd = finish + 1
        end

        table.insert(result, str:sub(lastEnd))

        return result
    end

    function StringUtil.Join(strings, delimiter)
        delimiter = delimiter or ","
        return table.concat(strings, delimiter)
    end

    function StringUtil.Lines(str)
        return StringUtil.Split(str, "\n")
    end

    function StringUtil.Words(str)
        local words = {}
        for word in str:gmatch("%S+") do
            table.insert(words, word)
        end
        return words
    end

    function StringUtil.Chars(str)
        local chars = {}
        for i = 1, #str do
            table.insert(chars, str:sub(i, i))
        end
        return chars
    end

    --// Search and Replace
    function StringUtil.Contains(str, substring)
        return str:find(substring, 1, true) ~= nil
    end

    function StringUtil.StartsWith(str, prefix)
        return str:sub(1, #prefix) == prefix
    end

    function StringUtil.EndsWith(str, suffix)
        return str:sub(-#suffix) == suffix
    end

    function StringUtil.IndexOf(str, substring, startIndex)
        startIndex = startIndex or 1
        local index = str:find(substring, startIndex, true)
        return index or -1
    end

    function StringUtil.LastIndexOf(str, substring)
        local lastIndex = -1
        local startIndex = 1

        while true do
            local index = str:find(substring, startIndex, true)
            if not index then break end
            lastIndex = index
            startIndex = index + 1
        end

        return lastIndex
    end

    function StringUtil.Replace(str, search, replacement, count)
        if count then
            local result = str
            for i = 1, count do
                result = result:gsub(search, replacement, 1)
            end
            return result
        else
            return str:gsub(search, replacement)
        end
    end

    function StringUtil.ReplaceFirst(str, search, replacement)
        return str:gsub(search, replacement, 1)
    end

    function StringUtil.Remove(str, pattern)
        return str:gsub(pattern, "")
    end

    function StringUtil.Count(str, substring)
        local count = 0
        local startIndex = 1

        while true do
            local index = str:find(substring, startIndex, true)
            if not index then break end
            count = count + 1
            startIndex = index + 1
        end

        return count
    end

    --// Substring Operations
    function StringUtil.Substring(str, startIndex, endIndex)
        return str:sub(startIndex, endIndex)
    end

    function StringUtil.Left(str, count)
        return str:sub(1, count)
    end

    function StringUtil.Right(str, count)
        return str:sub(-count)
    end

    function StringUtil.Mid(str, startIndex, length)
        return str:sub(startIndex, startIndex + length - 1)
    end

    function StringUtil.Truncate(str, maxLength, suffix)
        suffix = suffix or "..."

        if #str <= maxLength then
            return str
        end

        return str:sub(1, maxLength - #suffix) .. suffix
    end

    function StringUtil.TruncateWords(str, maxWords, suffix)
        suffix = suffix or "..."
        local words = StringUtil.Words(str)

        if #words <= maxWords then
            return str
        end

        local result = {}
        for i = 1, maxWords do
            table.insert(result, words[i])
        end

        return table.concat(result, " ") .. suffix
    end

    --// Case Conversion
    function StringUtil.CamelCase(str)
        local result = ""
        local capitalizeNext = false

        for i = 1, #str do
            local char = str:sub(i, i)

            if char:match("[%s_%-]") then
                capitalizeNext = true
            elseif capitalizeNext then
                result = result .. char:upper()
                capitalizeNext = false
            elseif result == "" then
                result = char:lower()
            else
                result = result .. char
            end
        end

        return result
    end

    function StringUtil.PascalCase(str)
        local camel = StringUtil.CamelCase(str)
        return camel:sub(1, 1):upper() .. camel:sub(2)
    end

    function StringUtil.SnakeCase(str)
        local result = str:gsub("([A-Z])", "_%1"):gsub("^_", ""):lower()
        result = result:gsub("[%s%-]", "_")
        result = result:gsub("_+", "_")
        return result
    end

    function StringUtil.KebabCase(str)
        local result = str:gsub("([A-Z])", "-%1"):gsub("^%-", ""):lower()
        result = result:gsub("[%s_]", "-")
        result = result:gsub("%-+", "-")
        return result
    end

    function StringUtil.ConstantCase(str)
        return StringUtil.SnakeCase(str):upper()
    end

    function StringUtil.DotCase(str)
        local result = str:gsub("([A-Z])", ".%1"):gsub("^%.", ""):lower()
        result = result:gsub("[%s_%-]", ".")
        result = result:gsub("%.+", ".")
        return result
    end

    --// Formatting
    function StringUtil.Format(template, ...)
        return string.format(template, ...)
    end

    function StringUtil.Template(template, variables)
        return template:gsub("{([%w_]+)}", function(key)
            local value = variables[key]
            return value ~= nil and tostring(value) or "{" .. key .. "}"
        end)
    end

    function StringUtil.Interpolate(template, variables)
        return template:gsub("%${([%w_]+)}", function(key)
            local value = variables[key]
            return value ~= nil and tostring(value) or "${" .. key .. "}"
        end)
    end

    function StringUtil.NumberFormat(number, decimals, thousandsSep, decimalSep)
        decimals = decimals or 0
        thousandsSep = thousandsSep or ","
        decimalSep = decimalSep or "."

        local formatted = string.format("%." .. decimals .. "f", number)
        local intPart, decPart = formatted:match("([^%.]+)%.?(.*)")

        intPart = intPart:reverse():gsub("(%d%d%d)", "%1" .. thousandsSep):reverse()
        intPart = intPart:gsub("^" .. thousandsSep, "")

        if decPart and #decPart > 0 then
            return intPart .. decimalSep .. decPart
        else
            return intPart
        end
    end

    function StringUtil.Pluralize(count, singular, plural)
        plural = plural or (singular .. "s")
        return count == 1 and singular or plural
    end

    --// Validation
    function StringUtil.IsEmpty(str)
        return str == nil or str == ""
    end

    function StringUtil.IsBlank(str)
        return str == nil or StringUtil.Trim(str) == ""
    end

    function StringUtil.IsNumeric(str)
        return str:match("^%-?%d+%.?%d*$") ~= nil
    end

    function StringUtil.IsInteger(str)
        return str:match("^%-?%d+$") ~= nil
    end

    function StringUtil.IsAlpha(str)
        return str:match("^%a+$") ~= nil
    end

    function StringUtil.IsAlphanumeric(str)
        return str:match("^%w+$") ~= nil
    end

    function StringUtil.IsLower(str)
        return str == str:lower() and str:match("%a") ~= nil
    end

    function StringUtil.IsUpper(str)
        return str == str:upper() and str:match("%a") ~= nil
    end

    function StringUtil.IsHex(str)
        return str:match("^#?[%x]+$") ~= nil
    end

    function StringUtil.IsEmail(str)
        return str:match("^[%w._%+-]+@[%w.-]+%.[%w]+$") ~= nil
    end

    function StringUtil.IsUrl(str)
        return str:match("^https?://[%w.-]+%.[%w]+") ~= nil
    end

    --// Encoding
    function StringUtil.EncodeBase64(str)
        local b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
        local result = {}

        local bytes = {str:byte(1, #str)}
        local padding = (3 - #bytes % 3) % 3

        for i = 1, padding do
            table.insert(bytes, 0)
        end

        for i = 1, #bytes, 3 do
            local b1, b2, b3 = bytes[i], bytes[i+1], bytes[i+2]

            local c1 = bit32.rshift(b1, 2)
            local c2 = bit32.bor(bit32.lshift(bit32.band(b1, 3), 4), bit32.rshift(b2, 4))
            local c3 = bit32.bor(bit32.lshift(bit32.band(b2, 15), 2), bit32.rshift(b3, 6))
            local c4 = bit32.band(b3, 63)

            table.insert(result, b64chars:sub(c1+1, c1+1))
            table.insert(result, b64chars:sub(c2+1, c2+1))
            table.insert(result, b64chars:sub(c3+1, c3+1))
            table.insert(result, b64chars:sub(c4+1, c4+1))
        end

        for i = 1, padding do
            result[#result - i + 1] = "="
        end

        return table.concat(result)
    end

    function StringUtil.DecodeBase64(str)
        local b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
        local b64lookup = {}

        for i = 1, #b64chars do
            b64lookup[b64chars:sub(i, i)] = i - 1
        end

        str = str:gsub("=", "")
        local result = {}

        for i = 1, #str, 4 do
            local c1 = b64lookup[str:sub(i, i)] or 0
            local c2 = b64lookup[str:sub(i+1, i+1)] or 0
            local c3 = b64lookup[str:sub(i+2, i+2)] or 0
            local c4 = b64lookup[str:sub(i+3, i+3)] or 0

            local b1 = bit32.bor(bit32.lshift(c1, 2), bit32.rshift(c2, 4))
            local b2 = bit32.bor(bit32.lshift(bit32.band(c2, 15), 4), bit32.rshift(c3, 2))
            local b3 = bit32.bor(bit32.lshift(bit32.band(c3, 3), 6), c4)

            table.insert(result, string.char(b1))
            if str:sub(i+2, i+2) ~= "" then table.insert(result, string.char(b2)) end
            if str:sub(i+3, i+3) ~= "" then table.insert(result, string.char(b3)) end
        end

        return table.concat(result)
    end

    function StringUtil.EncodeUri(str)
        return str:gsub("[^%w%-_.~]", function(char)
            return string.format("%%%02X", string.byte(char))
        end)
    end

    function StringUtil.DecodeUri(str)
        return str:gsub("%%(%x%x)", function(hex)
            return string.char(tonumber(hex, 16))
        end)
    end

    function StringUtil.EscapeHtml(str)
        local entities = {
            ["&"] = "&amp;",
            ["<"] = "&lt;",
            [">"] = "&gt;",
            ['"'] = "&quot;",
            ["'"] = "&#39;",
        }

        return str:gsub("[&<>\"']", entities)
    end

    function StringUtil.UnescapeHtml(str)
        local entities = {
            ["&amp;"] = "&",
            ["&lt;"] = "<",
            ["&gt;"] = ">",
            ["&quot;"] = '"',
            ["&#39;"] = "'",
        }

        return str:gsub("&%w+;", entities)
    end

    function StringUtil.EscapePattern(str)
        return str:gsub("([%.%+%-%*%?%^%$%(%)%[%]%%])", "%%%1")
    end

    --// Similarity and Comparison
    function StringUtil.Compare(str1, str2, ignoreCase)
        if ignoreCase then
            str1 = str1:lower()
            str2 = str2:lower()
        end

        if str1 < str2 then return -1
        elseif str1 > str2 then return 1
        else return 0 end
    end

    function StringUtil.Equals(str1, str2, ignoreCase)
        if ignoreCase then
            return str1:lower() == str2:lower()
        end
        return str1 == str2
    end

    function StringUtil.LevenshteinDistance(str1, str2)
        local len1, len2 = #str1, #str2
        local matrix = {}

        for i = 0, len1 do
            matrix[i] = {[0] = i}
        end

        for j = 0, len2 do
            matrix[0][j] = j
        end

        for i = 1, len1 do
            for j = 1, len2 do
                local cost = str1:sub(i, i) == str2:sub(j, j) and 0 or 1
                matrix[i][j] = math.min(
                    matrix[i-1][j] + 1,
                    matrix[i][j-1] + 1,
                    matrix[i-1][j-1] + cost
                )
            end
        end

        return matrix[len1][len2]
    end

    function StringUtil.Similarity(str1, str2)
        local distance = StringUtil.LevenshteinDistance(str1, str2)
        local maxLen = math.max(#str1, #str2)

        if maxLen == 0 then return 1 end

        return 1 - distance / maxLen
    end

    --// Generation
    function StringUtil.Random(length, charset)
        charset = charset or "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        local result = {}

        for i = 1, length do
            local randomIndex = math.random(1, #charset)
            table.insert(result, charset:sub(randomIndex, randomIndex))
        end

        return table.concat(result)
    end

    function StringUtil.UUID()
        local template = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx"
        return template:gsub("[xy]", function(c)
            local v = c == "x" and math.random(0, 15) or math.random(8, 11)
            return string.format("%x", v)
        end)
    end

    return StringUtil


end


-- ============================================================================
-- Module: NexusUI/Core/Utility/Table
-- ============================================================================
NexusUI_Modules["NexusUI/Core/Utility/Table"] = function()
    local script = CreateMockScript("NexusUI/Core/Utility/Table")
    
    --[[
        NexusUI Table Utilities
        Comprehensive table manipulation functions

        Features:
        - Deep operations (copy, merge, compare)
        - Array operations
        - Dictionary operations
        - Functional programming helpers
        - Serialization utilities
    ]]

    --// Table Utility Module
    local TableUtil = {}

    --// Type Checking
    function TableUtil.IsTable(value)
        return type(value) == "table"
    end

    function TableUtil.IsArray(tbl)
        if type(tbl) ~= "table" then return false end

        local count = 0
        for _ in pairs(tbl) do
            count = count + 1
        end

        return count == #tbl
    end

    function TableUtil.IsDictionary(tbl)
        if type(tbl) ~= "table" then return false end
        return not TableUtil.IsArray(tbl)
    end

    function TableUtil.IsEmpty(tbl)
        return next(tbl) == nil
    end

    --// Copying
    function TableUtil.ShallowCopy(tbl)
        if type(tbl) ~= "table" then
            return tbl
        end

        local copy = {}
        for key, value in pairs(tbl) do
            copy[key] = value
        end

        return copy
    end

    function TableUtil.DeepCopy(tbl, seen)
        if type(tbl) ~= "table" then
            return tbl
        end

        seen = seen or {}

        if seen[tbl] then
            return seen[tbl]
        end

        local copy = {}
        seen[tbl] = copy

        for key, value in pairs(tbl) do
            copy[TableUtil.DeepCopy(key, seen)] = TableUtil.DeepCopy(value, seen)
        end

        return setmetatable(copy, getmetatable(tbl))
    end

    function TableUtil.Clone(tbl)
        return TableUtil.DeepCopy(tbl)
    end

    --// Merging
    function TableUtil.Merge(base, override)
        local result = TableUtil.DeepCopy(base)

        for key, value in pairs(override) do
            if type(value) == "table" and type(result[key]) == "table" then
                result[key] = TableUtil.Merge(result[key], value)
            else
                result[key] = value
            end
        end

        return result
    end

    function TableUtil.MergeShallow(base, override)
        local result = TableUtil.ShallowCopy(base)

        for key, value in pairs(override) do
            result[key] = value
        end

        return result
    end

    function TableUtil.MergeMany(...)
        local result = {}

        for _, tbl in ipairs({...}) do
            result = TableUtil.Merge(result, tbl)
        end

        return result
    end

    function TableUtil.Defaults(tbl, defaults)
        local result = TableUtil.DeepCopy(tbl)

        for key, value in pairs(defaults) do
            if result[key] == nil then
                result[key] = TableUtil.DeepCopy(value)
            elseif type(value) == "table" and type(result[key]) == "table" then
                result[key] = TableUtil.Defaults(result[key], value)
            end
        end

        return result
    end

    --// Comparison
    function TableUtil.Equals(tbl1, tbl2)
        if tbl1 == tbl2 then return true end
        if type(tbl1) ~= "table" or type(tbl2) ~= "table" then return false end

        for key, value in pairs(tbl1) do
            if type(value) == "table" then
                if not TableUtil.Equals(value, tbl2[key]) then
                    return false
                end
            elseif value ~= tbl2[key] then
                return false
            end
        end

        for key, _ in pairs(tbl2) do
            if tbl1[key] == nil then
                return false
            end
        end

        return true
    end

    function TableUtil.Contains(tbl, value)
        for _, v in pairs(tbl) do
            if v == value then
                return true
            end
        end
        return false
    end

    function TableUtil.ContainsKey(tbl, key)
        return tbl[key] ~= nil
    end

    --// Keys and Values
    function TableUtil.Keys(tbl)
        local keys = {}
        for key, _ in pairs(tbl) do
            table.insert(keys, key)
        end
        return keys
    end

    function TableUtil.Values(tbl)
        local values = {}
        for _, value in pairs(tbl) do
            table.insert(values, value)
        end
        return values
    end

    function TableUtil.Entries(tbl)
        local entries = {}
        for key, value in pairs(tbl) do
            table.insert(entries, {key = key, value = value})
        end
        return entries
    end

    function TableUtil.FromEntries(entries)
        local tbl = {}
        for _, entry in ipairs(entries) do
            tbl[entry.key] = entry.value
        end
        return tbl
    end

    --// Counting
    function TableUtil.Count(tbl)
        local count = 0
        for _ in pairs(tbl) do
            count = count + 1
        end
        return count
    end

    function TableUtil.Length(tbl)
        return #tbl
    end

    function TableUtil.CountBy(tbl, predicate)
        local count = 0
        for key, value in pairs(tbl) do
            if predicate(value, key) then
                count = count + 1
            end
        end
        return count
    end

    --// Searching
    function TableUtil.Find(tbl, predicate)
        for key, value in pairs(tbl) do
            if predicate(value, key) then
                return value, key
            end
        end
        return nil
    end

    function TableUtil.FindIndex(tbl, predicate)
        for i, value in ipairs(tbl) do
            if predicate(value, i) then
                return i
            end
        end
        return nil
    end

    function TableUtil.IndexOf(tbl, value)
        for i, v in ipairs(tbl) do
            if v == value then
                return i
            end
        end
        return -1
    end

    function TableUtil.LastIndexOf(tbl, value)
        for i = #tbl, 1, -1 do
            if tbl[i] == value then
                return i
            end
        end
        return -1
    end

    function TableUtil.KeyOf(tbl, value)
        for key, v in pairs(tbl) do
            if v == value then
                return key
            end
        end
        return nil
    end

    --// Functional Operations
    function TableUtil.Map(tbl, transform)
        local result = {}

        for key, value in pairs(tbl) do
            local newValue = transform(value, key)

            if TableUtil.IsArray(tbl) then
                table.insert(result, newValue)
            else
                result[key] = newValue
            end
        end

        return result
    end

    function TableUtil.Filter(tbl, predicate)
        local result = {}

        for key, value in pairs(tbl) do
            if predicate(value, key) then
                if TableUtil.IsArray(tbl) then
                    table.insert(result, value)
                else
                    result[key] = value
                end
            end
        end

        return result
    end

    function TableUtil.Reject(tbl, predicate)
        return TableUtil.Filter(tbl, function(value, key)
            return not predicate(value, key)
        end)
    end

    function TableUtil.Reduce(tbl, reducer, initial)
        local accumulator = initial

        for key, value in pairs(tbl) do
            accumulator = reducer(accumulator, value, key)
        end

        return accumulator
    end

    function TableUtil.ReduceRight(tbl, reducer, initial)
        local accumulator = initial

        for i = #tbl, 1, -1 do
            accumulator = reducer(accumulator, tbl[i], i)
        end

        return accumulator
    end

    function TableUtil.ForEach(tbl, callback)
        for key, value in pairs(tbl) do
            callback(value, key)
        end
    end

    function TableUtil.Every(tbl, predicate)
        for key, value in pairs(tbl) do
            if not predicate(value, key) then
                return false
            end
        end
        return true
    end

    function TableUtil.Some(tbl, predicate)
        for key, value in pairs(tbl) do
            if predicate(value, key) then
                return true
            end
        end
        return false
    end

    function TableUtil.None(tbl, predicate)
        return not TableUtil.Some(tbl, predicate)
    end

    --// Array Operations
    function TableUtil.Push(tbl, ...)
        for _, value in ipairs({...}) do
            table.insert(tbl, value)
        end
        return #tbl
    end

    function TableUtil.Pop(tbl)
        return table.remove(tbl)
    end

    function TableUtil.Shift(tbl)
        return table.remove(tbl, 1)
    end

    function TableUtil.Unshift(tbl, ...)
        local args = {...}
        for i = #args, 1, -1 do
            table.insert(tbl, 1, args[i])
        end
        return #tbl
    end

    function TableUtil.Concat(...)
        local result = {}
        for _, tbl in ipairs({...}) do
            for _, value in ipairs(tbl) do
                table.insert(result, value)
            end
        end
        return result
    end

    function TableUtil.Slice(tbl, startIndex, endIndex)
        startIndex = startIndex or 1
        endIndex = endIndex or #tbl

        if startIndex < 0 then startIndex = #tbl + startIndex + 1 end
        if endIndex < 0 then endIndex = #tbl + endIndex + 1 end

        local result = {}
        for i = startIndex, endIndex do
            table.insert(result, tbl[i])
        end
        return result
    end

    function TableUtil.Splice(tbl, startIndex, deleteCount, ...)
        deleteCount = deleteCount or #tbl - startIndex + 1
        local removed = {}

        for i = 1, deleteCount do
            table.insert(removed, table.remove(tbl, startIndex))
        end

        local insertItems = {...}
        for i = #insertItems, 1, -1 do
            table.insert(tbl, startIndex, insertItems[i])
        end

        return removed
    end

    function TableUtil.Reverse(tbl)
        local result = {}
        for i = #tbl, 1, -1 do
            table.insert(result, tbl[i])
        end
        return result
    end

    function TableUtil.Sort(tbl, comparator)
        local result = TableUtil.ShallowCopy(tbl)
        table.sort(result, comparator)
        return result
    end

    function TableUtil.SortBy(tbl, key)
        return TableUtil.Sort(tbl, function(a, b)
            return a[key] < b[key]
        end)
    end

    function TableUtil.Shuffle(tbl)
        local result = TableUtil.ShallowCopy(tbl)

        for i = #result, 2, -1 do
            local j = math.random(i)
            result[i], result[j] = result[j], result[i]
        end

        return result
    end

    function TableUtil.Unique(tbl)
        local seen = {}
        local result = {}

        for _, value in ipairs(tbl) do
            if not seen[value] then
                seen[value] = true
                table.insert(result, value)
            end
        end

        return result
    end

    function TableUtil.UniqueBy(tbl, key)
        local seen = {}
        local result = {}

        for _, value in ipairs(tbl) do
            local k = type(key) == "function" and key(value) or value[key]
            if not seen[k] then
                seen[k] = true
                table.insert(result, value)
            end
        end

        return result
    end

    function TableUtil.Flatten(tbl, depth)
        depth = depth or 1
        local result = {}

        for _, value in ipairs(tbl) do
            if type(value) == "table" and depth > 0 then
                for _, innerValue in ipairs(TableUtil.Flatten(value, depth - 1)) do
                    table.insert(result, innerValue)
                end
            else
                table.insert(result, value)
            end
        end

        return result
    end

    function TableUtil.FlattenDeep(tbl)
        return TableUtil.Flatten(tbl, math.huge)
    end

    --// Grouping and Partitioning
    function TableUtil.GroupBy(tbl, key)
        local result = {}

        for _, value in ipairs(tbl) do
            local k = type(key) == "function" and key(value) or value[key]

            if not result[k] then
                result[k] = {}
            end

            table.insert(result[k], value)
        end

        return result
    end

    function TableUtil.Partition(tbl, predicate)
        local pass = {}
        local fail = {}

        for key, value in pairs(tbl) do
            if predicate(value, key) then
                table.insert(pass, value)
            else
                table.insert(fail, value)
            end
        end

        return pass, fail
    end

    function TableUtil.Chunk(tbl, size)
        local result = {}
        local chunk = {}

        for _, value in ipairs(tbl) do
            table.insert(chunk, value)

            if #chunk >= size then
                table.insert(result, chunk)
                chunk = {}
            end
        end

        if #chunk > 0 then
            table.insert(result, chunk)
        end

        return result
    end

    --// Set Operations
    function TableUtil.Union(...)
        local seen = {}
        local result = {}

        for _, tbl in ipairs({...}) do
            for _, value in ipairs(tbl) do
                if not seen[value] then
                    seen[value] = true
                    table.insert(result, value)
                end
            end
        end

        return result
    end

    function TableUtil.Intersection(tbl1, tbl2)
        local set = {}
        for _, value in ipairs(tbl2) do
            set[value] = true
        end

        local result = {}
        for _, value in ipairs(tbl1) do
            if set[value] then
                table.insert(result, value)
            end
        end

        return result
    end

    function TableUtil.Difference(tbl1, tbl2)
        local set = {}
        for _, value in ipairs(tbl2) do
            set[value] = true
        end

        local result = {}
        for _, value in ipairs(tbl1) do
            if not set[value] then
                table.insert(result, value)
            end
        end

        return result
    end

    function TableUtil.SymmetricDifference(tbl1, tbl2)
        return TableUtil.Union(
            TableUtil.Difference(tbl1, tbl2),
            TableUtil.Difference(tbl2, tbl1)
        )
    end

    --// Object Operations
    function TableUtil.Pick(tbl, keys)
        local result = {}

        for _, key in ipairs(keys) do
            result[key] = tbl[key]
        end

        return result
    end

    function TableUtil.Omit(tbl, keys)
        local keySet = {}
        for _, key in ipairs(keys) do
            keySet[key] = true
        end

        local result = {}
        for key, value in pairs(tbl) do
            if not keySet[key] then
                result[key] = value
            end
        end

        return result
    end

    function TableUtil.Invert(tbl)
        local result = {}
        for key, value in pairs(tbl) do
            result[value] = key
        end
        return result
    end

    function TableUtil.MapKeys(tbl, transform)
        local result = {}
        for key, value in pairs(tbl) do
            result[transform(key, value)] = value
        end
        return result
    end

    function TableUtil.MapValues(tbl, transform)
        local result = {}
        for key, value in pairs(tbl) do
            result[key] = transform(value, key)
        end
        return result
    end

    --// Math Operations
    function TableUtil.Sum(tbl)
        local sum = 0
        for _, value in ipairs(tbl) do
            sum = sum + value
        end
        return sum
    end

    function TableUtil.Average(tbl)
        if #tbl == 0 then return 0 end
        return TableUtil.Sum(tbl) / #tbl
    end

    function TableUtil.Min(tbl)
        local min = nil
        for _, value in ipairs(tbl) do
            if min == nil or value < min then
                min = value
            end
        end
        return min
    end

    function TableUtil.Max(tbl)
        local max = nil
        for _, value in ipairs(tbl) do
            if max == nil or value > max then
                max = value
            end
        end
        return max
    end

    function TableUtil.MinBy(tbl, key)
        local min = nil
        local minValue = nil

        for _, item in ipairs(tbl) do
            local value = type(key) == "function" and key(item) or item[key]
            if minValue == nil or value < minValue then
                minValue = value
                min = item
            end
        end

        return min
    end

    function TableUtil.MaxBy(tbl, key)
        local max = nil
        local maxValue = nil

        for _, item in ipairs(tbl) do
            local value = type(key) == "function" and key(item) or item[key]
            if maxValue == nil or value > maxValue then
                maxValue = value
                max = item
            end
        end

        return max
    end

    --// Random Selection
    function TableUtil.Sample(tbl)
        if #tbl == 0 then return nil end
        return tbl[math.random(#tbl)]
    end

    function TableUtil.SampleSize(tbl, n)
        local shuffled = TableUtil.Shuffle(tbl)
        return TableUtil.Slice(shuffled, 1, math.min(n, #shuffled))
    end

    --// Safe Access
    function TableUtil.Get(tbl, path, default)
        local current = tbl

        for _, key in ipairs(type(path) == "table" and path or {path}) do
            if type(current) ~= "table" then
                return default
            end
            current = current[key]
        end

        return current ~= nil and current or default
    end

    function TableUtil.Set(tbl, path, value)
        local keys = type(path) == "table" and path or {path}
        local current = tbl

        for i = 1, #keys - 1 do
            local key = keys[i]
            if type(current[key]) ~= "table" then
                current[key] = {}
            end
            current = current[key]
        end

        current[keys[#keys]] = value
    end

    function TableUtil.Has(tbl, path)
        return TableUtil.Get(tbl, path) ~= nil
    end

    --// Freezing
    function TableUtil.Freeze(tbl)
        return table.freeze(tbl)
    end

    function TableUtil.DeepFreeze(tbl)
        for key, value in pairs(tbl) do
            if type(value) == "table" then
                TableUtil.DeepFreeze(value)
            end
        end
        return table.freeze(tbl)
    end

    function TableUtil.IsFrozen(tbl)
        return table.isfrozen(tbl)
    end

    --// Clear
    function TableUtil.Clear(tbl)
        for key in pairs(tbl) do
            tbl[key] = nil
        end
        return tbl
    end

    function TableUtil.Assign(target, ...)
        for _, source in ipairs({...}) do
            for key, value in pairs(source) do
                target[key] = value
            end
        end
        return target
    end

    return TableUtil


end


-- ============================================================================
-- Module: NexusUI/Core/Utility/Color
-- ============================================================================
NexusUI_Modules["NexusUI/Core/Utility/Color"] = function()
    local script = CreateMockScript("NexusUI/Core/Utility/Color")
    
    --[[
        NexusUI Color Utilities
        Comprehensive color manipulation and conversion functions

        Features:
        - Color space conversions (RGB, HSV, HSL, HEX)
        - Color manipulation (lighten, darken, saturate, etc.)
        - Color blending and mixing
        - Palette generation
        - Accessibility helpers
    ]]

    --// Color Utility Module
    local ColorUtil = {}

    --// Constants
    ColorUtil.WHITE = Color3.new(1, 1, 1)
    ColorUtil.BLACK = Color3.new(0, 0, 0)
    ColorUtil.RED = Color3.new(1, 0, 0)
    ColorUtil.GREEN = Color3.new(0, 1, 0)
    ColorUtil.BLUE = Color3.new(0, 0, 1)
    ColorUtil.YELLOW = Color3.new(1, 1, 0)
    ColorUtil.CYAN = Color3.new(0, 1, 1)
    ColorUtil.MAGENTA = Color3.new(1, 0, 1)
    ColorUtil.TRANSPARENT = Color3.new(0, 0, 0)

    --// RGB Operations
    function ColorUtil.FromRGB(r, g, b)
        return Color3.new(r / 255, g / 255, b / 255)
    end

    function ColorUtil.ToRGB(color)
        return math.floor(color.R * 255 + 0.5),
               math.floor(color.G * 255 + 0.5),
               math.floor(color.B * 255 + 0.5)
    end

    function ColorUtil.FromRGBA(r, g, b, a)
        return Color3.new(r / 255, g / 255, b / 255), a / 255
    end

    function ColorUtil.GetComponents(color)
        return color.R, color.G, color.B
    end

    --// Hex Conversion
    function ColorUtil.FromHex(hex)
        hex = hex:gsub("#", "")

        if #hex == 3 then
            hex = hex:sub(1, 1):rep(2) .. hex:sub(2, 2):rep(2) .. hex:sub(3, 3):rep(2)
        end

        if #hex == 8 then
            -- RGBA format
            local r = tonumber(hex:sub(1, 2), 16) / 255
            local g = tonumber(hex:sub(3, 4), 16) / 255
            local b = tonumber(hex:sub(5, 6), 16) / 255
            local a = tonumber(hex:sub(7, 8), 16) / 255
            return Color3.new(r, g, b), a
        end

        local r = tonumber(hex:sub(1, 2), 16) / 255
        local g = tonumber(hex:sub(3, 4), 16) / 255
        local b = tonumber(hex:sub(5, 6), 16) / 255

        return Color3.new(r, g, b)
    end

    function ColorUtil.ToHex(color, includeHash)
        includeHash = includeHash ~= false
        local r, g, b = ColorUtil.ToRGB(color)
        local hex = string.format("%02X%02X%02X", r, g, b)
        return includeHash and "#" .. hex or hex
    end

    function ColorUtil.ToHexA(color, alpha, includeHash)
        includeHash = includeHash ~= false
        local r, g, b = ColorUtil.ToRGB(color)
        local a = math.floor(alpha * 255 + 0.5)
        local hex = string.format("%02X%02X%02X%02X", r, g, b, a)
        return includeHash and "#" .. hex or hex
    end

    --// HSV Conversion
    function ColorUtil.FromHSV(h, s, v)
        local r, g, b
        local i = math.floor(h * 6)
        local f = h * 6 - i
        local p = v * (1 - s)
        local q = v * (1 - f * s)
        local t = v * (1 - (1 - f) * s)

        i = i % 6

        if i == 0 then r, g, b = v, t, p
        elseif i == 1 then r, g, b = q, v, p
        elseif i == 2 then r, g, b = p, v, t
        elseif i == 3 then r, g, b = p, q, v
        elseif i == 4 then r, g, b = t, p, v
        elseif i == 5 then r, g, b = v, p, q
        end

        return Color3.new(r, g, b)
    end

    function ColorUtil.ToHSV(color)
        local r, g, b = color.R, color.G, color.B
        local max = math.max(r, g, b)
        local min = math.min(r, g, b)
        local h, s, v

        v = max
        local d = max - min

        if max == 0 then
            s = 0
        else
            s = d / max
        end

        if max == min then
            h = 0
        else
            if max == r then
                h = (g - b) / d
                if g < b then h = h + 6 end
            elseif max == g then
                h = (b - r) / d + 2
            else
                h = (r - g) / d + 4
            end
            h = h / 6
        end

        return h, s, v
    end

    --// HSL Conversion
    function ColorUtil.FromHSL(h, s, l)
        local r, g, b

        if s == 0 then
            r, g, b = l, l, l
        else
            local function hueToRgb(p, q, t)
                if t < 0 then t = t + 1 end
                if t > 1 then t = t - 1 end
                if t < 1/6 then return p + (q - p) * 6 * t end
                if t < 1/2 then return q end
                if t < 2/3 then return p + (q - p) * (2/3 - t) * 6 end
                return p
            end

            local q = l < 0.5 and l * (1 + s) or l + s - l * s
            local p = 2 * l - q

            r = hueToRgb(p, q, h + 1/3)
            g = hueToRgb(p, q, h)
            b = hueToRgb(p, q, h - 1/3)
        end

        return Color3.new(r, g, b)
    end

    function ColorUtil.ToHSL(color)
        local r, g, b = color.R, color.G, color.B
        local max = math.max(r, g, b)
        local min = math.min(r, g, b)
        local h, s, l

        l = (max + min) / 2

        if max == min then
            h, s = 0, 0
        else
            local d = max - min

            if l > 0.5 then
                s = d / (2 - max - min)
            else
                s = d / (max + min)
            end

            if max == r then
                h = (g - b) / d + (g < b and 6 or 0)
            elseif max == g then
                h = (b - r) / d + 2
            else
                h = (r - g) / d + 4
            end

            h = h / 6
        end

        return h, s, l
    end

    --// Color Manipulation
    function ColorUtil.Lighten(color, amount)
        amount = amount or 0.1
        local h, s, l = ColorUtil.ToHSL(color)
        l = math.min(1, l + amount)
        return ColorUtil.FromHSL(h, s, l)
    end

    function ColorUtil.Darken(color, amount)
        amount = amount or 0.1
        local h, s, l = ColorUtil.ToHSL(color)
        l = math.max(0, l - amount)
        return ColorUtil.FromHSL(h, s, l)
    end

    function ColorUtil.Saturate(color, amount)
        amount = amount or 0.1
        local h, s, v = ColorUtil.ToHSV(color)
        s = math.min(1, s + amount)
        return ColorUtil.FromHSV(h, s, v)
    end

    function ColorUtil.Desaturate(color, amount)
        amount = amount or 0.1
        local h, s, v = ColorUtil.ToHSV(color)
        s = math.max(0, s - amount)
        return ColorUtil.FromHSV(h, s, v)
    end

    function ColorUtil.Grayscale(color)
        local luminance = ColorUtil.GetLuminance(color)
        return Color3.new(luminance, luminance, luminance)
    end

    function ColorUtil.Invert(color)
        return Color3.new(1 - color.R, 1 - color.G, 1 - color.B)
    end

    function ColorUtil.RotateHue(color, degrees)
        local h, s, v = ColorUtil.ToHSV(color)
        h = (h + degrees / 360) % 1
        return ColorUtil.FromHSV(h, s, v)
    end

    function ColorUtil.SetHue(color, hue)
        local _, s, v = ColorUtil.ToHSV(color)
        return ColorUtil.FromHSV(hue, s, v)
    end

    function ColorUtil.SetSaturation(color, saturation)
        local h, _, v = ColorUtil.ToHSV(color)
        return ColorUtil.FromHSV(h, saturation, v)
    end

    function ColorUtil.SetValue(color, value)
        local h, s, _ = ColorUtil.ToHSV(color)
        return ColorUtil.FromHSV(h, s, value)
    end

    function ColorUtil.SetLightness(color, lightness)
        local h, s, _ = ColorUtil.ToHSL(color)
        return ColorUtil.FromHSL(h, s, lightness)
    end

    function ColorUtil.SetAlpha(color, alpha)
        return color, alpha
    end

    --// Color Blending
    function ColorUtil.Lerp(color1, color2, t)
        return Color3.new(
            color1.R + (color2.R - color1.R) * t,
            color1.G + (color2.G - color1.G) * t,
            color1.B + (color2.B - color1.B) * t
        )
    end

    function ColorUtil.Mix(color1, color2, ratio)
        ratio = ratio or 0.5
        return ColorUtil.Lerp(color1, color2, ratio)
    end

    function ColorUtil.Blend(color1, color2, mode, amount)
        amount = amount or 0.5
        mode = mode or "normal"

        if mode == "normal" then
            return ColorUtil.Lerp(color1, color2, amount)

        elseif mode == "multiply" then
            return Color3.new(
                color1.R * color2.R,
                color1.G * color2.G,
                color1.B * color2.B
            )

        elseif mode == "screen" then
            return Color3.new(
                1 - (1 - color1.R) * (1 - color2.R),
                1 - (1 - color1.G) * (1 - color2.G),
                1 - (1 - color1.B) * (1 - color2.B)
            )

        elseif mode == "overlay" then
            local function overlay(base, blend)
                if base < 0.5 then
                    return 2 * base * blend
                else
                    return 1 - 2 * (1 - base) * (1 - blend)
                end
            end
            return Color3.new(
                overlay(color1.R, color2.R),
                overlay(color1.G, color2.G),
                overlay(color1.B, color2.B)
            )

        elseif mode == "add" then
            return Color3.new(
                math.min(1, color1.R + color2.R * amount),
                math.min(1, color1.G + color2.G * amount),
                math.min(1, color1.B + color2.B * amount)
            )

        elseif mode == "subtract" then
            return Color3.new(
                math.max(0, color1.R - color2.R * amount),
                math.max(0, color1.G - color2.G * amount),
                math.max(0, color1.B - color2.B * amount)
            )

        elseif mode == "difference" then
            return Color3.new(
                math.abs(color1.R - color2.R),
                math.abs(color1.G - color2.G),
                math.abs(color1.B - color2.B)
            )

        elseif mode == "softlight" then
            local function softlight(base, blend)
                if blend < 0.5 then
                    return base - (1 - 2 * blend) * base * (1 - base)
                else
                    local d
                    if base < 0.25 then
                        d = ((16 * base - 12) * base + 4) * base
                    else
                        d = math.sqrt(base)
                    end
                    return base + (2 * blend - 1) * (d - base)
                end
            end
            return Color3.new(
                softlight(color1.R, color2.R),
                softlight(color1.G, color2.G),
                softlight(color1.B, color2.B)
            )

        elseif mode == "hardlight" then
            local function hardlight(base, blend)
                if blend < 0.5 then
                    return 2 * base * blend
                else
                    return 1 - 2 * (1 - base) * (1 - blend)
                end
            end
            return Color3.new(
                hardlight(color1.R, color2.R),
                hardlight(color1.G, color2.G),
                hardlight(color1.B, color2.B)
            )
        end

        return ColorUtil.Lerp(color1, color2, amount)
    end

    --// Luminance and Contrast
    function ColorUtil.GetLuminance(color)
        -- Using relative luminance formula (WCAG)
        local function linearize(c)
            if c <= 0.03928 then
                return c / 12.92
            else
                return ((c + 0.055) / 1.055) ^ 2.4
            end
        end

        local r = linearize(color.R)
        local g = linearize(color.G)
        local b = linearize(color.B)

        return 0.2126 * r + 0.7152 * g + 0.0722 * b
    end

    function ColorUtil.GetPerceivedBrightness(color)
        -- Using perceived brightness formula
        return math.sqrt(
            0.299 * color.R ^ 2 +
            0.587 * color.G ^ 2 +
            0.114 * color.B ^ 2
        )
    end

    function ColorUtil.GetContrastRatio(color1, color2)
        local l1 = ColorUtil.GetLuminance(color1)
        local l2 = ColorUtil.GetLuminance(color2)

        local lighter = math.max(l1, l2)
        local darker = math.min(l1, l2)

        return (lighter + 0.05) / (darker + 0.05)
    end

    function ColorUtil.GetContrastColor(backgroundColor, lightColor, darkColor)
        lightColor = lightColor or ColorUtil.WHITE
        darkColor = darkColor or ColorUtil.BLACK

        local brightness = ColorUtil.GetPerceivedBrightness(backgroundColor)
        return brightness > 0.5 and darkColor or lightColor
    end

    function ColorUtil.IsLight(color)
        return ColorUtil.GetPerceivedBrightness(color) > 0.5
    end

    function ColorUtil.IsDark(color)
        return ColorUtil.GetPerceivedBrightness(color) <= 0.5
    end

    function ColorUtil.MeetsContrastRatio(color1, color2, ratio)
        ratio = ratio or 4.5 -- WCAG AA standard
        return ColorUtil.GetContrastRatio(color1, color2) >= ratio
    end

    --// Palette Generation
    function ColorUtil.Complementary(color)
        return ColorUtil.RotateHue(color, 180)
    end

    function ColorUtil.Triadic(color)
        return {
            color,
            ColorUtil.RotateHue(color, 120),
            ColorUtil.RotateHue(color, 240)
        }
    end

    function ColorUtil.Tetradic(color)
        return {
            color,
            ColorUtil.RotateHue(color, 90),
            ColorUtil.RotateHue(color, 180),
            ColorUtil.RotateHue(color, 270)
        }
    end

    function ColorUtil.Analogous(color, spread)
        spread = spread or 30
        return {
            ColorUtil.RotateHue(color, -spread),
            color,
            ColorUtil.RotateHue(color, spread)
        }
    end

    function ColorUtil.SplitComplementary(color, spread)
        spread = spread or 30
        return {
            color,
            ColorUtil.RotateHue(color, 180 - spread),
            ColorUtil.RotateHue(color, 180 + spread)
        }
    end

    function ColorUtil.Monochromatic(color, count)
        count = count or 5
        local h, s, l = ColorUtil.ToHSL(color)
        local colors = {}

        for i = 1, count do
            local newL = (i - 1) / (count - 1)
            table.insert(colors, ColorUtil.FromHSL(h, s, newL))
        end

        return colors
    end

    function ColorUtil.Shades(color, count)
        count = count or 5
        local colors = {}

        for i = 1, count do
            local amount = (i - 1) / (count - 1)
            table.insert(colors, ColorUtil.Lerp(color, ColorUtil.BLACK, amount))
        end

        return colors
    end

    function ColorUtil.Tints(color, count)
        count = count or 5
        local colors = {}

        for i = 1, count do
            local amount = (i - 1) / (count - 1)
            table.insert(colors, ColorUtil.Lerp(color, ColorUtil.WHITE, amount))
        end

        return colors
    end

    function ColorUtil.Tones(color, count)
        count = count or 5
        local gray = Color3.new(0.5, 0.5, 0.5)
        local colors = {}

        for i = 1, count do
            local amount = (i - 1) / (count - 1)
            table.insert(colors, ColorUtil.Lerp(color, gray, amount))
        end

        return colors
    end

    function ColorUtil.Gradient(color1, color2, steps)
        steps = steps or 10
        local colors = {}

        for i = 1, steps do
            local t = (i - 1) / (steps - 1)
            table.insert(colors, ColorUtil.Lerp(color1, color2, t))
        end

        return colors
    end

    function ColorUtil.GradientMulti(colorStops, steps)
        steps = steps or 10
        local colors = {}

        for i = 1, steps do
            local t = (i - 1) / (steps - 1)
            local totalStops = #colorStops
            local scaledT = t * (totalStops - 1)
            local stopIndex = math.floor(scaledT) + 1
            local localT = scaledT - math.floor(scaledT)

            if stopIndex >= totalStops then
                table.insert(colors, colorStops[totalStops])
            else
                table.insert(colors, ColorUtil.Lerp(colorStops[stopIndex], colorStops[stopIndex + 1], localT))
            end
        end

        return colors
    end

    --// ColorSequence Helpers
    function ColorUtil.CreateColorSequence(colors)
        local keypoints = {}

        for i, color in ipairs(colors) do
            local time = (i - 1) / (#colors - 1)
            table.insert(keypoints, ColorSequenceKeypoint.new(time, color))
        end

        return ColorSequence.new(keypoints)
    end

    function ColorUtil.CreateColorSequenceFromStops(stops)
        local keypoints = {}

        for _, stop in ipairs(stops) do
            table.insert(keypoints, ColorSequenceKeypoint.new(stop.Time, stop.Color))
        end

        return ColorSequence.new(keypoints)
    end

    function ColorUtil.SampleColorSequence(colorSequence, t)
        local keypoints = colorSequence.Keypoints

        for i = 1, #keypoints - 1 do
            local current = keypoints[i]
            local next = keypoints[i + 1]

            if t >= current.Time and t <= next.Time then
                local localT = (t - current.Time) / (next.Time - current.Time)
                return ColorUtil.Lerp(current.Value, next.Value, localT)
            end
        end

        return keypoints[#keypoints].Value
    end

    --// Random Colors
    function ColorUtil.Random()
        return Color3.new(math.random(), math.random(), math.random())
    end

    function ColorUtil.RandomHue(saturation, value)
        saturation = saturation or 1
        value = value or 1
        return ColorUtil.FromHSV(math.random(), saturation, value)
    end

    function ColorUtil.RandomPastel()
        return ColorUtil.FromHSL(math.random(), 0.7, 0.8)
    end

    function ColorUtil.RandomVibrant()
        return ColorUtil.FromHSV(math.random(), 1, 1)
    end

    --// Named Colors
    ColorUtil.Named = {
        -- Basic colors
        White = Color3.fromRGB(255, 255, 255),
        Black = Color3.fromRGB(0, 0, 0),
        Red = Color3.fromRGB(255, 0, 0),
        Green = Color3.fromRGB(0, 255, 0),
        Blue = Color3.fromRGB(0, 0, 255),
        Yellow = Color3.fromRGB(255, 255, 0),
        Cyan = Color3.fromRGB(0, 255, 255),
        Magenta = Color3.fromRGB(255, 0, 255),

        -- Extended palette
        Orange = Color3.fromRGB(255, 165, 0),
        Pink = Color3.fromRGB(255, 192, 203),
        Purple = Color3.fromRGB(128, 0, 128),
        Violet = Color3.fromRGB(238, 130, 238),
        Indigo = Color3.fromRGB(75, 0, 130),
        Teal = Color3.fromRGB(0, 128, 128),
        Lime = Color3.fromRGB(0, 255, 0),
        Olive = Color3.fromRGB(128, 128, 0),
        Maroon = Color3.fromRGB(128, 0, 0),
        Navy = Color3.fromRGB(0, 0, 128),
        Aqua = Color3.fromRGB(0, 255, 255),
        Silver = Color3.fromRGB(192, 192, 192),
        Gray = Color3.fromRGB(128, 128, 128),
        Gold = Color3.fromRGB(255, 215, 0),
        Coral = Color3.fromRGB(255, 127, 80),
        Salmon = Color3.fromRGB(250, 128, 114),
        Turquoise = Color3.fromRGB(64, 224, 208),
        SlateBlue = Color3.fromRGB(106, 90, 205),
        Crimson = Color3.fromRGB(220, 20, 60),
    }

    function ColorUtil.FromName(name)
        return ColorUtil.Named[name]
    end

    return ColorUtil


end


-- ============================================================================
-- Module: NexusUI/Core/Utility/Bezier
-- ============================================================================
NexusUI_Modules["NexusUI/Core/Utility/Bezier"] = function()
    local script = CreateMockScript("NexusUI/Core/Utility/Bezier")
    
    --[[
        NexusUI Bezier Curve Utilities
        Bezier curve calculations for smooth animations

        Features:
        - Linear, quadratic, and cubic bezier curves
        - Bezier easing functions
        - Path interpolation
        - Curve fitting
    ]]

    --// Bezier Utility Module
    local BezierUtil = {}

    --// Constants
    local NEWTON_ITERATIONS = 4
    local NEWTON_MIN_SLOPE = 0.001
    local SUBDIVISION_PRECISION = 0.0000001
    local SUBDIVISION_MAX_ITERATIONS = 10

    --// Linear Bezier (Lerp)
    function BezierUtil.Linear(p0, p1, t)
        return p0 + (p1 - p0) * t
    end

    --// Quadratic Bezier
    function BezierUtil.Quadratic(p0, p1, p2, t)
        local t1 = 1 - t
        return t1 * t1 * p0 + 2 * t1 * t * p1 + t * t * p2
    end

    function BezierUtil.QuadraticDerivative(p0, p1, p2, t)
        return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1)
    end

    --// Cubic Bezier
    function BezierUtil.Cubic(p0, p1, p2, p3, t)
        local t1 = 1 - t
        local t1_2 = t1 * t1
        local t1_3 = t1_2 * t1
        local t_2 = t * t
        local t_3 = t_2 * t

        return t1_3 * p0 + 3 * t1_2 * t * p1 + 3 * t1 * t_2 * p2 + t_3 * p3
    end

    function BezierUtil.CubicDerivative(p0, p1, p2, p3, t)
        local t1 = 1 - t
        return 3 * t1 * t1 * (p1 - p0) + 6 * t1 * t * (p2 - p1) + 3 * t * t * (p3 - p2)
    end

    function BezierUtil.CubicSecondDerivative(p0, p1, p2, p3, t)
        return 6 * (1 - t) * (p2 - 2 * p1 + p0) + 6 * t * (p3 - 2 * p2 + p1)
    end

    --// Vector2 Bezier
    function BezierUtil.QuadraticVector2(p0, p1, p2, t)
        return Vector2.new(
            BezierUtil.Quadratic(p0.X, p1.X, p2.X, t),
            BezierUtil.Quadratic(p0.Y, p1.Y, p2.Y, t)
        )
    end

    function BezierUtil.CubicVector2(p0, p1, p2, p3, t)
        return Vector2.new(
            BezierUtil.Cubic(p0.X, p1.X, p2.X, p3.X, t),
            BezierUtil.Cubic(p0.Y, p1.Y, p2.Y, p3.Y, t)
        )
    end

    --// UDim2 Bezier
    function BezierUtil.CubicUDim2(p0, p1, p2, p3, t)
        return UDim2.new(
            BezierUtil.Cubic(p0.X.Scale, p1.X.Scale, p2.X.Scale, p3.X.Scale, t),
            BezierUtil.Cubic(p0.X.Offset, p1.X.Offset, p2.X.Offset, p3.X.Offset, t),
            BezierUtil.Cubic(p0.Y.Scale, p1.Y.Scale, p2.Y.Scale, p3.Y.Scale, t),
            BezierUtil.Cubic(p0.Y.Offset, p1.Y.Offset, p2.Y.Offset, p3.Y.Offset, t)
        )
    end

    --// Cubic Bezier Easing Function
    -- Creates a cubic bezier easing function from control points
    -- Similar to CSS cubic-bezier(x1, y1, x2, y2)
    function BezierUtil.CreateEasing(x1, y1, x2, y2)
        -- Validate control points
        x1 = math.max(0, math.min(1, x1))
        x2 = math.max(0, math.min(1, x2))

        -- Pre-compute sample table for faster lookup
        local sampleTableSize = 11
        local sampleTable = {}

        local function calcBezier(t, a1, a2)
            return ((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1 * t
        end

        local function getSlope(t, a1, a2)
            return 3 * (1 - 3 * a2 + 3 * a1) * t * t + 2 * (3 * a2 - 6 * a1) * t + 3 * a1
        end

        -- Build sample table
        for i = 0, sampleTableSize - 1 do
            sampleTable[i] = calcBezier(i / (sampleTableSize - 1), x1, x2)
        end

        local function getTForX(x)
            local intervalStart = 0
            local currentSample = 1
            local lastSample = sampleTableSize - 1

            while currentSample ~= lastSample and sampleTable[currentSample] <= x do
                intervalStart = intervalStart + 1 / (sampleTableSize - 1)
                currentSample = currentSample + 1
            end
            currentSample = currentSample - 1

            local dist = (x - sampleTable[currentSample]) / (sampleTable[currentSample + 1] - sampleTable[currentSample])
            local guessForT = intervalStart + dist / (sampleTableSize - 1)

            local initialSlope = getSlope(guessForT, x1, x2)

            if initialSlope >= NEWTON_MIN_SLOPE then
                -- Newton-Raphson iteration
                for i = 1, NEWTON_ITERATIONS do
                    local currentSlope = getSlope(guessForT, x1, x2)
                    if currentSlope == 0 then break end
                    local currentX = calcBezier(guessForT, x1, x2) - x
                    guessForT = guessForT - currentX / currentSlope
                end
                return guessForT
            elseif initialSlope == 0 then
                return guessForT
            else
                -- Binary subdivision
                local aA = intervalStart
                local aB = intervalStart + 1 / (sampleTableSize - 1)
                local currentX, currentT

                repeat
                    currentT = aA + (aB - aA) / 2
                    currentX = calcBezier(currentT, x1, x2) - x

                    if currentX > 0 then
                        aB = currentT
                    else
                        aA = currentT
                    end
                until math.abs(currentX) < SUBDIVISION_PRECISION

                return currentT
            end
        end

        return function(t)
            if t == 0 or t == 1 then
                return t
            end
            return calcBezier(getTForX(t), y1, y2)
        end
    end

    --// Common Easing Presets
    BezierUtil.Easings = {
        -- Standard
        Linear = BezierUtil.CreateEasing(0, 0, 1, 1),

        -- Sine
        EaseInSine = BezierUtil.CreateEasing(0.47, 0, 0.745, 0.715),
        EaseOutSine = BezierUtil.CreateEasing(0.39, 0.575, 0.565, 1),
        EaseInOutSine = BezierUtil.CreateEasing(0.445, 0.05, 0.55, 0.95),

        -- Quad
        EaseInQuad = BezierUtil.CreateEasing(0.55, 0.085, 0.68, 0.53),
        EaseOutQuad = BezierUtil.CreateEasing(0.25, 0.46, 0.45, 0.94),
        EaseInOutQuad = BezierUtil.CreateEasing(0.455, 0.03, 0.515, 0.955),

        -- Cubic
        EaseInCubic = BezierUtil.CreateEasing(0.55, 0.055, 0.675, 0.19),
        EaseOutCubic = BezierUtil.CreateEasing(0.215, 0.61, 0.355, 1),
        EaseInOutCubic = BezierUtil.CreateEasing(0.645, 0.045, 0.355, 1),

        -- Quart
        EaseInQuart = BezierUtil.CreateEasing(0.895, 0.03, 0.685, 0.22),
        EaseOutQuart = BezierUtil.CreateEasing(0.165, 0.84, 0.44, 1),
        EaseInOutQuart = BezierUtil.CreateEasing(0.77, 0, 0.175, 1),

        -- Quint
        EaseInQuint = BezierUtil.CreateEasing(0.755, 0.05, 0.855, 0.06),
        EaseOutQuint = BezierUtil.CreateEasing(0.23, 1, 0.32, 1),
        EaseInOutQuint = BezierUtil.CreateEasing(0.86, 0, 0.07, 1),

        -- Expo
        EaseInExpo = BezierUtil.CreateEasing(0.95, 0.05, 0.795, 0.035),
        EaseOutExpo = BezierUtil.CreateEasing(0.19, 1, 0.22, 1),
        EaseInOutExpo = BezierUtil.CreateEasing(1, 0, 0, 1),

        -- Circ
        EaseInCirc = BezierUtil.CreateEasing(0.6, 0.04, 0.98, 0.335),
        EaseOutCirc = BezierUtil.CreateEasing(0.075, 0.82, 0.165, 1),
        EaseInOutCirc = BezierUtil.CreateEasing(0.785, 0.135, 0.15, 0.86),

        -- Back
        EaseInBack = BezierUtil.CreateEasing(0.6, -0.28, 0.735, 0.045),
        EaseOutBack = BezierUtil.CreateEasing(0.175, 0.885, 0.32, 1.275),
        EaseInOutBack = BezierUtil.CreateEasing(0.68, -0.55, 0.265, 1.55),

        -- Custom smooth
        Smooth = BezierUtil.CreateEasing(0.25, 0.1, 0.25, 1),
        Sharp = BezierUtil.CreateEasing(0.4, 0, 0.6, 1),
        Standard = BezierUtil.CreateEasing(0.4, 0, 0.2, 1),
        Decelerate = BezierUtil.CreateEasing(0, 0, 0.2, 1),
        Accelerate = BezierUtil.CreateEasing(0.4, 0, 1, 1),
    }

    --// Get easing by name
    function BezierUtil.GetEasing(name)
        return BezierUtil.Easings[name] or BezierUtil.Easings.Linear
    end

    --// Path Operations
    function BezierUtil.SamplePath(points, samples)
        samples = samples or 100
        local result = {}

        for i = 0, samples do
            local t = i / samples
            table.insert(result, BezierUtil.GetPointOnPath(points, t))
        end

        return result
    end

    function BezierUtil.GetPointOnPath(points, t)
        local n = #points

        if n == 2 then
            return BezierUtil.Linear(points[1], points[2], t)
        elseif n == 3 then
            return BezierUtil.Quadratic(points[1], points[2], points[3], t)
        elseif n == 4 then
            return BezierUtil.Cubic(points[1], points[2], points[3], points[4], t)
        else
            -- De Casteljau's algorithm for higher-order bezier
            local newPoints = {}
            for i = 1, n - 1 do
                table.insert(newPoints, BezierUtil.Linear(points[i], points[i + 1], t))
            end
            return BezierUtil.GetPointOnPath(newPoints, t)
        end
    end

    function BezierUtil.GetPathLength(points, samples)
        samples = samples or 100
        local length = 0
        local lastPoint = nil

        for i = 0, samples do
            local t = i / samples
            local point = BezierUtil.GetPointOnPath(points, t)

            if lastPoint then
                if typeof(point) == "Vector2" then
                    length = length + (point - lastPoint).Magnitude
                elseif typeof(point) == "number" then
                    length = length + math.abs(point - lastPoint)
                end
            end

            lastPoint = point
        end

        return length
    end

    function BezierUtil.GetTangent(points, t)
        local n = #points

        if n == 2 then
            return points[2] - points[1]
        elseif n == 3 then
            return BezierUtil.QuadraticDerivative(points[1], points[2], points[3], t)
        elseif n == 4 then
            return BezierUtil.CubicDerivative(points[1], points[2], points[3], points[4], t)
        end

        return nil
    end

    function BezierUtil.GetNormal(points, t)
        local tangent = BezierUtil.GetTangent(points, t)

        if typeof(tangent) == "Vector2" then
            return Vector2.new(-tangent.Y, tangent.X).Unit
        end

        return nil
    end

    --// Arc Length Parameterization
    function BezierUtil.CreateArcLengthTable(points, samples)
        samples = samples or 100
        local table = {}
        local totalLength = 0
        local lastPoint = nil

        for i = 0, samples do
            local t = i / samples
            local point = BezierUtil.GetPointOnPath(points, t)

            if lastPoint then
                if typeof(point) == "Vector2" then
                    totalLength = totalLength + (point - lastPoint).Magnitude
                elseif typeof(point) == "number" then
                    totalLength = totalLength + math.abs(point - lastPoint)
                end
            end

            table[i] = { T = t, Length = totalLength }
            lastPoint = point
        end

        -- Normalize lengths
        for i = 0, samples do
            table[i].NormalizedLength = table[i].Length / totalLength
        end

        return table, totalLength
    end

    function BezierUtil.GetTAtArcLength(arcLengthTable, normalizedLength)
        local samples = #arcLengthTable

        for i = 1, samples do
            if arcLengthTable[i].NormalizedLength >= normalizedLength then
                local prev = arcLengthTable[i - 1]
                local curr = arcLengthTable[i]

                local lerpT = (normalizedLength - prev.NormalizedLength) / 
                             (curr.NormalizedLength - prev.NormalizedLength)

                return prev.T + (curr.T - prev.T) * lerpT
            end
        end

        return 1
    end

    --// Bezier Curve Class
    local BezierCurve = {}
    BezierCurve.__index = BezierCurve

    function BezierUtil.CreateCurve(points)
        local self = setmetatable({}, BezierCurve)

        self.Points = points
        self.ArcLengthTable = nil
        self.TotalLength = 0

        return self
    end

    function BezierCurve:GetPoint(t)
        return BezierUtil.GetPointOnPath(self.Points, t)
    end

    function BezierCurve:GetTangent(t)
        return BezierUtil.GetTangent(self.Points, t)
    end

    function BezierCurve:GetNormal(t)
        return BezierUtil.GetNormal(self.Points, t)
    end

    function BezierCurve:GetLength()
        if self.TotalLength == 0 then
            self.ArcLengthTable, self.TotalLength = BezierUtil.CreateArcLengthTable(self.Points)
        end
        return self.TotalLength
    end

    function BezierCurve:GetPointAtDistance(distance)
        if not self.ArcLengthTable then
            self:GetLength()
        end

        local normalizedDistance = distance / self.TotalLength
        local t = BezierUtil.GetTAtArcLength(self.ArcLengthTable, normalizedDistance)

        return self:GetPoint(t)
    end

    function BezierCurve:Sample(count)
        return BezierUtil.SamplePath(self.Points, count)
    end

    function BezierCurve:SampleUniform(count)
        if not self.ArcLengthTable then
            self:GetLength()
        end

        local result = {}

        for i = 0, count do
            local normalizedLength = i / count
            local t = BezierUtil.GetTAtArcLength(self.ArcLengthTable, normalizedLength)
            table.insert(result, self:GetPoint(t))
        end

        return result
    end

    --// Curve Splitting
    function BezierUtil.SplitCubic(p0, p1, p2, p3, t)
        local p01 = BezierUtil.Linear(p0, p1, t)
        local p12 = BezierUtil.Linear(p1, p2, t)
        local p23 = BezierUtil.Linear(p2, p3, t)

        local p012 = BezierUtil.Linear(p01, p12, t)
        local p123 = BezierUtil.Linear(p12, p23, t)

        local p0123 = BezierUtil.Linear(p012, p123, t)

        return {
            { p0, p01, p012, p0123 },
            { p0123, p123, p23, p3 }
        }
    end

    return BezierUtil


end


-- ============================================================================
-- Module: NexusUI/Core/Utility/UUID
-- ============================================================================
NexusUI_Modules["NexusUI/Core/Utility/UUID"] = function()
    local script = CreateMockScript("NexusUI/Core/Utility/UUID")
    
    --[[
        NexusUI UUID Utilities
        Universal Unique Identifier generation

        Features:
        - UUID v4 generation
        - Short ID generation
        - Sequential ID generation
        - Custom format IDs
    ]]

    --// UUID Utility Module
    local UUIDUtil = {}

    --// Services
    local HttpService = game:GetService("HttpService")

    --// Charset for short IDs
    local CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    local CHARSET_SAFE = "0123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz"  -- Without confusing chars
    local CHARSET_NUMBERS = "0123456789"
    local CHARSET_LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    local CHARSET_HEX = "0123456789abcdef"

    --// Sequential counter
    local sequentialCounter = 0
    local lastTimestamp = 0

    --// UUID v4 Generation
    function UUIDUtil.V4()
        return HttpService:GenerateGUID(false)
    end

    function UUIDUtil.V4WithBraces()
        return HttpService:GenerateGUID(true)
    end

    --// Simple UUID (without hyphens)
    function UUIDUtil.Simple()
        return UUIDUtil.V4():gsub("-", "")
    end

    --// Short ID Generation
    function UUIDUtil.Short(length, charset)
        length = length or 8
        charset = charset or CHARSET

        local result = {}
        local charsetLength = #charset

        for i = 1, length do
            local randomIndex = math.random(1, charsetLength)
            table.insert(result, charset:sub(randomIndex, randomIndex))
        end

        return table.concat(result)
    end

    function UUIDUtil.ShortSafe(length)
        return UUIDUtil.Short(length, CHARSET_SAFE)
    end

    function UUIDUtil.Numeric(length)
        return UUIDUtil.Short(length, CHARSET_NUMBERS)
    end

    function UUIDUtil.Alphabetic(length)
        return UUIDUtil.Short(length, CHARSET_LETTERS)
    end

    function UUIDUtil.Hex(length)
        return UUIDUtil.Short(length, CHARSET_HEX)
    end

    --// Prefixed IDs
    function UUIDUtil.Prefixed(prefix, length)
        prefix = prefix or "id"
        length = length or 12
        return prefix .. "_" .. UUIDUtil.Short(length)
    end

    --// Timestamped IDs
    function UUIDUtil.Timestamped(prefix)
        prefix = prefix or ""
        local timestamp = os.time()
        local random = UUIDUtil.Short(6)

        if prefix ~= "" then
            return prefix .. "_" .. timestamp .. "_" .. random
        else
            return timestamp .. "_" .. random
        end
    end

    function UUIDUtil.TimestampedShort()
        -- Base36 encoded timestamp + random
        local timestamp = os.time()
        local base36 = UUIDUtil.ToBase36(timestamp)
        local random = UUIDUtil.Short(4)
        return base36 .. random
    end

    --// Sequential IDs
    function UUIDUtil.Sequential(prefix)
        prefix = prefix or "seq"
        sequentialCounter = sequentialCounter + 1
        return prefix .. "_" .. string.format("%08d", sequentialCounter)
    end

    function UUIDUtil.ResetSequential()
        sequentialCounter = 0
    end

    function UUIDUtil.GetSequentialCount()
        return sequentialCounter
    end

    --// Time-based Sequential (ULID-like)
    function UUIDUtil.TimeSequential()
        local timestamp = os.time() * 1000 + (os.clock() % 1) * 1000

        if timestamp == lastTimestamp then
            sequentialCounter = sequentialCounter + 1
        else
            lastTimestamp = timestamp
            sequentialCounter = 0
        end

        local timePart = UUIDUtil.ToBase62(timestamp)
        local randomPart = UUIDUtil.Short(10)

        -- Pad time part to consistent length
        timePart = string.rep("0", 10 - #timePart) .. timePart

        return timePart .. randomPart
    end

    --// Base Conversion
    function UUIDUtil.ToBase36(number)
        local chars = "0123456789abcdefghijklmnopqrstuvwxyz"
        local result = {}

        if number == 0 then
            return "0"
        end

        while number > 0 do
            local remainder = number % 36
            table.insert(result, 1, chars:sub(remainder + 1, remainder + 1))
            number = math.floor(number / 36)
        end

        return table.concat(result)
    end

    function UUIDUtil.FromBase36(str)
        local chars = "0123456789abcdefghijklmnopqrstuvwxyz"
        local result = 0

        str = str:lower()

        for i = 1, #str do
            local char = str:sub(i, i)
            local value = chars:find(char) - 1
            result = result * 36 + value
        end

        return result
    end

    function UUIDUtil.ToBase62(number)
        local chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
        local result = {}

        if number == 0 then
            return "0"
        end

        while number > 0 do
            local remainder = number % 62
            table.insert(result, 1, chars:sub(remainder + 1, remainder + 1))
            number = math.floor(number / 62)
        end

        return table.concat(result)
    end

    function UUIDUtil.FromBase62(str)
        local chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
        local result = 0

        for i = 1, #str do
            local char = str:sub(i, i)
            local value = chars:find(char) - 1
            result = result * 62 + value
        end

        return result
    end

    --// Custom Format
    function UUIDUtil.Custom(format)
        -- Format: X = random letter, 9 = random digit, * = random alphanumeric, - = literal hyphen
        local result = {}

        for i = 1, #format do
            local char = format:sub(i, i)

            if char == "X" then
                table.insert(result, CHARSET_LETTERS:sub(math.random(1, #CHARSET_LETTERS), math.random(1, #CHARSET_LETTERS)))
            elseif char == "x" then
                table.insert(result, CHARSET_LETTERS:sub(math.random(27, #CHARSET_LETTERS), math.random(27, #CHARSET_LETTERS)))  -- lowercase only
            elseif char == "9" then
                table.insert(result, CHARSET_NUMBERS:sub(math.random(1, #CHARSET_NUMBERS), math.random(1, #CHARSET_NUMBERS)))
            elseif char == "*" then
                table.insert(result, CHARSET:sub(math.random(1, #CHARSET), math.random(1, #CHARSET)))
            elseif char == "#" then
                table.insert(result, CHARSET_HEX:sub(math.random(1, #CHARSET_HEX), math.random(1, #CHARSET_HEX)))
            else
                table.insert(result, char)
            end
        end

        return table.concat(result)
    end

    --// Validation
    function UUIDUtil.IsValidUUID(str)
        return str:match("^%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x$") ~= nil
    end

    function UUIDUtil.IsValidUUIDSimple(str)
        return str:match("^%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x$") ~= nil
    end

    --// UUID Parsing
    function UUIDUtil.Parse(str)
        -- Remove braces and hyphens
        str = str:gsub("[{}-]", "")

        if #str ~= 32 then
            return nil
        end

        return {
            TimeLow = str:sub(1, 8),
            TimeMid = str:sub(9, 12),
            TimeHiVersion = str:sub(13, 16),
            ClockSeq = str:sub(17, 20),
            Node = str:sub(21, 32),
        }
    end

    function UUIDUtil.Format(parsed, withBraces)
        local uuid = string.format("%s-%s-%s-%s-%s",
            parsed.TimeLow,
            parsed.TimeMid,
            parsed.TimeHiVersion,
            parsed.ClockSeq,
            parsed.Node
        )

        if withBraces then
            return "{" .. uuid .. "}"
        end

        return uuid
    end

    --// UUID Comparison
    function UUIDUtil.Compare(uuid1, uuid2)
        uuid1 = uuid1:gsub("[{}-]", ""):lower()
        uuid2 = uuid2:gsub("[{}-]", ""):lower()

        return uuid1 == uuid2
    end

    --// Namespace UUIDs (simplified)
    function UUIDUtil.NamespaceId(namespace, name)
        -- Simple hash-based namespace ID (not cryptographically secure)
        local combined = namespace .. ":" .. name
        local hash = 0

        for i = 1, #combined do
            hash = (hash * 31 + combined:byte(i)) % 0xFFFFFFFF
        end

        -- Format as UUID-like string
        return string.format("%08x-%04x-%04x-%04x-%012x",
            hash % 0xFFFFFFFF,
            hash % 0xFFFF,
            (hash % 0xFFFF) + 0x4000,  -- Version 4
            (hash % 0x3FFF) + 0x8000,  -- Variant
            hash % 0xFFFFFFFFFFFF
        )
    end

    --// Aliases
    UUIDUtil.Generate = UUIDUtil.V4
    UUIDUtil.New = UUIDUtil.V4
    UUIDUtil.Create = UUIDUtil.V4
    UUIDUtil.Random = UUIDUtil.V4

    return UUIDUtil


end


-- ============================================================================
-- Module: NexusUI/Core/Utility/Debounce
-- ============================================================================
NexusUI_Modules["NexusUI/Core/Utility/Debounce"] = function()
    local script = CreateMockScript("NexusUI/Core/Utility/Debounce")
    
    --[[
        NexusUI Debounce/Throttle Utilities
        Function rate limiting utilities

        Features:
        - Debounce (trailing, leading, both)
        - Throttle
        - Rate limiting
        - Once execution
        - Cooldown management
    ]]

    --// Debounce Utility Module
    local DebounceUtil = {}

    --// Simple Debounce (trailing edge)
    function DebounceUtil.Debounce(func, delay, immediate)
        delay = delay or 0.1
        immediate = immediate or false

        local lastCallTime = 0
        local scheduled = false
        local lastArgs = nil
        local lastSelf = nil

        return function(...)
            lastArgs = {...}
            lastSelf = select(1, ...)

            local now = os.clock()

            if immediate and not scheduled then
                func(...)
                lastCallTime = now
            end

            if not scheduled then
                scheduled = true

                task.delay(delay, function()
                    scheduled = false

                    if not immediate or (now - lastCallTime >= delay) then
                        func(unpack(lastArgs))
                    end

                    lastCallTime = os.clock()
                end)
            end
        end
    end

    --// Leading Edge Debounce
    function DebounceUtil.DebounceLeading(func, delay)
        return DebounceUtil.Debounce(func, delay, true)
    end

    --// Trailing Edge Debounce (default)
    function DebounceUtil.DebounceTrailing(func, delay)
        return DebounceUtil.Debounce(func, delay, false)
    end

    --// Both Edges Debounce
    function DebounceUtil.DebounceBoth(func, delay)
        delay = delay or 0.1

        local lastCallTime = 0
        local scheduled = false
        local lastArgs = nil
        local calledLeading = false

        return function(...)
            lastArgs = {...}
            local now = os.clock()

            -- Leading edge
            if not calledLeading then
                func(...)
                calledLeading = true
                lastCallTime = now
            end

            -- Schedule trailing edge
            if scheduled then
                return
            end

            scheduled = true

            task.delay(delay, function()
                scheduled = false
                calledLeading = false

                -- Trailing edge (only if there were calls after leading)
                if os.clock() - lastCallTime >= delay then
                    func(unpack(lastArgs))
                end
            end)
        end
    end

    --// Throttle (execute at most once per interval)
    function DebounceUtil.Throttle(func, interval)
        interval = interval or 0.1

        local lastCallTime = 0
        local scheduled = false
        local lastArgs = nil

        return function(...)
            lastArgs = {...}
            local now = os.clock()

            if now - lastCallTime >= interval then
                lastCallTime = now
                return func(...)
            elseif not scheduled then
                scheduled = true

                task.delay(interval - (now - lastCallTime), function()
                    scheduled = false
                    lastCallTime = os.clock()
                    func(unpack(lastArgs))
                end)
            end
        end
    end

    --// Rate Limiter (max calls per time window)
    function DebounceUtil.RateLimit(func, maxCalls, timeWindow)
        maxCalls = maxCalls or 10
        timeWindow = timeWindow or 1

        local callTimes = {}

        return function(...)
            local now = os.clock()

            -- Remove old call times
            local newCallTimes = {}
            for _, time in ipairs(callTimes) do
                if now - time < timeWindow then
                    table.insert(newCallTimes, time)
                end
            end
            callTimes = newCallTimes

            -- Check if within limit
            if #callTimes < maxCalls then
                table.insert(callTimes, now)
                return func(...)
            else
                return nil, "Rate limit exceeded"
            end
        end, function()
            -- Returns remaining calls
            local now = os.clock()
            local validCalls = 0

            for _, time in ipairs(callTimes) do
                if now - time < timeWindow then
                    validCalls = validCalls + 1
                end
            end

            return maxCalls - validCalls
        end
    end

    --// Once (execute only once)
    function DebounceUtil.Once(func)
        local called = false
        local result = nil

        return function(...)
            if not called then
                called = true
                result = {func(...)}
                return unpack(result)
            end
            return unpack(result or {})
        end
    end

    --// After (execute after N calls)
    function DebounceUtil.After(n, func)
        local callCount = 0

        return function(...)
            callCount = callCount + 1

            if callCount >= n then
                return func(...)
            end
        end
    end

    --// Before (execute only for first N calls)
    function DebounceUtil.Before(n, func)
        local callCount = 0
        local lastResult = nil

        return function(...)
            callCount = callCount + 1

            if callCount <= n then
                lastResult = {func(...)}
                return unpack(lastResult)
            end

            return unpack(lastResult or {})
        end
    end

    --// Cooldown (simple boolean cooldown)
    function DebounceUtil.Cooldown(duration)
        duration = duration or 1

        local onCooldown = false

        return function()
            if onCooldown then
                return false
            end

            onCooldown = true
            task.delay(duration, function()
                onCooldown = false
            end)

            return true
        end, function()
            return not onCooldown
        end, function()
            onCooldown = false
        end
    end

    --// Cooldown Manager (for multiple keys)
    local CooldownManager = {}
    CooldownManager.__index = CooldownManager

    function DebounceUtil.CreateCooldownManager()
        local self = setmetatable({}, CooldownManager)
        self._cooldowns = {}
        return self
    end

    function CooldownManager:IsReady(key)
        local cooldown = self._cooldowns[key]

        if not cooldown then
            return true
        end

        return os.clock() >= cooldown
    end

    function CooldownManager:SetCooldown(key, duration)
        self._cooldowns[key] = os.clock() + duration
    end

    function CooldownManager:GetRemaining(key)
        local cooldown = self._cooldowns[key]

        if not cooldown then
            return 0
        end

        return math.max(0, cooldown - os.clock())
    end

    function CooldownManager:Reset(key)
        self._cooldowns[key] = nil
    end

    function CooldownManager:ResetAll()
        self._cooldowns = {}
    end

    function CooldownManager:Execute(key, duration, func, ...)
        if self:IsReady(key) then
            self:SetCooldown(key, duration)
            return func(...)
        end

        return nil, self:GetRemaining(key)
    end

    --// Memoize (cache function results)
    function DebounceUtil.Memoize(func, hashFunc)
        local cache = {}

        hashFunc = hashFunc or function(...)
            local args = {...}
            local parts = {}

            for _, arg in ipairs(args) do
                table.insert(parts, tostring(arg))
            end

            return table.concat(parts, "_")
        end

        return function(...)
            local key = hashFunc(...)

            if cache[key] ~= nil then
                return unpack(cache[key])
            end

            local result = {func(...)}
            cache[key] = result

            return unpack(result)
        end, function()
            cache = {}
        end
    end

    --// Memoize with TTL (time-to-live)
    function DebounceUtil.MemoizeTTL(func, ttl, hashFunc)
        ttl = ttl or 60
        local cache = {}

        hashFunc = hashFunc or function(...)
            local args = {...}
            local parts = {}

            for _, arg in ipairs(args) do
                table.insert(parts, tostring(arg))
            end

            return table.concat(parts, "_")
        end

        return function(...)
            local key = hashFunc(...)
            local cached = cache[key]

            if cached and os.clock() - cached.Time < ttl then
                return unpack(cached.Result)
            end

            local result = {func(...)}
            cache[key] = {
                Result = result,
                Time = os.clock()
            }

            return unpack(result)
        end, function()
            cache = {}
        end
    end

    --// Queue (execute functions in order with delay)
    function DebounceUtil.CreateQueue(interval)
        interval = interval or 0.1

        local queue = {}
        local processing = false

        local function processQueue()
            if processing or #queue == 0 then
                return
            end

            processing = true

            while #queue > 0 do
                local item = table.remove(queue, 1)
                item.Func(unpack(item.Args))
                task.wait(interval)
            end

            processing = false
        end

        return {
            Add = function(func, ...)
                table.insert(queue, {
                    Func = func,
                    Args = {...}
                })
                processQueue()
            end,

            Clear = function()
                queue = {}
            end,

            GetLength = function()
                return #queue
            end,

            IsProcessing = function()
                return processing
            end
        }
    end

    --// Batch (collect calls and execute as batch)
    function DebounceUtil.Batch(func, delay)
        delay = delay or 0.1

        local batch = {}
        local scheduled = false

        return function(item)
            table.insert(batch, item)

            if not scheduled then
                scheduled = true

                task.delay(delay, function()
                    scheduled = false
                    local items = batch
                    batch = {}
                    func(items)
                end)
            end
        end
    end

    --// Retry (retry function on failure)
    function DebounceUtil.Retry(func, maxAttempts, delay, backoffMultiplier)
        maxAttempts = maxAttempts or 3
        delay = delay or 1
        backoffMultiplier = backoffMultiplier or 1

        return function(...)
            local attempts = 0
            local currentDelay = delay
            local lastError = nil

            while attempts < maxAttempts do
                attempts = attempts + 1

                local success, result = pcall(func, ...)

                if success then
                    return result
                end

                lastError = result

                if attempts < maxAttempts then
                    task.wait(currentDelay)
                    currentDelay = currentDelay * backoffMultiplier
                end
            end

            error(string.format("Failed after %d attempts: %s", maxAttempts, tostring(lastError)))
        end
    end

    return DebounceUtil


end


-- ============================================================================
-- Module: NexusUI/Core/Utility/DeepCopy
-- ============================================================================
NexusUI_Modules["NexusUI/Core/Utility/DeepCopy"] = function()
    local script = CreateMockScript("NexusUI/Core/Utility/DeepCopy")
    
    --[[
        NexusUI DeepCopy Utilities
        Deep cloning and comparison utilities

        Features:
        - Deep copy with cycle detection
        - Shallow copy
        - Deep comparison
        - Merge operations
        - Structural cloning
    ]]

    --// DeepCopy Utility Module
    local DeepCopyUtil = {}

    --// Deep Copy with Cycle Detection
    function DeepCopyUtil.Copy(original, seen)
        -- Handle non-tables
        if type(original) ~= "table" then
            return original
        end

        -- Initialize seen table for cycle detection
        seen = seen or {}

        -- Check for cycles
        if seen[original] then
            return seen[original]
        end

        -- Create new table
        local copy = {}
        seen[original] = copy

        -- Copy all key-value pairs
        for key, value in pairs(original) do
            copy[DeepCopyUtil.Copy(key, seen)] = DeepCopyUtil.Copy(value, seen)
        end

        -- Copy metatable if present
        local mt = getmetatable(original)
        if mt then
            setmetatable(copy, DeepCopyUtil.Copy(mt, seen))
        end

        return copy
    end

    --// Shallow Copy
    function DeepCopyUtil.ShallowCopy(original)
        if type(original) ~= "table" then
            return original
        end

        local copy = {}
        for key, value in pairs(original) do
            copy[key] = value
        end

        return copy
    end

    --// Deep Copy without Metatable
    function DeepCopyUtil.CopyWithoutMeta(original, seen)
        if type(original) ~= "table" then
            return original
        end

        seen = seen or {}

        if seen[original] then
            return seen[original]
        end

        local copy = {}
        seen[original] = copy

        for key, value in pairs(original) do
            copy[DeepCopyUtil.CopyWithoutMeta(key, seen)] = DeepCopyUtil.CopyWithoutMeta(value, seen)
        end

        return copy
    end

    --// Structured Clone (handles special types)
    function DeepCopyUtil.StructuredClone(original, seen)
        local originalType = typeof(original)

        -- Handle primitives
        if originalType == "nil" or originalType == "boolean" or 
           originalType == "number" or originalType == "string" then
            return original
        end

        -- Handle Roblox types (these are immutable, return as-is)
        if originalType == "Color3" or originalType == "Vector2" or 
           originalType == "Vector3" or originalType == "UDim" or 
           originalType == "UDim2" or originalType == "CFrame" or
           originalType == "Rect" or originalType == "NumberRange" or
           originalType == "NumberSequence" or originalType == "ColorSequence" or
           originalType == "Font" or originalType == "EnumItem" then
            return original
        end

        -- Handle Instance (can't be cloned, return reference)
        if originalType == "Instance" then
            return original
        end

        -- Handle function (return reference)
        if originalType == "function" then
            return original
        end

        -- Handle table
        if originalType == "table" then
            seen = seen or {}

            if seen[original] then
                return seen[original]
            end

            local copy = {}
            seen[original] = copy

            for key, value in pairs(original) do
                copy[DeepCopyUtil.StructuredClone(key, seen)] = DeepCopyUtil.StructuredClone(value, seen)
            end

            local mt = getmetatable(original)
            if mt then
                setmetatable(copy, DeepCopyUtil.StructuredClone(mt, seen))
            end

            return copy
        end

        -- Unknown type, return as-is
        return original
    end

    --// Deep Equality Check
    function DeepCopyUtil.Equals(a, b, seen)
        -- Same reference
        if a == b then
            return true
        end

        -- Type mismatch
        if type(a) ~= type(b) then
            return false
        end

        -- Handle non-tables
        if type(a) ~= "table" then
            return a == b
        end

        -- Cycle detection
        seen = seen or {}
        local key = tostring(a) .. tostring(b)

        if seen[key] then
            return true  -- Assume equal if we've seen this pair (cycle)
        end
        seen[key] = true

        -- Compare tables
        for k, v in pairs(a) do
            if not DeepCopyUtil.Equals(v, b[k], seen) then
                return false
            end
        end

        for k, v in pairs(b) do
            if a[k] == nil then
                return false
            end
        end

        return true
    end

    --// Deep Merge (target is modified)
    function DeepCopyUtil.MergeInto(target, source)
        if type(target) ~= "table" or type(source) ~= "table" then
            return target
        end

        for key, value in pairs(source) do
            if type(value) == "table" and type(target[key]) == "table" then
                DeepCopyUtil.MergeInto(target[key], value)
            else
                target[key] = DeepCopyUtil.Copy(value)
            end
        end

        return target
    end

    --// Deep Merge (returns new table)
    function DeepCopyUtil.Merge(...)
        local result = {}

        for _, tbl in ipairs({...}) do
            if type(tbl) == "table" then
                DeepCopyUtil.MergeInto(result, tbl)
            end
        end

        return result
    end

    --// Shallow Merge
    function DeepCopyUtil.ShallowMerge(...)
        local result = {}

        for _, tbl in ipairs({...}) do
            if type(tbl) == "table" then
                for key, value in pairs(tbl) do
                    result[key] = value
                end
            end
        end

        return result
    end

    --// Deep Diff (find differences between two tables)
    function DeepCopyUtil.Diff(a, b, path)
        path = path or ""
        local differences = {}

        if type(a) ~= type(b) then
            table.insert(differences, {
                Path = path,
                Type = "type_mismatch",
                ValueA = a,
                ValueB = b
            })
            return differences
        end

        if type(a) ~= "table" then
            if a ~= b then
                table.insert(differences, {
                    Path = path,
                    Type = "value_changed",
                    ValueA = a,
                    ValueB = b
                })
            end
            return differences
        end

        -- Check keys in a
        for key, valueA in pairs(a) do
            local newPath = path == "" and tostring(key) or (path .. "." .. tostring(key))
            local valueB = b[key]

            if valueB == nil then
                table.insert(differences, {
                    Path = newPath,
                    Type = "removed",
                    ValueA = valueA,
                    ValueB = nil
                })
            else
                local subDiff = DeepCopyUtil.Diff(valueA, valueB, newPath)
                for _, diff in ipairs(subDiff) do
                    table.insert(differences, diff)
                end
            end
        end

        -- Check keys in b that aren't in a
        for key, valueB in pairs(b) do
            if a[key] == nil then
                local newPath = path == "" and tostring(key) or (path .. "." .. tostring(key))
                table.insert(differences, {
                    Path = newPath,
                    Type = "added",
                    ValueA = nil,
                    ValueB = valueB
                })
            end
        end

        return differences
    end

    --// Apply Diff
    function DeepCopyUtil.ApplyDiff(target, diff)
        for _, change in ipairs(diff) do
            local path = change.Path
            local parts = string.split(path, ".")

            local current = target

            for i = 1, #parts - 1 do
                local key = tonumber(parts[i]) or parts[i]
                if type(current[key]) ~= "table" then
                    current[key] = {}
                end
                current = current[key]
            end

            local lastKey = tonumber(parts[#parts]) or parts[#parts]

            if change.Type == "removed" then
                current[lastKey] = nil
            else
                current[lastKey] = DeepCopyUtil.Copy(change.ValueB)
            end
        end

        return target
    end

    --// Deep Freeze
    function DeepCopyUtil.Freeze(tbl)
        if type(tbl) ~= "table" then
            return tbl
        end

        for key, value in pairs(tbl) do
            if type(value) == "table" then
                DeepCopyUtil.Freeze(value)
            end
        end

        return table.freeze(tbl)
    end

    --// Is Frozen
    function DeepCopyUtil.IsFrozen(tbl)
        if type(tbl) ~= "table" then
            return false
        end

        return table.isfrozen(tbl)
    end

    --// Deep Contains (check if a contains all of b)
    function DeepCopyUtil.Contains(a, b)
        if type(a) ~= "table" or type(b) ~= "table" then
            return a == b
        end

        for key, valueB in pairs(b) do
            local valueA = a[key]

            if valueA == nil then
                return false
            end

            if not DeepCopyUtil.Contains(valueA, valueB) then
                return false
            end
        end

        return true
    end

    --// Pick (select specific keys)
    function DeepCopyUtil.Pick(tbl, keys)
        local result = {}

        for _, key in ipairs(keys) do
            if tbl[key] ~= nil then
                result[key] = DeepCopyUtil.Copy(tbl[key])
            end
        end

        return result
    end

    --// Omit (exclude specific keys)
    function DeepCopyUtil.Omit(tbl, keys)
        local keySet = {}
        for _, key in ipairs(keys) do
            keySet[key] = true
        end

        local result = {}

        for key, value in pairs(tbl) do
            if not keySet[key] then
                result[key] = DeepCopyUtil.Copy(value)
            end
        end

        return result
    end

    --// Deep Get (get nested value by path)
    function DeepCopyUtil.Get(tbl, path, default)
        local parts = type(path) == "table" and path or string.split(path, ".")
        local current = tbl

        for _, key in ipairs(parts) do
            key = tonumber(key) or key

            if type(current) ~= "table" then
                return default
            end

            current = current[key]
        end

        if current == nil then
            return default
        end

        return current
    end

    --// Deep Set (set nested value by path)
    function DeepCopyUtil.Set(tbl, path, value)
        local parts = type(path) == "table" and path or string.split(path, ".")
        local current = tbl

        for i = 1, #parts - 1 do
            local key = tonumber(parts[i]) or parts[i]

            if type(current[key]) ~= "table" then
                current[key] = {}
            end

            current = current[key]
        end

        local lastKey = tonumber(parts[#parts]) or parts[#parts]
        current[lastKey] = value

        return tbl
    end

    --// Aliases
    DeepCopyUtil.DeepCopy = DeepCopyUtil.Copy
    DeepCopyUtil.Clone = DeepCopyUtil.Copy
    DeepCopyUtil.DeepClone = DeepCopyUtil.Copy
    DeepCopyUtil.DeepEquals = DeepCopyUtil.Equals
    DeepCopyUtil.DeepMerge = DeepCopyUtil.Merge

    return DeepCopyUtil


end


-- ============================================================================
-- Module: NexusUI/Core/Utility/Lerp
-- ============================================================================
NexusUI_Modules["NexusUI/Core/Utility/Lerp"] = function()
    local script = CreateMockScript("NexusUI/Core/Utility/Lerp")
    
    --[[
        NexusUI Lerp Utilities
        Linear interpolation for various types

        Features:
        - Basic lerp operations
        - Type-specific lerp functions
        - Inverse lerp
        - Smooth step variations
        - Remap utilities
    ]]

    --// Lerp Utility Module
    local LerpUtil = {}

    --// Basic Lerp
    function LerpUtil.Lerp(a, b, t)
        return a + (b - a) * t
    end

    function LerpUtil.LerpClamped(a, b, t)
        t = math.max(0, math.min(1, t))
        return a + (b - a) * t
    end

    function LerpUtil.LerpUnclamped(a, b, t)
        return a + (b - a) * t
    end

    --// Inverse Lerp
    function LerpUtil.InverseLerp(a, b, value)
        if a == b then
            return 0
        end
        return (value - a) / (b - a)
    end

    function LerpUtil.InverseLerpClamped(a, b, value)
        return math.max(0, math.min(1, LerpUtil.InverseLerp(a, b, value)))
    end

    --// Remap (combined inverse lerp + lerp)
    function LerpUtil.Remap(value, inMin, inMax, outMin, outMax)
        local t = LerpUtil.InverseLerp(inMin, inMax, value)
        return LerpUtil.Lerp(outMin, outMax, t)
    end

    function LerpUtil.RemapClamped(value, inMin, inMax, outMin, outMax)
        local t = LerpUtil.InverseLerpClamped(inMin, inMax, value)
        return LerpUtil.Lerp(outMin, outMax, t)
    end

    --// Color3 Lerp
    function LerpUtil.Color3(c1, c2, t)
        return Color3.new(
            LerpUtil.Lerp(c1.R, c2.R, t),
            LerpUtil.Lerp(c1.G, c2.G, t),
            LerpUtil.Lerp(c1.B, c2.B, t)
        )
    end

    function LerpUtil.Color3HSV(c1, c2, t)
        local h1, s1, v1 = Color3.toHSV(c1)
        local h2, s2, v2 = Color3.toHSV(c2)

        -- Handle hue wraparound
        local hDiff = h2 - h1
        if math.abs(hDiff) > 0.5 then
            if hDiff > 0 then
                h1 = h1 + 1
            else
                h2 = h2 + 1
            end
        end

        local h = LerpUtil.Lerp(h1, h2, t) % 1
        local s = LerpUtil.Lerp(s1, s2, t)
        local v = LerpUtil.Lerp(v1, v2, t)

        return Color3.fromHSV(h, s, v)
    end

    --// Vector2 Lerp
    function LerpUtil.Vector2(v1, v2, t)
        return Vector2.new(
            LerpUtil.Lerp(v1.X, v2.X, t),
            LerpUtil.Lerp(v1.Y, v2.Y, t)
        )
    end

    --// Vector3 Lerp
    function LerpUtil.Vector3(v1, v2, t)
        return Vector3.new(
            LerpUtil.Lerp(v1.X, v2.X, t),
            LerpUtil.Lerp(v1.Y, v2.Y, t),
            LerpUtil.Lerp(v1.Z, v2.Z, t)
        )
    end

    --// UDim Lerp
    function LerpUtil.UDim(u1, u2, t)
        return UDim.new(
            LerpUtil.Lerp(u1.Scale, u2.Scale, t),
            LerpUtil.Lerp(u1.Offset, u2.Offset, t)
        )
    end

    --// UDim2 Lerp
    function LerpUtil.UDim2(u1, u2, t)
        return UDim2.new(
            LerpUtil.Lerp(u1.X.Scale, u2.X.Scale, t),
            LerpUtil.Lerp(u1.X.Offset, u2.X.Offset, t),
            LerpUtil.Lerp(u1.Y.Scale, u2.Y.Scale, t),
            LerpUtil.Lerp(u1.Y.Offset, u2.Y.Offset, t)
        )
    end

    --// CFrame Lerp
    function LerpUtil.CFrame(cf1, cf2, t)
        return cf1:Lerp(cf2, t)
    end

    --// NumberRange Lerp
    function LerpUtil.NumberRange(r1, r2, t)
        return NumberRange.new(
            LerpUtil.Lerp(r1.Min, r2.Min, t),
            LerpUtil.Lerp(r1.Max, r2.Max, t)
        )
    end

    --// Rect Lerp
    function LerpUtil.Rect(rect1, rect2, t)
        return Rect.new(
            LerpUtil.Lerp(rect1.Min.X, rect2.Min.X, t),
            LerpUtil.Lerp(rect1.Min.Y, rect2.Min.Y, t),
            LerpUtil.Lerp(rect1.Max.X, rect2.Max.X, t),
            LerpUtil.Lerp(rect1.Max.Y, rect2.Max.Y, t)
        )
    end

    --// Angle Lerp (handles wraparound)
    function LerpUtil.Angle(a1, a2, t)
        local diff = (a2 - a1) % (math.pi * 2)

        if diff > math.pi then
            diff = diff - math.pi * 2
        end

        return a1 + diff * t
    end

    function LerpUtil.AngleDegrees(a1, a2, t)
        local diff = (a2 - a1) % 360

        if diff > 180 then
            diff = diff - 360
        end

        return a1 + diff * t
    end

    --// Smooth Step Variations
    function LerpUtil.SmoothStep(a, b, t)
        t = math.max(0, math.min(1, t))
        t = t * t * (3 - 2 * t)
        return a + (b - a) * t
    end

    function LerpUtil.SmootherStep(a, b, t)
        t = math.max(0, math.min(1, t))
        t = t * t * t * (t * (t * 6 - 15) + 10)
        return a + (b - a) * t
    end

    function LerpUtil.SmoothestStep(a, b, t)
        t = math.max(0, math.min(1, t))
        t = t * t * t * t * (t * (t * (t * -20 + 70) - 84) + 35)
        return a + (b - a) * t
    end

    --// Ease In/Out Variations
    function LerpUtil.EaseIn(a, b, t, power)
        power = power or 2
        t = math.max(0, math.min(1, t))
        return a + (b - a) * (t ^ power)
    end

    function LerpUtil.EaseOut(a, b, t, power)
        power = power or 2
        t = math.max(0, math.min(1, t))
        return a + (b - a) * (1 - (1 - t) ^ power)
    end

    function LerpUtil.EaseInOut(a, b, t, power)
        power = power or 2
        t = math.max(0, math.min(1, t))

        if t < 0.5 then
            return a + (b - a) * ((2 * t) ^ power) / 2
        else
            return a + (b - a) * (1 - ((-2 * t + 2) ^ power) / 2)
        end
    end

    --// Spring Lerp (simplified)
    function LerpUtil.Spring(current, target, velocity, stiffness, damping, dt)
        stiffness = stiffness or 100
        damping = damping or 10
        dt = dt or 1/60

        local displacement = current - target
        local springForce = -stiffness * displacement
        local dampingForce = -damping * velocity

        local acceleration = springForce + dampingForce
        velocity = velocity + acceleration * dt
        current = current + velocity * dt

        return current, velocity
    end

    --// Damp (exponential decay)
    function LerpUtil.Damp(current, target, smoothing, dt)
        return LerpUtil.Lerp(current, target, 1 - math.exp(-smoothing * dt))
    end

    function LerpUtil.DampVector2(current, target, smoothing, dt)
        return LerpUtil.Vector2(current, target, 1 - math.exp(-smoothing * dt))
    end

    function LerpUtil.DampVector3(current, target, smoothing, dt)
        return LerpUtil.Vector3(current, target, 1 - math.exp(-smoothing * dt))
    end

    function LerpUtil.DampColor3(current, target, smoothing, dt)
        return LerpUtil.Color3(current, target, 1 - math.exp(-smoothing * dt))
    end

    function LerpUtil.DampUDim2(current, target, smoothing, dt)
        return LerpUtil.UDim2(current, target, 1 - math.exp(-smoothing * dt))
    end

    --// Move Towards (constant speed)
    function LerpUtil.MoveTowards(current, target, maxDelta)
        local diff = target - current

        if math.abs(diff) <= maxDelta then
            return target
        end

        return current + math.sign(diff) * maxDelta
    end

    function LerpUtil.MoveTowardsVector2(current, target, maxDelta)
        local diff = target - current
        local dist = diff.Magnitude

        if dist <= maxDelta or dist == 0 then
            return target
        end

        return current + diff / dist * maxDelta
    end

    function LerpUtil.MoveTowardsVector3(current, target, maxDelta)
        local diff = target - current
        local dist = diff.Magnitude

        if dist <= maxDelta or dist == 0 then
            return target
        end

        return current + diff / dist * maxDelta
    end

    --// Ping Pong
    function LerpUtil.PingPong(t, length)
        length = length or 1
        t = t % (length * 2)
        return length - math.abs(t - length)
    end

    function LerpUtil.PingPongLerp(a, b, t)
        local pingPongT = LerpUtil.PingPong(t, 1)
        return LerpUtil.Lerp(a, b, pingPongT)
    end

    --// Repeat
    function LerpUtil.Repeat(t, length)
        length = length or 1
        return t % length
    end

    --// Delta Lerp (frame-rate independent)
    function LerpUtil.DeltaLerp(current, target, smoothTime, dt)
        local t = 1 - math.exp(-dt / smoothTime)
        return LerpUtil.Lerp(current, target, t)
    end

    --// Bezier Lerp (quadratic)
    function LerpUtil.QuadraticBezier(p0, p1, p2, t)
        local t1 = 1 - t
        return t1 * t1 * p0 + 2 * t1 * t * p1 + t * t * p2
    end

    --// Bezier Lerp (cubic)
    function LerpUtil.CubicBezier(p0, p1, p2, p3, t)
        local t1 = 1 - t
        local t1_2 = t1 * t1
        local t1_3 = t1_2 * t1
        local t_2 = t * t
        local t_3 = t_2 * t

        return t1_3 * p0 + 3 * t1_2 * t * p1 + 3 * t1 * t_2 * p2 + t_3 * p3
    end

    --// Catmull-Rom Spline
    function LerpUtil.CatmullRom(p0, p1, p2, p3, t)
        local t2 = t * t
        local t3 = t2 * t

        return 0.5 * (
            (2 * p1) +
            (-p0 + p2) * t +
            (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 +
            (-p0 + 3 * p1 - 3 * p2 + p3) * t3
        )
    end

    --// Auto Lerp (detects type)
    function LerpUtil.Auto(a, b, t)
        local typeA = typeof(a)

        if typeA == "number" then
            return LerpUtil.Lerp(a, b, t)
        elseif typeA == "Color3" then
            return LerpUtil.Color3(a, b, t)
        elseif typeA == "Vector2" then
            return LerpUtil.Vector2(a, b, t)
        elseif typeA == "Vector3" then
            return LerpUtil.Vector3(a, b, t)
        elseif typeA == "UDim" then
            return LerpUtil.UDim(a, b, t)
        elseif typeA == "UDim2" then
            return LerpUtil.UDim2(a, b, t)
        elseif typeA == "CFrame" then
            return LerpUtil.CFrame(a, b, t)
        elseif typeA == "NumberRange" then
            return LerpUtil.NumberRange(a, b, t)
        elseif typeA == "Rect" then
            return LerpUtil.Rect(a, b, t)
        end

        -- Default to returning b if t >= 0.5, else a
        return t >= 0.5 and b or a
    end

    return LerpUtil


end


-- ============================================================================
-- Module: NexusUI/Core/Utility/Validate
-- ============================================================================
NexusUI_Modules["NexusUI/Core/Utility/Validate"] = function()
    local script = CreateMockScript("NexusUI/Core/Utility/Validate")
    
    --[[
        NexusUI Validation Utilities
        Input validation and sanitization functions

        Features:
        - Type validation
        - Value range validation
        - Pattern validation
        - Schema validation
        - Sanitization helpers
    ]]

    --// Validate Utility Module
    local ValidateUtil = {}

    --// Type Checking
    function ValidateUtil.IsString(value)
        return type(value) == "string"
    end

    function ValidateUtil.IsNumber(value)
        return type(value) == "number"
    end

    function ValidateUtil.IsBoolean(value)
        return type(value) == "boolean"
    end

    function ValidateUtil.IsTable(value)
        return type(value) == "table"
    end

    function ValidateUtil.IsFunction(value)
        return type(value) == "function"
    end

    function ValidateUtil.IsNil(value)
        return value == nil
    end

    function ValidateUtil.IsNotNil(value)
        return value ~= nil
    end

    function ValidateUtil.IsInstance(value)
        return typeof(value) == "Instance"
    end

    function ValidateUtil.IsColor3(value)
        return typeof(value) == "Color3"
    end

    function ValidateUtil.IsVector2(value)
        return typeof(value) == "Vector2"
    end

    function ValidateUtil.IsVector3(value)
        return typeof(value) == "Vector3"
    end

    function ValidateUtil.IsUDim(value)
        return typeof(value) == "UDim"
    end

    function ValidateUtil.IsUDim2(value)
        return typeof(value) == "UDim2"
    end

    function ValidateUtil.IsCFrame(value)
        return typeof(value) == "CFrame"
    end

    function ValidateUtil.IsEnum(value)
        return typeof(value) == "EnumItem"
    end

    --// Type Validation with Error
    function ValidateUtil.ExpectType(value, expectedType, name)
        local actualType = type(value)

        if actualType ~= expectedType then
            return false, string.format("Expected %s to be %s, got %s", name or "value", expectedType, actualType)
        end

        return true
    end

    function ValidateUtil.ExpectTypeOf(value, expectedType, name)
        local actualType = typeof(value)

        if actualType ~= expectedType then
            return false, string.format("Expected %s to be %s, got %s", name or "value", expectedType, actualType)
        end

        return true
    end

    --// Number Validation
    function ValidateUtil.IsInteger(value)
        return type(value) == "number" and value == math.floor(value)
    end

    function ValidateUtil.IsPositive(value)
        return type(value) == "number" and value > 0
    end

    function ValidateUtil.IsNegative(value)
        return type(value) == "number" and value < 0
    end

    function ValidateUtil.IsNonNegative(value)
        return type(value) == "number" and value >= 0
    end

    function ValidateUtil.IsNonPositive(value)
        return type(value) == "number" and value <= 0
    end

    function ValidateUtil.IsFinite(value)
        return type(value) == "number" and value == value and value ~= math.huge and value ~= -math.huge
    end

    function ValidateUtil.IsNaN(value)
        return type(value) == "number" and value ~= value
    end

    function ValidateUtil.IsInRange(value, min, max)
        return type(value) == "number" and value >= min and value <= max
    end

    function ValidateUtil.IsInRangeExclusive(value, min, max)
        return type(value) == "number" and value > min and value < max
    end

    --// String Validation
    function ValidateUtil.IsEmpty(value)
        return value == nil or value == ""
    end

    function ValidateUtil.IsNotEmpty(value)
        return value ~= nil and value ~= ""
    end

    function ValidateUtil.IsBlank(value)
        return value == nil or (type(value) == "string" and value:match("^%s*$") ~= nil)
    end

    function ValidateUtil.IsNotBlank(value)
        return type(value) == "string" and value:match("^%s*$") == nil
    end

    function ValidateUtil.HasMinLength(value, minLength)
        return type(value) == "string" and #value >= minLength
    end

    function ValidateUtil.HasMaxLength(value, maxLength)
        return type(value) == "string" and #value <= maxLength
    end

    function ValidateUtil.HasLength(value, length)
        return type(value) == "string" and #value == length
    end

    function ValidateUtil.HasLengthBetween(value, minLength, maxLength)
        return type(value) == "string" and #value >= minLength and #value <= maxLength
    end

    function ValidateUtil.MatchesPattern(value, pattern)
        return type(value) == "string" and value:match(pattern) ~= nil
    end

    function ValidateUtil.StartsWith(value, prefix)
        return type(value) == "string" and value:sub(1, #prefix) == prefix
    end

    function ValidateUtil.EndsWith(value, suffix)
        return type(value) == "string" and value:sub(-#suffix) == suffix
    end

    function ValidateUtil.Contains(value, substring)
        return type(value) == "string" and value:find(substring, 1, true) ~= nil
    end

    --// Format Validation
    function ValidateUtil.IsEmail(value)
        return type(value) == "string" and value:match("^[%w._%+-]+@[%w.-]+%.[%w]+$") ~= nil
    end

    function ValidateUtil.IsUrl(value)
        return type(value) == "string" and value:match("^https?://[%w.-]+") ~= nil
    end

    function ValidateUtil.IsHex(value)
        return type(value) == "string" and value:match("^#?[%x]+$") ~= nil
    end

    function ValidateUtil.IsHexColor(value)
        return type(value) == "string" and (value:match("^#[%x][%x][%x]$") ~= nil or value:match("^#[%x][%x][%x][%x][%x][%x]$") ~= nil)
    end

    function ValidateUtil.IsAlpha(value)
        return type(value) == "string" and value:match("^%a+$") ~= nil
    end

    function ValidateUtil.IsAlphanumeric(value)
        return type(value) == "string" and value:match("^%w+$") ~= nil
    end

    function ValidateUtil.IsNumeric(value)
        return type(value) == "string" and value:match("^%d+$") ~= nil
    end

    function ValidateUtil.IsUUID(value)
        return type(value) == "string" and value:match("^%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x$") ~= nil
    end

    --// Array/Table Validation
    function ValidateUtil.IsArray(value)
        if type(value) ~= "table" then
            return false
        end

        local count = 0
        for _ in pairs(value) do
            count = count + 1
        end

        return count == #value
    end

    function ValidateUtil.IsDictionary(value)
        return type(value) == "table" and not ValidateUtil.IsArray(value)
    end

    function ValidateUtil.IsEmptyTable(value)
        return type(value) == "table" and next(value) == nil
    end

    function ValidateUtil.HasKey(value, key)
        return type(value) == "table" and value[key] ~= nil
    end

    function ValidateUtil.HasKeys(value, keys)
        if type(value) ~= "table" then
            return false
        end

        for _, key in ipairs(keys) do
            if value[key] == nil then
                return false
            end
        end

        return true
    end

    function ValidateUtil.HasMinItems(value, minItems)
        if type(value) ~= "table" then
            return false
        end

        local count = 0
        for _ in pairs(value) do
            count = count + 1
            if count >= minItems then
                return true
            end
        end

        return count >= minItems
    end

    function ValidateUtil.HasMaxItems(value, maxItems)
        if type(value) ~= "table" then
            return false
        end

        local count = 0
        for _ in pairs(value) do
            count = count + 1
            if count > maxItems then
                return false
            end
        end

        return true
    end

    function ValidateUtil.ContainsValue(value, searchValue)
        if type(value) ~= "table" then
            return false
        end

        for _, v in pairs(value) do
            if v == searchValue then
                return true
            end
        end

        return false
    end

    function ValidateUtil.AllMatch(value, predicate)
        if type(value) ~= "table" then
            return false
        end

        for k, v in pairs(value) do
            if not predicate(v, k) then
                return false
            end
        end

        return true
    end

    function ValidateUtil.AnyMatch(value, predicate)
        if type(value) ~= "table" then
            return false
        end

        for k, v in pairs(value) do
            if predicate(v, k) then
                return true
            end
        end

        return false
    end

    --// Instance Validation
    function ValidateUtil.IsInstanceOfClass(value, className)
        return typeof(value) == "Instance" and value:IsA(className)
    end

    function ValidateUtil.HasProperty(instance, propertyName)
        if typeof(instance) ~= "Instance" then
            return false
        end

        local success = pcall(function()
            local _ = instance[propertyName]
        end)

        return success
    end

    --// Schema Validation
    function ValidateUtil.ValidateSchema(value, schema)
        local errors = {}

        if type(value) ~= "table" then
            return false, {"Value must be a table"}
        end

        for fieldName, fieldSchema in pairs(schema) do
            local fieldValue = value[fieldName]
            local isValid, error = ValidateUtil.ValidateField(fieldValue, fieldSchema, fieldName)

            if not isValid then
                table.insert(errors, error)
            end
        end

        return #errors == 0, errors
    end

    function ValidateUtil.ValidateField(value, schema, fieldName)
        fieldName = fieldName or "field"

        -- Required check
        if schema.Required and value == nil then
            return false, string.format("%s is required", fieldName)
        end

        -- Skip further validation if nil and not required
        if value == nil then
            return true
        end

        -- Type check
        if schema.Type then
            if type(value) ~= schema.Type and typeof(value) ~= schema.Type then
                return false, string.format("%s must be of type %s", fieldName, schema.Type)
            end
        end

        -- Number validations
        if type(value) == "number" then
            if schema.Min ~= nil and value < schema.Min then
                return false, string.format("%s must be at least %s", fieldName, schema.Min)
            end

            if schema.Max ~= nil and value > schema.Max then
                return false, string.format("%s must be at most %s", fieldName, schema.Max)
            end

            if schema.Integer and value ~= math.floor(value) then
                return false, string.format("%s must be an integer", fieldName)
            end
        end

        -- String validations
        if type(value) == "string" then
            if schema.MinLength ~= nil and #value < schema.MinLength then
                return false, string.format("%s must be at least %d characters", fieldName, schema.MinLength)
            end

            if schema.MaxLength ~= nil and #value > schema.MaxLength then
                return false, string.format("%s must be at most %d characters", fieldName, schema.MaxLength)
            end

            if schema.Pattern and not value:match(schema.Pattern) then
                return false, string.format("%s does not match required pattern", fieldName)
            end
        end

        -- Enum validation
        if schema.Enum then
            local found = false
            for _, enumValue in ipairs(schema.Enum) do
                if value == enumValue then
                    found = true
                    break
                end
            end

            if not found then
                return false, string.format("%s must be one of: %s", fieldName, table.concat(schema.Enum, ", "))
            end
        end

        -- Custom validator
        if schema.Validator then
            local isValid, error = schema.Validator(value)
            if not isValid then
                return false, error or string.format("%s failed custom validation", fieldName)
            end
        end

        return true
    end

    --// Create Validator Function
    function ValidateUtil.CreateValidator(schema)
        return function(value)
            return ValidateUtil.ValidateSchema(value, schema)
        end
    end

    --// Sanitization
    function ValidateUtil.Sanitize(value, options)
        options = options or {}

        if type(value) == "string" then
            -- Trim whitespace
            if options.Trim ~= false then
                value = value:match("^%s*(.-)%s*$")
            end

            -- Remove control characters
            if options.RemoveControlChars then
                value = value:gsub("%c", "")
            end

            -- Lowercase
            if options.Lowercase then
                value = value:lower()
            end

            -- Uppercase
            if options.Uppercase then
                value = value:upper()
            end

            -- Max length truncation
            if options.MaxLength and #value > options.MaxLength then
                value = value:sub(1, options.MaxLength)
            end

            -- Default value for empty
            if options.DefaultIfEmpty and value == "" then
                value = options.DefaultIfEmpty
            end
        elseif type(value) == "number" then
            -- Clamp
            if options.Min ~= nil then
                value = math.max(options.Min, value)
            end

            if options.Max ~= nil then
                value = math.min(options.Max, value)
            end

            -- Round
            if options.Round then
                local decimals = options.RoundDecimals or 0
                local mult = 10 ^ decimals
                value = math.floor(value * mult + 0.5) / mult
            end

            -- Floor/Ceil
            if options.Floor then
                value = math.floor(value)
            elseif options.Ceil then
                value = math.ceil(value)
            end
        end

        return value
    end

    --// Assert Helpers
    function ValidateUtil.Assert(condition, message)
        if not condition then
            error(message or "Assertion failed", 2)
        end
    end

    function ValidateUtil.AssertType(value, expectedType, name)
        local isValid, error = ValidateUtil.ExpectType(value, expectedType, name)
        if not isValid then
            error(error, 2)
        end
    end

    function ValidateUtil.AssertNotNil(value, name)
        if value == nil then
            error(string.format("%s cannot be nil", name or "Value"), 2)
        end
    end

    function ValidateUtil.AssertInRange(value, min, max, name)
        if not ValidateUtil.IsInRange(value, min, max) then
            error(string.format("%s must be between %s and %s", name or "Value", min, max), 2)
        end
    end

    return ValidateUtil


end


-- ============================================================================
-- Module: NexusUI/Core/Utility/init
-- ============================================================================
NexusUI_Modules["NexusUI/Core/Utility/init"] = function()
    local script = CreateMockScript("NexusUI/Core/Utility/init")
    
    --[[
        NexusUI Utility Module
        Central utility function hub

        Provides:
        - Math utilities
        - String utilities
        - Table utilities
        - Color utilities
        - Validation utilities
        - And more...
    ]]

    --// Utility Module
    local Utility = {}

    --// Load Sub-modules
    local function SafeRequire(modulePath)
        local success, result = pcall(function()
            if modulePath and modulePath:IsA("ModuleScript") then
                return require(modulePath)
            end
            return nil
        end)

        if success then
            return result
        end

        return nil
    end

    --// Sub-module References
    Utility.Math = SafeRequire(script:FindFirstChild("Math"))
    Utility.String = SafeRequire(script:FindFirstChild("String"))
    Utility.Table = SafeRequire(script:FindFirstChild("Table"))
    Utility.Color = SafeRequire(script:FindFirstChild("Color"))
    Utility.Bezier = SafeRequire(script:FindFirstChild("Bezier"))
    Utility.UUID = SafeRequire(script:FindFirstChild("UUID"))
    Utility.Debounce = SafeRequire(script:FindFirstChild("Debounce"))
    Utility.DeepCopy = SafeRequire(script:FindFirstChild("DeepCopy"))
    Utility.Lerp = SafeRequire(script:FindFirstChild("Lerp"))
    Utility.Validate = SafeRequire(script:FindFirstChild("Validate"))

    --// Common Utility Functions (directly accessible)

    -- Type checking
    function Utility.IsNumber(value)
        return type(value) == "number"
    end

    function Utility.IsString(value)
        return type(value) == "string"
    end

    function Utility.IsBoolean(value)
        return type(value) == "boolean"
    end

    function Utility.IsTable(value)
        return type(value) == "table"
    end

    function Utility.IsFunction(value)
        return type(value) == "function"
    end

    function Utility.IsNil(value)
        return value == nil
    end

    function Utility.IsInstance(value)
        return typeof(value) == "Instance"
    end

    function Utility.IsColor3(value)
        return typeof(value) == "Color3"
    end

    function Utility.IsUDim2(value)
        return typeof(value) == "UDim2"
    end

    function Utility.IsVector2(value)
        return typeof(value) == "Vector2"
    end

    function Utility.IsVector3(value)
        return typeof(value) == "Vector3"
    end

    -- Safe operations
    function Utility.SafeCall(func, ...)
        if type(func) ~= "function" then
            return false, "Not a function"
        end
        return pcall(func, ...)
    end

    function Utility.SafeIndex(tbl, ...)
        local current = tbl
        for _, key in ipairs({...}) do
            if type(current) ~= "table" then
                return nil
            end
            current = current[key]
        end
        return current
    end

    function Utility.SafeSet(tbl, value, ...)
        local keys = {...}
        local current = tbl

        for i = 1, #keys - 1 do
            local key = keys[i]
            if type(current[key]) ~= "table" then
                current[key] = {}
            end
            current = current[key]
        end

        current[keys[#keys]] = value
    end

    -- Instance utilities
    function Utility.IsValidInstance(instance)
        if instance == nil then return false end

        local success, result = pcall(function()
            return instance.Parent ~= nil or instance.ClassName ~= nil
        end)

        return success and result ~= nil
    end

    function Utility.SafeDestroy(instance)
        if Utility.IsValidInstance(instance) then
            pcall(function()
                instance:Destroy()
            end)
        end
    end

    function Utility.WaitForChild(parent, childName, timeout)
        timeout = timeout or 5

        local child = parent:FindFirstChild(childName)
        if child then return child end

        local startTime = os.clock()
        while os.clock() - startTime < timeout do
            child = parent:FindFirstChild(childName)
            if child then return child end
            task.wait()
        end

        return nil
    end

    function Utility.GetDescendants(instance, className)
        local results = {}

        for _, descendant in ipairs(instance:GetDescendants()) do
            if not className or descendant:IsA(className) then
                table.insert(results, descendant)
            end
        end

        return results
    end

    -- Number utilities
    function Utility.Clamp(value, min, max)
        return math.max(min, math.min(max, value))
    end

    function Utility.Round(value, decimals)
        decimals = decimals or 0
        local mult = 10 ^ decimals
        return math.floor(value * mult + 0.5) / mult
    end

    function Utility.Map(value, inMin, inMax, outMin, outMax)
        return outMin + (value - inMin) * (outMax - outMin) / (inMax - inMin)
    end

    function Utility.Lerp(a, b, t)
        return a + (b - a) * t
    end

    function Utility.InverseLerp(a, b, value)
        if a == b then return 0 end
        return (value - a) / (b - a)
    end

    function Utility.SmoothStep(edge0, edge1, x)
        local t = Utility.Clamp((x - edge0) / (edge1 - edge0), 0, 1)
        return t * t * (3 - 2 * t)
    end

    function Utility.SmootherStep(edge0, edge1, x)
        local t = Utility.Clamp((x - edge0) / (edge1 - edge0), 0, 1)
        return t * t * t * (t * (t * 6 - 15) + 10)
    end

    -- String utilities
    function Utility.Trim(str)
        return str:match("^%s*(.-)%s*$")
    end

    function Utility.Split(str, delimiter)
        delimiter = delimiter or ","
        local result = {}
        for match in (str .. delimiter):gmatch("(.-)" .. delimiter) do
            table.insert(result, match)
        end
        return result
    end

    function Utility.StartsWith(str, prefix)
        return str:sub(1, #prefix) == prefix
    end

    function Utility.EndsWith(str, suffix)
        return str:sub(-#suffix) == suffix
    end

    function Utility.Contains(str, substring)
        return str:find(substring, 1, true) ~= nil
    end

    function Utility.Capitalize(str)
        return str:sub(1, 1):upper() .. str:sub(2):lower()
    end

    function Utility.CamelCase(str)
        local result = ""
        for word in str:gmatch("[%w]+") do
            if result == "" then
                result = word:lower()
            else
                result = result .. Utility.Capitalize(word)
            end
        end
        return result
    end

    function Utility.PascalCase(str)
        local result = ""
        for word in str:gmatch("[%w]+") do
            result = result .. Utility.Capitalize(word)
        end
        return result
    end

    function Utility.SnakeCase(str)
        return str:gsub("([A-Z])", "_%1"):gsub("^_", ""):lower()
    end

    function Utility.Truncate(str, maxLength, suffix)
        suffix = suffix or "..."
        if #str <= maxLength then
            return str
        end
        return str:sub(1, maxLength - #suffix) .. suffix
    end

    -- Table utilities
    function Utility.DeepCopy(original)
        if type(original) ~= "table" then
            return original
        end

        local copy = {}
        for key, value in pairs(original) do
            copy[Utility.DeepCopy(key)] = Utility.DeepCopy(value)
        end

        return setmetatable(copy, getmetatable(original))
    end

    function Utility.ShallowCopy(original)
        if type(original) ~= "table" then
            return original
        end

        local copy = {}
        for key, value in pairs(original) do
            copy[key] = value
        end

        return copy
    end

    function Utility.Merge(base, override)
        local result = Utility.DeepCopy(base)

        for key, value in pairs(override) do
            if type(value) == "table" and type(result[key]) == "table" then
                result[key] = Utility.Merge(result[key], value)
            else
                result[key] = value
            end
        end

        return result
    end

    function Utility.Keys(tbl)
        local keys = {}
        for key, _ in pairs(tbl) do
            table.insert(keys, key)
        end
        return keys
    end

    function Utility.Values(tbl)
        local values = {}
        for _, value in pairs(tbl) do
            table.insert(values, value)
        end
        return values
    end

    function Utility.Count(tbl)
        local count = 0
        for _ in pairs(tbl) do
            count = count + 1
        end
        return count
    end

    function Utility.IsEmpty(tbl)
        return next(tbl) == nil
    end

    function Utility.Find(tbl, predicate)
        for key, value in pairs(tbl) do
            if predicate(value, key) then
                return value, key
            end
        end
        return nil
    end

    function Utility.Filter(tbl, predicate)
        local result = {}
        for key, value in pairs(tbl) do
            if predicate(value, key) then
                if type(key) == "number" then
                    table.insert(result, value)
                else
                    result[key] = value
                end
            end
        end
        return result
    end

    function Utility.Map(tbl, transform)
        local result = {}
        for key, value in pairs(tbl) do
            if type(key) == "number" then
                table.insert(result, transform(value, key))
            else
                result[key] = transform(value, key)
            end
        end
        return result
    end

    function Utility.Reduce(tbl, reducer, initial)
        local accumulator = initial
        for key, value in pairs(tbl) do
            accumulator = reducer(accumulator, value, key)
        end
        return accumulator
    end

    function Utility.Reverse(tbl)
        local result = {}
        for i = #tbl, 1, -1 do
            table.insert(result, tbl[i])
        end
        return result
    end

    function Utility.Shuffle(tbl)
        local result = Utility.ShallowCopy(tbl)
        for i = #result, 2, -1 do
            local j = math.random(i)
            result[i], result[j] = result[j], result[i]
        end
        return result
    end

    -- Time utilities
    function Utility.Now()
        return os.clock()
    end

    function Utility.FormatTime(seconds)
        local hours = math.floor(seconds / 3600)
        local minutes = math.floor((seconds % 3600) / 60)
        local secs = math.floor(seconds % 60)

        if hours > 0 then
            return string.format("%02d:%02d:%02d", hours, minutes, secs)
        else
            return string.format("%02d:%02d", minutes, secs)
        end
    end

    function Utility.FormatTimestamp(timestamp)
        return os.date("%Y-%m-%d %H:%M:%S", timestamp)
    end

    -- Number formatting
    function Utility.FormatNumber(num, decimals)
        decimals = decimals or 0

        if num >= 1e12 then
            return Utility.Round(num / 1e12, decimals) .. "T"
        elseif num >= 1e9 then
            return Utility.Round(num / 1e9, decimals) .. "B"
        elseif num >= 1e6 then
            return Utility.Round(num / 1e6, decimals) .. "M"
        elseif num >= 1e3 then
            return Utility.Round(num / 1e3, decimals) .. "K"
        else
            return Utility.Round(num, decimals)
        end
    end

    function Utility.FormatBytes(bytes)
        local units = {"B", "KB", "MB", "GB", "TB"}
        local index = 1

        while bytes >= 1024 and index < #units do
            bytes = bytes / 1024
            index = index + 1
        end

        return string.format("%.2f %s", bytes, units[index])
    end

    function Utility.FormatPercentage(value, decimals)
        decimals = decimals or 1
        return Utility.Round(value * 100, decimals) .. "%"
    end

    -- ID generation
    function Utility.GenerateUID(prefix)
        prefix = prefix or "uid"
        local chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        local uid = prefix .. "_"

        for i = 1, 16 do
            local randomIndex = math.random(1, #chars)
            uid = uid .. chars:sub(randomIndex, randomIndex)
        end

        return uid .. "_" .. tostring(os.clock()):gsub("%.", "")
    end

    function Utility.GenerateGUID()
        local HttpService = game:GetService("HttpService")
        return HttpService:GenerateGUID(false)
    end

    -- Debounce/Throttle
    function Utility.Debounce(func, delay)
        local lastCall = 0

        return function(...)
            local now = os.clock()
            if now - lastCall >= delay then
                lastCall = now
                return func(...)
            end
        end
    end

    function Utility.Throttle(func, delay)
        local lastCall = 0
        local scheduled = false
        local lastArgs = nil

        return function(...)
            lastArgs = {...}
            local now = os.clock()

            if now - lastCall >= delay then
                lastCall = now
                return func(...)
            elseif not scheduled then
                scheduled = true
                task.delay(delay - (now - lastCall), function()
                    scheduled = false
                    lastCall = os.clock()
                    func(unpack(lastArgs))
                end)
            end
        end
    end

    -- Color utilities (basic)
    function Utility.HexToColor3(hex)
        hex = hex:gsub("#", "")

        if #hex == 3 then
            hex = hex:sub(1, 1):rep(2) .. hex:sub(2, 2):rep(2) .. hex:sub(3, 3):rep(2)
        end

        local r = tonumber(hex:sub(1, 2), 16) / 255
        local g = tonumber(hex:sub(3, 4), 16) / 255
        local b = tonumber(hex:sub(5, 6), 16) / 255

        return Color3.new(r, g, b)
    end

    function Utility.Color3ToHex(color)
        return string.format("#%02X%02X%02X",
            math.floor(color.R * 255 + 0.5),
            math.floor(color.G * 255 + 0.5),
            math.floor(color.B * 255 + 0.5)
        )
    end

    function Utility.LerpColor3(c1, c2, t)
        return Color3.new(
            Utility.Lerp(c1.R, c2.R, t),
            Utility.Lerp(c1.G, c2.G, t),
            Utility.Lerp(c1.B, c2.B, t)
        )
    end

    -- Screen utilities
    function Utility.GetScreenSize()
        local camera = workspace.CurrentCamera
        if camera then
            return camera.ViewportSize
        end
        return Vector2.new(1920, 1080)
    end

    function Utility.GetMousePosition()
        local UserInputService = game:GetService("UserInputService")
        return UserInputService:GetMouseLocation()
    end

    function Utility.IsMouseOver(guiObject)
        if not Utility.IsValidInstance(guiObject) then return false end

        local mousePos = Utility.GetMousePosition()
        local objPos = guiObject.AbsolutePosition
        local objSize = guiObject.AbsoluteSize

        return mousePos.X >= objPos.X and 
               mousePos.X <= objPos.X + objSize.X and
               mousePos.Y >= objPos.Y and 
               mousePos.Y <= objPos.Y + objSize.Y
    end

    -- Text utilities
    function Utility.GetTextSize(text, fontSize, font, maxWidth)
        local TextService = game:GetService("TextService")
        maxWidth = maxWidth or math.huge

        local textSize = TextService:GetTextSize(
            text,
            fontSize,
            font,
            Vector2.new(maxWidth, math.huge)
        )

        return textSize.X, textSize.Y
    end

    return Utility


end


-- ============================================================================
-- Module: NexusUI/Core/Initialization
-- ============================================================================
NexusUI_Modules["NexusUI/Core/Initialization"] = function()
    local script = CreateMockScript("NexusUI/Core/Initialization")
    
    --[[
        NexusUI Initialization Module
        Handles library bootstrap and setup procedures

        Features:
        - Environment detection
        - Dependency validation
        - Module loading orchestration
        - Error handling and recovery
        - Initialization hooks
        - Cleanup registration
    ]]

    --// Services
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local HttpService = game:GetService("HttpService")

    --// Initialization Module
    local Initialization = {}
    Initialization.__index = Initialization
    Initialization.ClassName = "Initialization"

    --// State
    local InitState = {
        Initialized = false,
        InitStartTime = 0,
        InitEndTime = 0,
        InitDuration = 0,
        Errors = {},
        Warnings = {},
        LoadedModules = {},
        Hooks = {
            PreInit = {},
            PostInit = {},
            PreDestroy = {},
            PostDestroy = {},
        },
    }

    --// Environment Info
    local Environment = {
        IsStudio = RunService:IsStudio(),
        IsClient = RunService:IsClient(),
        IsServer = RunService:IsServer(),
        IsExecutor = false,
        ExecutorName = "Unknown",
        ExecutorVersion = "Unknown",
        GameId = game.GameId,
        PlaceId = game.PlaceId,
        PlaceVersion = game.PlaceVersion,
    }

    --// Executor Detection
    local function DetectExecutor()
        local executors = {
            { Name = "Synapse X", Check = function() return syn ~= nil end },
            { Name = "Script-Ware", Check = function() return identifyexecutor and identifyexecutor():find("Script%-Ware") end },
            { Name = "Krnl", Check = function() return KRNL_LOADED ~= nil end },
            { Name = "Fluxus", Check = function() return fluxus ~= nil end },
            { Name = "Oxygen U", Check = function() return pebc_execute ~= nil end },
            { Name = "Electron", Check = function() return Electron ~= nil end },
            { Name = "Celery", Check = function() return celession ~= nil end },
            { Name = "Comet", Check = function() return Comet ~= nil end },
            { Name = "Wave", Check = function() return wave_loaded ~= nil end },
        }

        for _, executor in ipairs(executors) do
            local success, result = pcall(executor.Check)
            if success and result then
                Environment.IsExecutor = true
                Environment.ExecutorName = executor.Name
                break
            end
        end

        -- Try identifyexecutor function
        if not Environment.IsExecutor then
            local success, result = pcall(function()
                if identifyexecutor then
                    return identifyexecutor()
                end
                return nil
            end)

            if success and result then
                Environment.IsExecutor = true
                Environment.ExecutorName = result
            end
        end

        -- Get version if available
        local success, version = pcall(function()
            if getexecutorversion then
                return getexecutorversion()
            end
            return "Unknown"
        end)

        if success then
            Environment.ExecutorVersion = version
        end
    end

    --// Dependency Checks
    local function CheckDependencies()
        local issues = {}

        -- Check for required executor functions
        local requiredFunctions = {
            -- These are optional but recommended
            { Name = "getgenv", Required = false },
            { Name = "getrenv", Required = false },
            { Name = "hookfunction", Required = false },
            { Name = "newcclosure", Required = false },
            { Name = "setclipboard", Required = false },
            { Name = "writefile", Required = false },
            { Name = "readfile", Required = false },
            { Name = "isfile", Required = false },
            { Name = "delfile", Required = false },
            { Name = "makefolder", Required = false },
            { Name = "isfolder", Required = false },
            { Name = "listfiles", Required = false },
        }

        for _, func in ipairs(requiredFunctions) do
            local exists = getfenv()[func.Name] ~= nil

            if not exists and func.Required then
                table.insert(issues, {
                    Type = "Error",
                    Message = string.format("Required function '%s' not found", func.Name)
                })
            elseif not exists then
                table.insert(issues, {
                    Type = "Warning",
                    Message = string.format("Optional function '%s' not available", func.Name)
                })
            end
        end

        return issues
    end

    --// File System Setup
    local function SetupFileSystem()
        local folders = {
            "NexusUI",
            "NexusUI/Configs",
            "NexusUI/Themes",
            "NexusUI/Cache",
            "NexusUI/Logs",
        }

        local success = pcall(function()
            if makefolder and isfolder then
                for _, folder in ipairs(folders) do
                    if not isfolder(folder) then
                        makefolder(folder)
                    end
                end
            end
        end)

        return success
    end

    --// Hook System
    function Initialization:AddHook(hookType, callback, priority)
        priority = priority or 0

        if not InitState.Hooks[hookType] then
            warn(string.format("[NexusUI.Init] Invalid hook type: %s", hookType))
            return
        end

        table.insert(InitState.Hooks[hookType], {
            Callback = callback,
            Priority = priority,
        })

        -- Sort by priority (higher first)
        table.sort(InitState.Hooks[hookType], function(a, b)
            return a.Priority > b.Priority
        end)
    end

    function Initialization:RemoveHook(hookType, callback)
        local hooks = InitState.Hooks[hookType]
        if not hooks then return end

        for i, hook in ipairs(hooks) do
            if hook.Callback == callback then
                table.remove(hooks, i)
                return true
            end
        end

        return false
    end

    local function RunHooks(hookType, ...)
        local hooks = InitState.Hooks[hookType]
        if not hooks then return end

        for _, hook in ipairs(hooks) do
            local success, err = pcall(hook.Callback, ...)

            if not success then
                table.insert(InitState.Errors, {
                    Type = "HookError",
                    Hook = hookType,
                    Message = tostring(err),
                    Time = os.clock(),
                })
            end
        end
    end

    --// Module Loading
    local function LoadCoreModules()
        local modules = {
            { Name = "Services", Path = script.Parent.Services },
            { Name = "SignalClass", Path = script.Parent.SignalClass },
            { Name = "Maid", Path = script.Parent.Maid },
            { Name = "Promise", Path = script.Parent.Promise },
            { Name = "Types", Path = script.Parent.Types },
            { Name = "Constants", Path = script.Parent.Constants },
            { Name = "EventSystem", Path = script.Parent.EventSystem },
            { Name = "StateManager", Path = script.Parent.StateManager },
            { Name = "InstancePool", Path = script.Parent.InstancePool },
            { Name = "ScreenGui", Path = script.Parent.ScreenGui },
        }

        for _, moduleInfo in ipairs(modules) do
            local success, result = pcall(function()
                if moduleInfo.Path and moduleInfo.Path:IsA("ModuleScript") then
                    return require(moduleInfo.Path)
                end
                return nil
            end)

            if success and result then
                InitState.LoadedModules[moduleInfo.Name] = {
                    Module = result,
                    LoadTime = os.clock(),
                }
            else
                table.insert(InitState.Warnings, {
                    Type = "ModuleLoadWarning",
                    Module = moduleInfo.Name,
                    Message = tostring(result),
                    Time = os.clock(),
                })
            end
        end
    end

    --// Main Initialization
    function Initialization:Initialize(config)
        if InitState.Initialized then
            return {
                Success = true,
                Message = "Already initialized",
                Environment = Environment,
            }
        end

        InitState.InitStartTime = os.clock()
        config = config or {}

        -- Run pre-init hooks
        RunHooks("PreInit", config)

        -- Detect environment
        DetectExecutor()

        -- Check dependencies
        local depIssues = CheckDependencies()
        for _, issue in ipairs(depIssues) do
            if issue.Type == "Error" then
                table.insert(InitState.Errors, issue)
            else
                table.insert(InitState.Warnings, issue)
            end
        end

        -- Setup file system
        if Environment.IsExecutor then
            SetupFileSystem()
        end

        -- Load core modules
        LoadCoreModules()

        -- Mark as initialized
        InitState.Initialized = true
        InitState.InitEndTime = os.clock()
        InitState.InitDuration = InitState.InitEndTime - InitState.InitStartTime

        -- Run post-init hooks
        RunHooks("PostInit", config)

        return {
            Success = #InitState.Errors == 0,
            Duration = InitState.InitDuration,
            Errors = InitState.Errors,
            Warnings = InitState.Warnings,
            Environment = Environment,
            LoadedModules = InitState.LoadedModules,
        }
    end

    function Initialization:IsInitialized()
        return InitState.Initialized
    end

    function Initialization:GetEnvironment()
        if not Environment.IsExecutor then
            DetectExecutor()
        end
        return Environment
    end

    function Initialization:GetInitDuration()
        return InitState.InitDuration
    end

    function Initialization:GetErrors()
        return InitState.Errors
    end

    function Initialization:GetWarnings()
        return InitState.Warnings
    end

    function Initialization:GetLoadedModules()
        return InitState.LoadedModules
    end

    --// Cleanup
    function Initialization:Destroy()
        if not InitState.Initialized then
            return
        end

        -- Run pre-destroy hooks
        RunHooks("PreDestroy")

        -- Cleanup loaded modules
        for name, moduleData in pairs(InitState.LoadedModules) do
            if moduleData.Module and type(moduleData.Module) == "table" and moduleData.Module.Destroy then
                pcall(moduleData.Module.Destroy, moduleData.Module)
            end
        end

        -- Run post-destroy hooks
        RunHooks("PostDestroy")

        -- Reset state
        InitState.Initialized = false
        InitState.LoadedModules = {}
        InitState.Errors = {}
        InitState.Warnings = {}
    end

    --// Utility Functions
    function Initialization:HasFunction(funcName)
        return getfenv()[funcName] ~= nil
    end

    function Initialization:SafeCall(funcName, ...)
        local func = getfenv()[funcName]
        if not func then
            return false, "Function not found"
        end

        return pcall(func, ...)
    end

    function Initialization:GetGameInfo()
        return {
            GameId = Environment.GameId,
            PlaceId = Environment.PlaceId,
            PlaceVersion = Environment.PlaceVersion,
            JobId = game.JobId,
        }
    end

    function Initialization:GetPlayerInfo()
        local player = Players.LocalPlayer
        if not player then
            return nil
        end

        return {
            UserId = player.UserId,
            Name = player.Name,
            DisplayName = player.DisplayName,
            AccountAge = player.AccountAge,
        }
    end

    --// Debug
    function Initialization:PrintStatus()
        print("=== NexusUI Initialization Status ===")
        print(string.format("Initialized: %s", tostring(InitState.Initialized)))
        print(string.format("Duration: %.3f seconds", InitState.InitDuration))
        print("")
        print("Environment:")
        print(string.format("  Is Studio: %s", tostring(Environment.IsStudio)))
        print(string.format("  Is Executor: %s", tostring(Environment.IsExecutor)))
        print(string.format("  Executor: %s v%s", Environment.ExecutorName, Environment.ExecutorVersion))
        print("")
        print(string.format("Loaded Modules: %d", Initialization:_countTable(InitState.LoadedModules)))
        print(string.format("Errors: %d", #InitState.Errors))
        print(string.format("Warnings: %d", #InitState.Warnings))
    end

    function Initialization:_countTable(t)
        local count = 0
        for _ in pairs(t) do
            count = count + 1
        end
        return count
    end

    return Initialization


end


-- ============================================================================
-- Module: NexusUI/Core/init
-- ============================================================================
NexusUI_Modules["NexusUI/Core/init"] = function()
    local script = CreateMockScript("NexusUI/Core/init")
    
    --[[
        NexusUI Core Module
        Central hub for core functionality and module loading

        Provides:
        - Module registration and loading
        - Shared utilities access
        - Service caching
        - State management bridge
        - Event system bridge
    ]]

    --// Services
    local RunService = game:GetService("RunService")
    local HttpService = game:GetService("HttpService")

    --// Module Container
    local Core = {}
    Core.__index = Core

    --// Cached Modules
    local LoadedModules = {}
    local ModuleMetadata = {}

    --// Core Configuration
    local CoreConfig = {
        LazyLoading = true,
        CacheModules = true,
        DebugMode = false,
        LogLevel = "INFO", -- DEBUG, INFO, WARN, ERROR
        MaxModuleLoadTime = 5,
        EnableHotReload = false,
    }

    --// Module Registry
    local ModuleRegistry = {
        -- Core modules
        Services = { Path = "Services", Required = true, Priority = 1 },
        Types = { Path = "Types", Required = true, Priority = 2 },
        Constants = { Path = "Constants", Required = true, Priority = 3 },
        SignalClass = { Path = "SignalClass", Required = true, Priority = 4 },
        Maid = { Path = "Maid", Required = true, Priority = 5 },
        Promise = { Path = "Promise", Required = true, Priority = 6 },
        EventSystem = { Path = "EventSystem", Required = true, Priority = 7 },
        StateManager = { Path = "StateManager", Required = true, Priority = 8 },
        InstancePool = { Path = "InstancePool", Required = false, Priority = 9 },
        ScreenGui = { Path = "ScreenGui", Required = false, Priority = 10 },
        Initialization = { Path = "Initialization", Required = false, Priority = 11 },

        -- Utility modules
        Utility = { Path = "Utility", Required = true, Priority = 100 },
        Math = { Path = "Utility.Math", Required = false, Priority = 101 },
        String = { Path = "Utility.String", Required = false, Priority = 102 },
        Table = { Path = "Utility.Table", Required = false, Priority = 103 },
        Color = { Path = "Utility.Color", Required = false, Priority = 104 },
        Bezier = { Path = "Utility.Bezier", Required = false, Priority = 105 },
        UUID = { Path = "Utility.UUID", Required = false, Priority = 106 },
        Debounce = { Path = "Utility.Debounce", Required = false, Priority = 107 },
        DeepCopy = { Path = "Utility.DeepCopy", Required = false, Priority = 108 },
        Lerp = { Path = "Utility.Lerp", Required = false, Priority = 109 },
        Validate = { Path = "Utility.Validate", Required = false, Priority = 110 },
    }

    --// Logging
    local function Log(level, message, ...)
        if CoreConfig.DebugMode or level == "ERROR" then
            local formattedMessage = string.format(message, ...)
            local prefix = string.format("[NexusUI.Core] [%s]", level)

            if level == "ERROR" then
                warn(prefix, formattedMessage)
            elseif level == "WARN" then
                warn(prefix, formattedMessage)
            else
                print(prefix, formattedMessage)
            end
        end
    end

    --// Module Loading
    local function ResolveModulePath(moduleName)
        local parts = string.split(moduleName, ".")
        local current = script

        for _, part in ipairs(parts) do
            local child = current:FindFirstChild(part)
            if not child then
                return nil
            end
            current = child
        end

        return current
    end

    local function LoadModuleInternal(moduleName)
        -- Check cache first
        if LoadedModules[moduleName] then
            return LoadedModules[moduleName]
        end

        -- Get module info from registry
        local moduleInfo = ModuleRegistry[moduleName]
        local modulePath = moduleInfo and moduleInfo.Path or moduleName

        -- Resolve module
        local moduleScript = ResolveModulePath(modulePath)

        if not moduleScript then
            -- Try direct child lookup
            moduleScript = script:FindFirstChild(moduleName, true)
        end

        if not moduleScript then
            if moduleInfo and moduleInfo.Required then
                Log("ERROR", "Required module not found: %s", moduleName)
            else
                Log("DEBUG", "Optional module not found: %s", moduleName)
            end
            return nil
        end

        -- Load module with timeout protection
        local startTime = os.clock()
        local success, result = pcall(function()
            return require(moduleScript)
        end)
        local loadTime = os.clock() - startTime

        if not success then
            Log("ERROR", "Failed to load module %s: %s", moduleName, tostring(result))
            return nil
        end

        -- Store metadata
        ModuleMetadata[moduleName] = {
            LoadTime = loadTime,
            LoadedAt = os.clock(),
            Path = modulePath,
            Script = moduleScript
        }

        -- Cache module
        if CoreConfig.CacheModules then
            LoadedModules[moduleName] = result
        end

        Log("DEBUG", "Loaded module: %s (%.3fs)", moduleName, loadTime)

        return result
    end

    --// Core Methods
    function Core.new()
        local self = setmetatable({}, Core)

        self._initialized = false
        self._initTime = 0
        self._modules = {}

        return self
    end

    function Core:Initialize(config)
        if self._initialized then
            Log("WARN", "Core already initialized")
            return self
        end

        local startTime = os.clock()

        -- Apply configuration
        if config then
            for key, value in pairs(config) do
                if CoreConfig[key] ~= nil then
                    CoreConfig[key] = value
                end
            end
        end

        Log("INFO", "Initializing Core module...")

        -- Load required modules in priority order
        local sortedModules = {}
        for name, info in pairs(ModuleRegistry) do
            if info.Required then
                table.insert(sortedModules, { Name = name, Priority = info.Priority })
            end
        end

        table.sort(sortedModules, function(a, b)
            return a.Priority < b.Priority
        end)

        for _, moduleData in ipairs(sortedModules) do
            local module = LoadModuleInternal(moduleData.Name)
            if module then
                self._modules[moduleData.Name] = module
            end
        end

        self._initTime = os.clock() - startTime
        self._initialized = true

        Log("INFO", "Core initialized in %.3fs", self._initTime)

        return self
    end

    function Core:LoadModule(moduleName)
        if self._modules[moduleName] then
            return self._modules[moduleName]
        end

        local module = LoadModuleInternal(moduleName)
        if module then
            self._modules[moduleName] = module
        end

        return module
    end

    function Core:GetModule(moduleName)
        return self._modules[moduleName] or LoadedModules[moduleName]
    end

    function Core:UnloadModule(moduleName)
        self._modules[moduleName] = nil
        LoadedModules[moduleName] = nil
        ModuleMetadata[moduleName] = nil

        Log("DEBUG", "Unloaded module: %s", moduleName)
    end

    function Core:ReloadModule(moduleName)
        self:UnloadModule(moduleName)
        return self:LoadModule(moduleName)
    end

    function Core:GetModuleMetadata(moduleName)
        return ModuleMetadata[moduleName]
    end

    function Core:GetAllModuleMetadata()
        local copy = {}
        for name, meta in pairs(ModuleMetadata) do
            copy[name] = {
                LoadTime = meta.LoadTime,
                LoadedAt = meta.LoadedAt,
                Path = meta.Path
            }
        end
        return copy
    end

    function Core:IsModuleLoaded(moduleName)
        return LoadedModules[moduleName] ~= nil or self._modules[moduleName] ~= nil
    end

    function Core:GetLoadedModuleCount()
        local count = 0
        for _ in pairs(LoadedModules) do
            count = count + 1
        end
        return count
    end

    function Core:GetInitTime()
        return self._initTime
    end

    function Core:IsInitialized()
        return self._initialized
    end

    --// Configuration
    function Core:SetConfig(key, value)
        if CoreConfig[key] ~= nil then
            CoreConfig[key] = value
            Log("DEBUG", "Config updated: %s = %s", key, tostring(value))
        end
    end

    function Core:GetConfig(key)
        return CoreConfig[key]
    end

    function Core:GetAllConfig()
        local copy = {}
        for k, v in pairs(CoreConfig) do
            copy[k] = v
        end
        return copy
    end

    --// Utility Access (shortcuts)
    function Core:GetServices()
        return self:GetModule("Services")
    end

    function Core:GetTypes()
        return self:GetModule("Types")
    end

    function Core:GetConstants()
        return self:GetModule("Constants")
    end

    function Core:GetSignalClass()
        return self:GetModule("SignalClass")
    end

    function Core:GetMaid()
        return self:GetModule("Maid")
    end

    function Core:GetPromise()
        return self:GetModule("Promise")
    end

    function Core:GetEventSystem()
        return self:GetModule("EventSystem")
    end

    function Core:GetStateManager()
        return self:GetModule("StateManager")
    end

    function Core:GetInstancePool()
        return self:GetModule("InstancePool")
    end

    function Core:GetUtility()
        return self:GetModule("Utility")
    end

    --// Signal Creation (convenience)
    function Core:CreateSignal(name)
        local SignalClass = self:GetSignalClass()
        if SignalClass then
            return SignalClass.new(name)
        end
        return nil
    end

    --// Maid Creation (convenience)
    function Core:CreateMaid()
        local Maid = self:GetMaid()
        if Maid then
            return Maid.new()
        end
        return nil
    end

    --// Promise Creation (convenience)
    function Core:CreatePromise(executor)
        local Promise = self:GetPromise()
        if Promise then
            return Promise.new(executor)
        end
        return nil
    end

    --// Event Dispatch (convenience)
    function Core:DispatchEvent(eventName, ...)
        local EventSystem = self:GetEventSystem()
        if EventSystem then
            EventSystem:Dispatch(eventName, ...)
        end
    end

    function Core:SubscribeEvent(eventName, callback)
        local EventSystem = self:GetEventSystem()
        if EventSystem then
            return EventSystem:Subscribe(eventName, callback)
        end
        return nil
    end

    --// State Management (convenience)
    function Core:SetState(key, value)
        local StateManager = self:GetStateManager()
        if StateManager then
            StateManager:Set(key, value)
        end
    end

    function Core:GetState(key)
        local StateManager = self:GetStateManager()
        if StateManager then
            return StateManager:Get(key)
        end
        return nil
    end

    function Core:WatchState(key, callback)
        local StateManager = self:GetStateManager()
        if StateManager then
            return StateManager:Watch(key, callback)
        end
        return nil
    end

    --// Cleanup
    function Core:Destroy()
        Log("INFO", "Destroying Core module...")

        -- Unload all modules
        for name, _ in pairs(self._modules) do
            self:UnloadModule(name)
        end

        self._modules = {}
        self._initialized = false

        Log("INFO", "Core destroyed")
    end

    --// Create and return singleton instance
    local instance = Core.new()

    -- Auto-initialize with default config
    instance:Initialize()

    return instance


end


-- ============================================================================
-- Module: NexusUI/Animation/SpringPhysics
-- ============================================================================
NexusUI_Modules["NexusUI/Animation/SpringPhysics"] = function()
    local script = CreateMockScript("NexusUI/Animation/SpringPhysics")
    
    --[[
        NexusUI Spring Physics
        Realistic spring-based animations

        Features:
        - Damped spring simulation
        - Configurable stiffness, damping, mass
        - Velocity-based animations
        - Multi-property springs
        - Spring presets
    ]]

    --// Services
    local RunService = game:GetService("RunService")

    --// Spring Physics Module
    local SpringPhysics = {}
    SpringPhysics.__index = SpringPhysics
    SpringPhysics.ClassName = "SpringPhysics"

    --// Spring Presets
    SpringPhysics.Presets = {
        Default = { Stiffness = 100, Damping = 10, Mass = 1 },
        Gentle = { Stiffness = 50, Damping = 8, Mass = 1 },
        Wobbly = { Stiffness = 180, Damping = 12, Mass = 1 },
        Stiff = { Stiffness = 210, Damping = 20, Mass = 1 },
        Slow = { Stiffness = 50, Damping = 15, Mass = 1 },
        Molasses = { Stiffness = 30, Damping = 20, Mass = 1 },
        Bouncy = { Stiffness = 200, Damping = 5, Mass = 1 },
        Snappy = { Stiffness = 300, Damping = 25, Mass = 1 },
        Quick = { Stiffness = 250, Damping = 18, Mass = 0.8 },
        Responsive = { Stiffness = 400, Damping = 30, Mass = 1 },
    }

    --// Active Springs
    local ActiveSprings = {}
    local SpringIdCounter = 0

    --// Generate Spring ID
    local function GenerateSpringId()
        SpringIdCounter = SpringIdCounter + 1
        return "spring_" .. SpringIdCounter
    end

    --// Spring State
    local SpringState = {
        Idle = "Idle",
        Active = "Active",
        Completed = "Completed",
        Cancelled = "Cancelled",
    }

    --// Value Operations
    local function GetValueType(value)
        return typeof(value)
    end

    local function SubtractValues(a, b)
        local valueType = typeof(a)

        if valueType == "number" then
            return a - b
        elseif valueType == "Vector2" then
            return a - b
        elseif valueType == "Vector3" then
            return a - b
        elseif valueType == "UDim" then
            return UDim.new(a.Scale - b.Scale, a.Offset - b.Offset)
        elseif valueType == "UDim2" then
            return UDim2.new(
                a.X.Scale - b.X.Scale, a.X.Offset - b.X.Offset,
                a.Y.Scale - b.Y.Scale, a.Y.Offset - b.Y.Offset
            )
        elseif valueType == "Color3" then
            return { R = a.R - b.R, G = a.G - b.G, B = a.B - b.B }
        end

        return 0
    end

    local function AddValues(a, b)
        local valueType = typeof(a)

        if valueType == "number" then
            return a + b
        elseif valueType == "Vector2" then
            return a + b
        elseif valueType == "Vector3" then
            return a + b
        elseif valueType == "UDim" then
            return UDim.new(a.Scale + b.Scale, a.Offset + b.Offset)
        elseif valueType == "UDim2" then
            return UDim2.new(
                a.X.Scale + b.X.Scale, a.X.Offset + b.X.Offset,
                a.Y.Scale + b.Y.Scale, a.Y.Offset + b.Y.Offset
            )
        elseif valueType == "Color3" and type(b) == "table" then
            return Color3.new(
                math.clamp(a.R + b.R, 0, 1),
                math.clamp(a.G + b.G, 0, 1),
                math.clamp(a.B + b.B, 0, 1)
            )
        end

        return a
    end

    local function MultiplyValue(value, scalar)
        local valueType = typeof(value)

        if valueType == "number" then
            return value * scalar
        elseif valueType == "Vector2" then
            return value * scalar
        elseif valueType == "Vector3" then
            return value * scalar
        elseif valueType == "UDim" then
            return UDim.new(value.Scale * scalar, value.Offset * scalar)
        elseif valueType == "UDim2" then
            return UDim2.new(
                value.X.Scale * scalar, value.X.Offset * scalar,
                value.Y.Scale * scalar, value.Y.Offset * scalar
            )
        elseif type(value) == "table" and value.R then
            return { R = value.R * scalar, G = value.G * scalar, B = value.B * scalar }
        end

        return value
    end

    local function GetMagnitude(value)
        local valueType = typeof(value)

        if valueType == "number" then
            return math.abs(value)
        elseif valueType == "Vector2" then
            return value.Magnitude
        elseif valueType == "Vector3" then
            return value.Magnitude
        elseif valueType == "UDim" then
            return math.abs(value.Scale) + math.abs(value.Offset)
        elseif valueType == "UDim2" then
            return math.abs(value.X.Scale) + math.abs(value.X.Offset) +
                   math.abs(value.Y.Scale) + math.abs(value.Y.Offset)
        elseif type(value) == "table" and value.R then
            return math.abs(value.R) + math.abs(value.G) + math.abs(value.B)
        end

        return 0
    end

    local function CreateZeroValue(template)
        local valueType = typeof(template)

        if valueType == "number" then
            return 0
        elseif valueType == "Vector2" then
            return Vector2.new(0, 0)
        elseif valueType == "Vector3" then
            return Vector3.new(0, 0, 0)
        elseif valueType == "UDim" then
            return UDim.new(0, 0)
        elseif valueType == "UDim2" then
            return UDim2.new(0, 0, 0, 0)
        elseif valueType == "Color3" then
            return { R = 0, G = 0, B = 0 }
        end

        return 0
    end

    --// Spring Class
    local Spring = {}
    Spring.__index = Spring

    function Spring.new(config)
        local self = setmetatable({}, Spring)

        self.Id = GenerateSpringId()
        self.Target = config.Target
        self.Property = config.Property
        self.GoalValue = config.GoalValue

        -- Spring parameters
        local preset = config.Preset and SpringPhysics.Presets[config.Preset]
        self.Stiffness = config.Stiffness or (preset and preset.Stiffness) or 100
        self.Damping = config.Damping or (preset and preset.Damping) or 10
        self.Mass = config.Mass or (preset and preset.Mass) or 1
        self.Precision = config.Precision or 0.001

        -- Callbacks
        self.OnStart = config.OnStart
        self.OnUpdate = config.OnUpdate
        self.OnComplete = config.OnComplete

        -- State
        self.State = SpringState.Idle
        self.CurrentValue = nil
        self.Velocity = nil

        return self
    end

    function Spring:_captureCurrentValue()
        if self.Target and self.Property then
            local success, value = pcall(function()
                return self.Target[self.Property]
            end)

            if success then
                self.CurrentValue = value
                self.Velocity = CreateZeroValue(value)
            end
        end
    end

    function Spring:Start()
        if self.State == SpringState.Active then
            return self
        end

        self:_captureCurrentValue()

        if self.CurrentValue == nil then
            return self
        end

        self.State = SpringState.Active

        if self.OnStart then
            pcall(self.OnStart, self)
        end

        ActiveSprings[self.Id] = self

        return self
    end

    function Spring:Stop()
        self.State = SpringState.Cancelled
        ActiveSprings[self.Id] = nil
        return self
    end

    function Spring:Cancel()
        return self:Stop()
    end

    function Spring:SetGoal(goalValue)
        self.GoalValue = goalValue

        if self.State ~= SpringState.Active then
            self:Start()
        end

        return self
    end

    function Spring:Impulse(impulseVelocity)
        if self.Velocity then
            self.Velocity = AddValues(self.Velocity, impulseVelocity)
        end

        if self.State ~= SpringState.Active then
            self:Start()
        end

        return self
    end

    function Spring:Update(deltaTime)
        if self.State ~= SpringState.Active then
            return self.State == SpringState.Completed or self.State == SpringState.Cancelled
        end

        if not self.CurrentValue or not self.GoalValue then
            return true
        end

        -- Spring physics calculation
        -- F = -k * x - c * v
        -- a = F / m
        -- v = v + a * dt
        -- x = x + v * dt

        local displacement = SubtractValues(self.CurrentValue, self.GoalValue)
        local springForce = MultiplyValue(displacement, -self.Stiffness)
        local dampingForce = MultiplyValue(self.Velocity, -self.Damping)
        local totalForce = AddValues(springForce, dampingForce)
        local acceleration = MultiplyValue(totalForce, 1 / self.Mass)

        self.Velocity = AddValues(self.Velocity, MultiplyValue(acceleration, deltaTime))
        self.CurrentValue = AddValues(self.CurrentValue, MultiplyValue(self.Velocity, deltaTime))

        -- Apply to target
        if self.Target and self.Property then
            pcall(function()
                self.Target[self.Property] = self.CurrentValue
            end)
        end

        -- Callback
        if self.OnUpdate then
            pcall(self.OnUpdate, self.CurrentValue, self.Velocity, self)
        end

        -- Check if settled
        local displacementMag = GetMagnitude(SubtractValues(self.CurrentValue, self.GoalValue))
        local velocityMag = GetMagnitude(self.Velocity)

        if displacementMag < self.Precision and velocityMag < self.Precision then
            -- Snap to goal
            self.CurrentValue = self.GoalValue
            self.Velocity = CreateZeroValue(self.GoalValue)

            if self.Target and self.Property then
                pcall(function()
                    self.Target[self.Property] = self.GoalValue
                end)
            end

            self.State = SpringState.Completed

            if self.OnComplete then
                pcall(self.OnComplete, self)
            end

            return true
        end

        return false
    end

    function Spring:GetVelocity()
        return self.Velocity
    end

    function Spring:GetCurrentValue()
        return self.CurrentValue
    end

    function Spring:GetGoalValue()
        return self.GoalValue
    end

    function Spring:IsActive()
        return self.State == SpringState.Active
    end

    function Spring:IsComplete()
        return self.State == SpringState.Completed
    end

    function Spring:Then(callback)
        local originalOnComplete = self.OnComplete

        self.OnComplete = function(spring)
            if originalOnComplete then
                originalOnComplete(spring)
            end
            callback(spring)
        end

        return self
    end

    function Spring:Await()
        while self.State == SpringState.Active do
            task.wait()
        end
        return self
    end

    --// Spring Physics API
    function SpringPhysics.Create(target, property, goalValue, config)
        config = config or {}

        return Spring.new({
            Target = target,
            Property = property,
            GoalValue = goalValue,
            Stiffness = config.Stiffness,
            Damping = config.Damping,
            Mass = config.Mass,
            Precision = config.Precision,
            Preset = config.Preset,
            OnStart = config.OnStart,
            OnUpdate = config.OnUpdate,
            OnComplete = config.OnComplete,
        })
    end

    function SpringPhysics.To(target, property, goalValue, config)
        return SpringPhysics.Create(target, property, goalValue, config):Start()
    end

    function SpringPhysics.Animate(target, properties, config)
        config = config or {}
        local springs = {}

        for property, goalValue in pairs(properties) do
            local spring = SpringPhysics.Create(target, property, goalValue, config)
            table.insert(springs, spring)
        end

        -- Start all springs
        for _, spring in ipairs(springs) do
            spring:Start()
        end

        return springs
    end

    function SpringPhysics.CreateSimple(initialValue, goalValue, config)
        config = config or {}

        local spring = {
            CurrentValue = initialValue,
            GoalValue = goalValue,
            Velocity = CreateZeroValue(initialValue),
            Stiffness = config.Stiffness or 100,
            Damping = config.Damping or 10,
            Mass = config.Mass or 1,
            Precision = config.Precision or 0.001,
        }

        function spring:Update(deltaTime)
            local displacement = SubtractValues(self.CurrentValue, self.GoalValue)
            local springForce = MultiplyValue(displacement, -self.Stiffness)
            local dampingForce = MultiplyValue(self.Velocity, -self.Damping)
            local totalForce = AddValues(springForce, dampingForce)
            local acceleration = MultiplyValue(totalForce, 1 / self.Mass)

            self.Velocity = AddValues(self.Velocity, MultiplyValue(acceleration, deltaTime))
            self.CurrentValue = AddValues(self.CurrentValue, MultiplyValue(self.Velocity, deltaTime))

            return self.CurrentValue
        end

        function spring:SetGoal(goal)
            self.GoalValue = goal
        end

        function spring:Impulse(velocity)
            self.Velocity = AddValues(self.Velocity, velocity)
        end

        function spring:IsSettled()
            local displacementMag = GetMagnitude(SubtractValues(self.CurrentValue, self.GoalValue))
            local velocityMag = GetMagnitude(self.Velocity)
            return displacementMag < self.Precision and velocityMag < self.Precision
        end

        return spring
    end

    --// Update Loop
    function SpringPhysics.Update(deltaTime)
        local toRemove = {}

        for id, spring in pairs(ActiveSprings) do
            local completed = spring:Update(deltaTime)

            if completed then
                table.insert(toRemove, id)
            end
        end

        for _, id in ipairs(toRemove) do
            ActiveSprings[id] = nil
        end
    end

    --// Management
    function SpringPhysics.CancelAll()
        for id, spring in pairs(ActiveSprings) do
            spring:Cancel()
        end
        ActiveSprings = {}
    end

    function SpringPhysics.CancelSpringsOf(target)
        for id, spring in pairs(ActiveSprings) do
            if spring.Target == target then
                spring:Cancel()
                ActiveSprings[id] = nil
            end
        end
    end

    function SpringPhysics.GetActiveCount()
        local count = 0
        for _ in pairs(ActiveSprings) do
            count = count + 1
        end
        return count
    end

    function SpringPhysics.GetSpringsOf(target)
        local springs = {}
        for id, spring in pairs(ActiveSprings) do
            if spring.Target == target then
                table.insert(springs, spring)
            end
        end
        return springs
    end

    --// Presets
    function SpringPhysics.GetPreset(name)
        return SpringPhysics.Presets[name]
    end

    function SpringPhysics.GetPresetNames()
        local names = {}
        for name, _ in pairs(SpringPhysics.Presets) do
            table.insert(names, name)
        end
        return names
    end

    function SpringPhysics.AddPreset(name, config)
        SpringPhysics.Presets[name] = config
    end

    --// Export State
    SpringPhysics.State = SpringState

    return SpringPhysics


end


-- ============================================================================
-- Module: NexusUI/Animation/EasingFunctions
-- ============================================================================
NexusUI_Modules["NexusUI/Animation/EasingFunctions"] = function()
    local script = CreateMockScript("NexusUI/Animation/EasingFunctions")
    
    --[[
        NexusUI Easing Functions
        40+ easing functions for smooth animations

        Categories:
        - Linear
        - Quad, Cubic, Quart, Quint, Expo
        - Sine, Circ
        - Back, Elastic, Bounce
        - Custom bezier-based easings
    ]]

    --// Easing Functions Module
    local EasingFunctions = {}

    --// Constants
    local PI = math.pi
    local TAU = PI * 2
    local HALF_PI = PI / 2

    --// Helper Functions
    local function Clamp(t)
        return math.max(0, math.min(1, t))
    end

    --// Linear
    function EasingFunctions.Linear(t)
        return t
    end

    --// Sine Easings
    function EasingFunctions.SineIn(t)
        return 1 - math.cos(t * HALF_PI)
    end

    function EasingFunctions.SineOut(t)
        return math.sin(t * HALF_PI)
    end

    function EasingFunctions.SineInOut(t)
        return -(math.cos(PI * t) - 1) / 2
    end

    --// Quad Easings (t^2)
    function EasingFunctions.QuadIn(t)
        return t * t
    end

    function EasingFunctions.QuadOut(t)
        return 1 - (1 - t) * (1 - t)
    end

    function EasingFunctions.QuadInOut(t)
        if t < 0.5 then
            return 2 * t * t
        else
            return 1 - (-2 * t + 2) ^ 2 / 2
        end
    end

    --// Cubic Easings (t^3)
    function EasingFunctions.CubicIn(t)
        return t * t * t
    end

    function EasingFunctions.CubicOut(t)
        return 1 - (1 - t) ^ 3
    end

    function EasingFunctions.CubicInOut(t)
        if t < 0.5 then
            return 4 * t * t * t
        else
            return 1 - (-2 * t + 2) ^ 3 / 2
        end
    end

    --// Quart Easings (t^4)
    function EasingFunctions.QuartIn(t)
        return t * t * t * t
    end

    function EasingFunctions.QuartOut(t)
        return 1 - (1 - t) ^ 4
    end

    function EasingFunctions.QuartInOut(t)
        if t < 0.5 then
            return 8 * t * t * t * t
        else
            return 1 - (-2 * t + 2) ^ 4 / 2
        end
    end

    --// Quint Easings (t^5)
    function EasingFunctions.QuintIn(t)
        return t * t * t * t * t
    end

    function EasingFunctions.QuintOut(t)
        return 1 - (1 - t) ^ 5
    end

    function EasingFunctions.QuintInOut(t)
        if t < 0.5 then
            return 16 * t * t * t * t * t
        else
            return 1 - (-2 * t + 2) ^ 5 / 2
        end
    end

    --// Expo Easings (2^t)
    function EasingFunctions.ExpoIn(t)
        if t == 0 then
            return 0
        end
        return 2 ^ (10 * t - 10)
    end

    function EasingFunctions.ExpoOut(t)
        if t == 1 then
            return 1
        end
        return 1 - 2 ^ (-10 * t)
    end

    function EasingFunctions.ExpoInOut(t)
        if t == 0 then
            return 0
        elseif t == 1 then
            return 1
        elseif t < 0.5 then
            return 2 ^ (20 * t - 10) / 2
        else
            return (2 - 2 ^ (-20 * t + 10)) / 2
        end
    end

    --// Circ Easings (circular)
    function EasingFunctions.CircIn(t)
        return 1 - math.sqrt(1 - t * t)
    end

    function EasingFunctions.CircOut(t)
        return math.sqrt(1 - (t - 1) ^ 2)
    end

    function EasingFunctions.CircInOut(t)
        if t < 0.5 then
            return (1 - math.sqrt(1 - (2 * t) ^ 2)) / 2
        else
            return (math.sqrt(1 - (-2 * t + 2) ^ 2) + 1) / 2
        end
    end

    --// Back Easings (overshoot)
    local BACK_C1 = 1.70158
    local BACK_C2 = BACK_C1 * 1.525
    local BACK_C3 = BACK_C1 + 1

    function EasingFunctions.BackIn(t)
        return BACK_C3 * t * t * t - BACK_C1 * t * t
    end

    function EasingFunctions.BackOut(t)
        return 1 + BACK_C3 * (t - 1) ^ 3 + BACK_C1 * (t - 1) ^ 2
    end

    function EasingFunctions.BackInOut(t)
        if t < 0.5 then
            return ((2 * t) ^ 2 * ((BACK_C2 + 1) * 2 * t - BACK_C2)) / 2
        else
            return ((2 * t - 2) ^ 2 * ((BACK_C2 + 1) * (t * 2 - 2) + BACK_C2) + 2) / 2
        end
    end

    --// Elastic Easings
    local ELASTIC_C4 = TAU / 3
    local ELASTIC_C5 = TAU / 4.5

    function EasingFunctions.ElasticIn(t)
        if t == 0 then
            return 0
        elseif t == 1 then
            return 1
        end
        return -2 ^ (10 * t - 10) * math.sin((t * 10 - 10.75) * ELASTIC_C4)
    end

    function EasingFunctions.ElasticOut(t)
        if t == 0 then
            return 0
        elseif t == 1 then
            return 1
        end
        return 2 ^ (-10 * t) * math.sin((t * 10 - 0.75) * ELASTIC_C4) + 1
    end

    function EasingFunctions.ElasticInOut(t)
        if t == 0 then
            return 0
        elseif t == 1 then
            return 1
        elseif t < 0.5 then
            return -(2 ^ (20 * t - 10) * math.sin((20 * t - 11.125) * ELASTIC_C5)) / 2
        else
            return (2 ^ (-20 * t + 10) * math.sin((20 * t - 11.125) * ELASTIC_C5)) / 2 + 1
        end
    end

    --// Bounce Easings
    function EasingFunctions.BounceOut(t)
        local n1 = 7.5625
        local d1 = 2.75

        if t < 1 / d1 then
            return n1 * t * t
        elseif t < 2 / d1 then
            t = t - 1.5 / d1
            return n1 * t * t + 0.75
        elseif t < 2.5 / d1 then
            t = t - 2.25 / d1
            return n1 * t * t + 0.9375
        else
            t = t - 2.625 / d1
            return n1 * t * t + 0.984375
        end
    end

    function EasingFunctions.BounceIn(t)
        return 1 - EasingFunctions.BounceOut(1 - t)
    end

    function EasingFunctions.BounceInOut(t)
        if t < 0.5 then
            return (1 - EasingFunctions.BounceOut(1 - 2 * t)) / 2
        else
            return (1 + EasingFunctions.BounceOut(2 * t - 1)) / 2
        end
    end

    --// Smooth Step Variants
    function EasingFunctions.SmoothStep(t)
        return t * t * (3 - 2 * t)
    end

    function EasingFunctions.SmootherStep(t)
        return t * t * t * (t * (t * 6 - 15) + 10)
    end

    function EasingFunctions.SmoothestStep(t)
        return t * t * t * t * (t * (t * (t * -20 + 70) - 84) + 35)
    end

    --// Custom Power Easings
    function EasingFunctions.PowerIn(power)
        return function(t)
            return t ^ power
        end
    end

    function EasingFunctions.PowerOut(power)
        return function(t)
            return 1 - (1 - t) ^ power
        end
    end

    function EasingFunctions.PowerInOut(power)
        return function(t)
            if t < 0.5 then
                return (2 * t) ^ power / 2
            else
                return 1 - (-2 * t + 2) ^ power / 2
            end
        end
    end

    --// Spring-like Easing (approximation)
    function EasingFunctions.Spring(t, damping)
        damping = damping or 0.4
        local frequency = 10
        return 1 - math.exp(-damping * t) * math.cos(frequency * t)
    end

    --// Anticipate (slight pullback before motion)
    function EasingFunctions.Anticipate(t, overshoot)
        overshoot = overshoot or 2
        return t * t * ((overshoot + 1) * t - overshoot)
    end

    --// Anticipate Overshoot
    function EasingFunctions.AnticipateOvershoot(t, tension)
        tension = tension or 2
        if t < 0.5 then
            return 0.5 * (2 * t) ^ 2 * ((tension + 1) * 2 * t - tension)
        else
            local adjusted = 2 * t - 2
            return 0.5 * (adjusted ^ 2 * ((tension + 1) * adjusted + tension) + 2)
        end
    end

    --// Stepped Easing (discrete steps)
    function EasingFunctions.Steps(steps, jumpEnd)
        steps = steps or 10
        jumpEnd = jumpEnd ~= false

        return function(t)
            local progress = math.floor(t * steps)
            if jumpEnd then
                return math.min(progress / steps, 1)
            else
                return progress / (steps - 1)
            end
        end
    end

    --// Bezier-based Custom Easing
    function EasingFunctions.CubicBezier(x1, y1, x2, y2)
        -- Newton-Raphson iteration settings
        local NEWTON_ITERATIONS = 4
        local NEWTON_MIN_SLOPE = 0.001
        local SUBDIVISION_PRECISION = 0.0000001
        local SUBDIVISION_MAX_ITERATIONS = 10

        -- Clamp control points
        x1 = math.max(0, math.min(1, x1))
        x2 = math.max(0, math.min(1, x2))

        -- Pre-compute sample table
        local sampleTableSize = 11
        local sampleTable = {}

        local function calcBezier(t, a1, a2)
            return ((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1 * t
        end

        local function getSlope(t, a1, a2)
            return 3 * (1 - 3 * a2 + 3 * a1) * t * t + 2 * (3 * a2 - 6 * a1) * t + 3 * a1
        end

        for i = 0, sampleTableSize - 1 do
            sampleTable[i] = calcBezier(i / (sampleTableSize - 1), x1, x2)
        end

        local function getTForX(x)
            local intervalStart = 0
            local currentSample = 1
            local lastSample = sampleTableSize - 1

            while currentSample ~= lastSample and sampleTable[currentSample] <= x do
                intervalStart = intervalStart + 1 / (sampleTableSize - 1)
                currentSample = currentSample + 1
            end
            currentSample = currentSample - 1

            local dist = (x - sampleTable[currentSample]) / 
                         (sampleTable[currentSample + 1] - sampleTable[currentSample])
            local guessForT = intervalStart + dist / (sampleTableSize - 1)

            local initialSlope = getSlope(guessForT, x1, x2)

            if initialSlope >= NEWTON_MIN_SLOPE then
                for i = 1, NEWTON_ITERATIONS do
                    local currentSlope = getSlope(guessForT, x1, x2)
                    if currentSlope == 0 then break end
                    local currentX = calcBezier(guessForT, x1, x2) - x
                    guessForT = guessForT - currentX / currentSlope
                end
                return guessForT
            elseif initialSlope == 0 then
                return guessForT
            else
                local aA = intervalStart
                local aB = intervalStart + 1 / (sampleTableSize - 1)
                local currentX, currentT

                for i = 1, SUBDIVISION_MAX_ITERATIONS do
                    currentT = aA + (aB - aA) / 2
                    currentX = calcBezier(currentT, x1, x2) - x

                    if math.abs(currentX) < SUBDIVISION_PRECISION then
                        break
                    end

                    if currentX > 0 then
                        aB = currentT
                    else
                        aA = currentT
                    end
                end

                return currentT
            end
        end

        return function(t)
            if t == 0 or t == 1 then
                return t
            end
            return calcBezier(getTForX(t), y1, y2)
        end
    end

    --// Common Bezier Presets
    EasingFunctions.Ease = EasingFunctions.CubicBezier(0.25, 0.1, 0.25, 1)
    EasingFunctions.EaseIn = EasingFunctions.CubicBezier(0.42, 0, 1, 1)
    EasingFunctions.EaseOut = EasingFunctions.CubicBezier(0, 0, 0.58, 1)
    EasingFunctions.EaseInOut = EasingFunctions.CubicBezier(0.42, 0, 0.58, 1)

    --// Material Design Easings
    EasingFunctions.Standard = EasingFunctions.CubicBezier(0.4, 0, 0.2, 1)
    EasingFunctions.Decelerate = EasingFunctions.CubicBezier(0, 0, 0.2, 1)
    EasingFunctions.Accelerate = EasingFunctions.CubicBezier(0.4, 0, 1, 1)
    EasingFunctions.Sharp = EasingFunctions.CubicBezier(0.4, 0, 0.6, 1)

    --// iOS-like Easings
    EasingFunctions.DefaultiOS = EasingFunctions.CubicBezier(0.25, 0.46, 0.45, 0.94)
    EasingFunctions.SpringiOS = EasingFunctions.CubicBezier(0.5, 1.8, 0.4, 0.8)

    --// Utility Functions
    function EasingFunctions.Get(name)
        return EasingFunctions[name]
    end

    function EasingFunctions.GetAll()
        local easings = {}
        for name, func in pairs(EasingFunctions) do
            if type(func) == "function" and name ~= "Get" and name ~= "GetAll" and 
               name ~= "GetCategories" and name ~= "GetByCategory" and
               name ~= "CubicBezier" and name ~= "Steps" and
               name ~= "PowerIn" and name ~= "PowerOut" and name ~= "PowerInOut" then
                table.insert(easings, name)
            end
        end
        table.sort(easings)
        return easings
    end

    function EasingFunctions.GetCategories()
        return {
            "Linear",
            "Sine",
            "Quad",
            "Cubic",
            "Quart",
            "Quint",
            "Expo",
            "Circ",
            "Back",
            "Elastic",
            "Bounce",
            "Smooth",
            "Custom",
        }
    end

    function EasingFunctions.GetByCategory(category)
        local categoryMap = {
            Linear = {"Linear"},
            Sine = {"SineIn", "SineOut", "SineInOut"},
            Quad = {"QuadIn", "QuadOut", "QuadInOut"},
            Cubic = {"CubicIn", "CubicOut", "CubicInOut"},
            Quart = {"QuartIn", "QuartOut", "QuartInOut"},
            Quint = {"QuintIn", "QuintOut", "QuintInOut"},
            Expo = {"ExpoIn", "ExpoOut", "ExpoInOut"},
            Circ = {"CircIn", "CircOut", "CircInOut"},
            Back = {"BackIn", "BackOut", "BackInOut"},
            Elastic = {"ElasticIn", "ElasticOut", "ElasticInOut"},
            Bounce = {"BounceIn", "BounceOut", "BounceInOut"},
            Smooth = {"SmoothStep", "SmootherStep", "SmoothestStep"},
            Custom = {"Ease", "EaseIn", "EaseOut", "EaseInOut", "Standard", "Decelerate", "Accelerate", "Sharp"},
        }

        return categoryMap[category] or {}
    end

    --// Apply easing to a value
    function EasingFunctions.Apply(easingName, startValue, endValue, t)
        local easingFunc = EasingFunctions.Get(easingName) or EasingFunctions.Linear
        local easedT = easingFunc(t)

        local valueType = typeof(startValue)

        if valueType == "number" then
            return startValue + (endValue - startValue) * easedT
        elseif valueType == "Color3" then
            return Color3.new(
                startValue.R + (endValue.R - startValue.R) * easedT,
                startValue.G + (endValue.G - startValue.G) * easedT,
                startValue.B + (endValue.B - startValue.B) * easedT
            )
        elseif valueType == "Vector2" then
            return startValue:Lerp(endValue, easedT)
        elseif valueType == "Vector3" then
            return startValue:Lerp(endValue, easedT)
        elseif valueType == "UDim2" then
            return UDim2.new(
                startValue.X.Scale + (endValue.X.Scale - startValue.X.Scale) * easedT,
                startValue.X.Offset + (endValue.X.Offset - startValue.X.Offset) * easedT,
                startValue.Y.Scale + (endValue.Y.Scale - startValue.Y.Scale) * easedT,
                startValue.Y.Offset + (endValue.Y.Offset - startValue.Y.Offset) * easedT
            )
        elseif valueType == "CFrame" then
            return startValue:Lerp(endValue, easedT)
        end

        return easedT >= 0.5 and endValue or startValue
    end

    return EasingFunctions


end


-- ============================================================================
-- Module: NexusUI/Animation/Sequence
-- ============================================================================
NexusUI_Modules["NexusUI/Animation/Sequence"] = function()
    local script = CreateMockScript("NexusUI/Animation/Sequence")
    
    --[[
        NexusUI Animation Sequence
        Chain animations to play one after another

        Features:
        - Sequential animation execution
        - Delay between animations
        - Callbacks at each step
        - Pause/Resume/Cancel support
        - Loop support
    ]]

    --// Sequence Module
    local Sequence = {}
    Sequence.__index = Sequence
    Sequence.ClassName = "AnimationSequence"

    --// Sequence State
    local SequenceState = {
        Pending = "Pending",
        Playing = "Playing",
        Paused = "Paused",
        Completed = "Completed",
        Cancelled = "Cancelled",
    }

    --// Sequence ID Counter
    local SequenceIdCounter = 0

    local function GenerateSequenceId()
        SequenceIdCounter = SequenceIdCounter + 1
        return "seq_" .. SequenceIdCounter
    end

    --// Sequence Step
    local SequenceStep = {}
    SequenceStep.__index = SequenceStep

    function SequenceStep.new(config)
        local self = setmetatable({}, SequenceStep)

        self.Type = config.Type or "animation" -- animation, delay, callback, label
        self.Animation = config.Animation
        self.Duration = config.Duration or 0
        self.Callback = config.Callback
        self.Label = config.Label
        self.Completed = false

        return self
    end

    --// Sequence Class
    function Sequence.new(...)
        local self = setmetatable({}, Sequence)

        self.Id = GenerateSequenceId()
        self.Steps = {}
        self.CurrentStepIndex = 0
        self.State = SequenceState.Pending
        self.LoopCount = 0
        self.MaxLoops = 0 -- 0 = no loop, -1 = infinite
        self.CurrentLoop = 0
        self.Labels = {}

        -- Callbacks
        self.OnStart = nil
        self.OnStepComplete = nil
        self.OnComplete = nil
        self.OnLoop = nil

        -- Add initial animations if provided
        local animations = {...}
        for _, anim in ipairs(animations) do
            self:Add(anim)
        end

        return self
    end

    --// Adding Steps
    function Sequence:Add(animation, options)
        options = options or {}

        local step = SequenceStep.new({
            Type = "animation",
            Animation = animation,
        })

        table.insert(self.Steps, step)

        -- Add delay after if specified
        if options.DelayAfter and options.DelayAfter > 0 then
            self:AddDelay(options.DelayAfter)
        end

        return self
    end

    function Sequence:AddDelay(duration)
        local step = SequenceStep.new({
            Type = "delay",
            Duration = duration,
        })

        table.insert(self.Steps, step)

        return self
    end

    function Sequence:AddCallback(callback)
        local step = SequenceStep.new({
            Type = "callback",
            Callback = callback,
        })

        table.insert(self.Steps, step)

        return self
    end

    function Sequence:AddLabel(label)
        local step = SequenceStep.new({
            Type = "label",
            Label = label,
        })

        self.Labels[label] = #self.Steps + 1
        table.insert(self.Steps, step)

        return self
    end

    function Sequence:Insert(index, animation)
        local step = SequenceStep.new({
            Type = "animation",
            Animation = animation,
        })

        table.insert(self.Steps, index, step)

        return self
    end

    --// Playback Control
    function Sequence:Play()
        if self.State == SequenceState.Playing then
            return self
        end

        self.State = SequenceState.Playing
        self.CurrentStepIndex = 0
        self.CurrentLoop = 0

        if self.OnStart then
            pcall(self.OnStart, self)
        end

        self:_playNextStep()

        return self
    end

    function Sequence:Pause()
        if self.State == SequenceState.Playing then
            self.State = SequenceState.Paused

            -- Pause current animation if possible
            local currentStep = self.Steps[self.CurrentStepIndex]
            if currentStep and currentStep.Animation and currentStep.Animation.Pause then
                currentStep.Animation:Pause()
            end
        end

        return self
    end

    function Sequence:Resume()
        if self.State == SequenceState.Paused then
            self.State = SequenceState.Playing

            -- Resume current animation if possible
            local currentStep = self.Steps[self.CurrentStepIndex]
            if currentStep and currentStep.Animation and currentStep.Animation.Resume then
                currentStep.Animation:Resume()
            end
        end

        return self
    end

    function Sequence:Stop()
        self.State = SequenceState.Cancelled

        -- Stop current animation
        local currentStep = self.Steps[self.CurrentStepIndex]
        if currentStep and currentStep.Animation and currentStep.Animation.Stop then
            currentStep.Animation:Stop()
        end

        return self
    end

    function Sequence:Cancel()
        return self:Stop()
    end

    function Sequence:Restart()
        self:Stop()

        -- Reset all steps
        for _, step in ipairs(self.Steps) do
            step.Completed = false
        end

        self:Play()

        return self
    end

    function Sequence:GotoLabel(label)
        local index = self.Labels[label]
        if index then
            self.CurrentStepIndex = index - 1
            self:_playNextStep()
        end
        return self
    end

    function Sequence:GotoStep(index)
        self.CurrentStepIndex = math.max(0, math.min(index - 1, #self.Steps))
        self:_playNextStep()
        return self
    end

    --// Internal Playback
    function Sequence:_playNextStep()
        if self.State ~= SequenceState.Playing then
            return
        end

        self.CurrentStepIndex = self.CurrentStepIndex + 1

        -- Check if sequence is complete
        if self.CurrentStepIndex > #self.Steps then
            -- Check for looping
            if self.MaxLoops == -1 or self.CurrentLoop < self.MaxLoops then
                self.CurrentLoop = self.CurrentLoop + 1
                self.CurrentStepIndex = 0

                -- Reset steps
                for _, step in ipairs(self.Steps) do
                    step.Completed = false
                end

                if self.OnLoop then
                    pcall(self.OnLoop, self.CurrentLoop, self)
                end

                self:_playNextStep()
                return
            end

            self.State = SequenceState.Completed

            if self.OnComplete then
                pcall(self.OnComplete, self)
            end

            return
        end

        local step = self.Steps[self.CurrentStepIndex]

        if step.Type == "animation" then
            self:_playAnimationStep(step)
        elseif step.Type == "delay" then
            self:_playDelayStep(step)
        elseif step.Type == "callback" then
            self:_playCallbackStep(step)
        elseif step.Type == "label" then
            -- Labels are just markers, skip to next
            step.Completed = true
            self:_playNextStep()
        end
    end

    function Sequence:_playAnimationStep(step)
        local animation = step.Animation

        if not animation then
            step.Completed = true
            self:_onStepComplete(step)
            return
        end

        -- Set up completion handler
        local originalOnComplete = animation.OnComplete

        animation.OnComplete = function(...)
            if originalOnComplete then
                originalOnComplete(...)
            end

            step.Completed = true
            self:_onStepComplete(step)
        end

        -- Play animation
        if animation.Play then
            animation:Play()
        elseif animation.Start then
            animation:Start()
        end
    end

    function Sequence:_playDelayStep(step)
        task.delay(step.Duration, function()
            if self.State == SequenceState.Playing then
                step.Completed = true
                self:_onStepComplete(step)
            end
        end)
    end

    function Sequence:_playCallbackStep(step)
        if step.Callback then
            pcall(step.Callback, self)
        end

        step.Completed = true
        self:_onStepComplete(step)
    end

    function Sequence:_onStepComplete(step)
        if self.OnStepComplete then
            pcall(self.OnStepComplete, step, self.CurrentStepIndex, self)
        end

        self:_playNextStep()
    end

    --// Configuration
    function Sequence:SetLoops(count)
        self.MaxLoops = count
        return self
    end

    function Sequence:SetOnStart(callback)
        self.OnStart = callback
        return self
    end

    function Sequence:SetOnStepComplete(callback)
        self.OnStepComplete = callback
        return self
    end

    function Sequence:SetOnComplete(callback)
        self.OnComplete = callback
        return self
    end

    function Sequence:SetOnLoop(callback)
        self.OnLoop = callback
        return self
    end

    function Sequence:Then(callback)
        local originalOnComplete = self.OnComplete

        self.OnComplete = function(seq)
            if originalOnComplete then
                originalOnComplete(seq)
            end
            callback(seq)
        end

        return self
    end

    --// State Queries
    function Sequence:GetState()
        return self.State
    end

    function Sequence:IsPlaying()
        return self.State == SequenceState.Playing
    end

    function Sequence:IsPaused()
        return self.State == SequenceState.Paused
    end

    function Sequence:IsComplete()
        return self.State == SequenceState.Completed
    end

    function Sequence:GetCurrentStepIndex()
        return self.CurrentStepIndex
    end

    function Sequence:GetStepCount()
        return #self.Steps
    end

    function Sequence:GetProgress()
        if #self.Steps == 0 then return 1 end
        return (self.CurrentStepIndex - 1) / #self.Steps
    end

    function Sequence:GetCurrentLoop()
        return self.CurrentLoop
    end

    --// Await
    function Sequence:Await()
        while self.State == SequenceState.Playing or self.State == SequenceState.Paused do
            task.wait()
        end
        return self
    end

    --// Export State
    Sequence.State = SequenceState

    return Sequence


end


-- ============================================================================
-- Module: NexusUI/Animation/Timeline
-- ============================================================================
NexusUI_Modules["NexusUI/Animation/Timeline"] = function()
    local script = CreateMockScript("NexusUI/Animation/Timeline")
    
    --[[
        NexusUI Animation Timeline
        Time-based animation orchestration

        Features:
        - Time-positioned animations
        - Parallel and sequential animations
        - Scrubbing (seek to any time)
        - Speed control
        - Labels for easy seeking
    ]]

    --// Timeline Module
    local Timeline = {}
    Timeline.__index = Timeline
    Timeline.ClassName = "AnimationTimeline"

    --// Timeline State
    local TimelineState = {
        Pending = "Pending",
        Playing = "Playing",
        Paused = "Paused",
        Completed = "Completed",
        Cancelled = "Cancelled",
    }

    --// Timeline ID Counter
    local TimelineIdCounter = 0

    local function GenerateTimelineId()
        TimelineIdCounter = TimelineIdCounter + 1
        return "timeline_" .. TimelineIdCounter
    end

    --// Timeline Entry
    local TimelineEntry = {}
    TimelineEntry.__index = TimelineEntry

    function TimelineEntry.new(config)
        local self = setmetatable({}, TimelineEntry)

        self.StartTime = config.StartTime or 0
        self.Duration = config.Duration or 0
        self.Animation = config.Animation
        self.Callback = config.Callback
        self.Label = config.Label
        self.Type = config.Type or "animation" -- animation, callback, label
        self.HasStarted = false
        self.HasCompleted = false

        return self
    end

    function TimelineEntry:GetEndTime()
        return self.StartTime + self.Duration
    end

    --// Timeline Class
    function Timeline.new()
        local self = setmetatable({}, Timeline)

        self.Id = GenerateTimelineId()
        self.Entries = {}
        self.Labels = {}
        self.Duration = 0
        self.CurrentTime = 0
        self.PlaybackSpeed = 1
        self.State = TimelineState.Pending
        self.LoopCount = 0
        self.MaxLoops = 0
        self.CurrentLoop = 0
        self.Connection = nil

        -- Callbacks
        self.OnStart = nil
        self.OnUpdate = nil
        self.OnComplete = nil
        self.OnLoop = nil

        return self
    end

    --// Adding Entries
    function Timeline:Add(animation, startTime, duration)
        local entry = TimelineEntry.new({
            StartTime = startTime or self.Duration,
            Duration = duration or (animation.Duration or 0.3),
            Animation = animation,
            Type = "animation",
        })

        table.insert(self.Entries, entry)
        self:_updateDuration()

        return self
    end

    function Timeline:AddAt(time, animation, duration)
        return self:Add(animation, time, duration)
    end

    function Timeline:AddCallback(time, callback)
        local entry = TimelineEntry.new({
            StartTime = time,
            Duration = 0,
            Callback = callback,
            Type = "callback",
        })

        table.insert(self.Entries, entry)
        self:_updateDuration()

        return self
    end

    function Timeline:AddLabel(time, label)
        local entry = TimelineEntry.new({
            StartTime = time,
            Duration = 0,
            Label = label,
            Type = "label",
        })

        self.Labels[label] = time
        table.insert(self.Entries, entry)

        return self
    end

    function Timeline:AddStagger(animations, startTime, staggerDelay, duration)
        startTime = startTime or self.Duration
        staggerDelay = staggerDelay or 0.1
        duration = duration or 0.3

        for i, animation in ipairs(animations) do
            local time = startTime + (i - 1) * staggerDelay
            self:Add(animation, time, duration)
        end

        return self
    end

    function Timeline:_updateDuration()
        local maxEndTime = 0

        for _, entry in ipairs(self.Entries) do
            local endTime = entry:GetEndTime()
            if endTime > maxEndTime then
                maxEndTime = endTime
            end
        end

        self.Duration = maxEndTime
    end

    --// Playback Control
    function Timeline:Play()
        if self.State == TimelineState.Playing then
            return self
        end

        self.State = TimelineState.Playing

        if self.CurrentTime == 0 and self.OnStart then
            pcall(self.OnStart, self)
        end

        self:_startUpdateLoop()

        return self
    end

    function Timeline:Pause()
        if self.State == TimelineState.Playing then
            self.State = TimelineState.Paused
            self:_stopUpdateLoop()
        end

        return self
    end

    function Timeline:Resume()
        if self.State == TimelineState.Paused then
            self.State = TimelineState.Playing
            self:_startUpdateLoop()
        end

        return self
    end

    function Timeline:Stop()
        self.State = TimelineState.Cancelled
        self:_stopUpdateLoop()

        return self
    end

    function Timeline:Cancel()
        return self:Stop()
    end

    function Timeline:Restart()
        self:Stop()
        self.CurrentTime = 0
        self.CurrentLoop = 0

        -- Reset all entries
        for _, entry in ipairs(self.Entries) do
            entry.HasStarted = false
            entry.HasCompleted = false
        end

        self:Play()

        return self
    end

    function Timeline:Seek(time)
        time = math.max(0, math.min(time, self.Duration))

        local wasPlaying = self.State == TimelineState.Playing

        if wasPlaying then
            self:Pause()
        end

        -- Reset entries that come after the seek time
        for _, entry in ipairs(self.Entries) do
            if entry.StartTime > time then
                entry.HasStarted = false
                entry.HasCompleted = false
            elseif entry:GetEndTime() < time then
                entry.HasStarted = true
                entry.HasCompleted = true
            else
                entry.HasStarted = true
                entry.HasCompleted = false
            end
        end

        self.CurrentTime = time

        -- Update all animations to current time
        self:_updateAnimationsAtTime(time)

        if wasPlaying then
            self:Resume()
        end

        return self
    end

    function Timeline:SeekLabel(label)
        local time = self.Labels[label]
        if time then
            self:Seek(time)
        end
        return self
    end

    function Timeline:SeekProgress(progress)
        progress = math.max(0, math.min(1, progress))
        self:Seek(progress * self.Duration)
        return self
    end

    --// Update Loop
    function Timeline:_startUpdateLoop()
        if self.Connection then return end

        local RunService = game:GetService("RunService")

        self.Connection = RunService.Heartbeat:Connect(function(deltaTime)
            self:_update(deltaTime * self.PlaybackSpeed)
        end)
    end

    function Timeline:_stopUpdateLoop()
        if self.Connection then
            self.Connection:Disconnect()
            self.Connection = nil
        end
    end

    function Timeline:_update(deltaTime)
        if self.State ~= TimelineState.Playing then
            return
        end

        self.CurrentTime = self.CurrentTime + deltaTime

        -- Process entries
        for _, entry in ipairs(self.Entries) do
            -- Check if entry should start
            if not entry.HasStarted and self.CurrentTime >= entry.StartTime then
                entry.HasStarted = true

                if entry.Type == "animation" and entry.Animation then
                    if entry.Animation.Play then
                        entry.Animation:Play()
                    elseif entry.Animation.Start then
                        entry.Animation:Start()
                    end
                elseif entry.Type == "callback" and entry.Callback then
                    pcall(entry.Callback, self.CurrentTime, self)
                end
            end

            -- Check if entry should complete
            if entry.HasStarted and not entry.HasCompleted then
                if self.CurrentTime >= entry:GetEndTime() then
                    entry.HasCompleted = true
                end
            end
        end

        -- Update callback
        if self.OnUpdate then
            pcall(self.OnUpdate, self.CurrentTime, self:GetProgress(), self)
        end

        -- Check if timeline is complete
        if self.CurrentTime >= self.Duration then
            -- Check for looping
            if self.MaxLoops == -1 or self.CurrentLoop < self.MaxLoops then
                self.CurrentLoop = self.CurrentLoop + 1
                self.CurrentTime = 0

                -- Reset entries
                for _, entry in ipairs(self.Entries) do
                    entry.HasStarted = false
                    entry.HasCompleted = false
                end

                if self.OnLoop then
                    pcall(self.OnLoop, self.CurrentLoop, self)
                end
            else
                self.State = TimelineState.Completed
                self:_stopUpdateLoop()

                if self.OnComplete then
                    pcall(self.OnComplete, self)
                end
            end
        end
    end

    function Timeline:_updateAnimationsAtTime(time)
        for _, entry in ipairs(self.Entries) do
            if entry.Type == "animation" and entry.Animation then
                if time >= entry.StartTime and time <= entry:GetEndTime() then
                    local localProgress = (time - entry.StartTime) / entry.Duration

                    -- If animation has a SetProgress method, use it
                    if entry.Animation.SetProgress then
                        entry.Animation:SetProgress(localProgress)
                    end
                end
            end
        end
    end

    --// Configuration
    function Timeline:SetSpeed(speed)
        self.PlaybackSpeed = speed
        return self
    end

    function Timeline:SetLoops(count)
        self.MaxLoops = count
        return self
    end

    function Timeline:SetOnStart(callback)
        self.OnStart = callback
        return self
    end

    function Timeline:SetOnUpdate(callback)
        self.OnUpdate = callback
        return self
    end

    function Timeline:SetOnComplete(callback)
        self.OnComplete = callback
        return self
    end

    function Timeline:SetOnLoop(callback)
        self.OnLoop = callback
        return self
    end

    function Timeline:Then(callback)
        local originalOnComplete = self.OnComplete

        self.OnComplete = function(tl)
            if originalOnComplete then
                originalOnComplete(tl)
            end
            callback(tl)
        end

        return self
    end

    --// State Queries
    function Timeline:GetState()
        return self.State
    end

    function Timeline:IsPlaying()
        return self.State == TimelineState.Playing
    end

    function Timeline:IsPaused()
        return self.State == TimelineState.Paused
    end

    function Timeline:IsComplete()
        return self.State == TimelineState.Completed
    end

    function Timeline:GetCurrentTime()
        return self.CurrentTime
    end

    function Timeline:GetDuration()
        return self.Duration
    end

    function Timeline:GetProgress()
        if self.Duration == 0 then return 1 end
        return math.min(self.CurrentTime / self.Duration, 1)
    end

    function Timeline:GetSpeed()
        return self.PlaybackSpeed
    end

    function Timeline:GetCurrentLoop()
        return self.CurrentLoop
    end

    function Timeline:GetEntryCount()
        return #self.Entries
    end

    function Timeline:GetLabelTime(label)
        return self.Labels[label]
    end

    function Timeline:GetLabels()
        local labels = {}
        for label, time in pairs(self.Labels) do
            table.insert(labels, { Label = label, Time = time })
        end
        table.sort(labels, function(a, b) return a.Time < b.Time end)
        return labels
    end

    --// Await
    function Timeline:Await()
        while self.State == TimelineState.Playing or self.State == TimelineState.Paused do
            task.wait()
        end
        return self
    end

    --// Reverse Playback
    function Timeline:Reverse()
        self.PlaybackSpeed = -self.PlaybackSpeed
        return self
    end

    --// Export State
    Timeline.State = TimelineState

    return Timeline


end


-- ============================================================================
-- Module: NexusUI/Animation/Keyframes
-- ============================================================================
NexusUI_Modules["NexusUI/Animation/Keyframes"] = function()
    local script = CreateMockScript("NexusUI/Animation/Keyframes")
    
    --[[
        NexusUI Keyframe Animation
        CSS-like keyframe animations

        Features:
        - Define keyframes at percentages (0-100)
        - Multiple property animations
        - Custom easing per keyframe
        - Loop and direction control
    ]]

    --// Keyframes Module
    local Keyframes = {}
    Keyframes.__index = Keyframes
    Keyframes.ClassName = "KeyframeAnimation"

    --// Dependencies
    local EasingFunctions = nil

    local function GetEasing(name)
        if not EasingFunctions then
            local easingModule = script.Parent:FindFirstChild("EasingFunctions")
            if easingModule then
                EasingFunctions = require(easingModule)
            end
        end

        if EasingFunctions and EasingFunctions[name] then
            return EasingFunctions[name]
        end

        return function(t) return t end
    end

    --// Keyframe State
    local KeyframeState = {
        Pending = "Pending",
        Playing = "Playing",
        Paused = "Paused",
        Completed = "Completed",
        Cancelled = "Cancelled",
    }

    --// Direction
    local Direction = {
        Normal = "Normal",
        Reverse = "Reverse",
        Alternate = "Alternate",
        AlternateReverse = "AlternateReverse",
    }

    --// Keyframe ID Counter
    local KeyframeIdCounter = 0

    local function GenerateKeyframeId()
        KeyframeIdCounter = KeyframeIdCounter + 1
        return "keyframe_" .. KeyframeIdCounter
    end

    --// Value Interpolation
    local function LerpValue(a, b, t)
        local valueType = typeof(a)

        if valueType == "number" then
            return a + (b - a) * t
        elseif valueType == "Color3" then
            return Color3.new(
                a.R + (b.R - a.R) * t,
                a.G + (b.G - a.G) * t,
                a.B + (b.B - a.B) * t
            )
        elseif valueType == "Vector2" then
            return Vector2.new(
                a.X + (b.X - a.X) * t,
                a.Y + (b.Y - a.Y) * t
            )
        elseif valueType == "Vector3" then
            return Vector3.new(
                a.X + (b.X - a.X) * t,
                a.Y + (b.Y - a.Y) * t,
                a.Z + (b.Z - a.Z) * t
            )
        elseif valueType == "UDim" then
            return UDim.new(
                a.Scale + (b.Scale - a.Scale) * t,
                a.Offset + (b.Offset - a.Offset) * t
            )
        elseif valueType == "UDim2" then
            return UDim2.new(
                a.X.Scale + (b.X.Scale - a.X.Scale) * t,
                a.X.Offset + (b.X.Offset - a.X.Offset) * t,
                a.Y.Scale + (b.Y.Scale - a.Y.Scale) * t,
                a.Y.Offset + (b.Y.Offset - a.Y.Offset) * t
            )
        elseif valueType == "CFrame" then
            return a:Lerp(b, t)
        end

        return t >= 0.5 and b or a
    end

    --// Keyframe Definition
    local KeyframeDefinition = {}
    KeyframeDefinition.__index = KeyframeDefinition

    function KeyframeDefinition.new()
        local self = setmetatable({}, KeyframeDefinition)

        self.Frames = {} -- { Percentage, Properties, Easing }

        return self
    end

    function KeyframeDefinition:At(percentage, properties, easing)
        percentage = math.max(0, math.min(100, percentage))

        table.insert(self.Frames, {
            Percentage = percentage,
            Properties = properties,
            Easing = easing or "Linear",
        })

        -- Sort frames by percentage
        table.sort(self.Frames, function(a, b)
            return a.Percentage < b.Percentage
        end)

        return self
    end

    function KeyframeDefinition:From(properties, easing)
        return self:At(0, properties, easing)
    end

    function KeyframeDefinition:To(properties, easing)
        return self:At(100, properties, easing)
    end

    function KeyframeDefinition:GetFrameAt(percentage)
        -- Find the two frames to interpolate between
        local prevFrame = nil
        local nextFrame = nil

        for _, frame in ipairs(self.Frames) do
            if frame.Percentage <= percentage then
                prevFrame = frame
            end
            if frame.Percentage >= percentage and not nextFrame then
                nextFrame = frame
            end
        end

        return prevFrame, nextFrame
    end

    function KeyframeDefinition:GetValueAt(percentage, property)
        local prevFrame, nextFrame = self:GetFrameAt(percentage)

        if not prevFrame and not nextFrame then
            return nil
        end

        if not prevFrame then
            return nextFrame.Properties[property]
        end

        if not nextFrame or prevFrame == nextFrame then
            return prevFrame.Properties[property]
        end

        local prevValue = prevFrame.Properties[property]
        local nextValue = nextFrame.Properties[property]

        if prevValue == nil or nextValue == nil then
            return prevValue or nextValue
        end

        -- Calculate local progress between frames
        local range = nextFrame.Percentage - prevFrame.Percentage
        local localProgress = (percentage - prevFrame.Percentage) / range

        -- Apply easing
        local easingFunc = GetEasing(nextFrame.Easing or "Linear")
        local easedProgress = easingFunc(localProgress)

        return LerpValue(prevValue, nextValue, easedProgress)
    end

    function KeyframeDefinition:GetAllProperties()
        local properties = {}

        for _, frame in ipairs(self.Frames) do
            for prop, _ in pairs(frame.Properties) do
                properties[prop] = true
            end
        end

        local result = {}
        for prop, _ in pairs(properties) do
            table.insert(result, prop)
        end

        return result
    end

    --// Keyframe Animation Class
    function Keyframes.new(target, keyframes, config)
        local self = setmetatable({}, Keyframes)

        self.Id = GenerateKeyframeId()
        self.Target = target
        self.KeyframeDefinition = keyframes
        self.Duration = config and config.Duration or 1
        self.Delay = config and config.Delay or 0
        self.Direction = config and config.Direction or Direction.Normal
        self.IterationCount = config and config.IterationCount or 1 -- -1 for infinite
        self.FillMode = config and config.FillMode or "forwards" -- none, forwards, backwards, both

        -- State
        self.State = KeyframeState.Pending
        self.CurrentTime = 0
        self.CurrentIteration = 0
        self.DelayRemaining = self.Delay
        self.CurrentDirection = 1 -- 1 or -1
        self.Connection = nil

        -- Callbacks
        self.OnStart = config and config.OnStart
        self.OnUpdate = config and config.OnUpdate
        self.OnIteration = config and config.OnIteration
        self.OnComplete = config and config.OnComplete

        -- Initialize direction
        if self.Direction == Direction.Reverse or self.Direction == Direction.AlternateReverse then
            self.CurrentDirection = -1
        end

        return self
    end

    function Keyframes:Play()
        if self.State == KeyframeState.Playing then
            return self
        end

        self.State = KeyframeState.Playing

        -- Apply fill mode backwards
        if self.FillMode == "backwards" or self.FillMode == "both" then
            local startPercentage = self.CurrentDirection == 1 and 0 or 100
            self:_applyFrame(startPercentage)
        end

        if self.OnStart then
            pcall(self.OnStart, self)
        end

        self:_startUpdateLoop()

        return self
    end

    function Keyframes:Pause()
        if self.State == KeyframeState.Playing then
            self.State = KeyframeState.Paused
            self:_stopUpdateLoop()
        end
        return self
    end

    function Keyframes:Resume()
        if self.State == KeyframeState.Paused then
            self.State = KeyframeState.Playing
            self:_startUpdateLoop()
        end
        return self
    end

    function Keyframes:Stop()
        self.State = KeyframeState.Cancelled
        self:_stopUpdateLoop()
        return self
    end

    function Keyframes:Cancel()
        return self:Stop()
    end

    function Keyframes:Restart()
        self:Stop()
        self.CurrentTime = 0
        self.CurrentIteration = 0
        self.DelayRemaining = self.Delay

        if self.Direction == Direction.Reverse or self.Direction == Direction.AlternateReverse then
            self.CurrentDirection = -1
        else
            self.CurrentDirection = 1
        end

        self:Play()
        return self
    end

    function Keyframes:_startUpdateLoop()
        if self.Connection then return end

        local RunService = game:GetService("RunService")

        self.Connection = RunService.Heartbeat:Connect(function(deltaTime)
            self:_update(deltaTime)
        end)
    end

    function Keyframes:_stopUpdateLoop()
        if self.Connection then
            self.Connection:Disconnect()
            self.Connection = nil
        end
    end

    function Keyframes:_update(deltaTime)
        if self.State ~= KeyframeState.Playing then
            return
        end

        -- Handle delay
        if self.DelayRemaining > 0 then
            self.DelayRemaining = self.DelayRemaining - deltaTime
            return
        end

        -- Update time
        self.CurrentTime = self.CurrentTime + deltaTime

        -- Calculate progress
        local progress = math.min(self.CurrentTime / self.Duration, 1)

        -- Apply direction
        local percentage
        if self.CurrentDirection == 1 then
            percentage = progress * 100
        else
            percentage = (1 - progress) * 100
        end

        -- Apply frame
        self:_applyFrame(percentage)

        -- Callback
        if self.OnUpdate then
            pcall(self.OnUpdate, percentage, progress, self)
        end

        -- Check for iteration complete
        if progress >= 1 then
            self.CurrentIteration = self.CurrentIteration + 1

            if self.OnIteration then
                pcall(self.OnIteration, self.CurrentIteration, self)
            end

            -- Check if we should continue
            if self.IterationCount == -1 or self.CurrentIteration < self.IterationCount then
                self.CurrentTime = 0

                -- Handle direction change for alternate modes
                if self.Direction == Direction.Alternate or self.Direction == Direction.AlternateReverse then
                    self.CurrentDirection = -self.CurrentDirection
                end
            else
                -- Animation complete
                self.State = KeyframeState.Completed
                self:_stopUpdateLoop()

                -- Apply fill mode forwards
                if self.FillMode == "forwards" or self.FillMode == "both" then
                    local endPercentage = self.CurrentDirection == 1 and 100 or 0
                    self:_applyFrame(endPercentage)
                end

                if self.OnComplete then
                    pcall(self.OnComplete, self)
                end
            end
        end
    end

    function Keyframes:_applyFrame(percentage)
        if not self.Target or not self.KeyframeDefinition then
            return
        end

        local properties = self.KeyframeDefinition:GetAllProperties()

        for _, prop in ipairs(properties) do
            local value = self.KeyframeDefinition:GetValueAt(percentage, prop)

            if value ~= nil then
                pcall(function()
                    self.Target[prop] = value
                end)
            end
        end
    end

    --// Configuration
    function Keyframes:SetDuration(duration)
        self.Duration = duration
        return self
    end

    function Keyframes:SetDelay(delay)
        self.Delay = delay
        self.DelayRemaining = delay
        return self
    end

    function Keyframes:SetDirection(direction)
        self.Direction = direction
        return self
    end

    function Keyframes:SetIterationCount(count)
        self.IterationCount = count
        return self
    end

    function Keyframes:SetFillMode(mode)
        self.FillMode = mode
        return self
    end

    function Keyframes:Then(callback)
        local originalOnComplete = self.OnComplete

        self.OnComplete = function(anim)
            if originalOnComplete then
                originalOnComplete(anim)
            end
            callback(anim)
        end

        return self
    end

    --// State Queries
    function Keyframes:GetState()
        return self.State
    end

    function Keyframes:IsPlaying()
        return self.State == KeyframeState.Playing
    end

    function Keyframes:GetProgress()
        if self.Duration == 0 then return 1 end
        return math.min(self.CurrentTime / self.Duration, 1)
    end

    function Keyframes:GetCurrentIteration()
        return self.CurrentIteration
    end

    function Keyframes:Await()
        while self.State == KeyframeState.Playing or self.State == KeyframeState.Paused do
            task.wait()
        end
        return self
    end

    --// Static Constructor
    function Keyframes.Define()
        return KeyframeDefinition.new()
    end

    function Keyframes.Create(target, keyframes, config)
        return Keyframes.new(target, keyframes, config)
    end

    --// Preset Keyframe Animations
    Keyframes.Presets = {
        FadeIn = function()
            return KeyframeDefinition.new()
                :At(0, { BackgroundTransparency = 1 })
                :At(100, { BackgroundTransparency = 0 }, "QuadOut")
        end,

        FadeOut = function()
            return KeyframeDefinition.new()
                :At(0, { BackgroundTransparency = 0 })
                :At(100, { BackgroundTransparency = 1 }, "QuadIn")
        end,

        Pulse = function()
            return KeyframeDefinition.new()
                :At(0, { Size = UDim2.fromScale(1, 1) })
                :At(50, { Size = UDim2.fromScale(1.1, 1.1) }, "QuadOut")
                :At(100, { Size = UDim2.fromScale(1, 1) }, "QuadIn")
        end,

        Shake = function()
            return KeyframeDefinition.new()
                :At(0, { Rotation = 0 })
                :At(10, { Rotation = -5 })
                :At(20, { Rotation = 5 })
                :At(30, { Rotation = -5 })
                :At(40, { Rotation = 5 })
                :At(50, { Rotation = -3 })
                :At(60, { Rotation = 3 })
                :At(70, { Rotation = -2 })
                :At(80, { Rotation = 2 })
                :At(90, { Rotation = -1 })
                :At(100, { Rotation = 0 })
        end,

        Bounce = function()
            return KeyframeDefinition.new()
                :At(0, { Position = UDim2.fromScale(0.5, 0.5) })
                :At(20, { Position = UDim2.fromScale(0.5, 0.4) }, "QuadOut")
                :At(40, { Position = UDim2.fromScale(0.5, 0.5) }, "BounceOut")
                :At(60, { Position = UDim2.fromScale(0.5, 0.45) }, "QuadOut")
                :At(80, { Position = UDim2.fromScale(0.5, 0.5) }, "BounceOut")
                :At(100, { Position = UDim2.fromScale(0.5, 0.5) })
        end,
    }

    --// Export
    Keyframes.State = KeyframeState
    Keyframes.Direction = Direction

    return Keyframes


end


-- ============================================================================
-- Module: NexusUI/Animation/Tween
-- ============================================================================
NexusUI_Modules["NexusUI/Animation/Tween"] = function()
    local script = CreateMockScript("NexusUI/Animation/Tween")
    
    --[[
        NexusUI Tween System
        Enhanced tweening with advanced features

        Features:
        - Single and multi-property tweens
        - Custom easing functions
        - Tween chaining
        - Event callbacks
        - Pause/Resume support
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")
    local RunService = game:GetService("RunService")

    --// Tween Module
    local Tween = {}
    Tween.__index = Tween
    Tween.ClassName = "NexusTween"

    --// Dependencies
    local EasingFunctions = nil

    local function GetEasing(name)
        if not EasingFunctions then
            local easingModule = script.Parent:FindFirstChild("EasingFunctions")
            if easingModule then
                EasingFunctions = require(easingModule)
            end
        end

        if EasingFunctions and EasingFunctions[name] then
            return EasingFunctions[name]
        end

        return nil
    end

    --// Tween State
    local TweenState = {
        Pending = "Pending",
        Playing = "Playing",
        Paused = "Paused",
        Completed = "Completed",
        Cancelled = "Cancelled",
    }

    --// Active Tweens
    local ActiveTweens = {}
    local TweenIdCounter = 0

    local function GenerateTweenId()
        TweenIdCounter = TweenIdCounter + 1
        return "tween_" .. TweenIdCounter
    end

    --// Value Interpolation
    local function LerpValue(a, b, t)
        local valueType = typeof(a)

        if valueType == "number" then
            return a + (b - a) * t
        elseif valueType == "Color3" then
            return Color3.new(
                a.R + (b.R - a.R) * t,
                a.G + (b.G - a.G) * t,
                a.B + (b.B - a.B) * t
            )
        elseif valueType == "Vector2" then
            return Vector2.new(
                a.X + (b.X - a.X) * t,
                a.Y + (b.Y - a.Y) * t
            )
        elseif valueType == "Vector3" then
            return Vector3.new(
                a.X + (b.X - a.X) * t,
                a.Y + (b.Y - a.Y) * t,
                a.Z + (b.Z - a.Z) * t
            )
        elseif valueType == "UDim" then
            return UDim.new(
                a.Scale + (b.Scale - a.Scale) * t,
                a.Offset + (b.Offset - a.Offset) * t
            )
        elseif valueType == "UDim2" then
            return UDim2.new(
                a.X.Scale + (b.X.Scale - a.X.Scale) * t,
                a.X.Offset + (b.X.Offset - a.X.Offset) * t,
                a.Y.Scale + (b.Y.Scale - a.Y.Scale) * t,
                a.Y.Offset + (b.Y.Offset - a.Y.Offset) * t
            )
        elseif valueType == "CFrame" then
            return a:Lerp(b, t)
        elseif valueType == "Rect" then
            return Rect.new(
                LerpValue(a.Min, b.Min, t),
                LerpValue(a.Max, b.Max, t)
            )
        elseif valueType == "NumberRange" then
            return NumberRange.new(
                LerpValue(a.Min, b.Min, t),
                LerpValue(a.Max, b.Max, t)
            )
        elseif valueType == "NumberSequence" then
            -- For NumberSequence, interpolate between first keypoints
            local aVal = a.Keypoints[1].Value
            local bVal = b.Keypoints[1].Value
            return NumberSequence.new(LerpValue(aVal, bVal, t))
        elseif valueType == "ColorSequence" then
            -- For ColorSequence, interpolate between first keypoints
            local aCol = a.Keypoints[1].Value
            local bCol = b.Keypoints[1].Value
            return ColorSequence.new(LerpValue(aCol, bCol, t))
        end

        return t >= 0.5 and b or a
    end

    --// Tween Class
    function Tween.new(target, properties, config)
        local self = setmetatable({}, Tween)

        self.Id = GenerateTweenId()
        self.Target = target
        self.Properties = properties
        self.Duration = config and config.Duration or 0.3
        self.Delay = config and config.Delay or 0
        self.Easing = config and config.Easing or "QuadOut"
        self.EasingFunc = nil
        self.Reversible = config and config.Reversible or false
        self.RepeatCount = config and config.RepeatCount or 0
        self.ReverseOnComplete = config and config.ReverseOnComplete or false

        -- State
        self.State = TweenState.Pending
        self.CurrentTime = 0
        self.DelayRemaining = self.Delay
        self.StartValues = {}
        self.CurrentRepeat = 0
        self.IsReversed = false
        self.Connection = nil

        -- Native tween (for hardware acceleration when possible)
        self.NativeTween = nil
        self.UseNative = config and config.UseNative

        -- Callbacks
        self.OnStart = config and config.OnStart
        self.OnUpdate = config and config.OnUpdate
        self.OnComplete = config and config.OnComplete
        self.OnRepeat = config and config.OnRepeat

        -- Resolve easing
        self:_resolveEasing()

        return self
    end

    function Tween:_resolveEasing()
        if type(self.Easing) == "function" then
            self.EasingFunc = self.Easing
        elseif type(self.Easing) == "string" then
            self.EasingFunc = GetEasing(self.Easing)
        end

        -- Fallback to linear if no easing found
        if not self.EasingFunc then
            self.EasingFunc = function(t) return t end
        end
    end

    function Tween:_captureStartValues()
        self.StartValues = {}

        if self.Target then
            for prop, _ in pairs(self.Properties) do
                pcall(function()
                    self.StartValues[prop] = self.Target[prop]
                end)
            end
        end
    end

    function Tween:Play()
        if self.State == TweenState.Playing then
            return self
        end

        self:_captureStartValues()
        self.State = TweenState.Playing

        if self.OnStart then
            pcall(self.OnStart, self)
        end

        -- Check if we can use native tween
        if self.UseNative ~= false and self:_canUseNative() then
            self:_playNative()
        else
            self:_playCustom()
        end

        return self
    end

    function Tween:_canUseNative()
        -- Check if easing is a Roblox enum
        if type(self.Easing) == "string" then
            local robloxEasings = {
                "Linear", "Quad", "Cubic", "Quart", "Quint",
                "Sine", "Expo", "Circ", "Back", "Elastic", "Bounce",
            }

            for _, name in ipairs(robloxEasings) do
                if self.Easing:find(name) then
                    return true
                end
            end
        end

        return false
    end

    function Tween:_getRobloxTweenInfo()
        local style = Enum.EasingStyle.Quad
        local direction = Enum.EasingDirection.Out

        -- Parse easing name
        local easingName = self.Easing or "QuadOut"

        local styleMap = {
            Linear = Enum.EasingStyle.Linear,
            Quad = Enum.EasingStyle.Quad,
            Cubic = Enum.EasingStyle.Cubic,
            Quart = Enum.EasingStyle.Quart,
            Quint = Enum.EasingStyle.Quint,
            Sine = Enum.EasingStyle.Sine,
            Expo = Enum.EasingStyle.Exponential,
            Circ = Enum.EasingStyle.Circular,
            Back = Enum.EasingStyle.Back,
            Elastic = Enum.EasingStyle.Elastic,
            Bounce = Enum.EasingStyle.Bounce,
        }

        for name, enumStyle in pairs(styleMap) do
            if easingName:find(name) then
                style = enumStyle
                break
            end
        end

        if easingName:find("In") then
            if easingName:find("Out") then
                direction = Enum.EasingDirection.InOut
            else
                direction = Enum.EasingDirection.In
            end
        elseif easingName:find("Out") then
            direction = Enum.EasingDirection.Out
        end

        return TweenInfo.new(
            self.Duration,
            style,
            direction,
            self.RepeatCount,
            self.ReverseOnComplete,
            self.Delay
        )
    end

    function Tween:_playNative()
        local tweenInfo = self:_getRobloxTweenInfo()

        self.NativeTween = TweenService:Create(self.Target, tweenInfo, self.Properties)

        self.NativeTween.Completed:Connect(function(playbackState)
            if playbackState == Enum.PlaybackState.Completed then
                self.State = TweenState.Completed

                if self.OnComplete then
                    pcall(self.OnComplete, self)
                end
            elseif playbackState == Enum.PlaybackState.Cancelled then
                self.State = TweenState.Cancelled
            end

            ActiveTweens[self.Id] = nil
        end)

        ActiveTweens[self.Id] = self
        self.NativeTween:Play()
    end

    function Tween:_playCustom()
        ActiveTweens[self.Id] = self

        self.Connection = RunService.Heartbeat:Connect(function(deltaTime)
            self:_update(deltaTime)
        end)
    end

    function Tween:_update(deltaTime)
        if self.State ~= TweenState.Playing then
            return
        end

        -- Handle delay
        if self.DelayRemaining > 0 then
            self.DelayRemaining = self.DelayRemaining - deltaTime
            return
        end

        -- Update time
        self.CurrentTime = self.CurrentTime + deltaTime

        -- Calculate progress
        local rawProgress = math.min(self.CurrentTime / self.Duration, 1)
        local progress = self.IsReversed and (1 - rawProgress) or rawProgress
        local easedProgress = self.EasingFunc(progress)

        -- Apply values
        if self.Target then
            for prop, endValue in pairs(self.Properties) do
                local startValue = self.StartValues[prop]

                if startValue ~= nil then
                    local currentValue = LerpValue(startValue, endValue, easedProgress)

                    pcall(function()
                        self.Target[prop] = currentValue
                    end)
                end
            end
        end

        -- Callback
        if self.OnUpdate then
            pcall(self.OnUpdate, easedProgress, rawProgress, self)
        end

        -- Check for completion
        if rawProgress >= 1 then
            self:_onComplete()
        end
    end

    function Tween:_onComplete()
        -- Handle repeating
        if self.RepeatCount == -1 or self.CurrentRepeat < self.RepeatCount then
            self.CurrentRepeat = self.CurrentRepeat + 1
            self.CurrentTime = 0

            if self.ReverseOnComplete then
                self.IsReversed = not self.IsReversed
            end

            if self.OnRepeat then
                pcall(self.OnRepeat, self.CurrentRepeat, self)
            end

            return
        end

        -- Animation complete
        self.State = TweenState.Completed

        if self.Connection then
            self.Connection:Disconnect()
            self.Connection = nil
        end

        ActiveTweens[self.Id] = nil

        if self.OnComplete then
            pcall(self.OnComplete, self)
        end
    end

    function Tween:Pause()
        if self.State == TweenState.Playing then
            self.State = TweenState.Paused

            if self.NativeTween then
                self.NativeTween:Pause()
            end

            if self.Connection then
                self.Connection:Disconnect()
                self.Connection = nil
            end
        end

        return self
    end

    function Tween:Resume()
        if self.State == TweenState.Paused then
            self.State = TweenState.Playing

            if self.NativeTween then
                self.NativeTween:Play()
            else
                self.Connection = RunService.Heartbeat:Connect(function(deltaTime)
                    self:_update(deltaTime)
                end)
            end
        end

        return self
    end

    function Tween:Stop()
        self.State = TweenState.Cancelled

        if self.NativeTween then
            self.NativeTween:Cancel()
        end

        if self.Connection then
            self.Connection:Disconnect()
            self.Connection = nil
        end

        ActiveTweens[self.Id] = nil

        return self
    end

    function Tween:Cancel()
        return self:Stop()
    end

    function Tween:Reverse()
        if self.Reversible then
            self.IsReversed = not self.IsReversed
        end
        return self
    end

    function Tween:Then(callback)
        local originalOnComplete = self.OnComplete

        self.OnComplete = function(tween)
            if originalOnComplete then
                originalOnComplete(tween)
            end
            callback(tween)
        end

        return self
    end

    function Tween:Chain(nextTween)
        return self:Then(function()
            nextTween:Play()
        end)
    end

    --// State Queries
    function Tween:GetState()
        return self.State
    end

    function Tween:IsPlaying()
        return self.State == TweenState.Playing
    end

    function Tween:IsPaused()
        return self.State == TweenState.Paused
    end

    function Tween:IsComplete()
        return self.State == TweenState.Completed
    end

    function Tween:GetProgress()
        if self.Duration == 0 then return 1 end
        return math.min(self.CurrentTime / self.Duration, 1)
    end

    function Tween:Await()
        while self.State == TweenState.Playing or self.State == TweenState.Paused do
            task.wait()
        end
        return self
    end

    --// Static Methods
    function Tween.To(target, properties, duration, easing)
        return Tween.new(target, properties, {
            Duration = duration or 0.3,
            Easing = easing or "QuadOut",
        }):Play()
    end

    function Tween.From(target, properties, duration, easing)
        -- Capture current values as end values
        local endValues = {}
        for prop, _ in pairs(properties) do
            pcall(function()
                endValues[prop] = target[prop]
            end)
        end

        -- Set target to start values immediately
        for prop, value in pairs(properties) do
            pcall(function()
                target[prop] = value
            end)
        end

        return Tween.new(target, endValues, {
            Duration = duration or 0.3,
            Easing = easing or "QuadOut",
        }):Play()
    end

    function Tween.FromTo(target, fromProperties, toProperties, duration, easing)
        -- Set start values
        for prop, value in pairs(fromProperties) do
            pcall(function()
                target[prop] = value
            end)
        end

        return Tween.new(target, toProperties, {
            Duration = duration or 0.3,
            Easing = easing or "QuadOut",
        }):Play()
    end

    --// Global Management
    function Tween.CancelAll()
        for id, tween in pairs(ActiveTweens) do
            tween:Cancel()
        end
        ActiveTweens = {}
    end

    function Tween.CancelTweensOf(target)
        for id, tween in pairs(ActiveTweens) do
            if tween.Target == target then
                tween:Cancel()
            end
        end
    end

    function Tween.GetTweensOf(target)
        local tweens = {}
        for id, tween in pairs(ActiveTweens) do
            if tween.Target == target then
                table.insert(tweens, tween)
            end
        end
        return tweens
    end

    function Tween.GetActiveCount()
        local count = 0
        for _ in pairs(ActiveTweens) do
            count = count + 1
        end
        return count
    end

    --// Export
    Tween.State = TweenState

    return Tween


end


-- ============================================================================
-- Module: NexusUI/Animation/Parallel
-- ============================================================================
NexusUI_Modules["NexusUI/Animation/Parallel"] = function()
    local script = CreateMockScript("NexusUI/Animation/Parallel")
    
    --[[
        NexusUI Parallel Animation
        Run multiple animations simultaneously

        Features:
        - Execute animations in parallel
        - Wait for all to complete
        - Staggered starts
        - Group control (pause/stop all)
    ]]

    --// Parallel Module
    local Parallel = {}
    Parallel.__index = Parallel
    Parallel.ClassName = "ParallelAnimation"

    --// Parallel State
    local ParallelState = {
        Pending = "Pending",
        Playing = "Playing",
        Paused = "Paused",
        Completed = "Completed",
        Cancelled = "Cancelled",
    }

    --// ID Counter
    local ParallelIdCounter = 0

    local function GenerateParallelId()
        ParallelIdCounter = ParallelIdCounter + 1
        return "parallel_" .. ParallelIdCounter
    end

    --// Parallel Class
    function Parallel.new(...)
        local self = setmetatable({}, Parallel)

        self.Id = GenerateParallelId()
        self.Animations = {}
        self.State = ParallelState.Pending
        self.CompletedCount = 0
        self.StaggerDelay = 0

        -- Callbacks
        self.OnStart = nil
        self.OnAnimationComplete = nil
        self.OnComplete = nil

        -- Add initial animations
        local animations = {...}
        for _, anim in ipairs(animations) do
            self:Add(anim)
        end

        return self
    end

    --// Adding Animations
    function Parallel:Add(animation)
        table.insert(self.Animations, {
            Animation = animation,
            Completed = false,
            Started = false,
        })
        return self
    end

    function Parallel:AddAll(animations)
        for _, anim in ipairs(animations) do
            self:Add(anim)
        end
        return self
    end

    --// Configuration
    function Parallel:SetStagger(delay)
        self.StaggerDelay = delay
        return self
    end

    function Parallel:SetOnStart(callback)
        self.OnStart = callback
        return self
    end

    function Parallel:SetOnAnimationComplete(callback)
        self.OnAnimationComplete = callback
        return self
    end

    function Parallel:SetOnComplete(callback)
        self.OnComplete = callback
        return self
    end

    --// Playback
    function Parallel:Play()
        if self.State == ParallelState.Playing then
            return self
        end

        self.State = ParallelState.Playing
        self.CompletedCount = 0

        if self.OnStart then
            pcall(self.OnStart, self)
        end

        -- Start all animations
        for i, entry in ipairs(self.Animations) do
            local animation = entry.Animation

            -- Handle stagger delay
            local delay = (i - 1) * self.StaggerDelay

            if delay > 0 then
                task.delay(delay, function()
                    if self.State == ParallelState.Playing then
                        self:_startAnimation(entry, i)
                    end
                end)
            else
                self:_startAnimation(entry, i)
            end
        end

        return self
    end

    function Parallel:_startAnimation(entry, index)
        local animation = entry.Animation

        -- Set up completion handler
        local originalOnComplete = animation.OnComplete

        animation.OnComplete = function(...)
            if originalOnComplete then
                originalOnComplete(...)
            end

            entry.Completed = true
            self.CompletedCount = self.CompletedCount + 1

            if self.OnAnimationComplete then
                pcall(self.OnAnimationComplete, animation, index, self)
            end

            -- Check if all complete
            if self.CompletedCount >= #self.Animations then
                self.State = ParallelState.Completed

                if self.OnComplete then
                    pcall(self.OnComplete, self)
                end
            end
        end

        entry.Started = true

        -- Play animation
        if animation.Play then
            animation:Play()
        elseif animation.Start then
            animation:Start()
        end
    end

    function Parallel:Pause()
        if self.State == ParallelState.Playing then
            self.State = ParallelState.Paused

            for _, entry in ipairs(self.Animations) do
                if entry.Started and not entry.Completed then
                    if entry.Animation.Pause then
                        entry.Animation:Pause()
                    end
                end
            end
        end

        return self
    end

    function Parallel:Resume()
        if self.State == ParallelState.Paused then
            self.State = ParallelState.Playing

            for _, entry in ipairs(self.Animations) do
                if entry.Started and not entry.Completed then
                    if entry.Animation.Resume then
                        entry.Animation:Resume()
                    end
                end
            end
        end

        return self
    end

    function Parallel:Stop()
        self.State = ParallelState.Cancelled

        for _, entry in ipairs(self.Animations) do
            if entry.Started and not entry.Completed then
                if entry.Animation.Stop then
                    entry.Animation:Stop()
                elseif entry.Animation.Cancel then
                    entry.Animation:Cancel()
                end
            end
        end

        return self
    end

    function Parallel:Cancel()
        return self:Stop()
    end

    function Parallel:Restart()
        self:Stop()

        -- Reset all entries
        for _, entry in ipairs(self.Animations) do
            entry.Started = false
            entry.Completed = false
        end

        self:Play()

        return self
    end

    --// Chaining
    function Parallel:Then(callback)
        local originalOnComplete = self.OnComplete

        self.OnComplete = function(parallel)
            if originalOnComplete then
                originalOnComplete(parallel)
            end
            callback(parallel)
        end

        return self
    end

    --// State Queries
    function Parallel:GetState()
        return self.State
    end

    function Parallel:IsPlaying()
        return self.State == ParallelState.Playing
    end

    function Parallel:IsPaused()
        return self.State == ParallelState.Paused
    end

    function Parallel:IsComplete()
        return self.State == ParallelState.Completed
    end

    function Parallel:GetProgress()
        if #self.Animations == 0 then return 1 end
        return self.CompletedCount / #self.Animations
    end

    function Parallel:GetCompletedCount()
        return self.CompletedCount
    end

    function Parallel:GetAnimationCount()
        return #self.Animations
    end

    function Parallel:Await()
        while self.State == ParallelState.Playing or self.State == ParallelState.Paused do
            task.wait()
        end
        return self
    end

    --// Static Constructor
    function Parallel.All(...)
        return Parallel.new(...):Play()
    end

    function Parallel.AllStaggered(animations, staggerDelay)
        local parallel = Parallel.new()
        parallel:AddAll(animations)
        parallel:SetStagger(staggerDelay or 0.05)
        return parallel:Play()
    end

    --// Export
    Parallel.State = ParallelState

    return Parallel


end


-- ============================================================================
-- Module: NexusUI/Animation/Morph
-- ============================================================================
NexusUI_Modules["NexusUI/Animation/Morph"] = function()
    local script = CreateMockScript("NexusUI/Animation/Morph")
    
    --[[
        NexusUI Morph Animation
        Smooth morphing between UI states

        Features:
        - State-based morphing
        - Complex property transitions
        - Snapshot and restore
        - Interpolation between layouts
    ]]

    --// Morph Module
    local Morph = {}
    Morph.__index = Morph
    Morph.ClassName = "MorphAnimation"

    --// Dependencies
    local EasingFunctions = nil

    local function GetEasing(name)
        if not EasingFunctions then
            local easingModule = script.Parent:FindFirstChild("EasingFunctions")
            if easingModule then
                EasingFunctions = require(easingModule)
            end
        end

        if EasingFunctions and EasingFunctions[name] then
            return EasingFunctions[name]
        end

        return function(t) return t end
    end

    --// Morph State
    local MorphState = {
        Pending = "Pending",
        Morphing = "Morphing",
        Paused = "Paused",
        Completed = "Completed",
        Cancelled = "Cancelled",
    }

    --// ID Counter
    local MorphIdCounter = 0

    local function GenerateMorphId()
        MorphIdCounter = MorphIdCounter + 1
        return "morph_" .. MorphIdCounter
    end

    --// Properties to capture
    local CaptureProperties = {
        "Position",
        "Size",
        "AnchorPoint",
        "Rotation",
        "BackgroundColor3",
        "BackgroundTransparency",
        "BorderColor3",
        "BorderSizePixel",
        "Visible",
        "ZIndex",
    }

    local TextProperties = {
        "Text",
        "TextColor3",
        "TextTransparency",
        "TextSize",
        "Font",
    }

    local ImageProperties = {
        "Image",
        "ImageColor3",
        "ImageTransparency",
        "ImageRectOffset",
        "ImageRectSize",
    }

    --// Value Interpolation
    local function CanInterpolate(value)
        local valueType = typeof(value)
        return valueType == "number" or
               valueType == "Color3" or
               valueType == "Vector2" or
               valueType == "Vector3" or
               valueType == "UDim" or
               valueType == "UDim2" or
               valueType == "CFrame"
    end

    local function LerpValue(a, b, t)
        local valueType = typeof(a)

        if valueType == "number" then
            return a + (b - a) * t
        elseif valueType == "Color3" then
            return Color3.new(
                a.R + (b.R - a.R) * t,
                a.G + (b.G - a.G) * t,
                a.B + (b.B - a.B) * t
            )
        elseif valueType == "Vector2" then
            return Vector2.new(
                a.X + (b.X - a.X) * t,
                a.Y + (b.Y - a.Y) * t
            )
        elseif valueType == "Vector3" then
            return Vector3.new(
                a.X + (b.X - a.X) * t,
                a.Y + (b.Y - a.Y) * t,
                a.Z + (b.Z - a.Z) * t
            )
        elseif valueType == "UDim" then
            return UDim.new(
                a.Scale + (b.Scale - a.Scale) * t,
                a.Offset + (b.Offset - a.Offset) * t
            )
        elseif valueType == "UDim2" then
            return UDim2.new(
                a.X.Scale + (b.X.Scale - a.X.Scale) * t,
                a.X.Offset + (b.X.Offset - a.X.Offset) * t,
                a.Y.Scale + (b.Y.Scale - a.Y.Scale) * t,
                a.Y.Offset + (b.Y.Offset - a.Y.Offset) * t
            )
        elseif valueType == "CFrame" then
            return a:Lerp(b, t)
        end

        return t >= 0.5 and b or a
    end

    --// Snapshot
    local Snapshot = {}
    Snapshot.__index = Snapshot

    function Snapshot.new(target)
        local self = setmetatable({}, Snapshot)

        self.Target = target
        self.Properties = {}
        self.Children = {}

        return self
    end

    function Snapshot:Capture()
        if not self.Target then return self end

        -- Get all relevant properties
        local propsToCapture = {unpack(CaptureProperties)}

        if self.Target:IsA("TextLabel") or self.Target:IsA("TextButton") or self.Target:IsA("TextBox") then
            for _, prop in ipairs(TextProperties) do
                table.insert(propsToCapture, prop)
            end
        end

        if self.Target:IsA("ImageLabel") or self.Target:IsA("ImageButton") then
            for _, prop in ipairs(ImageProperties) do
                table.insert(propsToCapture, prop)
            end
        end

        -- Capture properties
        for _, prop in ipairs(propsToCapture) do
            pcall(function()
                self.Properties[prop] = self.Target[prop]
            end)
        end

        -- Capture children recursively
        for _, child in ipairs(self.Target:GetChildren()) do
            if child:IsA("GuiObject") then
                local childSnapshot = Snapshot.new(child)
                childSnapshot:Capture()
                self.Children[child.Name] = childSnapshot
            end
        end

        return self
    end

    function Snapshot:Apply(alpha)
        alpha = alpha or 1

        for prop, value in pairs(self.Properties) do
            if alpha >= 1 then
                pcall(function()
                    self.Target[prop] = value
                end)
            end
        end

        return self
    end

    --// Morph Class
    function Morph.new(target, config)
        local self = setmetatable({}, Morph)

        self.Id = GenerateMorphId()
        self.Target = target
        self.Duration = config and config.Duration or 0.5
        self.Easing = config and config.Easing or "QuadInOut"
        self.EasingFunc = GetEasing(self.Easing)

        -- State
        self.State = MorphState.Pending
        self.FromSnapshot = nil
        self.ToSnapshot = nil
        self.CurrentTime = 0
        self.Connection = nil

        -- Named states
        self.States = {}
        self.CurrentState = nil

        -- Callbacks
        self.OnStart = config and config.OnStart
        self.OnUpdate = config and config.OnUpdate
        self.OnComplete = config and config.OnComplete

        return self
    end

    --// State Management
    function Morph:SaveState(stateName)
        local snapshot = Snapshot.new(self.Target)
        snapshot:Capture()
        self.States[stateName] = snapshot
        return self
    end

    function Morph:RemoveState(stateName)
        self.States[stateName] = nil
        return self
    end

    function Morph:HasState(stateName)
        return self.States[stateName] ~= nil
    end

    function Morph:GetStateNames()
        local names = {}
        for name, _ in pairs(self.States) do
            table.insert(names, name)
        end
        return names
    end

    --// Morphing
    function Morph:MorphTo(targetState, duration, easing)
        local toSnapshot

        if type(targetState) == "string" then
            toSnapshot = self.States[targetState]
            if not toSnapshot then
                warn("Morph state not found:", targetState)
                return self
            end
        elseif type(targetState) == "table" then
            -- Direct properties table
            toSnapshot = Snapshot.new(self.Target)
            toSnapshot.Properties = targetState
        end

        -- Capture current state as from
        self.FromSnapshot = Snapshot.new(self.Target)
        self.FromSnapshot:Capture()
        self.ToSnapshot = toSnapshot

        -- Override duration/easing if provided
        if duration then self.Duration = duration end
        if easing then
            self.Easing = easing
            self.EasingFunc = GetEasing(easing)
        end

        return self:Play()
    end

    function Morph:MorphBetween(fromState, toState, duration, easing)
        local fromSnapshot, toSnapshot

        if type(fromState) == "string" then
            fromSnapshot = self.States[fromState]
        elseif type(fromState) == "table" then
            fromSnapshot = Snapshot.new(self.Target)
            fromSnapshot.Properties = fromState
        end

        if type(toState) == "string" then
            toSnapshot = self.States[toState]
        elseif type(toState) == "table" then
            toSnapshot = Snapshot.new(self.Target)
            toSnapshot.Properties = toState
        end

        if not fromSnapshot or not toSnapshot then
            warn("Invalid morph states")
            return self
        end

        self.FromSnapshot = fromSnapshot
        self.ToSnapshot = toSnapshot

        if duration then self.Duration = duration end
        if easing then
            self.Easing = easing
            self.EasingFunc = GetEasing(easing)
        end

        -- Apply from state immediately
        fromSnapshot:Apply()

        return self:Play()
    end

    function Morph:Play()
        if self.State == MorphState.Morphing then
            return self
        end

        if not self.FromSnapshot or not self.ToSnapshot then
            -- Use current state as from if not set
            if not self.FromSnapshot then
                self.FromSnapshot = Snapshot.new(self.Target)
                self.FromSnapshot:Capture()
            end

            if not self.ToSnapshot then
                warn("No target state set for morph")
                return self
            end
        end

        self.State = MorphState.Morphing
        self.CurrentTime = 0

        if self.OnStart then
            pcall(self.OnStart, self)
        end

        self:_startUpdateLoop()

        return self
    end

    function Morph:_startUpdateLoop()
        if self.Connection then return end

        local RunService = game:GetService("RunService")

        self.Connection = RunService.Heartbeat:Connect(function(deltaTime)
            self:_update(deltaTime)
        end)
    end

    function Morph:_stopUpdateLoop()
        if self.Connection then
            self.Connection:Disconnect()
            self.Connection = nil
        end
    end

    function Morph:_update(deltaTime)
        if self.State ~= MorphState.Morphing then
            return
        end

        self.CurrentTime = self.CurrentTime + deltaTime
        local progress = math.min(self.CurrentTime / self.Duration, 1)
        local easedProgress = self.EasingFunc(progress)

        -- Interpolate all properties
        self:_applyMorph(easedProgress)

        if self.OnUpdate then
            pcall(self.OnUpdate, easedProgress, progress, self)
        end

        if progress >= 1 then
            self.State = MorphState.Completed
            self:_stopUpdateLoop()

            if self.OnComplete then
                pcall(self.OnComplete, self)
            end
        end
    end

    function Morph:_applyMorph(t)
        if not self.Target or not self.FromSnapshot or not self.ToSnapshot then
            return
        end

        local fromProps = self.FromSnapshot.Properties
        local toProps = self.ToSnapshot.Properties

        -- Interpolate each property
        for prop, toValue in pairs(toProps) do
            local fromValue = fromProps[prop]

            if fromValue ~= nil and CanInterpolate(fromValue) then
                local interpolated = LerpValue(fromValue, toValue, t)

                pcall(function()
                    self.Target[prop] = interpolated
                end)
            elseif t >= 0.5 then
                -- For non-interpolable values, switch at midpoint
                pcall(function()
                    self.Target[prop] = toValue
                end)
            end
        end
    end

    function Morph:Pause()
        if self.State == MorphState.Morphing then
            self.State = MorphState.Paused
            self:_stopUpdateLoop()
        end
        return self
    end

    function Morph:Resume()
        if self.State == MorphState.Paused then
            self.State = MorphState.Morphing
            self:_startUpdateLoop()
        end
        return self
    end

    function Morph:Stop()
        self.State = MorphState.Cancelled
        self:_stopUpdateLoop()
        return self
    end

    function Morph:Cancel()
        return self:Stop()
    end

    --// Chaining
    function Morph:Then(callback)
        local originalOnComplete = self.OnComplete

        self.OnComplete = function(morph)
            if originalOnComplete then
                originalOnComplete(morph)
            end
            callback(morph)
        end

        return self
    end

    --// State Queries
    function Morph:GetState()
        return self.State
    end

    function Morph:IsMorphing()
        return self.State == MorphState.Morphing
    end

    function Morph:GetProgress()
        if self.Duration == 0 then return 1 end
        return math.min(self.CurrentTime / self.Duration, 1)
    end

    function Morph:Await()
        while self.State == MorphState.Morphing or self.State == MorphState.Paused do
            task.wait()
        end
        return self
    end

    --// Static Methods
    function Morph.CreateSnapshot(target)
        local snapshot = Snapshot.new(target)
        return snapshot:Capture()
    end

    function Morph.To(target, properties, duration, easing)
        local morph = Morph.new(target, {
            Duration = duration or 0.5,
            Easing = easing or "QuadInOut",
        })

        return morph:MorphTo(properties)
    end

    --// Export
    Morph.State = MorphState
    Morph.Snapshot = Snapshot

    return Morph


end


-- ============================================================================
-- Module: NexusUI/Animation/Transition
-- ============================================================================
NexusUI_Modules["NexusUI/Animation/Transition"] = function()
    local script = CreateMockScript("NexusUI/Animation/Transition")
    
    --[[
        NexusUI Transition System
        Pre-built transitions for common UI animations

        Features:
        - Fade transitions
        - Slide transitions
        - Scale transitions
        - Combinations
        - Custom transition builder
    ]]

    --// Transition Module
    local Transition = {}
    Transition.ClassName = "Transition"

    --// Dependencies
    local Tween = nil
    local Parallel = nil

    local function GetTween()
        if not Tween then
            local tweenModule = script.Parent:FindFirstChild("Tween")
            if tweenModule then
                Tween = require(tweenModule)
            end
        end
        return Tween
    end

    local function GetParallel()
        if not Parallel then
            local parallelModule = script.Parent:FindFirstChild("Parallel")
            if parallelModule then
                Parallel = require(parallelModule)
            end
        end
        return Parallel
    end

    --// Transition Config
    local DefaultConfig = {
        Duration = 0.3,
        Easing = "QuadOut",
        Delay = 0,
    }

    local function MergeConfig(config)
        local merged = {}
        for k, v in pairs(DefaultConfig) do
            merged[k] = v
        end
        if config then
            for k, v in pairs(config) do
                merged[k] = v
            end
        end
        return merged
    end

    --// Fade Transitions
    Transition.Fade = {}

    function Transition.Fade.In(target, config)
        config = MergeConfig(config)

        target.BackgroundTransparency = 1
        target.Visible = true

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                BackgroundTransparency = 0,
            }, config):Play()
        end
    end

    function Transition.Fade.Out(target, config)
        config = MergeConfig(config)

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                BackgroundTransparency = 1,
            }, {
                Duration = config.Duration,
                Easing = config.Easing,
                Delay = config.Delay,
                OnComplete = function()
                    target.Visible = false
                end,
            }):Play()
        end
    end

    function Transition.Fade.InOut(target, duration, holdTime, config)
        config = MergeConfig(config)
        holdTime = holdTime or 1

        Transition.Fade.In(target, config):Then(function()
            task.wait(holdTime)
            Transition.Fade.Out(target, config)
        end)
    end

    --// Slide Transitions
    Transition.Slide = {}

    function Transition.Slide.FromLeft(target, config)
        config = MergeConfig(config)

        local originalPosition = target.Position
        target.Position = UDim2.new(originalPosition.X.Scale - 1, originalPosition.X.Offset, originalPosition.Y.Scale, originalPosition.Y.Offset)
        target.Visible = true

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                Position = originalPosition,
            }, config):Play()
        end
    end

    function Transition.Slide.FromRight(target, config)
        config = MergeConfig(config)

        local originalPosition = target.Position
        target.Position = UDim2.new(originalPosition.X.Scale + 1, originalPosition.X.Offset, originalPosition.Y.Scale, originalPosition.Y.Offset)
        target.Visible = true

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                Position = originalPosition,
            }, config):Play()
        end
    end

    function Transition.Slide.FromTop(target, config)
        config = MergeConfig(config)

        local originalPosition = target.Position
        target.Position = UDim2.new(originalPosition.X.Scale, originalPosition.X.Offset, originalPosition.Y.Scale - 1, originalPosition.Y.Offset)
        target.Visible = true

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                Position = originalPosition,
            }, config):Play()
        end
    end

    function Transition.Slide.FromBottom(target, config)
        config = MergeConfig(config)

        local originalPosition = target.Position
        target.Position = UDim2.new(originalPosition.X.Scale, originalPosition.X.Offset, originalPosition.Y.Scale + 1, originalPosition.Y.Offset)
        target.Visible = true

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                Position = originalPosition,
            }, config):Play()
        end
    end

    function Transition.Slide.ToLeft(target, config)
        config = MergeConfig(config)

        local originalPosition = target.Position

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                Position = UDim2.new(originalPosition.X.Scale - 1, originalPosition.X.Offset, originalPosition.Y.Scale, originalPosition.Y.Offset),
            }, {
                Duration = config.Duration,
                Easing = config.Easing,
                Delay = config.Delay,
                OnComplete = function()
                    target.Visible = false
                    target.Position = originalPosition
                end,
            }):Play()
        end
    end

    function Transition.Slide.ToRight(target, config)
        config = MergeConfig(config)

        local originalPosition = target.Position

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                Position = UDim2.new(originalPosition.X.Scale + 1, originalPosition.X.Offset, originalPosition.Y.Scale, originalPosition.Y.Offset),
            }, {
                Duration = config.Duration,
                Easing = config.Easing,
                Delay = config.Delay,
                OnComplete = function()
                    target.Visible = false
                    target.Position = originalPosition
                end,
            }):Play()
        end
    end

    function Transition.Slide.ToTop(target, config)
        config = MergeConfig(config)

        local originalPosition = target.Position

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                Position = UDim2.new(originalPosition.X.Scale, originalPosition.X.Offset, originalPosition.Y.Scale - 1, originalPosition.Y.Offset),
            }, {
                Duration = config.Duration,
                Easing = config.Easing,
                Delay = config.Delay,
                OnComplete = function()
                    target.Visible = false
                    target.Position = originalPosition
                end,
            }):Play()
        end
    end

    function Transition.Slide.ToBottom(target, config)
        config = MergeConfig(config)

        local originalPosition = target.Position

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                Position = UDim2.new(originalPosition.X.Scale, originalPosition.X.Offset, originalPosition.Y.Scale + 1, originalPosition.Y.Offset),
            }, {
                Duration = config.Duration,
                Easing = config.Easing,
                Delay = config.Delay,
                OnComplete = function()
                    target.Visible = false
                    target.Position = originalPosition
                end,
            }):Play()
        end
    end

    --// Scale Transitions
    Transition.Scale = {}

    function Transition.Scale.In(target, config)
        config = MergeConfig(config)

        local originalSize = target.Size
        target.Size = UDim2.new(0, 0, 0, 0)
        target.Visible = true

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                Size = originalSize,
            }, config):Play()
        end
    end

    function Transition.Scale.Out(target, config)
        config = MergeConfig(config)

        local originalSize = target.Size

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                Size = UDim2.new(0, 0, 0, 0),
            }, {
                Duration = config.Duration,
                Easing = config.Easing,
                Delay = config.Delay,
                OnComplete = function()
                    target.Visible = false
                    target.Size = originalSize
                end,
            }):Play()
        end
    end

    function Transition.Scale.Pop(target, config)
        config = MergeConfig(config)

        local originalSize = target.Size
        target.Size = UDim2.new(originalSize.X.Scale * 0.8, originalSize.X.Offset * 0.8, originalSize.Y.Scale * 0.8, originalSize.Y.Offset * 0.8)
        target.Visible = true

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                Size = originalSize,
            }, {
                Duration = config.Duration,
                Easing = "BackOut",
            }):Play()
        end
    end

    function Transition.Scale.Bounce(target, config)
        config = MergeConfig(config)

        local originalSize = target.Size
        target.Size = UDim2.new(0, 0, 0, 0)
        target.Visible = true

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                Size = originalSize,
            }, {
                Duration = config.Duration,
                Easing = "ElasticOut",
            }):Play()
        end
    end

    --// Combined Transitions
    Transition.Combined = {}

    function Transition.Combined.FadeSlideFromLeft(target, config)
        config = MergeConfig(config)

        local originalPosition = target.Position
        target.Position = UDim2.new(originalPosition.X.Scale - 0.1, originalPosition.X.Offset - 20, originalPosition.Y.Scale, originalPosition.Y.Offset)
        target.BackgroundTransparency = 1
        target.Visible = true

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                Position = originalPosition,
                BackgroundTransparency = 0,
            }, config):Play()
        end
    end

    function Transition.Combined.FadeSlideFromRight(target, config)
        config = MergeConfig(config)

        local originalPosition = target.Position
        target.Position = UDim2.new(originalPosition.X.Scale + 0.1, originalPosition.X.Offset + 20, originalPosition.Y.Scale, originalPosition.Y.Offset)
        target.BackgroundTransparency = 1
        target.Visible = true

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                Position = originalPosition,
                BackgroundTransparency = 0,
            }, config):Play()
        end
    end

    function Transition.Combined.FadeSlideFromTop(target, config)
        config = MergeConfig(config)

        local originalPosition = target.Position
        target.Position = UDim2.new(originalPosition.X.Scale, originalPosition.X.Offset, originalPosition.Y.Scale - 0.1, originalPosition.Y.Offset - 20)
        target.BackgroundTransparency = 1
        target.Visible = true

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                Position = originalPosition,
                BackgroundTransparency = 0,
            }, config):Play()
        end
    end

    function Transition.Combined.FadeSlideFromBottom(target, config)
        config = MergeConfig(config)

        local originalPosition = target.Position
        target.Position = UDim2.new(originalPosition.X.Scale, originalPosition.X.Offset, originalPosition.Y.Scale + 0.1, originalPosition.Y.Offset + 20)
        target.BackgroundTransparency = 1
        target.Visible = true

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                Position = originalPosition,
                BackgroundTransparency = 0,
            }, config):Play()
        end
    end

    function Transition.Combined.FadeScale(target, config)
        config = MergeConfig(config)

        local originalSize = target.Size
        target.Size = UDim2.new(originalSize.X.Scale * 0.95, originalSize.X.Offset * 0.95, originalSize.Y.Scale * 0.95, originalSize.Y.Offset * 0.95)
        target.BackgroundTransparency = 1
        target.Visible = true

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                Size = originalSize,
                BackgroundTransparency = 0,
            }, config):Play()
        end
    end

    --// Flip Transitions
    Transition.Flip = {}

    function Transition.Flip.Horizontal(target, config)
        config = MergeConfig(config)

        -- Note: Roblox doesn't have true 3D transforms for UI
        -- This simulates a flip by scaling
        local originalSize = target.Size
        target.Visible = true

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                Size = UDim2.new(0, 0, originalSize.Y.Scale, originalSize.Y.Offset),
            }, {
                Duration = config.Duration / 2,
                Easing = "QuadIn",
                OnComplete = function()
                    -- Flip content here if needed
                    TweenClass.new(target, {
                        Size = originalSize,
                    }, {
                        Duration = config.Duration / 2,
                        Easing = "QuadOut",
                    }):Play()
                end,
            }):Play()
        end
    end

    function Transition.Flip.Vertical(target, config)
        config = MergeConfig(config)

        local originalSize = target.Size
        target.Visible = true

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                Size = UDim2.new(originalSize.X.Scale, originalSize.X.Offset, 0, 0),
            }, {
                Duration = config.Duration / 2,
                Easing = "QuadIn",
                OnComplete = function()
                    TweenClass.new(target, {
                        Size = originalSize,
                    }, {
                        Duration = config.Duration / 2,
                        Easing = "QuadOut",
                    }):Play()
                end,
            }):Play()
        end
    end

    --// Rotate Transitions
    Transition.Rotate = {}

    function Transition.Rotate.In(target, config)
        config = MergeConfig(config)

        target.Rotation = -90
        target.BackgroundTransparency = 1
        target.Visible = true

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                Rotation = 0,
                BackgroundTransparency = 0,
            }, config):Play()
        end
    end

    function Transition.Rotate.Out(target, config)
        config = MergeConfig(config)

        local TweenClass = GetTween()
        if TweenClass then
            return TweenClass.new(target, {
                Rotation = 90,
                BackgroundTransparency = 1,
            }, {
                Duration = config.Duration,
                Easing = config.Easing,
                Delay = config.Delay,
                OnComplete = function()
                    target.Visible = false
                    target.Rotation = 0
                end,
            }):Play()
        end
    end

    --// Transition Presets
    Transition.Presets = {
        Default = { Duration = 0.3, Easing = "QuadOut" },
        Fast = { Duration = 0.15, Easing = "QuadOut" },
        Slow = { Duration = 0.6, Easing = "QuadInOut" },
        Bouncy = { Duration = 0.5, Easing = "BackOut" },
        Elastic = { Duration = 0.7, Easing = "ElasticOut" },
        Smooth = { Duration = 0.4, Easing = "SineInOut" },
    }

    function Transition.GetPreset(name)
        return Transition.Presets[name] or Transition.Presets.Default
    end

    return Transition


end


-- ============================================================================
-- Module: NexusUI/Animation/Controller
-- ============================================================================
NexusUI_Modules["NexusUI/Animation/Controller"] = function()
    local script = CreateMockScript("NexusUI/Animation/Controller")
    
    --[[
        NexusUI Animation Controller
        Central management for all animations

        Features:
        - Global animation management
        - Animation groups
        - Priority system
        - Performance monitoring
        - Batch operations
    ]]

    --// Services
    local RunService = game:GetService("RunService")

    --// Controller Module
    local Controller = {}
    Controller.__index = Controller
    Controller.ClassName = "AnimationController"

    --// Singleton Instance
    local Instance_Singleton = nil

    --// Animation Registry
    local AnimationRegistry = {}
    local AnimationGroups = {}
    local AnimationIdCounter = 0

    --// Performance Tracking
    local PerformanceStats = {
        ActiveAnimations = 0,
        TotalAnimationsPlayed = 0,
        FrameTime = 0,
        AverageFrameTime = 0,
        FrameCount = 0,
    }

    --// Generate ID
    local function GenerateAnimationId()
        AnimationIdCounter = AnimationIdCounter + 1
        return "anim_" .. AnimationIdCounter
    end

    --// Controller Singleton
    function Controller.Get()
        if not Instance_Singleton then
            Instance_Singleton = setmetatable({}, Controller)
            Instance_Singleton:_initialize()
        end
        return Instance_Singleton
    end

    function Controller:_initialize()
        self.IsEnabled = true
        self.GlobalTimeScale = 1
        self.MaxConcurrentAnimations = 100
        self.UpdateConnection = nil

        -- Start update loop
        self:_startUpdateLoop()
    end

    function Controller:_startUpdateLoop()
        if self.UpdateConnection then return end

        self.UpdateConnection = RunService.Heartbeat:Connect(function(deltaTime)
            local startTime = os.clock()

            -- Update all managed animations
            self:_update(deltaTime * self.GlobalTimeScale)

            -- Track performance
            local frameTime = os.clock() - startTime
            PerformanceStats.FrameTime = frameTime
            PerformanceStats.FrameCount = PerformanceStats.FrameCount + 1
            PerformanceStats.AverageFrameTime = (PerformanceStats.AverageFrameTime * (PerformanceStats.FrameCount - 1) + frameTime) / PerformanceStats.FrameCount
        end)
    end

    function Controller:_stopUpdateLoop()
        if self.UpdateConnection then
            self.UpdateConnection:Disconnect()
            self.UpdateConnection = nil
        end
    end

    function Controller:_update(deltaTime)
        if not self.IsEnabled then return end

        local activeCount = 0
        local toRemove = {}

        for id, animData in pairs(AnimationRegistry) do
            if animData.Animation and animData.IsActive then
                activeCount = activeCount + 1

                -- Check if animation has Update method
                if animData.Animation.Update then
                    local success, err = pcall(function()
                        animData.Animation:Update(deltaTime)
                    end)

                    if not success then
                        warn("Animation update error:", err)
                        table.insert(toRemove, id)
                    end
                end

                -- Check if animation is complete
                if animData.Animation.IsComplete and animData.Animation:IsComplete() then
                    animData.IsActive = false
                end

                if animData.Animation.State then
                    local state = animData.Animation:GetState()
                    if state == "Completed" or state == "Cancelled" then
                        animData.IsActive = false
                    end
                end
            end
        end

        -- Clean up completed animations
        for _, id in ipairs(toRemove) do
            AnimationRegistry[id] = nil
        end

        PerformanceStats.ActiveAnimations = activeCount
    end

    --// Registration
    function Controller:Register(animation, options)
        options = options or {}

        local id = options.Id or GenerateAnimationId()

        AnimationRegistry[id] = {
            Id = id,
            Animation = animation,
            Group = options.Group,
            Priority = options.Priority or 0,
            IsActive = false,
            CreatedAt = os.clock(),
        }

        -- Add to group if specified
        if options.Group then
            if not AnimationGroups[options.Group] then
                AnimationGroups[options.Group] = {}
            end
            table.insert(AnimationGroups[options.Group], id)
        end

        return id
    end

    function Controller:Unregister(id)
        local animData = AnimationRegistry[id]

        if animData then
            -- Remove from group
            if animData.Group and AnimationGroups[animData.Group] then
                for i, animId in ipairs(AnimationGroups[animData.Group]) do
                    if animId == id then
                        table.remove(AnimationGroups[animData.Group], i)
                        break
                    end
                end
            end

            -- Stop animation if active
            if animData.IsActive and animData.Animation then
                if animData.Animation.Stop then
                    animData.Animation:Stop()
                elseif animData.Animation.Cancel then
                    animData.Animation:Cancel()
                end
            end

            AnimationRegistry[id] = nil
        end
    end

    --// Playback Control
    function Controller:Play(id)
        local animData = AnimationRegistry[id]

        if animData and animData.Animation then
            -- Check max concurrent
            if PerformanceStats.ActiveAnimations >= self.MaxConcurrentAnimations then
                warn("Max concurrent animations reached")
                return false
            end

            animData.IsActive = true
            PerformanceStats.TotalAnimationsPlayed = PerformanceStats.TotalAnimationsPlayed + 1

            if animData.Animation.Play then
                animData.Animation:Play()
            elseif animData.Animation.Start then
                animData.Animation:Start()
            end

            return true
        end

        return false
    end

    function Controller:Pause(id)
        local animData = AnimationRegistry[id]

        if animData and animData.Animation and animData.Animation.Pause then
            animData.Animation:Pause()
        end
    end

    function Controller:Resume(id)
        local animData = AnimationRegistry[id]

        if animData and animData.Animation and animData.Animation.Resume then
            animData.Animation:Resume()
        end
    end

    function Controller:Stop(id)
        local animData = AnimationRegistry[id]

        if animData then
            animData.IsActive = false

            if animData.Animation then
                if animData.Animation.Stop then
                    animData.Animation:Stop()
                elseif animData.Animation.Cancel then
                    animData.Animation:Cancel()
                end
            end
        end
    end

    --// Group Operations
    function Controller:CreateGroup(groupName)
        if not AnimationGroups[groupName] then
            AnimationGroups[groupName] = {}
        end
        return groupName
    end

    function Controller:DeleteGroup(groupName, stopAnimations)
        if AnimationGroups[groupName] then
            if stopAnimations then
                for _, id in ipairs(AnimationGroups[groupName]) do
                    self:Stop(id)
                end
            end
            AnimationGroups[groupName] = nil
        end
    end

    function Controller:PlayGroup(groupName)
        if AnimationGroups[groupName] then
            for _, id in ipairs(AnimationGroups[groupName]) do
                self:Play(id)
            end
        end
    end

    function Controller:PauseGroup(groupName)
        if AnimationGroups[groupName] then
            for _, id in ipairs(AnimationGroups[groupName]) do
                self:Pause(id)
            end
        end
    end

    function Controller:ResumeGroup(groupName)
        if AnimationGroups[groupName] then
            for _, id in ipairs(AnimationGroups[groupName]) do
                self:Resume(id)
            end
        end
    end

    function Controller:StopGroup(groupName)
        if AnimationGroups[groupName] then
            for _, id in ipairs(AnimationGroups[groupName]) do
                self:Stop(id)
            end
        end
    end

    function Controller:GetGroupAnimations(groupName)
        local animations = {}
        if AnimationGroups[groupName] then
            for _, id in ipairs(AnimationGroups[groupName]) do
                if AnimationRegistry[id] then
                    table.insert(animations, AnimationRegistry[id].Animation)
                end
            end
        end
        return animations
    end

    --// Global Control
    function Controller:PauseAll()
        for id, animData in pairs(AnimationRegistry) do
            if animData.IsActive then
                self:Pause(id)
            end
        end
    end

    function Controller:ResumeAll()
        for id, animData in pairs(AnimationRegistry) do
            if animData.Animation and animData.Animation.IsPaused and animData.Animation:IsPaused() then
                self:Resume(id)
            end
        end
    end

    function Controller:StopAll()
        for id, _ in pairs(AnimationRegistry) do
            self:Stop(id)
        end
    end

    function Controller:ClearAll()
        self:StopAll()
        AnimationRegistry = {}
        AnimationGroups = {}
    end

    --// Configuration
    function Controller:SetTimeScale(scale)
        self.GlobalTimeScale = math.max(0, scale)
    end

    function Controller:GetTimeScale()
        return self.GlobalTimeScale
    end

    function Controller:SetEnabled(enabled)
        self.IsEnabled = enabled
    end

    function Controller:IsEnabled()
        return self.IsEnabled
    end

    function Controller:SetMaxConcurrent(max)
        self.MaxConcurrentAnimations = math.max(1, max)
    end

    --// Performance
    function Controller:GetStats()
        return {
            ActiveAnimations = PerformanceStats.ActiveAnimations,
            TotalPlayed = PerformanceStats.TotalAnimationsPlayed,
            FrameTime = PerformanceStats.FrameTime,
            AverageFrameTime = PerformanceStats.AverageFrameTime,
            RegisteredCount = self:GetRegisteredCount(),
            GroupCount = self:GetGroupCount(),
        }
    end

    function Controller:GetRegisteredCount()
        local count = 0
        for _ in pairs(AnimationRegistry) do
            count = count + 1
        end
        return count
    end

    function Controller:GetActiveCount()
        return PerformanceStats.ActiveAnimations
    end

    function Controller:GetGroupCount()
        local count = 0
        for _ in pairs(AnimationGroups) do
            count = count + 1
        end
        return count
    end

    function Controller:GetGroupNames()
        local names = {}
        for name, _ in pairs(AnimationGroups) do
            table.insert(names, name)
        end
        return names
    end

    --// Cleanup
    function Controller:Destroy()
        self:ClearAll()
        self:_stopUpdateLoop()
        Instance_Singleton = nil
    end

    return Controller


end


-- ============================================================================
-- Module: NexusUI/Animation/Effects
-- ============================================================================
NexusUI_Modules["NexusUI/Animation/Effects"] = function()
    local script = CreateMockScript("NexusUI/Animation/Effects")
    
    --[[
        NexusUI Animation Effects
        Visual effect animations for UI elements

        Effects:
        - Pulse, Shake, Bounce
        - Glow, Ripple, Wave
        - Blur, Focus, Highlight
        - Loading indicators
    ]]

    --// Effects Module
    local Effects = {}
    Effects.ClassName = "AnimationEffects"

    --// Dependencies
    local Tween = nil
    local Keyframes = nil

    local function GetTween()
        if not Tween then
            local tweenModule = script.Parent:FindFirstChild("Tween")
            if tweenModule then
                Tween = require(tweenModule)
            end
        end
        return Tween
    end

    local function GetKeyframes()
        if not Keyframes then
            local keyframesModule = script.Parent:FindFirstChild("Keyframes")
            if keyframesModule then
                Keyframes = require(keyframesModule)
            end
        end
        return Keyframes
    end

    --// Active Effects
    local ActiveEffects = {}
    local EffectIdCounter = 0

    local function GenerateEffectId()
        EffectIdCounter = EffectIdCounter + 1
        return "effect_" .. EffectIdCounter
    end

    --// Pulse Effect
    function Effects.Pulse(target, config)
        config = config or {}
        local scale = config.Scale or 1.1
        local duration = config.Duration or 0.5
        local iterations = config.Iterations or -1 -- -1 = infinite

        local originalSize = target.Size
        local scaledSize = UDim2.new(
            originalSize.X.Scale * scale,
            originalSize.X.Offset * scale,
            originalSize.Y.Scale * scale,
            originalSize.Y.Offset * scale
        )

        local KeyframesClass = GetKeyframes()
        if KeyframesClass then
            local keyframeDef = KeyframesClass.Define()
                :At(0, { Size = originalSize })
                :At(50, { Size = scaledSize }, "SineInOut")
                :At(100, { Size = originalSize }, "SineInOut")

            local animation = KeyframesClass.new(target, keyframeDef, {
                Duration = duration,
                IterationCount = iterations,
            })

            local effectId = GenerateEffectId()
            ActiveEffects[effectId] = animation
            animation:Play()

            return {
                Id = effectId,
                Stop = function()
                    animation:Stop()
                    target.Size = originalSize
                    ActiveEffects[effectId] = nil
                end,
            }
        end
    end

    --// Shake Effect
    function Effects.Shake(target, config)
        config = config or {}
        local intensity = config.Intensity or 5
        local duration = config.Duration or 0.5
        local decay = config.Decay ~= false

        local originalPosition = target.Position
        local effectId = GenerateEffectId()
        local running = true

        ActiveEffects[effectId] = { Running = true }

        task.spawn(function()
            local startTime = os.clock()

            while running and (os.clock() - startTime) < duration do
                local progress = (os.clock() - startTime) / duration
                local currentIntensity = decay and (intensity * (1 - progress)) or intensity

                local offsetX = (math.random() - 0.5) * 2 * currentIntensity
                local offsetY = (math.random() - 0.5) * 2 * currentIntensity

                target.Position = UDim2.new(
                    originalPosition.X.Scale,
                    originalPosition.X.Offset + offsetX,
                    originalPosition.Y.Scale,
                    originalPosition.Y.Offset + offsetY
                )

                task.wait()
            end

            target.Position = originalPosition
            ActiveEffects[effectId] = nil
        end)

        return {
            Id = effectId,
            Stop = function()
                running = false
                target.Position = originalPosition
                ActiveEffects[effectId] = nil
            end,
        }
    end

    --// Bounce Effect
    function Effects.Bounce(target, config)
        config = config or {}
        local height = config.Height or 20
        local duration = config.Duration or 0.6
        local iterations = config.Iterations or 3

        local originalPosition = target.Position
        local TweenClass = GetTween()

        if TweenClass then
            local effectId = GenerateEffectId()
            local currentIteration = 0

            local function doBounce()
                if currentIteration >= iterations then
                    target.Position = originalPosition
                    ActiveEffects[effectId] = nil
                    return
                end

                currentIteration = currentIteration + 1
                local currentHeight = height * (1 - (currentIteration - 1) / iterations)

                TweenClass.new(target, {
                    Position = UDim2.new(
                        originalPosition.X.Scale,
                        originalPosition.X.Offset,
                        originalPosition.Y.Scale,
                        originalPosition.Y.Offset - currentHeight
                    ),
                }, {
                    Duration = duration / (iterations * 2),
                    Easing = "QuadOut",
                }):Play():Then(function()
                    TweenClass.new(target, {
                        Position = originalPosition,
                    }, {
                        Duration = duration / (iterations * 2),
                        Easing = "BounceOut",
                    }):Play():Then(doBounce)
                end)
            end

            ActiveEffects[effectId] = { Running = true }
            doBounce()

            return {
                Id = effectId,
                Stop = function()
                    target.Position = originalPosition
                    ActiveEffects[effectId] = nil
                end,
            }
        end
    end

    --// Glow Effect (using BackgroundColor3)
    function Effects.Glow(target, config)
        config = config or {}
        local color = config.Color or Color3.fromRGB(255, 255, 100)
        local duration = config.Duration or 0.8
        local iterations = config.Iterations or -1

        local originalColor = target.BackgroundColor3

        local KeyframesClass = GetKeyframes()
        if KeyframesClass then
            local keyframeDef = KeyframesClass.Define()
                :At(0, { BackgroundColor3 = originalColor })
                :At(50, { BackgroundColor3 = color }, "SineInOut")
                :At(100, { BackgroundColor3 = originalColor }, "SineInOut")

            local animation = KeyframesClass.new(target, keyframeDef, {
                Duration = duration,
                IterationCount = iterations,
            })

            local effectId = GenerateEffectId()
            ActiveEffects[effectId] = animation
            animation:Play()

            return {
                Id = effectId,
                Stop = function()
                    animation:Stop()
                    target.BackgroundColor3 = originalColor
                    ActiveEffects[effectId] = nil
                end,
            }
        end
    end

    --// Ripple Effect (visual only, creates expanding circle)
    function Effects.Ripple(target, config)
        config = config or {}
        local color = config.Color or Color3.fromRGB(255, 255, 255)
        local duration = config.Duration or 0.6
        local origin = config.Origin or UDim2.new(0.5, 0, 0.5, 0)

        local effectId = GenerateEffectId()

        -- Create ripple element
        local ripple = Instance.new("Frame")
        ripple.Name = "Ripple"
        ripple.AnchorPoint = Vector2.new(0.5, 0.5)
        ripple.Position = origin
        ripple.Size = UDim2.new(0, 0, 0, 0)
        ripple.BackgroundColor3 = color
        ripple.BackgroundTransparency = 0.7
        ripple.BorderSizePixel = 0
        ripple.ZIndex = target.ZIndex + 1

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(1, 0)
        corner.Parent = ripple

        ripple.Parent = target

        local TweenClass = GetTween()
        if TweenClass then
            -- Get target size for ripple
            local maxSize = math.max(target.AbsoluteSize.X, target.AbsoluteSize.Y) * 2

            TweenClass.new(ripple, {
                Size = UDim2.new(0, maxSize, 0, maxSize),
                BackgroundTransparency = 1,
            }, {
                Duration = duration,
                Easing = "QuadOut",
                OnComplete = function()
                    ripple:Destroy()
                    ActiveEffects[effectId] = nil
                end,
            }):Play()

            ActiveEffects[effectId] = { Ripple = ripple }

            return {
                Id = effectId,
                Stop = function()
                    ripple:Destroy()
                    ActiveEffects[effectId] = nil
                end,
            }
        end
    end

    --// Wave Effect (for lists/grids)
    function Effects.Wave(targets, config)
        config = config or {}
        local amplitude = config.Amplitude or 10
        local frequency = config.Frequency or 2
        local duration = config.Duration or 2
        local delay = config.Delay or 0.05

        local effectId = GenerateEffectId()
        local running = true
        local originalPositions = {}

        -- Store original positions
        for i, target in ipairs(targets) do
            originalPositions[i] = target.Position
        end

        ActiveEffects[effectId] = { Running = true }

        task.spawn(function()
            local startTime = os.clock()

            while running and (os.clock() - startTime) < duration do
                local time = os.clock() - startTime

                for i, target in ipairs(targets) do
                    local offset = math.sin((time * frequency * math.pi * 2) + (i * delay * 10)) * amplitude

                    target.Position = UDim2.new(
                        originalPositions[i].X.Scale,
                        originalPositions[i].X.Offset,
                        originalPositions[i].Y.Scale,
                        originalPositions[i].Y.Offset + offset
                    )
                end

                task.wait()
            end

            -- Restore positions
            for i, target in ipairs(targets) do
                target.Position = originalPositions[i]
            end

            ActiveEffects[effectId] = nil
        end)

        return {
            Id = effectId,
            Stop = function()
                running = false
                for i, target in ipairs(targets) do
                    target.Position = originalPositions[i]
                end
                ActiveEffects[effectId] = nil
            end,
        }
    end

    --// Highlight Effect
    function Effects.Highlight(target, config)
        config = config or {}
        local color = config.Color or Color3.fromRGB(255, 255, 0)
        local duration = config.Duration or 1
        local thickness = config.Thickness or 2

        local effectId = GenerateEffectId()

        -- Create highlight border
        local highlight = Instance.new("Frame")
        highlight.Name = "Highlight"
        highlight.AnchorPoint = Vector2.new(0.5, 0.5)
        highlight.Position = UDim2.new(0.5, 0, 0.5, 0)
        highlight.Size = UDim2.new(1, thickness * 2, 1, thickness * 2)
        highlight.BackgroundTransparency = 1
        highlight.BorderSizePixel = 0
        highlight.ZIndex = target.ZIndex - 1

        local stroke = Instance.new("UIStroke")
        stroke.Color = color
        stroke.Thickness = thickness
        stroke.Transparency = 0
        stroke.Parent = highlight

        -- Match corner radius if target has one
        local targetCorner = target:FindFirstChildOfClass("UICorner")
        if targetCorner then
            local corner = Instance.new("UICorner")
            corner.CornerRadius = targetCorner.CornerRadius
            corner.Parent = highlight
        end

        highlight.Parent = target

        local TweenClass = GetTween()
        if TweenClass then
            -- Pulse the highlight
            local function pulseHighlight()
                if not ActiveEffects[effectId] then return end

                TweenClass.new(stroke, {
                    Transparency = 0.5,
                }, {
                    Duration = duration / 2,
                    Easing = "SineInOut",
                }):Play():Then(function()
                    if not ActiveEffects[effectId] then return end

                    TweenClass.new(stroke, {
                        Transparency = 0,
                    }, {
                        Duration = duration / 2,
                        Easing = "SineInOut",
                    }):Play():Then(pulseHighlight)
                end)
            end

            ActiveEffects[effectId] = { Highlight = highlight }
            pulseHighlight()

            return {
                Id = effectId,
                Stop = function()
                    ActiveEffects[effectId] = nil
                    highlight:Destroy()
                end,
            }
        end
    end

    --// Spin Effect
    function Effects.Spin(target, config)
        config = config or {}
        local speed = config.Speed or 360 -- degrees per second
        local duration = config.Duration or -1 -- -1 = infinite
        local direction = config.Direction or 1 -- 1 = clockwise, -1 = counter-clockwise

        local effectId = GenerateEffectId()
        local running = true
        local startRotation = target.Rotation

        ActiveEffects[effectId] = { Running = true }

        task.spawn(function()
            local startTime = os.clock()

            while running do
                local elapsed = os.clock() - startTime

                if duration > 0 and elapsed >= duration then
                    break
                end

                target.Rotation = startRotation + (elapsed * speed * direction)
                task.wait()
            end

            target.Rotation = startRotation
            ActiveEffects[effectId] = nil
        end)

        return {
            Id = effectId,
            Stop = function()
                running = false
                target.Rotation = startRotation
                ActiveEffects[effectId] = nil
            end,
        }
    end

    --// Typing Effect (for text)
    function Effects.Typing(target, config)
        config = config or {}
        local text = config.Text or target.Text
        local speed = config.Speed or 0.05 -- seconds per character
        local cursor = config.Cursor or "|"
        local showCursor = config.ShowCursor ~= false

        local effectId = GenerateEffectId()
        local running = true

        ActiveEffects[effectId] = { Running = true }

        target.Text = ""

        task.spawn(function()
            for i = 1, #text do
                if not running then break end

                local partial = string.sub(text, 1, i)
                target.Text = partial .. (showCursor and cursor or "")
                task.wait(speed)
            end

            target.Text = text
            ActiveEffects[effectId] = nil
        end)

        return {
            Id = effectId,
            Stop = function()
                running = false
                target.Text = text
                ActiveEffects[effectId] = nil
            end,
        }
    end

    --// Count Effect (for numbers)
    function Effects.Count(target, config)
        config = config or {}
        local startValue = config.From or 0
        local endValue = config.To or 100
        local duration = config.Duration or 1
        local format = config.Format or "%d"
        local easing = config.Easing or "QuadOut"

        local effectId = GenerateEffectId()
        local running = true

        local EasingFunctions = nil
        local easingModule = script.Parent:FindFirstChild("EasingFunctions")
        if easingModule then
            EasingFunctions = require(easingModule)
        end

        local easingFunc = EasingFunctions and EasingFunctions[easing] or function(t) return t end

        ActiveEffects[effectId] = { Running = true }

        task.spawn(function()
            local startTime = os.clock()

            while running and (os.clock() - startTime) < duration do
                local progress = (os.clock() - startTime) / duration
                local easedProgress = easingFunc(progress)
                local currentValue = startValue + (endValue - startValue) * easedProgress

                target.Text = string.format(format, currentValue)
                task.wait()
            end

            target.Text = string.format(format, endValue)
            ActiveEffects[effectId] = nil
        end)

        return {
            Id = effectId,
            Stop = function()
                running = false
                target.Text = string.format(format, endValue)
                ActiveEffects[effectId] = nil
            end,
        }
    end

    --// Loading Spinner Effect
    function Effects.LoadingSpinner(parent, config)
        config = config or {}
        local size = config.Size or 50
        local color = config.Color or Color3.fromRGB(255, 255, 255)
        local thickness = config.Thickness or 4
        local speed = config.Speed or 1

        local effectId = GenerateEffectId()

        -- Create spinner container
        local spinner = Instance.new("Frame")
        spinner.Name = "LoadingSpinner"
        spinner.AnchorPoint = Vector2.new(0.5, 0.5)
        spinner.Position = config.Position or UDim2.new(0.5, 0, 0.5, 0)
        spinner.Size = UDim2.new(0, size, 0, size)
        spinner.BackgroundTransparency = 1
        spinner.Parent = parent

        -- Create spinner arc (using ImageLabel)
        local arc = Instance.new("ImageLabel")
        arc.Name = "Arc"
        arc.AnchorPoint = Vector2.new(0.5, 0.5)
        arc.Position = UDim2.new(0.5, 0, 0.5, 0)
        arc.Size = UDim2.new(1, 0, 1, 0)
        arc.BackgroundTransparency = 1
        arc.ImageColor3 = color
        arc.Image = "rbxassetid://6031094667" -- Circular progress image
        arc.ImageRectSize = Vector2.new(100, 100)
        arc.Parent = spinner

        local running = true

        task.spawn(function()
            while running do
                spinner.Rotation = spinner.Rotation + (360 * speed * task.wait())
            end
        end)

        ActiveEffects[effectId] = { Spinner = spinner, Running = true }

        return {
            Id = effectId,
            Instance = spinner,
            Stop = function()
                running = false
                spinner:Destroy()
                ActiveEffects[effectId] = nil
            end,
        }
    end

    --// Management
    function Effects.StopEffect(effectId)
        local effect = ActiveEffects[effectId]
        if effect and effect.Stop then
            effect:Stop()
        end
        ActiveEffects[effectId] = nil
    end

    function Effects.StopAll()
        for id, effect in pairs(ActiveEffects) do
            if type(effect) == "table" then
                if effect.Stop then
                    pcall(effect.Stop)
                elseif effect.Cancel then
                    pcall(effect.Cancel, effect)
                end
            end
        end
        ActiveEffects = {}
    end

    function Effects.GetActiveCount()
        local count = 0
        for _ in pairs(ActiveEffects) do
            count = count + 1
        end
        return count
    end

    return Effects


end


-- ============================================================================
-- Module: NexusUI/Animation/Stagger
-- ============================================================================
NexusUI_Modules["NexusUI/Animation/Stagger"] = function()
    local script = CreateMockScript("NexusUI/Animation/Stagger")
    
    --[[
        NexusUI Stagger Animation
        Staggered/cascading animations for lists and grids

        Features:
        - Customizable stagger delay
        - Different stagger patterns
        - Grid-aware staggering
        - Reverse stagger
    ]]

    --// Stagger Module
    local Stagger = {}
    Stagger.ClassName = "StaggerAnimation"

    --// Stagger Patterns
    Stagger.Pattern = {
        Sequential = "Sequential",     -- One after another
        Reverse = "Reverse",           -- Last to first
        Center = "Center",             -- From center outward
        Edges = "Edges",               -- From edges to center
        Random = "Random",             -- Random order
        Grid = "Grid",                 -- Grid-aware (diagonal)
        GridReverse = "GridReverse",   -- Grid reverse diagonal
    }

    --// Dependencies
    local Tween = nil
    local Transition = nil

    local function GetTween()
        if not Tween then
            local tweenModule = script.Parent:FindFirstChild("Tween")
            if tweenModule then
                Tween = require(tweenModule)
            end
        end
        return Tween
    end

    local function GetTransition()
        if not Transition then
            local transitionModule = script.Parent:FindFirstChild("Transition")
            if transitionModule then
                Transition = require(transitionModule)
            end
        end
        return Transition
    end

    --// Stagger State
    local StaggerState = {
        Pending = "Pending",
        Playing = "Playing",
        Completed = "Completed",
        Cancelled = "Cancelled",
    }

    --// ID Counter
    local StaggerIdCounter = 0

    local function GenerateStaggerId()
        StaggerIdCounter = StaggerIdCounter + 1
        return "stagger_" .. StaggerIdCounter
    end

    --// Calculate stagger order
    local function CalculateOrder(targets, pattern, gridColumns)
        local order = {}
        local count = #targets

        if pattern == Stagger.Pattern.Sequential then
            for i = 1, count do
                order[i] = i
            end
        elseif pattern == Stagger.Pattern.Reverse then
            for i = 1, count do
                order[i] = count - i + 1
            end
        elseif pattern == Stagger.Pattern.Center then
            local mid = math.ceil(count / 2)
            local left, right = mid, mid + 1
            local index = 1

            while left >= 1 or right <= count do
                if left >= 1 then
                    order[left] = index
                    index = index + 1
                    left = left - 1
                end
                if right <= count then
                    order[right] = index
                    index = index + 1
                    right = right + 1
                end
            end
        elseif pattern == Stagger.Pattern.Edges then
            local left, right = 1, count
            local index = 1

            while left <= right do
                order[left] = index
                index = index + 1
                if left ~= right then
                    order[right] = index
                    index = index + 1
                end
                left = left + 1
                right = right - 1
            end
        elseif pattern == Stagger.Pattern.Random then
            local indices = {}
            for i = 1, count do
                indices[i] = i
            end

            -- Fisher-Yates shuffle
            for i = count, 2, -1 do
                local j = math.random(i)
                indices[i], indices[j] = indices[j], indices[i]
            end

            for i = 1, count do
                order[indices[i]] = i
            end
        elseif pattern == Stagger.Pattern.Grid or pattern == Stagger.Pattern.GridReverse then
            gridColumns = gridColumns or 3
            local gridRows = math.ceil(count / gridColumns)

            -- Calculate diagonal order
            local maxDiagonal = gridRows + gridColumns - 1
            local index = 1

            for d = 0, maxDiagonal - 1 do
                for row = 0, gridRows - 1 do
                    local col = d - row
                    if col >= 0 and col < gridColumns then
                        local itemIndex = row * gridColumns + col + 1
                        if itemIndex <= count then
                            if pattern == Stagger.Pattern.GridReverse then
                                order[itemIndex] = count - index + 1
                            else
                                order[itemIndex] = index
                            end
                            index = index + 1
                        end
                    end
                end
            end
        end

        return order
    end

    --// Stagger Class
    local StaggerAnimation = {}
    StaggerAnimation.__index = StaggerAnimation

    function StaggerAnimation.new(targets, config)
        local self = setmetatable({}, StaggerAnimation)

        self.Id = GenerateStaggerId()
        self.Targets = targets
        self.Pattern = config and config.Pattern or Stagger.Pattern.Sequential
        self.Delay = config and config.Delay or 0.05
        self.Duration = config and config.Duration or 0.3
        self.Easing = config and config.Easing or "QuadOut"
        self.GridColumns = config and config.GridColumns
        self.AnimationType = config and config.AnimationType or "FadeIn"
        self.Properties = config and config.Properties

        -- State
        self.State = StaggerState.Pending
        self.CompletedCount = 0
        self.Animations = {}

        -- Callbacks
        self.OnStart = config and config.OnStart
        self.OnItemStart = config and config.OnItemStart
        self.OnItemComplete = config and config.OnItemComplete
        self.OnComplete = config and config.OnComplete

        return self
    end

    function StaggerAnimation:Play()
        if self.State == StaggerState.Playing then
            return self
        end

        self.State = StaggerState.Playing
        self.CompletedCount = 0

        if self.OnStart then
            pcall(self.OnStart, self)
        end

        local order = CalculateOrder(self.Targets, self.Pattern, self.GridColumns)
        local TweenClass = GetTween()
        local TransitionClass = GetTransition()

        for i, target in ipairs(self.Targets) do
            local itemOrder = order[i] or i
            local itemDelay = (itemOrder - 1) * self.Delay

            task.delay(itemDelay, function()
                if self.State ~= StaggerState.Playing then
                    return
                end

                if self.OnItemStart then
                    pcall(self.OnItemStart, target, i, self)
                end

                local animation

                if self.Properties then
                    -- Custom property animation
                    if TweenClass then
                        animation = TweenClass.new(target, self.Properties, {
                            Duration = self.Duration,
                            Easing = self.Easing,
                            OnComplete = function()
                                self:_onItemComplete(target, i)
                            end,
                        }):Play()
                    end
                elseif TransitionClass then
                    -- Use transition
                    local transitionFunc = nil

                    if self.AnimationType == "FadeIn" then
                        transitionFunc = TransitionClass.Fade.In
                    elseif self.AnimationType == "FadeOut" then
                        transitionFunc = TransitionClass.Fade.Out
                    elseif self.AnimationType == "SlideFromLeft" then
                        transitionFunc = TransitionClass.Slide.FromLeft
                    elseif self.AnimationType == "SlideFromRight" then
                        transitionFunc = TransitionClass.Slide.FromRight
                    elseif self.AnimationType == "SlideFromTop" then
                        transitionFunc = TransitionClass.Slide.FromTop
                    elseif self.AnimationType == "SlideFromBottom" then
                        transitionFunc = TransitionClass.Slide.FromBottom
                    elseif self.AnimationType == "ScaleIn" then
                        transitionFunc = TransitionClass.Scale.In
                    elseif self.AnimationType == "ScaleOut" then
                        transitionFunc = TransitionClass.Scale.Out
                    end

                    if transitionFunc then
                        animation = transitionFunc(target, {
                            Duration = self.Duration,
                            Easing = self.Easing,
                        })

                        if animation and animation.Then then
                            animation:Then(function()
                                self:_onItemComplete(target, i)
                            end)
                        else
                            -- Fallback: wait for duration
                            task.delay(self.Duration, function()
                                self:_onItemComplete(target, i)
                            end)
                        end
                    end
                end

                if animation then
                    self.Animations[i] = animation
                end
            end)
        end

        return self
    end

    function StaggerAnimation:_onItemComplete(target, index)
        self.CompletedCount = self.CompletedCount + 1

        if self.OnItemComplete then
            pcall(self.OnItemComplete, target, index, self)
        end

        if self.CompletedCount >= #self.Targets then
            self.State = StaggerState.Completed

            if self.OnComplete then
                pcall(self.OnComplete, self)
            end
        end
    end

    function StaggerAnimation:Stop()
        self.State = StaggerState.Cancelled

        for _, animation in pairs(self.Animations) do
            if animation and animation.Stop then
                animation:Stop()
            elseif animation and animation.Cancel then
                animation:Cancel()
            end
        end

        return self
    end

    function StaggerAnimation:Cancel()
        return self:Stop()
    end

    function StaggerAnimation:Then(callback)
        local originalOnComplete = self.OnComplete

        self.OnComplete = function(stagger)
            if originalOnComplete then
                originalOnComplete(stagger)
            end
            callback(stagger)
        end

        return self
    end

    function StaggerAnimation:GetState()
        return self.State
    end

    function StaggerAnimation:GetProgress()
        if #self.Targets == 0 then return 1 end
        return self.CompletedCount / #self.Targets
    end

    function StaggerAnimation:Await()
        while self.State == StaggerState.Playing do
            task.wait()
        end
        return self
    end

    --// Static Methods
    function Stagger.Create(targets, config)
        return StaggerAnimation.new(targets, config)
    end

    function Stagger.Play(targets, delay, animationType, config)
        config = config or {}
        config.Delay = delay or config.Delay
        config.AnimationType = animationType or config.AnimationType

        return StaggerAnimation.new(targets, config):Play()
    end

    function Stagger.FadeIn(targets, delay, duration)
        return Stagger.Play(targets, delay, "FadeIn", {
            Duration = duration,
        })
    end

    function Stagger.FadeOut(targets, delay, duration)
        return Stagger.Play(targets, delay, "FadeOut", {
            Duration = duration,
        })
    end

    function Stagger.SlideIn(targets, direction, delay, duration)
        return Stagger.Play(targets, delay, "SlideFrom" .. (direction or "Left"), {
            Duration = duration,
        })
    end

    function Stagger.ScaleIn(targets, delay, duration)
        return Stagger.Play(targets, delay, "ScaleIn", {
            Duration = duration,
        })
    end

    function Stagger.Custom(targets, properties, delay, duration, easing)
        return StaggerAnimation.new(targets, {
            Properties = properties,
            Delay = delay or 0.05,
            Duration = duration or 0.3,
            Easing = easing or "QuadOut",
        }):Play()
    end

    --// Grid Stagger
    function Stagger.GridFadeIn(targets, columns, delay, duration)
        return StaggerAnimation.new(targets, {
            Pattern = Stagger.Pattern.Grid,
            GridColumns = columns,
            AnimationType = "FadeIn",
            Delay = delay or 0.03,
            Duration = duration or 0.3,
        }):Play()
    end

    function Stagger.GridScaleIn(targets, columns, delay, duration)
        return StaggerAnimation.new(targets, {
            Pattern = Stagger.Pattern.Grid,
            GridColumns = columns,
            AnimationType = "ScaleIn",
            Delay = delay or 0.03,
            Duration = duration or 0.3,
        }):Play()
    end

    --// Export
    Stagger.State = StaggerState

    return Stagger


end


-- ============================================================================
-- Module: NexusUI/Animation/Interpolate
-- ============================================================================
NexusUI_Modules["NexusUI/Animation/Interpolate"] = function()
    local script = CreateMockScript("NexusUI/Animation/Interpolate")
    
    --[[
        NexusUI Interpolation Utilities
        Value interpolation for animations

        Features:
        - Linear interpolation (Lerp)
        - Smooth interpolation
        - Multi-type support
        - Path interpolation
    ]]

    --// Interpolate Module
    local Interpolate = {}
    Interpolate.ClassName = "Interpolate"

    --// Basic Lerp
    function Interpolate.Lerp(a, b, t)
        local valueType = typeof(a)

        if valueType == "number" then
            return a + (b - a) * t
        elseif valueType == "Color3" then
            return Color3.new(
                a.R + (b.R - a.R) * t,
                a.G + (b.G - a.G) * t,
                a.B + (b.B - a.B) * t
            )
        elseif valueType == "Vector2" then
            return Vector2.new(
                a.X + (b.X - a.X) * t,
                a.Y + (b.Y - a.Y) * t
            )
        elseif valueType == "Vector3" then
            return Vector3.new(
                a.X + (b.X - a.X) * t,
                a.Y + (b.Y - a.Y) * t,
                a.Z + (b.Z - a.Z) * t
            )
        elseif valueType == "UDim" then
            return UDim.new(
                a.Scale + (b.Scale - a.Scale) * t,
                a.Offset + (b.Offset - a.Offset) * t
            )
        elseif valueType == "UDim2" then
            return UDim2.new(
                a.X.Scale + (b.X.Scale - a.X.Scale) * t,
                a.X.Offset + (b.X.Offset - a.X.Offset) * t,
                a.Y.Scale + (b.Y.Scale - a.Y.Scale) * t,
                a.Y.Offset + (b.Y.Offset - a.Y.Offset) * t
            )
        elseif valueType == "CFrame" then
            return a:Lerp(b, t)
        elseif valueType == "Rect" then
            return Rect.new(
                Interpolate.Lerp(a.Min, b.Min, t),
                Interpolate.Lerp(a.Max, b.Max, t)
            )
        elseif valueType == "NumberRange" then
            return NumberRange.new(
                Interpolate.Lerp(a.Min, b.Min, t),
                Interpolate.Lerp(a.Max, b.Max, t)
            )
        end

        -- For non-interpolatable types, return b when t >= 0.5
        return t >= 0.5 and b or a
    end

    --// Number Interpolation
    function Interpolate.Number(a, b, t)
        return a + (b - a) * t
    end

    --// Inverse Lerp
    function Interpolate.InverseLerp(a, b, value)
        if a == b then return 0 end
        return (value - a) / (b - a)
    end

    --// Remap value from one range to another
    function Interpolate.Remap(value, inMin, inMax, outMin, outMax)
        local t = Interpolate.InverseLerp(inMin, inMax, value)
        return Interpolate.Lerp(outMin, outMax, t)
    end

    --// Clamp
    function Interpolate.Clamp(value, min, max)
        return math.max(min, math.min(max, value))
    end

    --// Clamped Lerp
    function Interpolate.ClampedLerp(a, b, t)
        return Interpolate.Lerp(a, b, Interpolate.Clamp(t, 0, 1))
    end

    --// Smooth Step (Hermite interpolation)
    function Interpolate.SmoothStep(a, b, t)
        t = Interpolate.Clamp(t, 0, 1)
        t = t * t * (3 - 2 * t)
        return Interpolate.Lerp(a, b, t)
    end

    --// Smoother Step
    function Interpolate.SmootherStep(a, b, t)
        t = Interpolate.Clamp(t, 0, 1)
        t = t * t * t * (t * (t * 6 - 15) + 10)
        return Interpolate.Lerp(a, b, t)
    end

    --// Color Interpolation (HSV)
    function Interpolate.ColorHSV(a, b, t)
        local aH, aS, aV = Color3.toHSV(a)
        local bH, bS, bV = Color3.toHSV(b)

        -- Handle hue wrapping
        local hDiff = bH - aH
        if math.abs(hDiff) > 0.5 then
            if hDiff > 0 then
                aH = aH + 1
            else
                bH = bH + 1
            end
        end

        local h = Interpolate.Number(aH, bH, t) % 1
        local s = Interpolate.Number(aS, bS, t)
        local v = Interpolate.Number(aV, bV, t)

        return Color3.fromHSV(h, s, v)
    end

    --// Color Interpolation (RGB)
    function Interpolate.ColorRGB(a, b, t)
        return Color3.new(
            Interpolate.Number(a.R, b.R, t),
            Interpolate.Number(a.G, b.G, t),
            Interpolate.Number(a.B, b.B, t)
        )
    end

    --// Angle Interpolation (handles wrapping)
    function Interpolate.Angle(a, b, t)
        local diff = (b - a + 180) % 360 - 180
        return a + diff * t
    end

    --// Bezier Interpolation
    function Interpolate.Bezier(points, t)
        local n = #points

        if n == 0 then return nil end
        if n == 1 then return points[1] end

        -- De Casteljau's algorithm
        local temp = {}
        for i, p in ipairs(points) do
            temp[i] = p
        end

        for i = 1, n - 1 do
            for j = 1, n - i do
                temp[j] = Interpolate.Lerp(temp[j], temp[j + 1], t)
            end
        end

        return temp[1]
    end

    --// Catmull-Rom Spline
    function Interpolate.CatmullRom(p0, p1, p2, p3, t)
        local t2 = t * t
        local t3 = t2 * t

        local function calc(v0, v1, v2, v3)
            return 0.5 * (
                (2 * v1) +
                (-v0 + v2) * t +
                (2 * v0 - 5 * v1 + 4 * v2 - v3) * t2 +
                (-v0 + 3 * v1 - 3 * v2 + v3) * t3
            )
        end

        local valueType = typeof(p0)

        if valueType == "number" then
            return calc(p0, p1, p2, p3)
        elseif valueType == "Vector2" then
            return Vector2.new(
                calc(p0.X, p1.X, p2.X, p3.X),
                calc(p0.Y, p1.Y, p2.Y, p3.Y)
            )
        elseif valueType == "Vector3" then
            return Vector3.new(
                calc(p0.X, p1.X, p2.X, p3.X),
                calc(p0.Y, p1.Y, p2.Y, p3.Y),
                calc(p0.Z, p1.Z, p2.Z, p3.Z)
            )
        elseif valueType == "UDim2" then
            return UDim2.new(
                calc(p0.X.Scale, p1.X.Scale, p2.X.Scale, p3.X.Scale),
                calc(p0.X.Offset, p1.X.Offset, p2.X.Offset, p3.X.Offset),
                calc(p0.Y.Scale, p1.Y.Scale, p2.Y.Scale, p3.Y.Scale),
                calc(p0.Y.Offset, p1.Y.Offset, p2.Y.Offset, p3.Y.Offset)
            )
        end

        return Interpolate.Lerp(p1, p2, t)
    end

    --// Path Interpolation
    local Path = {}
    Path.__index = Path

    function Path.new(points)
        local self = setmetatable({}, Path)

        self.Points = points or {}
        self.Closed = false

        return self
    end

    function Path:AddPoint(point)
        table.insert(self.Points, point)
        return self
    end

    function Path:SetClosed(closed)
        self.Closed = closed
        return self
    end

    function Path:GetPointAt(t)
        local count = #self.Points

        if count == 0 then return nil end
        if count == 1 then return self.Points[1] end

        if self.Closed then
            t = t % 1
        else
            t = Interpolate.Clamp(t, 0, 1)
        end

        local segmentCount = self.Closed and count or (count - 1)
        local segment = math.floor(t * segmentCount)
        local localT = (t * segmentCount) - segment

        if segment >= segmentCount then
            segment = segmentCount - 1
            localT = 1
        end

        local p1 = self.Points[segment + 1]
        local p2 = self.Points[((segment + 1) % count) + 1]

        return Interpolate.Lerp(p1, p2, localT)
    end

    function Path:GetSmoothPointAt(t)
        local count = #self.Points

        if count < 4 then
            return self:GetPointAt(t)
        end

        if self.Closed then
            t = t % 1
        else
            t = Interpolate.Clamp(t, 0, 1)
        end

        local segmentCount = self.Closed and count or (count - 1)
        local segment = math.floor(t * segmentCount)
        local localT = (t * segmentCount) - segment

        if segment >= segmentCount then
            segment = segmentCount - 1
            localT = 1
        end

        local function getPoint(i)
            if self.Closed then
                return self.Points[((i - 1) % count) + 1]
            else
                return self.Points[Interpolate.Clamp(i, 1, count)]
            end
        end

        local p0 = getPoint(segment)
        local p1 = getPoint(segment + 1)
        local p2 = getPoint(segment + 2)
        local p3 = getPoint(segment + 3)

        return Interpolate.CatmullRom(p0, p1, p2, p3, localT)
    end

    function Path:GetLength()
        local length = 0
        local count = #self.Points

        if count < 2 then return 0 end

        local endIndex = self.Closed and count or (count - 1)

        for i = 1, endIndex do
            local p1 = self.Points[i]
            local p2 = self.Points[(i % count) + 1]

            local diff
            local valueType = typeof(p1)

            if valueType == "Vector2" then
                diff = (p2 - p1).Magnitude
            elseif valueType == "Vector3" then
                diff = (p2 - p1).Magnitude
            elseif valueType == "number" then
                diff = math.abs(p2 - p1)
            elseif valueType == "UDim2" then
                local dx = p2.X.Offset - p1.X.Offset
                local dy = p2.Y.Offset - p1.Y.Offset
                diff = math.sqrt(dx * dx + dy * dy)
            else
                diff = 1
            end

            length = length + diff
        end

        return length
    end

    --// Gradient Interpolation
    function Interpolate.Gradient(colors, t)
        t = Interpolate.Clamp(t, 0, 1)

        local count = #colors
        if count == 0 then return Color3.new(1, 1, 1) end
        if count == 1 then return colors[1] end

        local segment = math.floor(t * (count - 1))
        local localT = (t * (count - 1)) - segment

        if segment >= count - 1 then
            return colors[count]
        end

        return Interpolate.ColorRGB(colors[segment + 1], colors[segment + 2], localT)
    end

    --// Spring Interpolation (critically damped)
    function Interpolate.Spring(current, target, velocity, stiffness, damping, dt)
        stiffness = stiffness or 100
        damping = damping or 10

        local displacement = current - target
        local springForce = -stiffness * displacement
        local dampingForce = -damping * velocity
        local acceleration = springForce + dampingForce

        local newVelocity = velocity + acceleration * dt
        local newValue = current + newVelocity * dt

        return newValue, newVelocity
    end

    --// Exponential Smoothing
    function Interpolate.Damp(current, target, smoothing, dt)
        local factor = 1 - math.exp(-smoothing * dt)
        return Interpolate.Lerp(current, target, factor)
    end

    --// Type Utilities
    function Interpolate.CanInterpolate(value)
        local valueType = typeof(value)
        return valueType == "number" or
               valueType == "Color3" or
               valueType == "Vector2" or
               valueType == "Vector3" or
               valueType == "UDim" or
               valueType == "UDim2" or
               valueType == "CFrame" or
               valueType == "Rect" or
               valueType == "NumberRange"
    end

    function Interpolate.GetValueType(value)
        return typeof(value)
    end

    --// Export Path class
    Interpolate.Path = Path

    return Interpolate


end


-- ============================================================================
-- Module: NexusUI/Animation/init
-- ============================================================================
NexusUI_Modules["NexusUI/Animation/init"] = function()
    local script = CreateMockScript("NexusUI/Animation/init")
    
    --[[
        NexusUI Animation System
        Comprehensive animation library for UI

        Modules:
        - SpringPhysics: Realistic spring-based animations
        - EasingFunctions: 40+ easing functions
        - Sequence: Sequential animation chains
        - Timeline: Time-based orchestration
        - Keyframes: CSS-like keyframe animations
        - Tween: Enhanced tweening system
        - Parallel: Simultaneous animations
        - Morph: State morphing
        - Transition: Pre-built transitions
        - Controller: Central management
        - Effects: Visual effect animations
        - Stagger: Staggered animations
        - Interpolate: Value interpolation
    ]]

    --// Animation Module
    local Animation = {}

    --// Load all sub-modules
    Animation.SpringPhysics = NexusRequire("NexusUI/Animation/SpringPhysics")
    Animation.Easing = NexusRequire("NexusUI/Animation/EasingFunctions")
    Animation.Sequence = NexusRequire("NexusUI/Animation/Sequence")
    Animation.Timeline = NexusRequire("NexusUI/Animation/Timeline")
    Animation.Keyframes = NexusRequire("NexusUI/Animation/Keyframes")
    Animation.Tween = NexusRequire("NexusUI/Animation/Tween")
    Animation.Parallel = NexusRequire("NexusUI/Animation/Parallel")
    Animation.Morph = NexusRequire("NexusUI/Animation/Morph")
    Animation.Transition = NexusRequire("NexusUI/Animation/Transition")
    Animation.Controller = NexusRequire("NexusUI/Animation/Controller")
    Animation.Effects = NexusRequire("NexusUI/Animation/Effects")
    Animation.Stagger = NexusRequire("NexusUI/Animation/Stagger")
    Animation.Interpolate = NexusRequire("NexusUI/Animation/Interpolate")

    --// Quick Access Aliases
    Animation.Spring = Animation.SpringPhysics
    Animation.EasingFunctions = Animation.Easing

    --// Convenience Methods

    -- Quick tween
    function Animation.To(target, properties, duration, easing)
        return Animation.Tween.To(target, properties, duration, easing)
    end

    -- Quick spring
    function Animation.SpringTo(target, property, goalValue, config)
        return Animation.SpringPhysics.To(target, property, goalValue, config)
    end

    -- Quick fade in
    function Animation.FadeIn(target, duration)
        return Animation.Transition.Fade.In(target, { Duration = duration })
    end

    -- Quick fade out
    function Animation.FadeOut(target, duration)
        return Animation.Transition.Fade.Out(target, { Duration = duration })
    end

    -- Quick slide
    function Animation.SlideIn(target, direction, duration)
        direction = direction or "Left"
        local slideFunc = Animation.Transition.Slide["From" .. direction]
        if slideFunc then
            return slideFunc(target, { Duration = duration })
        end
    end

    function Animation.SlideOut(target, direction, duration)
        direction = direction or "Left"
        local slideFunc = Animation.Transition.Slide["To" .. direction]
        if slideFunc then
            return slideFunc(target, { Duration = duration })
        end
    end

    -- Quick scale
    function Animation.ScaleIn(target, duration)
        return Animation.Transition.Scale.In(target, { Duration = duration })
    end

    function Animation.ScaleOut(target, duration)
        return Animation.Transition.Scale.Out(target, { Duration = duration })
    end

    -- Get controller singleton
    function Animation.GetController()
        return Animation.Controller.Get()
    end

    -- Create sequence
    function Animation.CreateSequence(...)
        return Animation.Sequence.new(...)
    end

    -- Create timeline
    function Animation.CreateTimeline()
        return Animation.Timeline.new()
    end

    -- Create keyframe animation
    function Animation.CreateKeyframes(target, keyframes, config)
        return Animation.Keyframes.new(target, keyframes, config)
    end

    -- Define keyframes
    function Animation.DefineKeyframes()
        return Animation.Keyframes.Define()
    end

    -- Create parallel
    function Animation.CreateParallel(...)
        return Animation.Parallel.new(...)
    end

    -- Play all animations
    function Animation.PlayAll(...)
        return Animation.Parallel.All(...)
    end

    -- Staggered animations
    function Animation.PlayStaggered(animations, delay)
        return Animation.Stagger.Play(animations, delay)
    end

    -- Get easing function
    function Animation.GetEasing(name)
        return Animation.Easing.Get(name)
    end

    -- Apply easing to value
    function Animation.ApplyEasing(easingName, startValue, endValue, t)
        return Animation.Easing.Apply(easingName, startValue, endValue, t)
    end

    -- Interpolate value
    function Animation.Lerp(a, b, t)
        return Animation.Interpolate.Lerp(a, b, t)
    end

    -- Get active animation count
    function Animation.GetActiveCount()
        return Animation.Controller.Get():GetActiveCount()
    end

    -- Stop all animations
    function Animation.StopAll()
        Animation.Controller.Get():StopAll()
        Animation.SpringPhysics.CancelAll()
        Animation.Tween.CancelAll()
    end

    -- Global time scale
    function Animation.SetTimeScale(scale)
        Animation.Controller.Get():SetTimeScale(scale)
    end

    function Animation.GetTimeScale()
        return Animation.Controller.Get():GetTimeScale()
    end

    return Animation


end


-- ============================================================================
-- Module: NexusUI/Themes/Palette
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Palette"] = function()
    local script = CreateMockScript("NexusUI/Themes/Palette")
    
    --[[
        NexusUI Color Palette Generator
        Generate harmonious color palettes from base colors
    ]]

    --// Palette Module
    local Palette = {}
    Palette.ClassName = "ColorPalette"

    --// Color Utilities
    local function RGBtoHSL(color)
        local r, g, b = color.R, color.G, color.B
        local max = math.max(r, g, b)
        local min = math.min(r, g, b)
        local h, s, l = 0, 0, (max + min) / 2

        if max ~= min then
            local d = max - min
            s = l > 0.5 and d / (2 - max - min) or d / (max + min)

            if max == r then
                h = (g - b) / d + (g < b and 6 or 0)
            elseif max == g then
                h = (b - r) / d + 2
            else
                h = (r - g) / d + 4
            end

            h = h / 6
        end

        return h, s, l
    end

    local function HSLtoRGB(h, s, l)
        local r, g, b

        if s == 0 then
            r, g, b = l, l, l
        else
            local function hue2rgb(p, q, t)
                if t < 0 then t = t + 1 end
                if t > 1 then t = t - 1 end
                if t < 1/6 then return p + (q - p) * 6 * t end
                if t < 1/2 then return q end
                if t < 2/3 then return p + (q - p) * (2/3 - t) * 6 end
                return p
            end

            local q = l < 0.5 and l * (1 + s) or l + s - l * s
            local p = 2 * l - q

            r = hue2rgb(p, q, h + 1/3)
            g = hue2rgb(p, q, h)
            b = hue2rgb(p, q, h - 1/3)
        end

        return Color3.new(r, g, b)
    end

    local function Clamp(value, min, max)
        return math.max(min, math.min(max, value))
    end

    --// Lighten Color
    function Palette.Lighten(color, amount)
        local h, s, l = RGBtoHSL(color)
        l = Clamp(l + amount, 0, 1)
        return HSLtoRGB(h, s, l)
    end

    --// Darken Color
    function Palette.Darken(color, amount)
        local h, s, l = RGBtoHSL(color)
        l = Clamp(l - amount, 0, 1)
        return HSLtoRGB(h, s, l)
    end

    --// Saturate Color
    function Palette.Saturate(color, amount)
        local h, s, l = RGBtoHSL(color)
        s = Clamp(s + amount, 0, 1)
        return HSLtoRGB(h, s, l)
    end

    --// Desaturate Color
    function Palette.Desaturate(color, amount)
        local h, s, l = RGBtoHSL(color)
        s = Clamp(s - amount, 0, 1)
        return HSLtoRGB(h, s, l)
    end

    --// Rotate Hue
    function Palette.RotateHue(color, degrees)
        local h, s, l = RGBtoHSL(color)
        h = (h + degrees / 360) % 1
        return HSLtoRGB(h, s, l)
    end

    --// Get Complementary Color
    function Palette.Complementary(color)
        return Palette.RotateHue(color, 180)
    end

    --// Get Analogous Colors
    function Palette.Analogous(color, angle)
        angle = angle or 30
        return {
            Palette.RotateHue(color, -angle),
            color,
            Palette.RotateHue(color, angle),
        }
    end

    --// Get Triadic Colors
    function Palette.Triadic(color)
        return {
            color,
            Palette.RotateHue(color, 120),
            Palette.RotateHue(color, 240),
        }
    end

    --// Get Tetradic Colors
    function Palette.Tetradic(color)
        return {
            color,
            Palette.RotateHue(color, 90),
            Palette.RotateHue(color, 180),
            Palette.RotateHue(color, 270),
        }
    end

    --// Get Split Complementary
    function Palette.SplitComplementary(color)
        return {
            color,
            Palette.RotateHue(color, 150),
            Palette.RotateHue(color, 210),
        }
    end

    --// Mix Two Colors
    function Palette.Mix(color1, color2, weight)
        weight = weight or 0.5
        return Color3.new(
            color1.R + (color2.R - color1.R) * weight,
            color1.G + (color2.G - color1.G) * weight,
            color1.B + (color2.B - color1.B) * weight
        )
    end

    --// Generate Color Scale (light to dark)
    function Palette.Scale(baseColor, steps)
        steps = steps or 10
        local scale = {}
        local h, s, l = RGBtoHSL(baseColor)

        for i = 1, steps do
            local newL = 0.95 - ((i - 1) / (steps - 1)) * 0.9
            scale[i] = HSLtoRGB(h, s, newL)
        end

        return scale
    end

    --// Generate from Primary Color
    function Palette.Generate(primaryColor)
        local h, s, l = RGBtoHSL(primaryColor)

        local palette = {
            -- Primary Scale
            Primary = primaryColor,
            Primary50 = HSLtoRGB(h, Clamp(s * 0.3, 0, 1), 0.97),
            Primary100 = HSLtoRGB(h, Clamp(s * 0.5, 0, 1), 0.94),
            Primary200 = HSLtoRGB(h, Clamp(s * 0.7, 0, 1), 0.86),
            Primary300 = HSLtoRGB(h, Clamp(s * 0.85, 0, 1), 0.76),
            Primary400 = HSLtoRGB(h, Clamp(s * 0.95, 0, 1), 0.64),
            Primary500 = primaryColor,
            Primary600 = HSLtoRGB(h, s, Clamp(l - 0.1, 0, 1)),
            Primary700 = HSLtoRGB(h, s, Clamp(l - 0.2, 0, 1)),
            Primary800 = HSLtoRGB(h, s, Clamp(l - 0.3, 0, 1)),
            Primary900 = HSLtoRGB(h, s, Clamp(l - 0.4, 0, 1)),

            -- Hover/Pressed variants
            PrimaryHover = Palette.Lighten(primaryColor, 0.1),
            PrimaryPressed = Palette.Darken(primaryColor, 0.1),
            PrimaryFaded = HSLtoRGB(h, Clamp(s * 0.4, 0, 1), Clamp(l + 0.3, 0, 1)),

            -- Complementary for Accent
            Accent = Palette.RotateHue(primaryColor, 180),
            AccentHover = Palette.Lighten(Palette.RotateHue(primaryColor, 180), 0.1),
            AccentPressed = Palette.Darken(Palette.RotateHue(primaryColor, 180), 0.1),

            -- Secondary (desaturated primary)
            Secondary = Palette.Desaturate(primaryColor, 0.5),
            SecondaryHover = Palette.Lighten(Palette.Desaturate(primaryColor, 0.5), 0.1),
            SecondaryPressed = Palette.Darken(Palette.Desaturate(primaryColor, 0.5), 0.1),

            -- Background colors (very dark, slightly tinted)
            Background = HSLtoRGB(h, Clamp(s * 0.1, 0, 1), 0.06),
            BackgroundAlt = HSLtoRGB(h, Clamp(s * 0.12, 0, 1), 0.09),
            BackgroundElevated = HSLtoRGB(h, Clamp(s * 0.14, 0, 1), 0.12),
            BackgroundFloating = HSLtoRGB(h, Clamp(s * 0.16, 0, 1), 0.15),

            -- Surface
            Surface = HSLtoRGB(h, Clamp(s * 0.12, 0, 1), 0.09),
            SurfaceHover = HSLtoRGB(h, Clamp(s * 0.14, 0, 1), 0.14),
            SurfaceActive = HSLtoRGB(h, Clamp(s * 0.16, 0, 1), 0.20),

            -- Border
            Border = HSLtoRGB(h, Clamp(s * 0.15, 0, 1), 0.27),
            BorderFocused = primaryColor,

            -- Glow
            Glow = primaryColor,
        }

        return palette
    end

    --// Generate Dark Theme from Primary
    function Palette.GenerateDarkTheme(primaryColor)
        local colors = Palette.Generate(primaryColor)

        -- Add standard colors
        colors.Text = Color3.fromRGB(250, 250, 250)
        colors.TextSecondary = Color3.fromRGB(161, 161, 170)
        colors.TextMuted = Color3.fromRGB(113, 113, 122)
        colors.TextInverse = Color3.fromRGB(15, 15, 15)

        colors.Success = Color3.fromRGB(34, 197, 94)
        colors.SuccessHover = Color3.fromRGB(74, 222, 128)
        colors.Warning = Color3.fromRGB(234, 179, 8)
        colors.WarningHover = Color3.fromRGB(250, 204, 21)
        colors.Error = Color3.fromRGB(239, 68, 68)
        colors.ErrorHover = Color3.fromRGB(248, 113, 113)
        colors.Info = Color3.fromRGB(59, 130, 246)
        colors.InfoHover = Color3.fromRGB(96, 165, 250)
        colors.BorderError = Color3.fromRGB(239, 68, 68)

        colors.Overlay = Color3.fromRGB(0, 0, 0)
        colors.OverlayTransparency = 0.5
        colors.Shadow = Color3.fromRGB(0, 0, 0)
        colors.ShadowTransparency = 0.5
        colors.GlowTransparency = 0.8

        colors.ScrollbarTrack = colors.BackgroundAlt
        colors.ScrollbarThumb = colors.Border
        colors.ScrollbarThumbHover = colors.TextMuted

        return colors
    end

    --// Generate Light Theme from Primary
    function Palette.GenerateLightTheme(primaryColor)
        local h, s, l = RGBtoHSL(primaryColor)

        local colors = {
            Primary = primaryColor,
            PrimaryHover = Palette.Darken(primaryColor, 0.1),
            PrimaryPressed = Palette.Darken(primaryColor, 0.2),
            PrimaryFaded = HSLtoRGB(h, Clamp(s * 0.3, 0, 1), 0.9),

            Secondary = Palette.Desaturate(primaryColor, 0.5),
            SecondaryHover = Palette.Darken(Palette.Desaturate(primaryColor, 0.5), 0.1),
            SecondaryPressed = Palette.Darken(Palette.Desaturate(primaryColor, 0.5), 0.2),

            Accent = Palette.RotateHue(primaryColor, 180),
            AccentHover = Palette.Darken(Palette.RotateHue(primaryColor, 180), 0.1),
            AccentPressed = Palette.Darken(Palette.RotateHue(primaryColor, 180), 0.2),

            Background = Color3.fromRGB(255, 255, 255),
            BackgroundAlt = Color3.fromRGB(249, 250, 251),
            BackgroundElevated = Color3.fromRGB(243, 244, 246),
            BackgroundFloating = Color3.fromRGB(255, 255, 255),

            Surface = Color3.fromRGB(249, 250, 251),
            SurfaceHover = Color3.fromRGB(243, 244, 246),
            SurfaceActive = Color3.fromRGB(229, 231, 235),

            Border = Color3.fromRGB(209, 213, 219),
            BorderFocused = primaryColor,
            BorderError = Color3.fromRGB(239, 68, 68),

            Text = Color3.fromRGB(17, 24, 39),
            TextSecondary = Color3.fromRGB(75, 85, 99),
            TextMuted = Color3.fromRGB(156, 163, 175),
            TextInverse = Color3.fromRGB(255, 255, 255),

            Success = Color3.fromRGB(22, 163, 74),
            SuccessHover = Color3.fromRGB(21, 128, 61),
            Warning = Color3.fromRGB(202, 138, 4),
            WarningHover = Color3.fromRGB(161, 98, 7),
            Error = Color3.fromRGB(220, 38, 38),
            ErrorHover = Color3.fromRGB(185, 28, 28),
            Info = Color3.fromRGB(37, 99, 235),
            InfoHover = Color3.fromRGB(29, 78, 216),

            Overlay = Color3.fromRGB(0, 0, 0),
            OverlayTransparency = 0.3,
            Shadow = Color3.fromRGB(0, 0, 0),
            ShadowTransparency = 0.85,

            Glow = primaryColor,
            GlowTransparency = 0.9,

            ScrollbarTrack = Color3.fromRGB(243, 244, 246),
            ScrollbarThumb = Color3.fromRGB(209, 213, 219),
            ScrollbarThumbHover = Color3.fromRGB(156, 163, 175),
        }

        return colors
    end

    --// Hex to Color3
    function Palette.FromHex(hex)
        hex = hex:gsub("#", "")

        local r = tonumber(hex:sub(1, 2), 16) / 255
        local g = tonumber(hex:sub(3, 4), 16) / 255
        local b = tonumber(hex:sub(5, 6), 16) / 255

        return Color3.new(r, g, b)
    end

    --// Color3 to Hex
    function Palette.ToHex(color)
        return string.format("#%02X%02X%02X",
            math.floor(color.R * 255),
            math.floor(color.G * 255),
            math.floor(color.B * 255)
        )
    end

    --// Get Contrast Color (black or white)
    function Palette.GetContrastColor(backgroundColor)
        local luminance = 0.299 * backgroundColor.R + 0.587 * backgroundColor.G + 0.114 * backgroundColor.B

        if luminance > 0.5 then
            return Color3.fromRGB(0, 0, 0)
        else
            return Color3.fromRGB(255, 255, 255)
        end
    end

    --// Predefined Palettes
    Palette.Predefined = {
        Indigo = Color3.fromRGB(99, 102, 241),
        Blue = Color3.fromRGB(59, 130, 246),
        Cyan = Color3.fromRGB(6, 182, 212),
        Teal = Color3.fromRGB(20, 184, 166),
        Green = Color3.fromRGB(34, 197, 94),
        Lime = Color3.fromRGB(132, 204, 22),
        Yellow = Color3.fromRGB(234, 179, 8),
        Orange = Color3.fromRGB(249, 115, 22),
        Red = Color3.fromRGB(239, 68, 68),
        Pink = Color3.fromRGB(236, 72, 153),
        Purple = Color3.fromRGB(168, 85, 247),
        Violet = Color3.fromRGB(139, 92, 246),
        Rose = Color3.fromRGB(244, 63, 94),
        Emerald = Color3.fromRGB(16, 185, 129),
        Sky = Color3.fromRGB(14, 165, 233),
        Amber = Color3.fromRGB(245, 158, 11),
        Fuchsia = Color3.fromRGB(217, 70, 239),
        Slate = Color3.fromRGB(100, 116, 139),
        Zinc = Color3.fromRGB(113, 113, 122),
        Stone = Color3.fromRGB(120, 113, 108),
    }

    return Palette


end


-- ============================================================================
-- Module: NexusUI/Themes/Effects
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Effects"] = function()
    local script = CreateMockScript("NexusUI/Themes/Effects")
    
    --[[
        NexusUI Theme Effects
        Visual effects like liquid glass, blur, glow
    ]]

    --// Effects Module
    local Effects = {}
    Effects.ClassName = "ThemeEffects"

    --// Apply Liquid Glass Effect
    function Effects.ApplyLiquidGlass(element, config)
        config = config or {}

        local transparency = config.Transparency or 0.7
        local cornerRadius = config.CornerRadius or UDim.new(0, 12)
        local borderTransparency = config.BorderTransparency or 0.5
        local borderColor = config.BorderColor or Color3.fromRGB(255, 255, 255)
        local blurTint = config.BlurTint or Color3.fromRGB(30, 30, 40)

        -- Set element properties
        element.BackgroundTransparency = transparency
        element.BackgroundColor3 = blurTint
        element.BorderSizePixel = 0

        -- Add corner
        local corner = element:FindFirstChildOfClass("UICorner") or Instance.new("UICorner")
        corner.CornerRadius = cornerRadius
        corner.Parent = element

        -- Add stroke for glass border effect
        local stroke = element:FindFirstChild("GlassStroke") or Instance.new("UIStroke")
        stroke.Name = "GlassStroke"
        stroke.Color = borderColor
        stroke.Transparency = borderTransparency
        stroke.Thickness = 1
        stroke.Parent = element

        -- Add gradient for glass shimmer
        local gradient = element:FindFirstChild("GlassGradient") or Instance.new("UIGradient")
        gradient.Name = "GlassGradient"
        gradient.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
            ColorSequenceKeypoint.new(0.5, Color3.fromRGB(200, 200, 220)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(180, 180, 200)),
        })
        gradient.Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 0.9),
            NumberSequenceKeypoint.new(0.5, 0.95),
            NumberSequenceKeypoint.new(1, 0.9),
        })
        gradient.Rotation = -45
        gradient.Parent = element

        return {
            Corner = corner,
            Stroke = stroke,
            Gradient = gradient,

            Remove = function()
                corner:Destroy()
                stroke:Destroy()
                gradient:Destroy()
            end,
        }
    end

    --// Apply Frosted Glass Effect
    function Effects.ApplyFrostedGlass(element, config)
        config = config or {}

        local transparency = config.Transparency or 0.6
        local cornerRadius = config.CornerRadius or UDim.new(0, 8)
        local tint = config.Tint or Color3.fromRGB(255, 255, 255)

        element.BackgroundTransparency = transparency
        element.BackgroundColor3 = tint
        element.BorderSizePixel = 0

        -- Add corner
        local corner = element:FindFirstChildOfClass("UICorner") or Instance.new("UICorner")
        corner.CornerRadius = cornerRadius
        corner.Parent = element

        -- Add noise texture for frosted effect
        local noiseOverlay = element:FindFirstChild("FrostNoise") or Instance.new("ImageLabel")
        noiseOverlay.Name = "FrostNoise"
        noiseOverlay.Size = UDim2.new(1, 0, 1, 0)
        noiseOverlay.BackgroundTransparency = 1
        noiseOverlay.ImageTransparency = 0.95
        noiseOverlay.Image = "rbxassetid://6031094678" -- Noise texture
        noiseOverlay.ScaleType = Enum.ScaleType.Tile
        noiseOverlay.TileSize = UDim2.new(0, 128, 0, 128)
        noiseOverlay.ZIndex = element.ZIndex + 1
        noiseOverlay.Parent = element

        return {
            Corner = corner,
            Noise = noiseOverlay,

            Remove = function()
                corner:Destroy()
                noiseOverlay:Destroy()
            end,
        }
    end

    --// Apply Glow Effect
    function Effects.ApplyGlow(element, config)
        config = config or {}

        local color = config.Color or Color3.fromRGB(99, 102, 241)
        local size = config.Size or 8
        local transparency = config.Transparency or 0.5

        -- Create glow container
        local glowContainer = Instance.new("Frame")
        glowContainer.Name = "GlowEffect"
        glowContainer.Size = UDim2.new(1, size * 2, 1, size * 2)
        glowContainer.Position = UDim2.new(0, -size, 0, -size)
        glowContainer.BackgroundColor3 = color
        glowContainer.BackgroundTransparency = transparency
        glowContainer.BorderSizePixel = 0
        glowContainer.ZIndex = element.ZIndex - 1

        -- Match corner radius
        local elementCorner = element:FindFirstChildOfClass("UICorner")
        if elementCorner then
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(elementCorner.CornerRadius.Scale, elementCorner.CornerRadius.Offset + size)
            corner.Parent = glowContainer
        else
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, size)
            corner.Parent = glowContainer
        end

        glowContainer.Parent = element.Parent

        return {
            Glow = glowContainer,

            SetColor = function(newColor)
                glowContainer.BackgroundColor3 = newColor
            end,

            SetSize = function(newSize)
                glowContainer.Size = UDim2.new(1, newSize * 2, 1, newSize * 2)
                glowContainer.Position = UDim2.new(0, -newSize, 0, -newSize)
            end,

            Remove = function()
                glowContainer:Destroy()
            end,
        }
    end

    --// Apply Shadow Effect
    function Effects.ApplyShadow(element, config)
        config = config or {}

        local color = config.Color or Color3.fromRGB(0, 0, 0)
        local offset = config.Offset or Vector2.new(0, 4)
        local size = config.Size or 8
        local transparency = config.Transparency or 0.6

        -- Create shadow
        local shadow = Instance.new("ImageLabel")
        shadow.Name = "ShadowEffect"
        shadow.Size = UDim2.new(1, size * 2, 1, size * 2)
        shadow.Position = UDim2.new(0, -size + offset.X, 0, -size + offset.Y)
        shadow.BackgroundTransparency = 1
        shadow.ImageColor3 = color
        shadow.ImageTransparency = transparency
        shadow.Image = "rbxassetid://6015897843" -- Shadow image
        shadow.ScaleType = Enum.ScaleType.Slice
        shadow.SliceCenter = Rect.new(49, 49, 450, 450)
        shadow.ZIndex = element.ZIndex - 1
        shadow.Parent = element.Parent

        return {
            Shadow = shadow,

            SetOffset = function(newOffset)
                shadow.Position = UDim2.new(0, -size + newOffset.X, 0, -size + newOffset.Y)
            end,

            SetColor = function(newColor)
                shadow.ImageColor3 = newColor
            end,

            Remove = function()
                shadow:Destroy()
            end,
        }
    end

    --// Apply Gradient Background
    function Effects.ApplyGradient(element, config)
        config = config or {}

        local colors = config.Colors or {
            Color3.fromRGB(99, 102, 241),
            Color3.fromRGB(168, 85, 247),
        }
        local rotation = config.Rotation or 45
        local animated = config.Animated or false

        -- Build color sequence
        local colorKeypoints = {}
        for i, color in ipairs(colors) do
            local time = (i - 1) / (#colors - 1)
            table.insert(colorKeypoints, ColorSequenceKeypoint.new(time, color))
        end

        local gradient = element:FindFirstChild("GradientEffect") or Instance.new("UIGradient")
        gradient.Name = "GradientEffect"
        gradient.Color = ColorSequence.new(colorKeypoints)
        gradient.Rotation = rotation
        gradient.Parent = element

        local animConnection = nil

        if animated then
            local RunService = game:GetService("RunService")
            local offset = 0

            animConnection = RunService.Heartbeat:Connect(function(dt)
                offset = (offset + dt * 0.5) % 2
                gradient.Offset = Vector2.new(offset - 1, 0)
            end)
        end

        return {
            Gradient = gradient,

            SetColors = function(newColors)
                local newKeypoints = {}
                for i, color in ipairs(newColors) do
                    local time = (i - 1) / (#newColors - 1)
                    table.insert(newKeypoints, ColorSequenceKeypoint.new(time, color))
                end
                gradient.Color = ColorSequence.new(newKeypoints)
            end,

            SetRotation = function(newRotation)
                gradient.Rotation = newRotation
            end,

            Remove = function()
                if animConnection then
                    animConnection:Disconnect()
                end
                gradient:Destroy()
            end,
        }
    end

    --// Apply Neumorphism Effect
    function Effects.ApplyNeumorphism(element, config)
        config = config or {}

        local lightColor = config.LightColor or Color3.fromRGB(255, 255, 255)
        local darkColor = config.DarkColor or Color3.fromRGB(0, 0, 0)
        local distance = config.Distance or 4
        local blur = config.Blur or 8
        local cornerRadius = config.CornerRadius or UDim.new(0, 12)
        local baseColor = config.BaseColor or Color3.fromRGB(225, 228, 236)

        element.BackgroundColor3 = baseColor
        element.BorderSizePixel = 0

        -- Add corner
        local corner = element:FindFirstChildOfClass("UICorner") or Instance.new("UICorner")
        corner.CornerRadius = cornerRadius
        corner.Parent = element

        -- Light shadow (top-left)
        local lightShadow = Instance.new("ImageLabel")
        lightShadow.Name = "LightShadow"
        lightShadow.Size = UDim2.new(1, blur, 1, blur)
        lightShadow.Position = UDim2.new(0, -distance - blur/2, 0, -distance - blur/2)
        lightShadow.BackgroundTransparency = 1
        lightShadow.ImageColor3 = lightColor
        lightShadow.ImageTransparency = 0.7
        lightShadow.Image = "rbxassetid://6015897843"
        lightShadow.ScaleType = Enum.ScaleType.Slice
        lightShadow.SliceCenter = Rect.new(49, 49, 450, 450)
        lightShadow.ZIndex = element.ZIndex - 1
        lightShadow.Parent = element.Parent

        -- Dark shadow (bottom-right)
        local darkShadow = Instance.new("ImageLabel")
        darkShadow.Name = "DarkShadow"
        darkShadow.Size = UDim2.new(1, blur, 1, blur)
        darkShadow.Position = UDim2.new(0, distance - blur/2, 0, distance - blur/2)
        darkShadow.BackgroundTransparency = 1
        darkShadow.ImageColor3 = darkColor
        darkShadow.ImageTransparency = 0.85
        darkShadow.Image = "rbxassetid://6015897843"
        darkShadow.ScaleType = Enum.ScaleType.Slice
        darkShadow.SliceCenter = Rect.new(49, 49, 450, 450)
        darkShadow.ZIndex = element.ZIndex - 1
        darkShadow.Parent = element.Parent

        return {
            Corner = corner,
            LightShadow = lightShadow,
            DarkShadow = darkShadow,

            Remove = function()
                corner:Destroy()
                lightShadow:Destroy()
                darkShadow:Destroy()
            end,
        }
    end

    --// Apply Border Gradient
    function Effects.ApplyBorderGradient(element, config)
        config = config or {}

        local colors = config.Colors or {
            Color3.fromRGB(99, 102, 241),
            Color3.fromRGB(236, 72, 153),
        }
        local thickness = config.Thickness or 2
        local rotation = config.Rotation or 45
        local animated = config.Animated or false

        -- Create stroke
        local stroke = element:FindFirstChild("GradientStroke") or Instance.new("UIStroke")
        stroke.Name = "GradientStroke"
        stroke.Thickness = thickness
        stroke.Parent = element

        -- Add gradient to stroke
        local colorKeypoints = {}
        for i, color in ipairs(colors) do
            local time = (i - 1) / (#colors - 1)
            table.insert(colorKeypoints, ColorSequenceKeypoint.new(time, color))
        end

        local gradient = stroke:FindFirstChild("StrokeGradient") or Instance.new("UIGradient")
        gradient.Name = "StrokeGradient"
        gradient.Color = ColorSequence.new(colorKeypoints)
        gradient.Rotation = rotation
        gradient.Parent = stroke

        local animConnection = nil

        if animated then
            local RunService = game:GetService("RunService")

            animConnection = RunService.Heartbeat:Connect(function(dt)
                gradient.Rotation = (gradient.Rotation + dt * 60) % 360
            end)
        end

        return {
            Stroke = stroke,
            Gradient = gradient,

            SetColors = function(newColors)
                local newKeypoints = {}
                for i, color in ipairs(newColors) do
                    local time = (i - 1) / (#newColors - 1)
                    table.insert(newKeypoints, ColorSequenceKeypoint.new(time, color))
                end
                gradient.Color = ColorSequence.new(newKeypoints)
            end,

            Remove = function()
                if animConnection then
                    animConnection:Disconnect()
                end
                stroke:Destroy()
            end,
        }
    end

    --// Apply Shimmer Effect
    function Effects.ApplyShimmer(element, config)
        config = config or {}

        local color = config.Color or Color3.fromRGB(255, 255, 255)
        local speed = config.Speed or 1.5

        -- Create shimmer overlay
        local shimmer = Instance.new("Frame")
        shimmer.Name = "ShimmerEffect"
        shimmer.Size = UDim2.new(0.3, 0, 1, 0)
        shimmer.Position = UDim2.new(-0.3, 0, 0, 0)
        shimmer.BackgroundTransparency = 1
        shimmer.ZIndex = element.ZIndex + 1
        shimmer.ClipsDescendants = false

        -- Shimmer gradient
        local gradient = Instance.new("UIGradient")
        gradient.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, color),
            ColorSequenceKeypoint.new(0.5, color),
            ColorSequenceKeypoint.new(1, color),
        })
        gradient.Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 1),
            NumberSequenceKeypoint.new(0.5, 0.7),
            NumberSequenceKeypoint.new(1, 1),
        })
        gradient.Rotation = 20
        gradient.Parent = shimmer

        shimmer.Parent = element

        -- Animate shimmer
        local TweenService = game:GetService("TweenService")
        local running = true

        local function animateShimmer()
            while running do
                shimmer.Position = UDim2.new(-0.3, 0, 0, 0)

                local tween = TweenService:Create(shimmer, TweenInfo.new(speed, Enum.EasingStyle.Linear), {
                    Position = UDim2.new(1, 0, 0, 0),
                })
                tween:Play()
                tween.Completed:Wait()

                task.wait(1)
            end
        end

        task.spawn(animateShimmer)

        return {
            Shimmer = shimmer,

            Remove = function()
                running = false
                shimmer:Destroy()
            end,
        }
    end

    return Effects


end


-- ============================================================================
-- Module: NexusUI/Themes/Builder
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Builder"] = function()
    local script = CreateMockScript("NexusUI/Themes/Builder")
    
    --[[
        NexusUI Theme Builder
        Fluent API for creating custom themes
    ]]

    --// Theme Builder Module
    local Builder = {}
    Builder.__index = Builder
    Builder.ClassName = "ThemeBuilder"

    --// Create new builder
    function Builder.Create(name, baseTheme)
        local self = setmetatable({}, Builder)

        self._name = name or "Custom"
        self._baseTheme = baseTheme
        self._colors = {}
        self._fonts = {}
        self._fontSizes = {}
        self._spacing = {}
        self._cornerRadius = {}
        self._shadows = {}
        self._animation = {}
        self._glass = {}
        self._custom = {}

        return self
    end

    --// Set Name
    function Builder:Name(name)
        self._name = name
        return self
    end

    --// Set Base Theme
    function Builder:Base(baseThemeName)
        self._baseTheme = baseThemeName
        return self
    end

    --// Color Setters
    function Builder:Primary(color, hover, pressed, faded)
        self._colors.Primary = color
        if hover then self._colors.PrimaryHover = hover end
        if pressed then self._colors.PrimaryPressed = pressed end
        if faded then self._colors.PrimaryFaded = faded end
        return self
    end

    function Builder:Secondary(color, hover, pressed)
        self._colors.Secondary = color
        if hover then self._colors.SecondaryHover = hover end
        if pressed then self._colors.SecondaryPressed = pressed end
        return self
    end

    function Builder:Accent(color, hover, pressed)
        self._colors.Accent = color
        if hover then self._colors.AccentHover = hover end
        if pressed then self._colors.AccentPressed = pressed end
        return self
    end

    function Builder:Background(main, alt, elevated, floating)
        self._colors.Background = main
        if alt then self._colors.BackgroundAlt = alt end
        if elevated then self._colors.BackgroundElevated = elevated end
        if floating then self._colors.BackgroundFloating = floating end
        return self
    end

    function Builder:Surface(main, hover, active)
        self._colors.Surface = main
        if hover then self._colors.SurfaceHover = hover end
        if active then self._colors.SurfaceActive = active end
        return self
    end

    function Builder:Border(main, focused, error)
        self._colors.Border = main
        if focused then self._colors.BorderFocused = focused end
        if error then self._colors.BorderError = error end
        return self
    end

    function Builder:Text(main, secondary, muted, inverse)
        self._colors.Text = main
        if secondary then self._colors.TextSecondary = secondary end
        if muted then self._colors.TextMuted = muted end
        if inverse then self._colors.TextInverse = inverse end
        return self
    end

    function Builder:Success(color, hover)
        self._colors.Success = color
        if hover then self._colors.SuccessHover = hover end
        return self
    end

    function Builder:Warning(color, hover)
        self._colors.Warning = color
        if hover then self._colors.WarningHover = hover end
        return self
    end

    function Builder:Error(color, hover)
        self._colors.Error = color
        if hover then self._colors.ErrorHover = hover end
        return self
    end

    function Builder:Info(color, hover)
        self._colors.Info = color
        if hover then self._colors.InfoHover = hover end
        return self
    end

    function Builder:Overlay(color, transparency)
        self._colors.Overlay = color
        if transparency then self._colors.OverlayTransparency = transparency end
        return self
    end

    function Builder:Shadow(color, transparency)
        self._colors.Shadow = color
        if transparency then self._colors.ShadowTransparency = transparency end
        return self
    end

    function Builder:Glow(color, transparency)
        self._colors.Glow = color
        if transparency then self._colors.GlowTransparency = transparency end
        return self
    end

    function Builder:Scrollbar(track, thumb, thumbHover)
        self._colors.ScrollbarTrack = track
        if thumb then self._colors.ScrollbarThumb = thumb end
        if thumbHover then self._colors.ScrollbarThumbHover = thumbHover end
        return self
    end

    function Builder:Color(colorName, value)
        self._colors[colorName] = value
        return self
    end

    --// Font Setters
    function Builder:HeaderFont(font)
        self._fonts.Header = font
        return self
    end

    function Builder:TitleFont(font)
        self._fonts.Title = font
        return self
    end

    function Builder:BodyFont(font)
        self._fonts.Body = font
        return self
    end

    function Builder:LabelFont(font)
        self._fonts.Label = font
        return self
    end

    function Builder:ButtonFont(font)
        self._fonts.Button = font
        return self
    end

    function Builder:MonoFont(font)
        self._fonts.Mono = font
        return self
    end

    function Builder:Font(fontName, font)
        self._fonts[fontName] = font
        return self
    end

    --// Font Size Setters
    function Builder:FontSize(sizeName, size)
        self._fontSizes[sizeName] = size
        return self
    end

    function Builder:FontSizes(sizes)
        for name, size in pairs(sizes) do
            self._fontSizes[name] = size
        end
        return self
    end

    --// Spacing Setters
    function Builder:Spacing(spacingName, value)
        self._spacing[spacingName] = value
        return self
    end

    function Builder:Spacings(spacings)
        for name, value in pairs(spacings) do
            self._spacing[name] = value
        end
        return self
    end

    --// Corner Radius Setters
    function Builder:CornerRadius(radiusName, value)
        self._cornerRadius[radiusName] = value
        return self
    end

    function Builder:CornerRadii(radii)
        for name, value in pairs(radii) do
            self._cornerRadius[name] = value
        end
        return self
    end

    --// Shadow Setters
    function Builder:ShadowPreset(presetName, offset, blur, transparency)
        self._shadows[presetName] = {
            Offset = offset,
            Blur = blur,
            Transparency = transparency,
        }
        return self
    end

    --// Animation Setters
    function Builder:AnimationSpeed(speedName, duration)
        self._animation[speedName] = duration
        return self
    end

    function Builder:DefaultEasing(easingName)
        self._animation.DefaultEasing = easingName
        return self
    end

    --// Glass Effect Setters
    function Builder:Glass(settings)
        for key, value in pairs(settings) do
            self._glass[key] = value
        end
        return self
    end

    function Builder:GlassTransparency(transparency)
        self._glass.BackgroundTransparency = transparency
        return self
    end

    function Builder:GlassBlur(blurSize)
        self._glass.BlurSize = blurSize
        return self
    end

    --// Custom Properties
    function Builder:Custom(key, value)
        self._custom[key] = value
        return self
    end

    --// Build Theme
    function Builder:Build()
        local theme = {
            Name = self._name,
        }

        -- Add colors if any were set
        if next(self._colors) then
            theme.Colors = self._colors
        end

        -- Add fonts if any were set
        if next(self._fonts) then
            theme.Fonts = self._fonts
        end

        -- Add font sizes if any were set
        if next(self._fontSizes) then
            theme.FontSizes = self._fontSizes
        end

        -- Add spacing if any were set
        if next(self._spacing) then
            theme.Spacing = self._spacing
        end

        -- Add corner radius if any were set
        if next(self._cornerRadius) then
            theme.CornerRadius = self._cornerRadius
        end

        -- Add shadows if any were set
        if next(self._shadows) then
            theme.Shadows = self._shadows
        end

        -- Add animation if any were set
        if next(self._animation) then
            theme.Animation = self._animation
        end

        -- Add glass settings if any were set
        if next(self._glass) then
            theme.Glass = self._glass
        end

        -- Add custom properties
        if next(self._custom) then
            for key, value in pairs(self._custom) do
                theme[key] = value
            end
        end

        return theme
    end

    --// Build and Register
    function Builder:Register()
        local theme = self:Build()

        local Manager = NexusRequire("NexusUI/Manager")
        Manager.RegisterTheme(theme)

        return theme
    end

    --// Clone from existing theme
    function Builder.FromTheme(existingTheme)
        local builder = Builder.Create(existingTheme.Name .. "Clone")

        if existingTheme.Colors then
            for name, color in pairs(existingTheme.Colors) do
                builder._colors[name] = color
            end
        end

        if existingTheme.Fonts then
            for name, font in pairs(existingTheme.Fonts) do
                builder._fonts[name] = font
            end
        end

        if existingTheme.FontSizes then
            for name, size in pairs(existingTheme.FontSizes) do
                builder._fontSizes[name] = size
            end
        end

        if existingTheme.Spacing then
            for name, spacing in pairs(existingTheme.Spacing) do
                builder._spacing[name] = spacing
            end
        end

        if existingTheme.CornerRadius then
            for name, radius in pairs(existingTheme.CornerRadius) do
                builder._cornerRadius[name] = radius
            end
        end

        if existingTheme.Shadows then
            for name, shadow in pairs(existingTheme.Shadows) do
                builder._shadows[name] = shadow
            end
        end

        if existingTheme.Animation then
            for name, value in pairs(existingTheme.Animation) do
                builder._animation[name] = value
            end
        end

        if existingTheme.Glass then
            for name, value in pairs(existingTheme.Glass) do
                builder._glass[name] = value
            end
        end

        return builder
    end

    return Builder


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Dark
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Dark"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Dark")
    
    --[[
        NexusUI Dark Theme
        Modern dark theme with indigo accents
    ]]

    return {
        Name = "Dark",

        Colors = {
            -- Primary
            Primary = Color3.fromRGB(99, 102, 241),
            PrimaryHover = Color3.fromRGB(129, 140, 248),
            PrimaryPressed = Color3.fromRGB(79, 70, 229),
            PrimaryFaded = Color3.fromRGB(99, 102, 241),

            -- Secondary
            Secondary = Color3.fromRGB(100, 116, 139),
            SecondaryHover = Color3.fromRGB(148, 163, 184),
            SecondaryPressed = Color3.fromRGB(71, 85, 105),

            -- Accent
            Accent = Color3.fromRGB(236, 72, 153),
            AccentHover = Color3.fromRGB(244, 114, 182),
            AccentPressed = Color3.fromRGB(219, 39, 119),

            -- Background
            Background = Color3.fromRGB(15, 15, 15),
            BackgroundAlt = Color3.fromRGB(24, 24, 27),
            BackgroundElevated = Color3.fromRGB(32, 32, 38),
            BackgroundFloating = Color3.fromRGB(39, 39, 42),

            -- Surface
            Surface = Color3.fromRGB(24, 24, 27),
            SurfaceHover = Color3.fromRGB(39, 39, 42),
            SurfaceActive = Color3.fromRGB(52, 52, 58),

            -- Border
            Border = Color3.fromRGB(63, 63, 70),
            BorderFocused = Color3.fromRGB(99, 102, 241),
            BorderError = Color3.fromRGB(239, 68, 68),

            -- Text
            Text = Color3.fromRGB(250, 250, 250),
            TextSecondary = Color3.fromRGB(161, 161, 170),
            TextMuted = Color3.fromRGB(113, 113, 122),
            TextInverse = Color3.fromRGB(15, 15, 15),

            -- Status
            Success = Color3.fromRGB(34, 197, 94),
            SuccessHover = Color3.fromRGB(74, 222, 128),
            Warning = Color3.fromRGB(234, 179, 8),
            WarningHover = Color3.fromRGB(250, 204, 21),
            Error = Color3.fromRGB(239, 68, 68),
            ErrorHover = Color3.fromRGB(248, 113, 113),
            Info = Color3.fromRGB(59, 130, 246),
            InfoHover = Color3.fromRGB(96, 165, 250),

            -- Effects
            Overlay = Color3.fromRGB(0, 0, 0),
            OverlayTransparency = 0.5,
            Shadow = Color3.fromRGB(0, 0, 0),
            ShadowTransparency = 0.5,
            Glow = Color3.fromRGB(99, 102, 241),
            GlowTransparency = 0.8,

            -- Scrollbar
            ScrollbarTrack = Color3.fromRGB(39, 39, 42),
            ScrollbarThumb = Color3.fromRGB(82, 82, 91),
            ScrollbarThumbHover = Color3.fromRGB(113, 113, 122),
        },

        Glass = {
            BackgroundTransparency = 0.7,
            BlurSize = 24,
            BorderTransparency = 0.5,
            Saturation = 1.2,
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Light
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Light"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Light")
    
    --[[
        NexusUI Light Theme
        Clean light theme with vibrant accents
    ]]

    return {
        Name = "Light",

        Colors = {
            -- Primary
            Primary = Color3.fromRGB(79, 70, 229),
            PrimaryHover = Color3.fromRGB(99, 102, 241),
            PrimaryPressed = Color3.fromRGB(67, 56, 202),
            PrimaryFaded = Color3.fromRGB(224, 231, 255),

            -- Secondary
            Secondary = Color3.fromRGB(100, 116, 139),
            SecondaryHover = Color3.fromRGB(71, 85, 105),
            SecondaryPressed = Color3.fromRGB(51, 65, 85),

            -- Accent
            Accent = Color3.fromRGB(219, 39, 119),
            AccentHover = Color3.fromRGB(190, 24, 93),
            AccentPressed = Color3.fromRGB(157, 23, 77),

            -- Background
            Background = Color3.fromRGB(255, 255, 255),
            BackgroundAlt = Color3.fromRGB(249, 250, 251),
            BackgroundElevated = Color3.fromRGB(243, 244, 246),
            BackgroundFloating = Color3.fromRGB(255, 255, 255),

            -- Surface
            Surface = Color3.fromRGB(249, 250, 251),
            SurfaceHover = Color3.fromRGB(243, 244, 246),
            SurfaceActive = Color3.fromRGB(229, 231, 235),

            -- Border
            Border = Color3.fromRGB(209, 213, 219),
            BorderFocused = Color3.fromRGB(79, 70, 229),
            BorderError = Color3.fromRGB(239, 68, 68),

            -- Text
            Text = Color3.fromRGB(17, 24, 39),
            TextSecondary = Color3.fromRGB(75, 85, 99),
            TextMuted = Color3.fromRGB(156, 163, 175),
            TextInverse = Color3.fromRGB(255, 255, 255),

            -- Status
            Success = Color3.fromRGB(22, 163, 74),
            SuccessHover = Color3.fromRGB(21, 128, 61),
            Warning = Color3.fromRGB(202, 138, 4),
            WarningHover = Color3.fromRGB(161, 98, 7),
            Error = Color3.fromRGB(220, 38, 38),
            ErrorHover = Color3.fromRGB(185, 28, 28),
            Info = Color3.fromRGB(37, 99, 235),
            InfoHover = Color3.fromRGB(29, 78, 216),

            -- Effects
            Overlay = Color3.fromRGB(0, 0, 0),
            OverlayTransparency = 0.3,
            Shadow = Color3.fromRGB(0, 0, 0),
            ShadowTransparency = 0.9,
            Glow = Color3.fromRGB(79, 70, 229),
            GlowTransparency = 0.9,

            -- Scrollbar
            ScrollbarTrack = Color3.fromRGB(243, 244, 246),
            ScrollbarThumb = Color3.fromRGB(209, 213, 219),
            ScrollbarThumbHover = Color3.fromRGB(156, 163, 175),
        },

        Glass = {
            BackgroundTransparency = 0.4,
            BlurSize = 16,
            BorderTransparency = 0.7,
            Saturation = 1.0,
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Ocean
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Ocean"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Ocean")
    
    --[[
        NexusUI Ocean Theme
        Calming ocean-inspired teal theme
    ]]

    return {
        Name = "Ocean",

        Colors = {
            Primary = Color3.fromRGB(20, 184, 166),
            PrimaryHover = Color3.fromRGB(45, 212, 191),
            PrimaryPressed = Color3.fromRGB(13, 148, 136),
            PrimaryFaded = Color3.fromRGB(17, 94, 89),

            Secondary = Color3.fromRGB(71, 85, 105),
            SecondaryHover = Color3.fromRGB(100, 116, 139),
            SecondaryPressed = Color3.fromRGB(51, 65, 85),

            Accent = Color3.fromRGB(6, 182, 212),
            AccentHover = Color3.fromRGB(34, 211, 238),
            AccentPressed = Color3.fromRGB(8, 145, 178),

            Background = Color3.fromRGB(10, 20, 25),
            BackgroundAlt = Color3.fromRGB(15, 30, 38),
            BackgroundElevated = Color3.fromRGB(20, 40, 50),
            BackgroundFloating = Color3.fromRGB(25, 50, 62),

            Surface = Color3.fromRGB(15, 30, 38),
            SurfaceHover = Color3.fromRGB(25, 50, 62),
            SurfaceActive = Color3.fromRGB(35, 65, 80),

            Border = Color3.fromRGB(45, 80, 95),
            BorderFocused = Color3.fromRGB(20, 184, 166),
            BorderError = Color3.fromRGB(239, 68, 68),

            Text = Color3.fromRGB(240, 253, 250),
            TextSecondary = Color3.fromRGB(153, 246, 228),
            TextMuted = Color3.fromRGB(94, 234, 212),
            TextInverse = Color3.fromRGB(10, 20, 25),

            Success = Color3.fromRGB(34, 197, 94),
            SuccessHover = Color3.fromRGB(74, 222, 128),
            Warning = Color3.fromRGB(234, 179, 8),
            WarningHover = Color3.fromRGB(250, 204, 21),
            Error = Color3.fromRGB(239, 68, 68),
            ErrorHover = Color3.fromRGB(248, 113, 113),
            Info = Color3.fromRGB(6, 182, 212),
            InfoHover = Color3.fromRGB(34, 211, 238),

            Overlay = Color3.fromRGB(0, 10, 15),
            OverlayTransparency = 0.5,
            Shadow = Color3.fromRGB(0, 10, 15),
            ShadowTransparency = 0.4,
            Glow = Color3.fromRGB(20, 184, 166),
            GlowTransparency = 0.7,

            ScrollbarTrack = Color3.fromRGB(25, 50, 62),
            ScrollbarThumb = Color3.fromRGB(45, 80, 95),
            ScrollbarThumbHover = Color3.fromRGB(20, 184, 166),
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Forest
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Forest"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Forest")
    
    --[[
        NexusUI Forest Theme
        Natural forest green theme
    ]]

    return {
        Name = "Forest",

        Colors = {
            Primary = Color3.fromRGB(34, 197, 94),
            PrimaryHover = Color3.fromRGB(74, 222, 128),
            PrimaryPressed = Color3.fromRGB(22, 163, 74),
            PrimaryFaded = Color3.fromRGB(20, 83, 45),

            Secondary = Color3.fromRGB(82, 82, 91),
            SecondaryHover = Color3.fromRGB(113, 113, 122),
            SecondaryPressed = Color3.fromRGB(63, 63, 70),

            Accent = Color3.fromRGB(132, 204, 22),
            AccentHover = Color3.fromRGB(163, 230, 53),
            AccentPressed = Color3.fromRGB(101, 163, 13),

            Background = Color3.fromRGB(12, 18, 12),
            BackgroundAlt = Color3.fromRGB(18, 28, 18),
            BackgroundElevated = Color3.fromRGB(24, 38, 24),
            BackgroundFloating = Color3.fromRGB(30, 48, 30),

            Surface = Color3.fromRGB(18, 28, 18),
            SurfaceHover = Color3.fromRGB(30, 48, 30),
            SurfaceActive = Color3.fromRGB(42, 64, 42),

            Border = Color3.fromRGB(50, 80, 50),
            BorderFocused = Color3.fromRGB(34, 197, 94),
            BorderError = Color3.fromRGB(239, 68, 68),

            Text = Color3.fromRGB(240, 253, 244),
            TextSecondary = Color3.fromRGB(187, 247, 208),
            TextMuted = Color3.fromRGB(134, 239, 172),
            TextInverse = Color3.fromRGB(12, 18, 12),

            Success = Color3.fromRGB(34, 197, 94),
            SuccessHover = Color3.fromRGB(74, 222, 128),
            Warning = Color3.fromRGB(234, 179, 8),
            WarningHover = Color3.fromRGB(250, 204, 21),
            Error = Color3.fromRGB(239, 68, 68),
            ErrorHover = Color3.fromRGB(248, 113, 113),
            Info = Color3.fromRGB(59, 130, 246),
            InfoHover = Color3.fromRGB(96, 165, 250),

            Overlay = Color3.fromRGB(0, 10, 0),
            OverlayTransparency = 0.5,
            Shadow = Color3.fromRGB(0, 10, 0),
            ShadowTransparency = 0.4,
            Glow = Color3.fromRGB(34, 197, 94),
            GlowTransparency = 0.7,

            ScrollbarTrack = Color3.fromRGB(30, 48, 30),
            ScrollbarThumb = Color3.fromRGB(50, 80, 50),
            ScrollbarThumbHover = Color3.fromRGB(34, 197, 94),
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Sunset
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Sunset"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Sunset")
    
    --[[
        NexusUI Sunset Theme
        Warm sunset orange and pink theme
    ]]

    return {
        Name = "Sunset",

        Colors = {
            Primary = Color3.fromRGB(249, 115, 22),
            PrimaryHover = Color3.fromRGB(251, 146, 60),
            PrimaryPressed = Color3.fromRGB(234, 88, 12),
            PrimaryFaded = Color3.fromRGB(124, 45, 18),

            Secondary = Color3.fromRGB(120, 113, 108),
            SecondaryHover = Color3.fromRGB(168, 162, 158),
            SecondaryPressed = Color3.fromRGB(87, 83, 78),

            Accent = Color3.fromRGB(244, 63, 94),
            AccentHover = Color3.fromRGB(251, 113, 133),
            AccentPressed = Color3.fromRGB(225, 29, 72),

            Background = Color3.fromRGB(20, 12, 10),
            BackgroundAlt = Color3.fromRGB(32, 20, 16),
            BackgroundElevated = Color3.fromRGB(44, 28, 22),
            BackgroundFloating = Color3.fromRGB(56, 36, 28),

            Surface = Color3.fromRGB(32, 20, 16),
            SurfaceHover = Color3.fromRGB(56, 36, 28),
            SurfaceActive = Color3.fromRGB(72, 48, 38),

            Border = Color3.fromRGB(92, 60, 48),
            BorderFocused = Color3.fromRGB(249, 115, 22),
            BorderError = Color3.fromRGB(239, 68, 68),

            Text = Color3.fromRGB(255, 247, 237),
            TextSecondary = Color3.fromRGB(254, 215, 170),
            TextMuted = Color3.fromRGB(253, 186, 116),
            TextInverse = Color3.fromRGB(20, 12, 10),

            Success = Color3.fromRGB(34, 197, 94),
            SuccessHover = Color3.fromRGB(74, 222, 128),
            Warning = Color3.fromRGB(234, 179, 8),
            WarningHover = Color3.fromRGB(250, 204, 21),
            Error = Color3.fromRGB(239, 68, 68),
            ErrorHover = Color3.fromRGB(248, 113, 113),
            Info = Color3.fromRGB(59, 130, 246),
            InfoHover = Color3.fromRGB(96, 165, 250),

            Overlay = Color3.fromRGB(10, 5, 0),
            OverlayTransparency = 0.5,
            Shadow = Color3.fromRGB(10, 5, 0),
            ShadowTransparency = 0.4,
            Glow = Color3.fromRGB(249, 115, 22),
            GlowTransparency = 0.7,

            ScrollbarTrack = Color3.fromRGB(56, 36, 28),
            ScrollbarThumb = Color3.fromRGB(92, 60, 48),
            ScrollbarThumbHover = Color3.fromRGB(249, 115, 22),
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Midnight
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Midnight"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Midnight")
    
    --[[
        NexusUI Midnight Theme
        Deep midnight blue theme
    ]]

    return {
        Name = "Midnight",

        Colors = {
            Primary = Color3.fromRGB(59, 130, 246),
            PrimaryHover = Color3.fromRGB(96, 165, 250),
            PrimaryPressed = Color3.fromRGB(37, 99, 235),
            PrimaryFaded = Color3.fromRGB(30, 58, 138),

            Secondary = Color3.fromRGB(71, 85, 105),
            SecondaryHover = Color3.fromRGB(100, 116, 139),
            SecondaryPressed = Color3.fromRGB(51, 65, 85),

            Accent = Color3.fromRGB(139, 92, 246),
            AccentHover = Color3.fromRGB(167, 139, 250),
            AccentPressed = Color3.fromRGB(124, 58, 237),

            Background = Color3.fromRGB(8, 12, 21),
            BackgroundAlt = Color3.fromRGB(15, 23, 42),
            BackgroundElevated = Color3.fromRGB(22, 33, 56),
            BackgroundFloating = Color3.fromRGB(30, 41, 59),

            Surface = Color3.fromRGB(15, 23, 42),
            SurfaceHover = Color3.fromRGB(30, 41, 59),
            SurfaceActive = Color3.fromRGB(51, 65, 85),

            Border = Color3.fromRGB(51, 65, 85),
            BorderFocused = Color3.fromRGB(59, 130, 246),
            BorderError = Color3.fromRGB(239, 68, 68),

            Text = Color3.fromRGB(241, 245, 249),
            TextSecondary = Color3.fromRGB(148, 163, 184),
            TextMuted = Color3.fromRGB(100, 116, 139),
            TextInverse = Color3.fromRGB(15, 23, 42),

            Success = Color3.fromRGB(34, 197, 94),
            SuccessHover = Color3.fromRGB(74, 222, 128),
            Warning = Color3.fromRGB(234, 179, 8),
            WarningHover = Color3.fromRGB(250, 204, 21),
            Error = Color3.fromRGB(239, 68, 68),
            ErrorHover = Color3.fromRGB(248, 113, 113),
            Info = Color3.fromRGB(59, 130, 246),
            InfoHover = Color3.fromRGB(96, 165, 250),

            Overlay = Color3.fromRGB(0, 0, 0),
            OverlayTransparency = 0.5,
            Shadow = Color3.fromRGB(0, 0, 0),
            ShadowTransparency = 0.4,
            Glow = Color3.fromRGB(59, 130, 246),
            GlowTransparency = 0.7,

            ScrollbarTrack = Color3.fromRGB(30, 41, 59),
            ScrollbarThumb = Color3.fromRGB(71, 85, 105),
            ScrollbarThumbHover = Color3.fromRGB(100, 116, 139),
        },

        Glass = {
            BackgroundTransparency = 0.75,
            BlurSize = 28,
            BorderTransparency = 0.4,
            Saturation = 1.3,
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Neon
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Neon"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Neon")
    
    --[[
        NexusUI Neon Theme
        Vibrant neon colors on dark background
    ]]

    return {
        Name = "Neon",

        Colors = {
            Primary = Color3.fromRGB(0, 255, 136),
            PrimaryHover = Color3.fromRGB(102, 255, 178),
            PrimaryPressed = Color3.fromRGB(0, 204, 109),
            PrimaryFaded = Color3.fromRGB(0, 80, 43),

            Secondary = Color3.fromRGB(113, 113, 122),
            SecondaryHover = Color3.fromRGB(161, 161, 170),
            SecondaryPressed = Color3.fromRGB(82, 82, 91),

            Accent = Color3.fromRGB(255, 0, 128),
            AccentHover = Color3.fromRGB(255, 102, 178),
            AccentPressed = Color3.fromRGB(204, 0, 102),

            Background = Color3.fromRGB(5, 5, 10),
            BackgroundAlt = Color3.fromRGB(10, 10, 18),
            BackgroundElevated = Color3.fromRGB(15, 15, 26),
            BackgroundFloating = Color3.fromRGB(20, 20, 34),

            Surface = Color3.fromRGB(10, 10, 18),
            SurfaceHover = Color3.fromRGB(20, 20, 34),
            SurfaceActive = Color3.fromRGB(30, 30, 50),

            Border = Color3.fromRGB(40, 40, 65),
            BorderFocused = Color3.fromRGB(0, 255, 136),
            BorderError = Color3.fromRGB(255, 50, 50),

            Text = Color3.fromRGB(255, 255, 255),
            TextSecondary = Color3.fromRGB(200, 200, 220),
            TextMuted = Color3.fromRGB(140, 140, 170),
            TextInverse = Color3.fromRGB(5, 5, 10),

            Success = Color3.fromRGB(0, 255, 136),
            SuccessHover = Color3.fromRGB(102, 255, 178),
            Warning = Color3.fromRGB(255, 230, 0),
            WarningHover = Color3.fromRGB(255, 240, 102),
            Error = Color3.fromRGB(255, 50, 50),
            ErrorHover = Color3.fromRGB(255, 120, 120),
            Info = Color3.fromRGB(0, 200, 255),
            InfoHover = Color3.fromRGB(102, 220, 255),

            Overlay = Color3.fromRGB(0, 0, 0),
            OverlayTransparency = 0.4,
            Shadow = Color3.fromRGB(0, 255, 136),
            ShadowTransparency = 0.85,
            Glow = Color3.fromRGB(0, 255, 136),
            GlowTransparency = 0.5,

            ScrollbarTrack = Color3.fromRGB(20, 20, 34),
            ScrollbarThumb = Color3.fromRGB(0, 255, 136),
            ScrollbarThumbHover = Color3.fromRGB(102, 255, 178),
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Cyberpunk
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Cyberpunk"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Cyberpunk")
    
    --[[
        NexusUI Cyberpunk Theme
        Futuristic cyberpunk aesthetic with yellow accents
    ]]

    return {
        Name = "Cyberpunk",

        Colors = {
            Primary = Color3.fromRGB(252, 211, 77),
            PrimaryHover = Color3.fromRGB(253, 224, 71),
            PrimaryPressed = Color3.fromRGB(245, 158, 11),
            PrimaryFaded = Color3.fromRGB(120, 95, 25),

            Secondary = Color3.fromRGB(100, 116, 139),
            SecondaryHover = Color3.fromRGB(148, 163, 184),
            SecondaryPressed = Color3.fromRGB(71, 85, 105),

            Accent = Color3.fromRGB(236, 72, 153),
            AccentHover = Color3.fromRGB(244, 114, 182),
            AccentPressed = Color3.fromRGB(219, 39, 119),

            Background = Color3.fromRGB(8, 8, 15),
            BackgroundAlt = Color3.fromRGB(15, 15, 28),
            BackgroundElevated = Color3.fromRGB(22, 22, 40),
            BackgroundFloating = Color3.fromRGB(30, 30, 55),

            Surface = Color3.fromRGB(15, 15, 28),
            SurfaceHover = Color3.fromRGB(30, 30, 55),
            SurfaceActive = Color3.fromRGB(45, 45, 75),

            Border = Color3.fromRGB(55, 55, 85),
            BorderFocused = Color3.fromRGB(252, 211, 77),
            BorderError = Color3.fromRGB(255, 50, 50),

            Text = Color3.fromRGB(252, 211, 77),
            TextSecondary = Color3.fromRGB(200, 180, 140),
            TextMuted = Color3.fromRGB(140, 130, 110),
            TextInverse = Color3.fromRGB(8, 8, 15),

            Success = Color3.fromRGB(0, 255, 136),
            SuccessHover = Color3.fromRGB(102, 255, 178),
            Warning = Color3.fromRGB(252, 211, 77),
            WarningHover = Color3.fromRGB(253, 224, 71),
            Error = Color3.fromRGB(255, 50, 80),
            ErrorHover = Color3.fromRGB(255, 100, 120),
            Info = Color3.fromRGB(59, 130, 246),
            InfoHover = Color3.fromRGB(96, 165, 250),

            Overlay = Color3.fromRGB(0, 0, 0),
            OverlayTransparency = 0.4,
            Shadow = Color3.fromRGB(252, 211, 77),
            ShadowTransparency = 0.9,
            Glow = Color3.fromRGB(252, 211, 77),
            GlowTransparency = 0.6,

            ScrollbarTrack = Color3.fromRGB(30, 30, 55),
            ScrollbarThumb = Color3.fromRGB(252, 211, 77),
            ScrollbarThumbHover = Color3.fromRGB(253, 224, 71),
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Dracula
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Dracula"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Dracula")
    
    --[[
        NexusUI Dracula Theme
        Dark theme with vibrant purple and pink
    ]]

    return {
        Name = "Dracula",

        Colors = {
            Primary = Color3.fromRGB(189, 147, 249),
            PrimaryHover = Color3.fromRGB(210, 180, 255),
            PrimaryPressed = Color3.fromRGB(150, 110, 200),
            PrimaryFaded = Color3.fromRGB(100, 75, 130),

            Secondary = Color3.fromRGB(98, 114, 164),
            SecondaryHover = Color3.fromRGB(130, 145, 190),
            SecondaryPressed = Color3.fromRGB(70, 85, 130),

            Accent = Color3.fromRGB(255, 121, 198),
            AccentHover = Color3.fromRGB(255, 160, 215),
            AccentPressed = Color3.fromRGB(200, 90, 150),

            Background = Color3.fromRGB(40, 42, 54),
            BackgroundAlt = Color3.fromRGB(50, 52, 68),
            BackgroundElevated = Color3.fromRGB(60, 62, 80),
            BackgroundFloating = Color3.fromRGB(68, 71, 90),

            Surface = Color3.fromRGB(50, 52, 68),
            SurfaceHover = Color3.fromRGB(68, 71, 90),
            SurfaceActive = Color3.fromRGB(80, 84, 105),

            Border = Color3.fromRGB(68, 71, 90),
            BorderFocused = Color3.fromRGB(189, 147, 249),
            BorderError = Color3.fromRGB(255, 85, 85),

            Text = Color3.fromRGB(248, 248, 242),
            TextSecondary = Color3.fromRGB(189, 147, 249),
            TextMuted = Color3.fromRGB(98, 114, 164),
            TextInverse = Color3.fromRGB(40, 42, 54),

            Success = Color3.fromRGB(80, 250, 123),
            SuccessHover = Color3.fromRGB(130, 255, 165),
            Warning = Color3.fromRGB(241, 250, 140),
            WarningHover = Color3.fromRGB(250, 255, 180),
            Error = Color3.fromRGB(255, 85, 85),
            ErrorHover = Color3.fromRGB(255, 130, 130),
            Info = Color3.fromRGB(139, 233, 253),
            InfoHover = Color3.fromRGB(175, 240, 255),

            Overlay = Color3.fromRGB(30, 32, 42),
            OverlayTransparency = 0.4,
            Shadow = Color3.fromRGB(30, 32, 42),
            ShadowTransparency = 0.5,
            Glow = Color3.fromRGB(189, 147, 249),
            GlowTransparency = 0.6,

            ScrollbarTrack = Color3.fromRGB(60, 62, 80),
            ScrollbarThumb = Color3.fromRGB(189, 147, 249),
            ScrollbarThumbHover = Color3.fromRGB(255, 121, 198),
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Nord
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Nord"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Nord")
    
    --[[
        NexusUI Nord Theme
        Arctic, north-bluish color palette
    ]]

    return {
        Name = "Nord",

        Colors = {
            Primary = Color3.fromRGB(136, 192, 208),
            PrimaryHover = Color3.fromRGB(163, 209, 222),
            PrimaryPressed = Color3.fromRGB(129, 161, 193),
            PrimaryFaded = Color3.fromRGB(76, 86, 106),

            Secondary = Color3.fromRGB(76, 86, 106),
            SecondaryHover = Color3.fromRGB(94, 129, 172),
            SecondaryPressed = Color3.fromRGB(67, 76, 94),

            Accent = Color3.fromRGB(191, 97, 106),
            AccentHover = Color3.fromRGB(208, 135, 112),
            AccentPressed = Color3.fromRGB(163, 80, 90),

            Background = Color3.fromRGB(46, 52, 64),
            BackgroundAlt = Color3.fromRGB(59, 66, 82),
            BackgroundElevated = Color3.fromRGB(67, 76, 94),
            BackgroundFloating = Color3.fromRGB(76, 86, 106),

            Surface = Color3.fromRGB(59, 66, 82),
            SurfaceHover = Color3.fromRGB(76, 86, 106),
            SurfaceActive = Color3.fromRGB(94, 129, 172),

            Border = Color3.fromRGB(76, 86, 106),
            BorderFocused = Color3.fromRGB(136, 192, 208),
            BorderError = Color3.fromRGB(191, 97, 106),

            Text = Color3.fromRGB(236, 239, 244),
            TextSecondary = Color3.fromRGB(216, 222, 233),
            TextMuted = Color3.fromRGB(129, 161, 193),
            TextInverse = Color3.fromRGB(46, 52, 64),

            Success = Color3.fromRGB(163, 190, 140),
            SuccessHover = Color3.fromRGB(180, 205, 165),
            Warning = Color3.fromRGB(235, 203, 139),
            WarningHover = Color3.fromRGB(245, 215, 165),
            Error = Color3.fromRGB(191, 97, 106),
            ErrorHover = Color3.fromRGB(210, 130, 140),
            Info = Color3.fromRGB(129, 161, 193),
            InfoHover = Color3.fromRGB(136, 192, 208),

            Overlay = Color3.fromRGB(30, 35, 45),
            OverlayTransparency = 0.4,
            Shadow = Color3.fromRGB(30, 35, 45),
            ShadowTransparency = 0.5,
            Glow = Color3.fromRGB(136, 192, 208),
            GlowTransparency = 0.7,

            ScrollbarTrack = Color3.fromRGB(67, 76, 94),
            ScrollbarThumb = Color3.fromRGB(94, 129, 172),
            ScrollbarThumbHover = Color3.fromRGB(136, 192, 208),
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Monokai
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Monokai"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Monokai")
    
    --[[
        NexusUI Monokai Theme
        Classic code editor theme
    ]]

    return {
        Name = "Monokai",

        Colors = {
            Primary = Color3.fromRGB(166, 226, 46),
            PrimaryHover = Color3.fromRGB(190, 240, 90),
            PrimaryPressed = Color3.fromRGB(130, 180, 30),
            PrimaryFaded = Color3.fromRGB(80, 110, 20),

            Secondary = Color3.fromRGB(117, 113, 94),
            SecondaryHover = Color3.fromRGB(150, 145, 125),
            SecondaryPressed = Color3.fromRGB(90, 87, 70),

            Accent = Color3.fromRGB(249, 38, 114),
            AccentHover = Color3.fromRGB(255, 90, 150),
            AccentPressed = Color3.fromRGB(200, 25, 90),

            Background = Color3.fromRGB(39, 40, 34),
            BackgroundAlt = Color3.fromRGB(52, 53, 46),
            BackgroundElevated = Color3.fromRGB(62, 63, 54),
            BackgroundFloating = Color3.fromRGB(72, 73, 64),

            Surface = Color3.fromRGB(52, 53, 46),
            SurfaceHover = Color3.fromRGB(72, 73, 64),
            SurfaceActive = Color3.fromRGB(90, 91, 80),

            Border = Color3.fromRGB(72, 73, 64),
            BorderFocused = Color3.fromRGB(166, 226, 46),
            BorderError = Color3.fromRGB(249, 38, 114),

            Text = Color3.fromRGB(248, 248, 242),
            TextSecondary = Color3.fromRGB(230, 219, 116),
            TextMuted = Color3.fromRGB(117, 113, 94),
            TextInverse = Color3.fromRGB(39, 40, 34),

            Success = Color3.fromRGB(166, 226, 46),
            SuccessHover = Color3.fromRGB(190, 240, 90),
            Warning = Color3.fromRGB(230, 219, 116),
            WarningHover = Color3.fromRGB(245, 235, 150),
            Error = Color3.fromRGB(249, 38, 114),
            ErrorHover = Color3.fromRGB(255, 90, 150),
            Info = Color3.fromRGB(102, 217, 239),
            InfoHover = Color3.fromRGB(145, 230, 250),

            Overlay = Color3.fromRGB(25, 26, 22),
            OverlayTransparency = 0.4,
            Shadow = Color3.fromRGB(25, 26, 22),
            ShadowTransparency = 0.5,
            Glow = Color3.fromRGB(166, 226, 46),
            GlowTransparency = 0.7,

            ScrollbarTrack = Color3.fromRGB(62, 63, 54),
            ScrollbarThumb = Color3.fromRGB(166, 226, 46),
            ScrollbarThumbHover = Color3.fromRGB(249, 38, 114),
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Synthwave
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Synthwave"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Synthwave")
    
    --[[
        NexusUI Synthwave Theme
        80s retro synthwave aesthetic
    ]]

    return {
        Name = "Synthwave",

        Colors = {
            Primary = Color3.fromRGB(255, 0, 170),
            PrimaryHover = Color3.fromRGB(255, 80, 200),
            PrimaryPressed = Color3.fromRGB(200, 0, 130),
            PrimaryFaded = Color3.fromRGB(100, 0, 65),

            Secondary = Color3.fromRGB(0, 200, 255),
            SecondaryHover = Color3.fromRGB(80, 220, 255),
            SecondaryPressed = Color3.fromRGB(0, 150, 200),

            Accent = Color3.fromRGB(255, 200, 0),
            AccentHover = Color3.fromRGB(255, 220, 80),
            AccentPressed = Color3.fromRGB(200, 150, 0),

            Background = Color3.fromRGB(18, 5, 30),
            BackgroundAlt = Color3.fromRGB(28, 10, 48),
            BackgroundElevated = Color3.fromRGB(40, 15, 65),
            BackgroundFloating = Color3.fromRGB(55, 20, 85),

            Surface = Color3.fromRGB(28, 10, 48),
            SurfaceHover = Color3.fromRGB(55, 20, 85),
            SurfaceActive = Color3.fromRGB(75, 30, 110),

            Border = Color3.fromRGB(90, 40, 130),
            BorderFocused = Color3.fromRGB(255, 0, 170),
            BorderError = Color3.fromRGB(255, 80, 80),

            Text = Color3.fromRGB(255, 255, 255),
            TextSecondary = Color3.fromRGB(255, 200, 255),
            TextMuted = Color3.fromRGB(200, 150, 200),
            TextInverse = Color3.fromRGB(18, 5, 30),

            Success = Color3.fromRGB(0, 255, 170),
            SuccessHover = Color3.fromRGB(80, 255, 200),
            Warning = Color3.fromRGB(255, 200, 0),
            WarningHover = Color3.fromRGB(255, 220, 80),
            Error = Color3.fromRGB(255, 80, 100),
            ErrorHover = Color3.fromRGB(255, 130, 150),
            Info = Color3.fromRGB(0, 200, 255),
            InfoHover = Color3.fromRGB(80, 220, 255),

            Overlay = Color3.fromRGB(10, 0, 20),
            OverlayTransparency = 0.4,
            Shadow = Color3.fromRGB(255, 0, 170),
            ShadowTransparency = 0.85,
            Glow = Color3.fromRGB(255, 0, 170),
            GlowTransparency = 0.5,

            ScrollbarTrack = Color3.fromRGB(55, 20, 85),
            ScrollbarThumb = Color3.fromRGB(255, 0, 170),
            ScrollbarThumbHover = Color3.fromRGB(255, 80, 200),
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Catppuccin
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Catppuccin"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Catppuccin")
    
    --[[
        NexusUI Catppuccin Theme
        Soothing pastel theme (Mocha variant)
    ]]

    return {
        Name = "Catppuccin",

        Colors = {
            Primary = Color3.fromRGB(137, 180, 250),
            PrimaryHover = Color3.fromRGB(166, 200, 255),
            PrimaryPressed = Color3.fromRGB(110, 155, 225),
            PrimaryFaded = Color3.fromRGB(70, 95, 140),

            Secondary = Color3.fromRGB(108, 112, 134),
            SecondaryHover = Color3.fromRGB(140, 145, 170),
            SecondaryPressed = Color3.fromRGB(85, 90, 110),

            Accent = Color3.fromRGB(245, 194, 231),
            AccentHover = Color3.fromRGB(255, 220, 245),
            AccentPressed = Color3.fromRGB(215, 165, 200),

            Background = Color3.fromRGB(30, 30, 46),
            BackgroundAlt = Color3.fromRGB(36, 39, 58),
            BackgroundElevated = Color3.fromRGB(49, 50, 68),
            BackgroundFloating = Color3.fromRGB(69, 71, 90),

            Surface = Color3.fromRGB(36, 39, 58),
            SurfaceHover = Color3.fromRGB(69, 71, 90),
            SurfaceActive = Color3.fromRGB(88, 91, 112),

            Border = Color3.fromRGB(69, 71, 90),
            BorderFocused = Color3.fromRGB(137, 180, 250),
            BorderError = Color3.fromRGB(243, 139, 168),

            Text = Color3.fromRGB(205, 214, 244),
            TextSecondary = Color3.fromRGB(186, 194, 222),
            TextMuted = Color3.fromRGB(108, 112, 134),
            TextInverse = Color3.fromRGB(30, 30, 46),

            Success = Color3.fromRGB(166, 227, 161),
            SuccessHover = Color3.fromRGB(195, 240, 195),
            Warning = Color3.fromRGB(249, 226, 175),
            WarningHover = Color3.fromRGB(255, 240, 200),
            Error = Color3.fromRGB(243, 139, 168),
            ErrorHover = Color3.fromRGB(255, 175, 195),
            Info = Color3.fromRGB(116, 199, 236),
            InfoHover = Color3.fromRGB(155, 220, 250),

            Overlay = Color3.fromRGB(20, 20, 32),
            OverlayTransparency = 0.4,
            Shadow = Color3.fromRGB(20, 20, 32),
            ShadowTransparency = 0.5,
            Glow = Color3.fromRGB(137, 180, 250),
            GlowTransparency = 0.7,

            ScrollbarTrack = Color3.fromRGB(49, 50, 68),
            ScrollbarThumb = Color3.fromRGB(137, 180, 250),
            ScrollbarThumbHover = Color3.fromRGB(245, 194, 231),
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Rose
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Rose"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Rose")
    
    --[[
        NexusUI Rose Theme
        Elegant rose pink theme
    ]]

    return {
        Name = "Rose",

        Colors = {
            Primary = Color3.fromRGB(244, 63, 94),
            PrimaryHover = Color3.fromRGB(251, 113, 133),
            PrimaryPressed = Color3.fromRGB(225, 29, 72),
            PrimaryFaded = Color3.fromRGB(136, 19, 55),

            Secondary = Color3.fromRGB(113, 113, 122),
            SecondaryHover = Color3.fromRGB(161, 161, 170),
            SecondaryPressed = Color3.fromRGB(82, 82, 91),

            Accent = Color3.fromRGB(236, 72, 153),
            AccentHover = Color3.fromRGB(244, 114, 182),
            AccentPressed = Color3.fromRGB(219, 39, 119),

            Background = Color3.fromRGB(20, 12, 16),
            BackgroundAlt = Color3.fromRGB(32, 18, 26),
            BackgroundElevated = Color3.fromRGB(44, 26, 36),
            BackgroundFloating = Color3.fromRGB(58, 35, 47),

            Surface = Color3.fromRGB(32, 18, 26),
            SurfaceHover = Color3.fromRGB(58, 35, 47),
            SurfaceActive = Color3.fromRGB(75, 48, 62),

            Border = Color3.fromRGB(90, 55, 72),
            BorderFocused = Color3.fromRGB(244, 63, 94),
            BorderError = Color3.fromRGB(239, 68, 68),

            Text = Color3.fromRGB(255, 241, 242),
            TextSecondary = Color3.fromRGB(253, 164, 175),
            TextMuted = Color3.fromRGB(190, 120, 140),
            TextInverse = Color3.fromRGB(20, 12, 16),

            Success = Color3.fromRGB(34, 197, 94),
            SuccessHover = Color3.fromRGB(74, 222, 128),
            Warning = Color3.fromRGB(234, 179, 8),
            WarningHover = Color3.fromRGB(250, 204, 21),
            Error = Color3.fromRGB(239, 68, 68),
            ErrorHover = Color3.fromRGB(248, 113, 113),
            Info = Color3.fromRGB(59, 130, 246),
            InfoHover = Color3.fromRGB(96, 165, 250),

            Overlay = Color3.fromRGB(10, 6, 8),
            OverlayTransparency = 0.5,
            Shadow = Color3.fromRGB(10, 6, 8),
            ShadowTransparency = 0.4,
            Glow = Color3.fromRGB(244, 63, 94),
            GlowTransparency = 0.6,

            ScrollbarTrack = Color3.fromRGB(58, 35, 47),
            ScrollbarThumb = Color3.fromRGB(244, 63, 94),
            ScrollbarThumbHover = Color3.fromRGB(251, 113, 133),
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Crimson
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Crimson"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Crimson")
    
    --[[
        NexusUI Crimson Theme
        Deep crimson red theme
    ]]

    return {
        Name = "Crimson",

        Colors = {
            Primary = Color3.fromRGB(220, 38, 38),
            PrimaryHover = Color3.fromRGB(239, 68, 68),
            PrimaryPressed = Color3.fromRGB(185, 28, 28),
            PrimaryFaded = Color3.fromRGB(127, 29, 29),

            Secondary = Color3.fromRGB(113, 113, 122),
            SecondaryHover = Color3.fromRGB(161, 161, 170),
            SecondaryPressed = Color3.fromRGB(82, 82, 91),

            Accent = Color3.fromRGB(244, 63, 94),
            AccentHover = Color3.fromRGB(251, 113, 133),
            AccentPressed = Color3.fromRGB(225, 29, 72),

            Background = Color3.fromRGB(18, 8, 8),
            BackgroundAlt = Color3.fromRGB(30, 14, 14),
            BackgroundElevated = Color3.fromRGB(42, 20, 20),
            BackgroundFloating = Color3.fromRGB(56, 28, 28),

            Surface = Color3.fromRGB(30, 14, 14),
            SurfaceHover = Color3.fromRGB(56, 28, 28),
            SurfaceActive = Color3.fromRGB(75, 40, 40),

            Border = Color3.fromRGB(95, 50, 50),
            BorderFocused = Color3.fromRGB(220, 38, 38),
            BorderError = Color3.fromRGB(239, 68, 68),

            Text = Color3.fromRGB(254, 242, 242),
            TextSecondary = Color3.fromRGB(254, 202, 202),
            TextMuted = Color3.fromRGB(252, 165, 165),
            TextInverse = Color3.fromRGB(18, 8, 8),

            Success = Color3.fromRGB(34, 197, 94),
            SuccessHover = Color3.fromRGB(74, 222, 128),
            Warning = Color3.fromRGB(234, 179, 8),
            WarningHover = Color3.fromRGB(250, 204, 21),
            Error = Color3.fromRGB(220, 38, 38),
            ErrorHover = Color3.fromRGB(239, 68, 68),
            Info = Color3.fromRGB(59, 130, 246),
            InfoHover = Color3.fromRGB(96, 165, 250),

            Overlay = Color3.fromRGB(9, 4, 4),
            OverlayTransparency = 0.5,
            Shadow = Color3.fromRGB(9, 4, 4),
            ShadowTransparency = 0.4,
            Glow = Color3.fromRGB(220, 38, 38),
            GlowTransparency = 0.5,

            ScrollbarTrack = Color3.fromRGB(56, 28, 28),
            ScrollbarThumb = Color3.fromRGB(220, 38, 38),
            ScrollbarThumbHover = Color3.fromRGB(239, 68, 68),
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Lavender
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Lavender"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Lavender")
    
    --[[
        NexusUI Lavender Theme
        Soft purple lavender theme
    ]]

    return {
        Name = "Lavender",

        Colors = {
            Primary = Color3.fromRGB(168, 85, 247),
            PrimaryHover = Color3.fromRGB(192, 132, 252),
            PrimaryPressed = Color3.fromRGB(147, 51, 234),
            PrimaryFaded = Color3.fromRGB(88, 28, 135),

            Secondary = Color3.fromRGB(113, 113, 122),
            SecondaryHover = Color3.fromRGB(161, 161, 170),
            SecondaryPressed = Color3.fromRGB(82, 82, 91),

            Accent = Color3.fromRGB(139, 92, 246),
            AccentHover = Color3.fromRGB(167, 139, 250),
            AccentPressed = Color3.fromRGB(124, 58, 237),

            Background = Color3.fromRGB(16, 14, 22),
            BackgroundAlt = Color3.fromRGB(26, 22, 38),
            BackgroundElevated = Color3.fromRGB(36, 30, 52),
            BackgroundFloating = Color3.fromRGB(48, 40, 68),

            Surface = Color3.fromRGB(26, 22, 38),
            SurfaceHover = Color3.fromRGB(48, 40, 68),
            SurfaceActive = Color3.fromRGB(65, 55, 90),

            Border = Color3.fromRGB(75, 60, 105),
            BorderFocused = Color3.fromRGB(168, 85, 247),
            BorderError = Color3.fromRGB(239, 68, 68),

            Text = Color3.fromRGB(250, 245, 255),
            TextSecondary = Color3.fromRGB(216, 180, 254),
            TextMuted = Color3.fromRGB(167, 139, 250),
            TextInverse = Color3.fromRGB(16, 14, 22),

            Success = Color3.fromRGB(34, 197, 94),
            SuccessHover = Color3.fromRGB(74, 222, 128),
            Warning = Color3.fromRGB(234, 179, 8),
            WarningHover = Color3.fromRGB(250, 204, 21),
            Error = Color3.fromRGB(239, 68, 68),
            ErrorHover = Color3.fromRGB(248, 113, 113),
            Info = Color3.fromRGB(59, 130, 246),
            InfoHover = Color3.fromRGB(96, 165, 250),

            Overlay = Color3.fromRGB(8, 7, 12),
            OverlayTransparency = 0.5,
            Shadow = Color3.fromRGB(8, 7, 12),
            ShadowTransparency = 0.4,
            Glow = Color3.fromRGB(168, 85, 247),
            GlowTransparency = 0.6,

            ScrollbarTrack = Color3.fromRGB(48, 40, 68),
            ScrollbarThumb = Color3.fromRGB(168, 85, 247),
            ScrollbarThumbHover = Color3.fromRGB(192, 132, 252),
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Manager
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Manager"] = function()
    local script = CreateMockScript("NexusUI/Themes/Manager")
    
    --[[
        NexusUI Theme Manager
        Handles theme registration, switching, and application
    ]]

    --// Theme Manager Module
    local Manager = {}
    Manager.ClassName = "ThemeManager"

    --// Theme Registry
    local RegisteredThemes = {}
    local CurrentThemeName = "Dark"
    local CurrentTheme = nil
    local ThemeListeners = {}
    local TrackedElements = {}

    --// Default Theme Structure
    local DefaultThemeStructure = {
        Name = "Default",

        -- Colors
        Colors = {
            -- Primary palette
            Primary = Color3.fromRGB(99, 102, 241),
            PrimaryHover = Color3.fromRGB(129, 140, 248),
            PrimaryPressed = Color3.fromRGB(79, 70, 229),
            PrimaryFaded = Color3.fromRGB(99, 102, 241),

            -- Secondary palette
            Secondary = Color3.fromRGB(100, 116, 139),
            SecondaryHover = Color3.fromRGB(148, 163, 184),
            SecondaryPressed = Color3.fromRGB(71, 85, 105),

            -- Accent
            Accent = Color3.fromRGB(236, 72, 153),
            AccentHover = Color3.fromRGB(244, 114, 182),
            AccentPressed = Color3.fromRGB(219, 39, 119),

            -- Background
            Background = Color3.fromRGB(15, 15, 15),
            BackgroundAlt = Color3.fromRGB(24, 24, 27),
            BackgroundElevated = Color3.fromRGB(32, 32, 38),
            BackgroundFloating = Color3.fromRGB(39, 39, 42),

            -- Surface
            Surface = Color3.fromRGB(24, 24, 27),
            SurfaceHover = Color3.fromRGB(39, 39, 42),
            SurfaceActive = Color3.fromRGB(52, 52, 58),

            -- Border
            Border = Color3.fromRGB(63, 63, 70),
            BorderFocused = Color3.fromRGB(99, 102, 241),
            BorderError = Color3.fromRGB(239, 68, 68),

            -- Text
            Text = Color3.fromRGB(250, 250, 250),
            TextSecondary = Color3.fromRGB(161, 161, 170),
            TextMuted = Color3.fromRGB(113, 113, 122),
            TextInverse = Color3.fromRGB(15, 15, 15),

            -- Status
            Success = Color3.fromRGB(34, 197, 94),
            SuccessHover = Color3.fromRGB(74, 222, 128),
            Warning = Color3.fromRGB(234, 179, 8),
            WarningHover = Color3.fromRGB(250, 204, 21),
            Error = Color3.fromRGB(239, 68, 68),
            ErrorHover = Color3.fromRGB(248, 113, 113),
            Info = Color3.fromRGB(59, 130, 246),
            InfoHover = Color3.fromRGB(96, 165, 250),

            -- Overlay
            Overlay = Color3.fromRGB(0, 0, 0),
            OverlayTransparency = 0.5,

            -- Scrollbar
            ScrollbarTrack = Color3.fromRGB(39, 39, 42),
            ScrollbarThumb = Color3.fromRGB(82, 82, 91),
            ScrollbarThumbHover = Color3.fromRGB(113, 113, 122),

            -- Shadow
            Shadow = Color3.fromRGB(0, 0, 0),
            ShadowTransparency = 0.5,

            -- Glow
            Glow = Color3.fromRGB(99, 102, 241),
            GlowTransparency = 0.8,
        },

        -- Typography
        Fonts = {
            Header = Enum.Font.GothamBold,
            Title = Enum.Font.GothamMedium,
            Body = Enum.Font.Gotham,
            Label = Enum.Font.Gotham,
            Button = Enum.Font.GothamMedium,
            Mono = Enum.Font.RobotoMono,
            Code = Enum.Font.Code,
        },

        -- Font Sizes
        FontSizes = {
            XSmall = 10,
            Small = 12,
            Normal = 14,
            Medium = 16,
            Large = 18,
            XLarge = 24,
            XXLarge = 32,
            Header = 28,
            Title = 20,
        },

        -- Spacing
        Spacing = {
            None = 0,
            XSmall = 4,
            Small = 8,
            Medium = 12,
            Normal = 16,
            Large = 24,
            XLarge = 32,
            XXLarge = 48,
        },

        -- Border Radius
        CornerRadius = {
            None = UDim.new(0, 0),
            Small = UDim.new(0, 4),
            Medium = UDim.new(0, 8),
            Large = UDim.new(0, 12),
            XLarge = UDim.new(0, 16),
            Full = UDim.new(0, 9999),
        },

        -- Shadows
        Shadows = {
            None = { Offset = Vector2.new(0, 0), Blur = 0, Transparency = 1 },
            Small = { Offset = Vector2.new(0, 2), Blur = 4, Transparency = 0.7 },
            Medium = { Offset = Vector2.new(0, 4), Blur = 8, Transparency = 0.6 },
            Large = { Offset = Vector2.new(0, 8), Blur = 16, Transparency = 0.5 },
            XLarge = { Offset = Vector2.new(0, 12), Blur = 24, Transparency = 0.4 },
        },

        -- Animation
        Animation = {
            Fast = 0.15,
            Normal = 0.25,
            Slow = 0.4,
            VerySlow = 0.6,
            DefaultEasing = "QuadOut",
        },

        -- Liquid Glass Effect Settings
        Glass = {
            BackgroundTransparency = 0.7,
            BlurSize = 24,
            BorderTransparency = 0.5,
            Saturation = 1.2,
        },
    }

    --// Deep Copy
    local function DeepCopy(original)
        local copy

        if type(original) == "table" then
            copy = {}
            for key, value in pairs(original) do
                copy[DeepCopy(key)] = DeepCopy(value)
            end
        else
            copy = original
        end

        return copy
    end

    --// Merge Tables
    local function MergeTables(base, override)
        local result = DeepCopy(base)

        for key, value in pairs(override) do
            if type(value) == "table" and type(result[key]) == "table" then
                result[key] = MergeTables(result[key], value)
            else
                result[key] = value
            end
        end

        return result
    end

    --// Validate Theme
    local function ValidateTheme(theme)
        if not theme.Name then
            warn("Theme must have a Name")
            return false
        end

        if not theme.Colors then
            warn("Theme must have Colors")
            return false
        end

        return true
    end

    --// Initialize with default theme
    local function InitializeDefaultTheme()
        CurrentTheme = DeepCopy(DefaultThemeStructure)
        RegisteredThemes["Default"] = CurrentTheme
    end

    --// Register Theme
    function Manager.RegisterTheme(theme)
        if not ValidateTheme(theme) then
            return false
        end

        -- Merge with default structure
        local fullTheme = MergeTables(DefaultThemeStructure, theme)
        fullTheme.Name = theme.Name

        RegisteredThemes[theme.Name] = fullTheme

        return true
    end

    --// Get Theme
    function Manager.GetTheme(themeName)
        return RegisteredThemes[themeName]
    end

    --// Get Current Theme
    function Manager.GetCurrentTheme()
        return CurrentTheme
    end

    --// Get Current Theme Name
    function Manager.GetCurrentThemeName()
        return CurrentThemeName
    end

    --// Set Theme
    function Manager.SetTheme(themeName, animate)
        local theme = RegisteredThemes[themeName]

        if not theme then
            warn("Theme not found:", themeName)
            return false
        end

        local previousTheme = CurrentTheme
        CurrentThemeName = themeName
        CurrentTheme = theme

        -- Notify listeners
        for _, listener in ipairs(ThemeListeners) do
            pcall(listener, theme, previousTheme, animate)
        end

        -- Update tracked elements
        for element, category in pairs(TrackedElements) do
            if element and element.Parent then
                Manager.ApplyTheme(element, category, animate)
            else
                TrackedElements[element] = nil
            end
        end

        return true
    end

    --// Get Available Themes
    function Manager.GetAvailableThemes()
        local themes = {}
        for name, _ in pairs(RegisteredThemes) do
            table.insert(themes, name)
        end
        return themes
    end

    --// On Theme Change
    function Manager.OnThemeChange(callback)
        table.insert(ThemeListeners, callback)

        -- Return disconnect function
        return function()
            for i, listener in ipairs(ThemeListeners) do
                if listener == callback then
                    table.remove(ThemeListeners, i)
                    break
                end
            end
        end
    end

    --// Get Color
    function Manager.GetColor(colorName)
        if CurrentTheme and CurrentTheme.Colors[colorName] then
            return CurrentTheme.Colors[colorName]
        end
        return DefaultThemeStructure.Colors[colorName]
    end

    --// Get Font
    function Manager.GetFont(fontName)
        if CurrentTheme and CurrentTheme.Fonts[fontName] then
            return CurrentTheme.Fonts[fontName]
        end
        return DefaultThemeStructure.Fonts[fontName]
    end

    --// Get Font Size
    function Manager.GetFontSize(sizeName)
        if CurrentTheme and CurrentTheme.FontSizes[sizeName] then
            return CurrentTheme.FontSizes[sizeName]
        end
        return DefaultThemeStructure.FontSizes[sizeName]
    end

    --// Get Spacing
    function Manager.GetSpacing(spacingName)
        if CurrentTheme and CurrentTheme.Spacing[spacingName] then
            return CurrentTheme.Spacing[spacingName]
        end
        return DefaultThemeStructure.Spacing[spacingName]
    end

    --// Get Corner Radius
    function Manager.GetCornerRadius(radiusName)
        if CurrentTheme and CurrentTheme.CornerRadius[radiusName] then
            return CurrentTheme.CornerRadius[radiusName]
        end
        return DefaultThemeStructure.CornerRadius[radiusName]
    end

    --// Get Shadow
    function Manager.GetShadow(shadowName)
        if CurrentTheme and CurrentTheme.Shadows[shadowName] then
            return CurrentTheme.Shadows[shadowName]
        end
        return DefaultThemeStructure.Shadows[shadowName]
    end

    --// Get Animation Duration
    function Manager.GetAnimationDuration(speedName)
        if CurrentTheme and CurrentTheme.Animation[speedName] then
            return CurrentTheme.Animation[speedName]
        end
        return DefaultThemeStructure.Animation[speedName]
    end

    --// Get Glass Settings
    function Manager.GetGlassSettings()
        if CurrentTheme and CurrentTheme.Glass then
            return CurrentTheme.Glass
        end
        return DefaultThemeStructure.Glass
    end

    --// Apply Theme to Element
    function Manager.ApplyTheme(element, category, animate)
        if not element then return end
        if not CurrentTheme then return end

        category = category or "Surface"

        local colors = CurrentTheme.Colors
        local duration = animate and CurrentTheme.Animation.Normal or 0

        -- Track element for future updates
        TrackedElements[element] = category

        -- Apply based on category
        if category == "Background" then
            if duration > 0 then
                -- Use TweenService if available
                local TweenService = game:GetService("TweenService")
                local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                TweenService:Create(element, tweenInfo, {
                    BackgroundColor3 = colors.Background,
                }):Play()
            else
                element.BackgroundColor3 = colors.Background
            end
        elseif category == "Surface" then
            if duration > 0 then
                local TweenService = game:GetService("TweenService")
                local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                TweenService:Create(element, tweenInfo, {
                    BackgroundColor3 = colors.Surface,
                }):Play()
            else
                element.BackgroundColor3 = colors.Surface
            end
        elseif category == "Primary" then
            if duration > 0 then
                local TweenService = game:GetService("TweenService")
                local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                TweenService:Create(element, tweenInfo, {
                    BackgroundColor3 = colors.Primary,
                }):Play()
            else
                element.BackgroundColor3 = colors.Primary
            end
        elseif category == "Text" then
            if element:IsA("TextLabel") or element:IsA("TextButton") or element:IsA("TextBox") then
                if duration > 0 then
                    local TweenService = game:GetService("TweenService")
                    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                    TweenService:Create(element, tweenInfo, {
                        TextColor3 = colors.Text,
                    }):Play()
                else
                    element.TextColor3 = colors.Text
                end
            end
        end
    end

    --// Untrack Element
    function Manager.UntrackElement(element)
        TrackedElements[element] = nil
    end

    --// Clear Tracking
    function Manager.ClearTracking()
        TrackedElements = {}
    end

    --// Export Default Structure
    Manager.DefaultStructure = DefaultThemeStructure

    --// Initialize
    InitializeDefaultTheme()

    return Manager


end


-- ============================================================================
-- Module: NexusUI/Themes/init
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/init"] = function()
    local script = CreateMockScript("NexusUI/Themes/init")
    
    --[[
        NexusUI Theme System
        Comprehensive theming with 25+ presets

        Features:
        - Dynamic theme switching
        - Custom theme creation
        - Theme inheritance
        - Color palette generation
        - Accent color customization
    ]]

    --// Themes Module
    local Themes = {}

    --// Load sub-modules
    Themes.Manager = NexusRequire("NexusUI/Themes/Manager")
    Themes.Builder = NexusRequire("NexusUI/Themes/Builder")
    Themes.Palette = NexusRequire("NexusUI/Themes/Palette")
    Themes.Presets = NexusRequire("NexusUI/Themes/Presets")
    Themes.Effects = NexusRequire("NexusUI/Themes/Effects")

    --// Quick Access

    -- Get current theme
    function Themes.GetCurrent()
        return Themes.Manager.GetCurrentTheme()
    end

    -- Set theme by name
    function Themes.Set(themeName, animate)
        return Themes.Manager.SetTheme(themeName, animate)
    end

    -- Get theme by name
    function Themes.Get(themeName)
        return Themes.Manager.GetTheme(themeName)
    end

    -- Register custom theme
    function Themes.Register(theme)
        return Themes.Manager.RegisterTheme(theme)
    end

    -- Create new theme
    function Themes.Create(name, baseTheme)
        return Themes.Builder.Create(name, baseTheme)
    end

    -- Generate palette from color
    function Themes.GeneratePalette(baseColor)
        return Themes.Palette.Generate(baseColor)
    end

    -- Get all theme names
    function Themes.GetAvailable()
        return Themes.Manager.GetAvailableThemes()
    end

    -- Apply theme to element
    function Themes.ApplyTo(element, category)
        return Themes.Manager.ApplyTheme(element, category)
    end

    -- Subscribe to theme changes
    function Themes.OnChange(callback)
        return Themes.Manager.OnThemeChange(callback)
    end

    -- Get color from current theme
    function Themes.Color(colorName)
        return Themes.Manager.GetColor(colorName)
    end

    -- Get font from current theme
    function Themes.Font(fontName)
        return Themes.Manager.GetFont(fontName)
    end

    return Themes


end


-- ============================================================================
-- Module: NexusUI/Effects/LiquidGlass
-- ============================================================================
NexusUI_Modules["NexusUI/Effects/LiquidGlass"] = function()
    local script = CreateMockScript("NexusUI/Effects/LiquidGlass")
    
    --[[
        NexusUI Liquid Glass Effect
        Premium liquid glass effect with refraction-like visuals
    ]]

    --// Services
    local RunService = game:GetService("RunService")
    local TweenService = game:GetService("TweenService")

    --// Liquid Glass Module
    local LiquidGlass = {}
    LiquidGlass.ClassName = "LiquidGlassEffect"

    --// Active Effects
    local ActiveEffects = {}
    local EffectIdCounter = 0

    local function GenerateEffectId()
        EffectIdCounter = EffectIdCounter + 1
        return "liquidglass_" .. EffectIdCounter
    end

    --// Default Configuration
    local DefaultConfig = {
        BackgroundTransparency = 0.75,
        TintColor = Color3.fromRGB(40, 42, 54),
        BorderColor = Color3.fromRGB(255, 255, 255),
        BorderTransparency = 0.6,
        BorderThickness = 1,
        CornerRadius = UDim.new(0, 12),
        RefractionStrength = 0.15,
        ChromaticAberration = true,
        ShimmerEnabled = true,
        ShimmerSpeed = 3,
        ShimmerOpacity = 0.1,
        HighlightEnabled = true,
        HighlightAngle = -45,
        AnimateOnHover = true,
        HoverGlow = true,
        GlowColor = Color3.fromRGB(99, 102, 241),
        GlowSize = 8,
        GlowTransparency = 0.8,
    }

    --// Create the liquid glass effect
    function LiquidGlass.Apply(element, config)
        if not element then
            warn("LiquidGlass.Apply: No element provided")
            return nil
        end

        config = config or {}

        -- Merge with defaults
        for key, defaultValue in pairs(DefaultConfig) do
            if config[key] == nil then
                config[key] = defaultValue
            end
        end

        local effectId = GenerateEffectId()
        local effectData = {
            Id = effectId,
            Element = element,
            Config = config,
            Components = {},
            Connections = {},
            IsHovered = false,
        }

        -- Store original properties
        effectData.OriginalProperties = {
            BackgroundTransparency = element.BackgroundTransparency,
            BackgroundColor3 = element.BackgroundColor3,
            BorderSizePixel = element.BorderSizePixel,
        }

        -- Apply base transparency and color
        element.BackgroundTransparency = config.BackgroundTransparency
        element.BackgroundColor3 = config.TintColor
        element.BorderSizePixel = 0

        -- Add corner radius
        local corner = element:FindFirstChild("LG_Corner") or Instance.new("UICorner")
        corner.Name = "LG_Corner"
        corner.CornerRadius = config.CornerRadius
        corner.Parent = element
        effectData.Components.Corner = corner

        -- Add border stroke
        local stroke = element:FindFirstChild("LG_Stroke") or Instance.new("UIStroke")
        stroke.Name = "LG_Stroke"
        stroke.Color = config.BorderColor
        stroke.Transparency = config.BorderTransparency
        stroke.Thickness = config.BorderThickness
        stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        stroke.Parent = element
        effectData.Components.Stroke = stroke

        -- Add highlight gradient (top-left light reflection)
        if config.HighlightEnabled then
            local highlightGradient = element:FindFirstChild("LG_Highlight") or Instance.new("UIGradient")
            highlightGradient.Name = "LG_Highlight"
            highlightGradient.Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
                ColorSequenceKeypoint.new(0.3, Color3.fromRGB(200, 200, 220)),
                ColorSequenceKeypoint.new(0.7, config.TintColor),
                ColorSequenceKeypoint.new(1, config.TintColor),
            })
            highlightGradient.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 0.85),
                NumberSequenceKeypoint.new(0.3, 0.92),
                NumberSequenceKeypoint.new(0.7, 0.98),
                NumberSequenceKeypoint.new(1, 1),
            })
            highlightGradient.Rotation = config.HighlightAngle
            highlightGradient.Parent = element
            effectData.Components.HighlightGradient = highlightGradient
        end

        -- Add shimmer effect (animated light sweep)
        if config.ShimmerEnabled then
            local shimmerFrame = Instance.new("Frame")
            shimmerFrame.Name = "LG_ShimmerFrame"
            shimmerFrame.Size = UDim2.new(1, 0, 1, 0)
            shimmerFrame.BackgroundTransparency = 1
            shimmerFrame.ClipsDescendants = true
            shimmerFrame.ZIndex = element.ZIndex + 1
            shimmerFrame.Parent = element

            local shimmerCorner = Instance.new("UICorner")
            shimmerCorner.CornerRadius = config.CornerRadius
            shimmerCorner.Parent = shimmerFrame

            local shimmer = Instance.new("Frame")
            shimmer.Name = "LG_Shimmer"
            shimmer.Size = UDim2.new(0.5, 0, 2, 0)
            shimmer.Position = UDim2.new(-0.5, 0, -0.5, 0)
            shimmer.AnchorPoint = Vector2.new(0, 0)
            shimmer.Rotation = 20
            shimmer.BackgroundTransparency = 1
            shimmer.ZIndex = element.ZIndex + 2
            shimmer.Parent = shimmerFrame

            local shimmerGradient = Instance.new("UIGradient")
            shimmerGradient.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
            shimmerGradient.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 1),
                NumberSequenceKeypoint.new(0.4, 1 - config.ShimmerOpacity),
                NumberSequenceKeypoint.new(0.5, 1 - config.ShimmerOpacity * 1.5),
                NumberSequenceKeypoint.new(0.6, 1 - config.ShimmerOpacity),
                NumberSequenceKeypoint.new(1, 1),
            })
            shimmerGradient.Parent = shimmer

            effectData.Components.ShimmerFrame = shimmerFrame
            effectData.Components.Shimmer = shimmer

            -- Animate shimmer
            local function animateShimmer()
                while effectData.Components.Shimmer and effectData.Components.Shimmer.Parent do
                    shimmer.Position = UDim2.new(-0.5, 0, -0.5, 0)

                    local tween = TweenService:Create(shimmer, TweenInfo.new(config.ShimmerSpeed, Enum.EasingStyle.Linear), {
                        Position = UDim2.new(1.5, 0, -0.5, 0),
                    })
                    tween:Play()
                    tween.Completed:Wait()

                    task.wait(2)
                end
            end

            task.spawn(animateShimmer)
        end

        -- Add chromatic aberration effect (RGB split)
        if config.ChromaticAberration then
            -- Red channel (slight offset left)
            local chromaticRed = Instance.new("Frame")
            chromaticRed.Name = "LG_ChromaticRed"
            chromaticRed.Size = UDim2.new(1, 2, 1, 0)
            chromaticRed.Position = UDim2.new(0, -1, 0, 0)
            chromaticRed.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
            chromaticRed.BackgroundTransparency = 0.97
            chromaticRed.BorderSizePixel = 0
            chromaticRed.ZIndex = element.ZIndex - 1

            local redCorner = Instance.new("UICorner")
            redCorner.CornerRadius = config.CornerRadius
            redCorner.Parent = chromaticRed

            chromaticRed.Parent = element
            effectData.Components.ChromaticRed = chromaticRed

            -- Blue channel (slight offset right)
            local chromaticBlue = Instance.new("Frame")
            chromaticBlue.Name = "LG_ChromaticBlue"
            chromaticBlue.Size = UDim2.new(1, 2, 1, 0)
            chromaticBlue.Position = UDim2.new(0, 1, 0, 0)
            chromaticBlue.BackgroundColor3 = Color3.fromRGB(100, 100, 255)
            chromaticBlue.BackgroundTransparency = 0.97
            chromaticBlue.BorderSizePixel = 0
            chromaticBlue.ZIndex = element.ZIndex - 1

            local blueCorner = Instance.new("UICorner")
            blueCorner.CornerRadius = config.CornerRadius
            blueCorner.Parent = chromaticBlue

            chromaticBlue.Parent = element
            effectData.Components.ChromaticBlue = chromaticBlue
        end

        -- Add hover effects
        if config.AnimateOnHover then
            local mouseEnter = element.MouseEnter:Connect(function()
                effectData.IsHovered = true

                -- Brighten on hover
                TweenService:Create(element, TweenInfo.new(0.2), {
                    BackgroundTransparency = config.BackgroundTransparency - 0.1,
                }):Play()

                TweenService:Create(stroke, TweenInfo.new(0.2), {
                    Transparency = config.BorderTransparency - 0.2,
                }):Play()

                if config.HoverGlow then
                    LiquidGlass._showGlow(effectData)
                end
            end)

            local mouseLeave = element.MouseLeave:Connect(function()
                effectData.IsHovered = false

                TweenService:Create(element, TweenInfo.new(0.2), {
                    BackgroundTransparency = config.BackgroundTransparency,
                }):Play()

                TweenService:Create(stroke, TweenInfo.new(0.2), {
                    Transparency = config.BorderTransparency,
                }):Play()

                if config.HoverGlow then
                    LiquidGlass._hideGlow(effectData)
                end
            end)

            table.insert(effectData.Connections, mouseEnter)
            table.insert(effectData.Connections, mouseLeave)
        end

        -- Store effect
        ActiveEffects[effectId] = effectData

        -- Return effect handle
        return {
            Id = effectId,

            SetTransparency = function(transparency)
                config.BackgroundTransparency = transparency
                if not effectData.IsHovered then
                    element.BackgroundTransparency = transparency
                end
            end,

            SetTintColor = function(color)
                config.TintColor = color
                element.BackgroundColor3 = color
            end,

            SetBorderColor = function(color)
                config.BorderColor = color
                stroke.Color = color
            end,

            SetCornerRadius = function(radius)
                config.CornerRadius = radius
                corner.CornerRadius = radius
            end,

            ShowGlow = function()
                LiquidGlass._showGlow(effectData)
            end,

            HideGlow = function()
                LiquidGlass._hideGlow(effectData)
            end,

            Remove = function()
                LiquidGlass.Remove(effectId)
            end,
        }
    end

    --// Show glow effect
    function LiquidGlass._showGlow(effectData)
        if effectData.Components.GlowFrame then
            TweenService:Create(effectData.Components.GlowFrame, TweenInfo.new(0.2), {
                BackgroundTransparency = effectData.Config.GlowTransparency,
            }):Play()
            return
        end

        local element = effectData.Element
        local config = effectData.Config

        local glowFrame = Instance.new("Frame")
        glowFrame.Name = "LG_Glow"
        glowFrame.Size = UDim2.new(1, config.GlowSize * 2, 1, config.GlowSize * 2)
        glowFrame.Position = UDim2.new(0, -config.GlowSize, 0, -config.GlowSize)
        glowFrame.BackgroundColor3 = config.GlowColor
        glowFrame.BackgroundTransparency = 1
        glowFrame.BorderSizePixel = 0
        glowFrame.ZIndex = element.ZIndex - 2

        local glowCorner = Instance.new("UICorner")
        glowCorner.CornerRadius = UDim.new(config.CornerRadius.Scale, config.CornerRadius.Offset + config.GlowSize)
        glowCorner.Parent = glowFrame

        glowFrame.Parent = element.Parent
        effectData.Components.GlowFrame = glowFrame

        -- Position glow behind element
        glowFrame.Position = UDim2.new(
            element.Position.X.Scale,
            element.Position.X.Offset - config.GlowSize,
            element.Position.Y.Scale,
            element.Position.Y.Offset - config.GlowSize
        )
        glowFrame.Size = UDim2.new(
            element.Size.X.Scale,
            element.Size.X.Offset + config.GlowSize * 2,
            element.Size.Y.Scale,
            element.Size.Y.Offset + config.GlowSize * 2
        )

        TweenService:Create(glowFrame, TweenInfo.new(0.2), {
            BackgroundTransparency = config.GlowTransparency,
        }):Play()
    end

    --// Hide glow effect
    function LiquidGlass._hideGlow(effectData)
        if effectData.Components.GlowFrame then
            TweenService:Create(effectData.Components.GlowFrame, TweenInfo.new(0.2), {
                BackgroundTransparency = 1,
            }):Play()
        end
    end

    --// Remove effect
    function LiquidGlass.Remove(effectId)
        local effectData = ActiveEffects[effectId]
        if not effectData then return end

        -- Disconnect all connections
        for _, connection in ipairs(effectData.Connections) do
            connection:Disconnect()
        end

        -- Destroy all components
        for _, component in pairs(effectData.Components) do
            if component and component.Parent then
                component:Destroy()
            end
        end

        -- Restore original properties
        if effectData.Element and effectData.OriginalProperties then
            for prop, value in pairs(effectData.OriginalProperties) do
                pcall(function()
                    effectData.Element[prop] = value
                end)
            end
        end

        ActiveEffects[effectId] = nil
    end

    --// Remove all effects
    function LiquidGlass.RemoveAll()
        for effectId, _ in pairs(ActiveEffects) do
            LiquidGlass.Remove(effectId)
        end
    end

    --// Get effect count
    function LiquidGlass.GetActiveCount()
        local count = 0
        for _ in pairs(ActiveEffects) do
            count = count + 1
        end
        return count
    end

    return LiquidGlass


end


-- ============================================================================
-- Module: NexusUI/Effects/Glassmorphism
-- ============================================================================
NexusUI_Modules["NexusUI/Effects/Glassmorphism"] = function()
    local script = CreateMockScript("NexusUI/Effects/Glassmorphism")
    
    --[[
        NexusUI Glassmorphism Effect
        Modern frosted glass UI effect
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Glassmorphism Module
    local Glassmorphism = {}
    Glassmorphism.ClassName = "GlassmorphismEffect"

    --// Active Effects
    local ActiveEffects = {}
    local EffectIdCounter = 0

    local function GenerateEffectId()
        EffectIdCounter = EffectIdCounter + 1
        return "glass_" .. EffectIdCounter
    end

    --// Default Configuration
    local DefaultConfig = {
        BackgroundTransparency = 0.6,
        TintColor = Color3.fromRGB(255, 255, 255),
        BlurIntensity = 0.8,
        BorderColor = Color3.fromRGB(255, 255, 255),
        BorderTransparency = 0.7,
        BorderThickness = 1,
        CornerRadius = UDim.new(0, 16),
        NoiseEnabled = true,
        NoiseOpacity = 0.03,
        ShadowEnabled = true,
        ShadowOffset = Vector2.new(0, 8),
        ShadowBlur = 24,
        ShadowTransparency = 0.7,
        InnerGlow = false,
        InnerGlowColor = Color3.fromRGB(255, 255, 255),
        InnerGlowTransparency = 0.95,
    }

    --// Apply glassmorphism effect
    function Glassmorphism.Apply(element, config)
        if not element then
            warn("Glassmorphism.Apply: No element provided")
            return nil
        end

        config = config or {}

        -- Merge with defaults
        for key, defaultValue in pairs(DefaultConfig) do
            if config[key] == nil then
                config[key] = defaultValue
            end
        end

        local effectId = GenerateEffectId()
        local effectData = {
            Id = effectId,
            Element = element,
            Config = config,
            Components = {},
            Connections = {},
        }

        -- Store original properties
        effectData.OriginalProperties = {
            BackgroundTransparency = element.BackgroundTransparency,
            BackgroundColor3 = element.BackgroundColor3,
            BorderSizePixel = element.BorderSizePixel,
        }

        -- Apply base glass
        element.BackgroundTransparency = config.BackgroundTransparency
        element.BackgroundColor3 = config.TintColor
        element.BorderSizePixel = 0

        -- Add corner radius
        local corner = element:FindFirstChild("GM_Corner") or Instance.new("UICorner")
        corner.Name = "GM_Corner"
        corner.CornerRadius = config.CornerRadius
        corner.Parent = element
        effectData.Components.Corner = corner

        -- Add border
        local stroke = element:FindFirstChild("GM_Stroke") or Instance.new("UIStroke")
        stroke.Name = "GM_Stroke"
        stroke.Color = config.BorderColor
        stroke.Transparency = config.BorderTransparency
        stroke.Thickness = config.BorderThickness
        stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        stroke.Parent = element
        effectData.Components.Stroke = stroke

        -- Add subtle gradient for depth
        local gradient = element:FindFirstChild("GM_Gradient") or Instance.new("UIGradient")
        gradient.Name = "GM_Gradient"
        gradient.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
            ColorSequenceKeypoint.new(1, config.TintColor),
        })
        gradient.Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 0.9),
            NumberSequenceKeypoint.new(1, 0.95),
        })
        gradient.Rotation = -45
        gradient.Parent = element
        effectData.Components.Gradient = gradient

        -- Add noise texture for frosted effect
        if config.NoiseEnabled then
            local noiseFrame = Instance.new("Frame")
            noiseFrame.Name = "GM_NoiseFrame"
            noiseFrame.Size = UDim2.new(1, 0, 1, 0)
            noiseFrame.BackgroundTransparency = 1
            noiseFrame.ClipsDescendants = true
            noiseFrame.ZIndex = element.ZIndex + 1

            local noiseCorner = Instance.new("UICorner")
            noiseCorner.CornerRadius = config.CornerRadius
            noiseCorner.Parent = noiseFrame

            local noise = Instance.new("ImageLabel")
            noise.Name = "GM_Noise"
            noise.Size = UDim2.new(1, 0, 1, 0)
            noise.BackgroundTransparency = 1
            noise.Image = "rbxassetid://6031094678" -- Noise texture
            noise.ImageTransparency = 1 - config.NoiseOpacity
            noise.ScaleType = Enum.ScaleType.Tile
            noise.TileSize = UDim2.new(0, 256, 0, 256)
            noise.ZIndex = element.ZIndex + 2
            noise.Parent = noiseFrame

            noiseFrame.Parent = element
            effectData.Components.NoiseFrame = noiseFrame
            effectData.Components.Noise = noise
        end

        -- Add shadow
        if config.ShadowEnabled then
            local shadowFrame = Instance.new("ImageLabel")
            shadowFrame.Name = "GM_Shadow"
            shadowFrame.Size = UDim2.new(1, config.ShadowBlur, 1, config.ShadowBlur)
            shadowFrame.Position = UDim2.new(0.5, config.ShadowOffset.X, 0.5, config.ShadowOffset.Y)
            shadowFrame.AnchorPoint = Vector2.new(0.5, 0.5)
            shadowFrame.BackgroundTransparency = 1
            shadowFrame.Image = "rbxassetid://6015897843" -- Shadow image
            shadowFrame.ImageTransparency = config.ShadowTransparency
            shadowFrame.ImageColor3 = Color3.fromRGB(0, 0, 0)
            shadowFrame.ScaleType = Enum.ScaleType.Slice
            shadowFrame.SliceCenter = Rect.new(49, 49, 450, 450)
            shadowFrame.ZIndex = element.ZIndex - 1
            shadowFrame.Parent = element.Parent

            -- Position shadow relative to element
            shadowFrame.Position = UDim2.new(
                element.Position.X.Scale,
                element.Position.X.Offset - config.ShadowBlur/2 + config.ShadowOffset.X,
                element.Position.Y.Scale,
                element.Position.Y.Offset - config.ShadowBlur/2 + config.ShadowOffset.Y
            )
            shadowFrame.Size = UDim2.new(
                element.Size.X.Scale,
                element.Size.X.Offset + config.ShadowBlur,
                element.Size.Y.Scale,
                element.Size.Y.Offset + config.ShadowBlur
            )

            effectData.Components.Shadow = shadowFrame
        end

        -- Add inner glow
        if config.InnerGlow then
            local innerGlowStroke = Instance.new("UIStroke")
            innerGlowStroke.Name = "GM_InnerGlow"
            innerGlowStroke.Color = config.InnerGlowColor
            innerGlowStroke.Transparency = config.InnerGlowTransparency
            innerGlowStroke.Thickness = 4
            innerGlowStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
            innerGlowStroke.Parent = element
            effectData.Components.InnerGlow = innerGlowStroke
        end

        -- Store effect
        ActiveEffects[effectId] = effectData

        -- Return effect handle
        return {
            Id = effectId,

            SetTransparency = function(transparency)
                config.BackgroundTransparency = transparency
                element.BackgroundTransparency = transparency
            end,

            SetTintColor = function(color)
                config.TintColor = color
                element.BackgroundColor3 = color
            end,

            SetBorderColor = function(color)
                config.BorderColor = color
                stroke.Color = color
            end,

            SetNoiseOpacity = function(opacity)
                config.NoiseOpacity = opacity
                if effectData.Components.Noise then
                    effectData.Components.Noise.ImageTransparency = 1 - opacity
                end
            end,

            SetShadowOffset = function(offset)
                config.ShadowOffset = offset
                if effectData.Components.Shadow then
                    effectData.Components.Shadow.Position = UDim2.new(
                        element.Position.X.Scale,
                        element.Position.X.Offset - config.ShadowBlur/2 + offset.X,
                        element.Position.Y.Scale,
                        element.Position.Y.Offset - config.ShadowBlur/2 + offset.Y
                    )
                end
            end,

            AnimateIn = function(duration)
                duration = duration or 0.3

                element.BackgroundTransparency = 1
                if stroke then stroke.Transparency = 1 end
                if effectData.Components.Shadow then effectData.Components.Shadow.ImageTransparency = 1 end

                TweenService:Create(element, TweenInfo.new(duration), {
                    BackgroundTransparency = config.BackgroundTransparency,
                }):Play()

                if stroke then
                    TweenService:Create(stroke, TweenInfo.new(duration), {
                        Transparency = config.BorderTransparency,
                    }):Play()
                end

                if effectData.Components.Shadow then
                    TweenService:Create(effectData.Components.Shadow, TweenInfo.new(duration), {
                        ImageTransparency = config.ShadowTransparency,
                    }):Play()
                end
            end,

            AnimateOut = function(duration)
                duration = duration or 0.3

                TweenService:Create(element, TweenInfo.new(duration), {
                    BackgroundTransparency = 1,
                }):Play()

                if stroke then
                    TweenService:Create(stroke, TweenInfo.new(duration), {
                        Transparency = 1,
                    }):Play()
                end

                if effectData.Components.Shadow then
                    TweenService:Create(effectData.Components.Shadow, TweenInfo.new(duration), {
                        ImageTransparency = 1,
                    }):Play()
                end
            end,

            Remove = function()
                Glassmorphism.Remove(effectId)
            end,
        }
    end

    --// Remove effect
    function Glassmorphism.Remove(effectId)
        local effectData = ActiveEffects[effectId]
        if not effectData then return end

        -- Disconnect all connections
        for _, connection in ipairs(effectData.Connections) do
            connection:Disconnect()
        end

        -- Destroy all components
        for _, component in pairs(effectData.Components) do
            if component and component.Parent then
                component:Destroy()
            end
        end

        -- Restore original properties
        if effectData.Element and effectData.OriginalProperties then
            for prop, value in pairs(effectData.OriginalProperties) do
                pcall(function()
                    effectData.Element[prop] = value
                end)
            end
        end

        ActiveEffects[effectId] = nil
    end

    --// Remove all effects
    function Glassmorphism.RemoveAll()
        for effectId, _ in pairs(ActiveEffects) do
            Glassmorphism.Remove(effectId)
        end
    end

    --// Preset configurations
    Glassmorphism.Presets = {
        Light = {
            BackgroundTransparency = 0.5,
            TintColor = Color3.fromRGB(255, 255, 255),
            BorderColor = Color3.fromRGB(255, 255, 255),
            BorderTransparency = 0.6,
            NoiseOpacity = 0.02,
            ShadowTransparency = 0.8,
        },

        Dark = {
            BackgroundTransparency = 0.6,
            TintColor = Color3.fromRGB(30, 30, 35),
            BorderColor = Color3.fromRGB(80, 80, 90),
            BorderTransparency = 0.7,
            NoiseOpacity = 0.05,
            ShadowTransparency = 0.6,
        },

        Colorful = {
            BackgroundTransparency = 0.7,
            TintColor = Color3.fromRGB(99, 102, 241),
            BorderColor = Color3.fromRGB(167, 139, 250),
            BorderTransparency = 0.5,
            NoiseOpacity = 0.03,
            ShadowTransparency = 0.7,
            InnerGlow = true,
            InnerGlowColor = Color3.fromRGB(167, 139, 250),
        },

        Minimal = {
            BackgroundTransparency = 0.8,
            TintColor = Color3.fromRGB(245, 245, 250),
            BorderColor = Color3.fromRGB(200, 200, 210),
            BorderTransparency = 0.8,
            BorderThickness = 0.5,
            NoiseEnabled = false,
            ShadowEnabled = false,
        },
    }

    function Glassmorphism.GetPreset(name)
        return Glassmorphism.Presets[name]
    end

    return Glassmorphism


end


-- ============================================================================
-- Module: NexusUI/Effects/Blur
-- ============================================================================
NexusUI_Modules["NexusUI/Effects/Blur"] = function()
    local script = CreateMockScript("NexusUI/Effects/Blur")
    
    --[[
        NexusUI Blur Effect
        Simulated blur effects for UI elements
    ]]

    --// Blur Module
    local Blur = {}
    Blur.ClassName = "BlurEffect"

    --// Note: Roblox doesn't have true UI blur, so we simulate it with transparency and overlays

    --// Default Configuration
    local DefaultConfig = {
        BlurSize = 10,
        BlurColor = Color3.fromRGB(0, 0, 0),
        BlurTransparency = 0.5,
        Layers = 3,
        Spread = 2,
    }

    --// Apply blur effect (simulated)
    function Blur.Apply(element, config)
        if not element then
            warn("Blur.Apply: No element provided")
            return nil
        end

        config = config or {}

        -- Merge with defaults
        for key, defaultValue in pairs(DefaultConfig) do
            if config[key] == nil then
                config[key] = defaultValue
            end
        end

        local blurLayers = {}

        -- Create blur layers
        for i = 1, config.Layers do
            local offset = i * config.Spread
            local layerTransparency = config.BlurTransparency + (i / config.Layers) * (1 - config.BlurTransparency)

            local blurLayer = Instance.new("Frame")
            blurLayer.Name = "BlurLayer_" .. i
            blurLayer.Size = UDim2.new(1, offset * 2, 1, offset * 2)
            blurLayer.Position = UDim2.new(0, -offset, 0, -offset)
            blurLayer.BackgroundColor3 = config.BlurColor
            blurLayer.BackgroundTransparency = layerTransparency
            blurLayer.BorderSizePixel = 0
            blurLayer.ZIndex = element.ZIndex - i

            -- Match corner radius
            local elementCorner = element:FindFirstChildOfClass("UICorner")
            if elementCorner then
                local corner = Instance.new("UICorner")
                corner.CornerRadius = UDim.new(elementCorner.CornerRadius.Scale, elementCorner.CornerRadius.Offset + offset)
                corner.Parent = blurLayer
            end

            blurLayer.Parent = element.Parent
            table.insert(blurLayers, blurLayer)
        end

        return {
            Layers = blurLayers,

            SetColor = function(color)
                for _, layer in ipairs(blurLayers) do
                    layer.BackgroundColor3 = color
                end
            end,

            SetTransparency = function(transparency)
                for i, layer in ipairs(blurLayers) do
                    layer.BackgroundTransparency = transparency + (i / #blurLayers) * (1 - transparency)
                end
            end,

            Remove = function()
                for _, layer in ipairs(blurLayers) do
                    layer:Destroy()
                end
            end,
        }
    end

    --// Background blur for entire screen
    function Blur.ApplyBackground(parent, config)
        config = config or {}

        local transparency = config.Transparency or 0.3
        local color = config.Color or Color3.fromRGB(0, 0, 0)

        local blurFrame = Instance.new("Frame")
        blurFrame.Name = "BackgroundBlur"
        blurFrame.Size = UDim2.new(1, 0, 1, 0)
        blurFrame.BackgroundColor3 = color
        blurFrame.BackgroundTransparency = transparency
        blurFrame.BorderSizePixel = 0
        blurFrame.ZIndex = 1
        blurFrame.Parent = parent

        return {
            Frame = blurFrame,

            SetTransparency = function(t)
                blurFrame.BackgroundTransparency = t
            end,

            SetColor = function(c)
                blurFrame.BackgroundColor3 = c
            end,

            Remove = function()
                blurFrame:Destroy()
            end,
        }
    end

    return Blur


end


-- ============================================================================
-- Module: NexusUI/Effects/Glow
-- ============================================================================
NexusUI_Modules["NexusUI/Effects/Glow"] = function()
    local script = CreateMockScript("NexusUI/Effects/Glow")
    
    --[[
        NexusUI Glow Effect
        Glowing effects for UI elements
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")
    local RunService = game:GetService("RunService")

    --// Glow Module
    local Glow = {}
    Glow.ClassName = "GlowEffect"

    --// Active Effects
    local ActiveEffects = {}
    local EffectIdCounter = 0

    local function GenerateEffectId()
        EffectIdCounter = EffectIdCounter + 1
        return "glow_" .. EffectIdCounter
    end

    --// Default Configuration
    local DefaultConfig = {
        Color = Color3.fromRGB(99, 102, 241),
        Size = 10,
        Transparency = 0.6,
        Animated = false,
        PulseSpeed = 1.5,
        PulseRange = { 0.5, 0.8 },
        Layers = 2,
    }

    --// Apply glow effect
    function Glow.Apply(element, config)
        if not element then
            warn("Glow.Apply: No element provided")
            return nil
        end

        config = config or {}

        -- Merge with defaults
        for key, defaultValue in pairs(DefaultConfig) do
            if config[key] == nil then
                config[key] = defaultValue
            end
        end

        local effectId = GenerateEffectId()
        local effectData = {
            Id = effectId,
            Element = element,
            Config = config,
            GlowLayers = {},
            Connections = {},
        }

        -- Create glow layers
        for i = 1, config.Layers do
            local layerSize = config.Size * (i / config.Layers)
            local layerTransparency = config.Transparency + (1 - config.Transparency) * ((i - 1) / config.Layers)

            local glowLayer = Instance.new("Frame")
            glowLayer.Name = "GlowLayer_" .. i
            glowLayer.Size = UDim2.new(1, layerSize * 2, 1, layerSize * 2)
            glowLayer.Position = UDim2.new(0.5, 0, 0.5, 0)
            glowLayer.AnchorPoint = Vector2.new(0.5, 0.5)
            glowLayer.BackgroundColor3 = config.Color
            glowLayer.BackgroundTransparency = layerTransparency
            glowLayer.BorderSizePixel = 0
            glowLayer.ZIndex = element.ZIndex - 1

            -- Match corner radius
            local elementCorner = element:FindFirstChildOfClass("UICorner")
            if elementCorner then
                local corner = Instance.new("UICorner")
                corner.CornerRadius = UDim.new(elementCorner.CornerRadius.Scale, elementCorner.CornerRadius.Offset + layerSize)
                corner.Parent = glowLayer
            else
                local corner = Instance.new("UICorner")
                corner.CornerRadius = UDim.new(0, layerSize)
                corner.Parent = glowLayer
            end

            glowLayer.Parent = element
            table.insert(effectData.GlowLayers, glowLayer)
        end

        -- Animate if enabled
        if config.Animated then
            local function pulse()
                while effectData.GlowLayers[1] and effectData.GlowLayers[1].Parent do
                    -- Pulse out
                    for _, layer in ipairs(effectData.GlowLayers) do
                        TweenService:Create(layer, TweenInfo.new(config.PulseSpeed / 2, Enum.EasingStyle.Sine), {
                            BackgroundTransparency = config.PulseRange[2],
                        }):Play()
                    end
                    task.wait(config.PulseSpeed / 2)

                    -- Pulse in
                    for _, layer in ipairs(effectData.GlowLayers) do
                        TweenService:Create(layer, TweenInfo.new(config.PulseSpeed / 2, Enum.EasingStyle.Sine), {
                            BackgroundTransparency = config.PulseRange[1],
                        }):Play()
                    end
                    task.wait(config.PulseSpeed / 2)
                end
            end

            task.spawn(pulse)
        end

        -- Store effect
        ActiveEffects[effectId] = effectData

        -- Return effect handle
        return {
            Id = effectId,

            SetColor = function(color)
                config.Color = color
                for _, layer in ipairs(effectData.GlowLayers) do
                    TweenService:Create(layer, TweenInfo.new(0.2), {
                        BackgroundColor3 = color,
                    }):Play()
                end
            end,

            SetSize = function(size)
                config.Size = size
                for i, layer in ipairs(effectData.GlowLayers) do
                    local layerSize = size * (i / #effectData.GlowLayers)
                    TweenService:Create(layer, TweenInfo.new(0.2), {
                        Size = UDim2.new(1, layerSize * 2, 1, layerSize * 2),
                    }):Play()
                end
            end,

            SetTransparency = function(transparency)
                config.Transparency = transparency
                for i, layer in ipairs(effectData.GlowLayers) do
                    local layerTransparency = transparency + (1 - transparency) * ((i - 1) / #effectData.GlowLayers)
                    layer.BackgroundTransparency = layerTransparency
                end
            end,

            Show = function(duration)
                duration = duration or 0.2
                for i, layer in ipairs(effectData.GlowLayers) do
                    local layerTransparency = config.Transparency + (1 - config.Transparency) * ((i - 1) / #effectData.GlowLayers)
                    layer.BackgroundTransparency = 1
                    TweenService:Create(layer, TweenInfo.new(duration), {
                        BackgroundTransparency = layerTransparency,
                    }):Play()
                end
            end,

            Hide = function(duration)
                duration = duration or 0.2
                for _, layer in ipairs(effectData.GlowLayers) do
                    TweenService:Create(layer, TweenInfo.new(duration), {
                        BackgroundTransparency = 1,
                    }):Play()
                end
            end,

            Remove = function()
                Glow.Remove(effectId)
            end,
        }
    end

    --// Remove effect
    function Glow.Remove(effectId)
        local effectData = ActiveEffects[effectId]
        if not effectData then return end

        -- Disconnect connections
        for _, connection in ipairs(effectData.Connections) do
            connection:Disconnect()
        end

        -- Destroy glow layers
        for _, layer in ipairs(effectData.GlowLayers) do
            layer:Destroy()
        end

        ActiveEffects[effectId] = nil
    end

    --// Remove all effects
    function Glow.RemoveAll()
        for effectId, _ in pairs(ActiveEffects) do
            Glow.Remove(effectId)
        end
    end

    --// Quick glow flash
    function Glow.Flash(element, color, duration)
        color = color or Color3.fromRGB(255, 255, 255)
        duration = duration or 0.3

        local glow = Glow.Apply(element, {
            Color = color,
            Size = 15,
            Transparency = 0.3,
            Layers = 3,
        })

        task.delay(duration, function()
            if glow then
                glow.Remove()
            end
        end)

        return glow
    end

    return Glow


end


-- ============================================================================
-- Module: NexusUI/Effects/Shadow
-- ============================================================================
NexusUI_Modules["NexusUI/Effects/Shadow"] = function()
    local script = CreateMockScript("NexusUI/Effects/Shadow")
    
    --[[
        NexusUI Shadow Effect
        Drop shadows for UI elements
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Shadow Module
    local Shadow = {}
    Shadow.ClassName = "ShadowEffect"

    --// Default Configuration
    local DefaultConfig = {
        Color = Color3.fromRGB(0, 0, 0),
        Offset = Vector2.new(0, 4),
        Size = 16,
        Transparency = 0.6,
        Softness = 0.5,
    }

    --// Presets
    Shadow.Presets = {
        None = { Size = 0, Transparency = 1 },
        Small = { Offset = Vector2.new(0, 2), Size = 8, Transparency = 0.75 },
        Medium = { Offset = Vector2.new(0, 4), Size = 16, Transparency = 0.65 },
        Large = { Offset = Vector2.new(0, 8), Size = 24, Transparency = 0.55 },
        XLarge = { Offset = Vector2.new(0, 12), Size = 32, Transparency = 0.45 },
        Floating = { Offset = Vector2.new(0, 16), Size = 40, Transparency = 0.5 },
        Subtle = { Offset = Vector2.new(0, 2), Size = 4, Transparency = 0.85 },
        Sharp = { Offset = Vector2.new(2, 2), Size = 0, Transparency = 0.3 },
    }

    --// Apply shadow effect
    function Shadow.Apply(element, config)
        if not element then
            warn("Shadow.Apply: No element provided")
            return nil
        end

        -- Handle preset
        if type(config) == "string" then
            config = Shadow.Presets[config] or Shadow.Presets.Medium
        end

        config = config or {}

        -- Merge with defaults
        for key, defaultValue in pairs(DefaultConfig) do
            if config[key] == nil then
                config[key] = defaultValue
            end
        end

        -- Create shadow image
        local shadow = Instance.new("ImageLabel")
        shadow.Name = "Shadow"
        shadow.BackgroundTransparency = 1
        shadow.ImageColor3 = config.Color
        shadow.ImageTransparency = config.Transparency
        shadow.Image = "rbxassetid://6015897843" -- Shadow asset
        shadow.ScaleType = Enum.ScaleType.Slice
        shadow.SliceCenter = Rect.new(49, 49, 450, 450)
        shadow.ZIndex = element.ZIndex - 1

        -- Calculate size and position
        local halfSize = config.Size / 2

        shadow.Size = UDim2.new(
            element.Size.X.Scale,
            element.Size.X.Offset + config.Size,
            element.Size.Y.Scale,
            element.Size.Y.Offset + config.Size
        )

        shadow.Position = UDim2.new(
            element.Position.X.Scale,
            element.Position.X.Offset - halfSize + config.Offset.X,
            element.Position.Y.Scale,
            element.Position.Y.Offset - halfSize + config.Offset.Y
        )

        shadow.AnchorPoint = element.AnchorPoint

        shadow.Parent = element.Parent

        -- Update function for when element moves/resizes
        local function updateShadow()
            shadow.Size = UDim2.new(
                element.Size.X.Scale,
                element.Size.X.Offset + config.Size,
                element.Size.Y.Scale,
                element.Size.Y.Offset + config.Size
            )

            shadow.Position = UDim2.new(
                element.Position.X.Scale,
                element.Position.X.Offset - halfSize + config.Offset.X,
                element.Position.Y.Scale,
                element.Position.Y.Offset - halfSize + config.Offset.Y
            )
        end

        -- Return shadow handle
        return {
            Shadow = shadow,

            SetColor = function(color)
                config.Color = color
                shadow.ImageColor3 = color
            end,

            SetOffset = function(offset)
                config.Offset = offset
                updateShadow()
            end,

            SetSize = function(size)
                config.Size = size
                halfSize = size / 2
                updateShadow()
            end,

            SetTransparency = function(transparency)
                config.Transparency = transparency
                shadow.ImageTransparency = transparency
            end,

            Show = function(duration)
                duration = duration or 0.2
                shadow.ImageTransparency = 1
                TweenService:Create(shadow, TweenInfo.new(duration), {
                    ImageTransparency = config.Transparency,
                }):Play()
            end,

            Hide = function(duration)
                duration = duration or 0.2
                TweenService:Create(shadow, TweenInfo.new(duration), {
                    ImageTransparency = 1,
                }):Play()
            end,

            Update = updateShadow,

            Remove = function()
                shadow:Destroy()
            end,
        }
    end

    --// Apply inner shadow
    function Shadow.ApplyInner(element, config)
        config = config or {}

        local color = config.Color or Color3.fromRGB(0, 0, 0)
        local size = config.Size or 8
        local transparency = config.Transparency or 0.8

        -- Create inner shadow using gradient
        local topShadow = Instance.new("Frame")
        topShadow.Name = "InnerShadowTop"
        topShadow.Size = UDim2.new(1, 0, 0, size)
        topShadow.Position = UDim2.new(0, 0, 0, 0)
        topShadow.BackgroundColor3 = color
        topShadow.BorderSizePixel = 0
        topShadow.ZIndex = element.ZIndex + 1

        local topGradient = Instance.new("UIGradient")
        topGradient.Rotation = 90
        topGradient.Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0, transparency),
            NumberSequenceKeypoint.new(1, 1),
        })
        topGradient.Parent = topShadow

        topShadow.Parent = element

        return {
            TopShadow = topShadow,

            Remove = function()
                topShadow:Destroy()
            end,
        }
    end

    return Shadow


end


-- ============================================================================
-- Module: NexusUI/Effects/Gradient
-- ============================================================================
NexusUI_Modules["NexusUI/Effects/Gradient"] = function()
    local script = CreateMockScript("NexusUI/Effects/Gradient")
    
    --[[
        NexusUI Gradient Effect
        Dynamic gradient backgrounds and overlays
    ]]

    --// Services
    local RunService = game:GetService("RunService")
    local TweenService = game:GetService("TweenService")

    --// Gradient Module
    local Gradient = {}
    Gradient.ClassName = "GradientEffect"

    --// Default Configuration
    local DefaultConfig = {
        Colors = {
            Color3.fromRGB(99, 102, 241),
            Color3.fromRGB(168, 85, 247),
        },
        Rotation = 45,
        Animated = false,
        AnimationSpeed = 1,
        AnimationType = "Rotate", -- Rotate, Shift, Pulse
        Transparency = 0,
    }

    --// Presets
    Gradient.Presets = {
        Sunset = {
            Colors = {
                Color3.fromRGB(249, 115, 22),
                Color3.fromRGB(244, 63, 94),
                Color3.fromRGB(168, 85, 247),
            },
            Rotation = 135,
        },

        Ocean = {
            Colors = {
                Color3.fromRGB(6, 182, 212),
                Color3.fromRGB(59, 130, 246),
                Color3.fromRGB(99, 102, 241),
            },
            Rotation = 180,
        },

        Forest = {
            Colors = {
                Color3.fromRGB(16, 185, 129),
                Color3.fromRGB(34, 197, 94),
                Color3.fromRGB(132, 204, 22),
            },
            Rotation = 120,
        },

        Fire = {
            Colors = {
                Color3.fromRGB(239, 68, 68),
                Color3.fromRGB(249, 115, 22),
                Color3.fromRGB(234, 179, 8),
            },
            Rotation = 0,
        },

        Night = {
            Colors = {
                Color3.fromRGB(15, 23, 42),
                Color3.fromRGB(30, 41, 59),
                Color3.fromRGB(51, 65, 85),
            },
            Rotation = 180,
        },

        Rainbow = {
            Colors = {
                Color3.fromRGB(239, 68, 68),
                Color3.fromRGB(249, 115, 22),
                Color3.fromRGB(234, 179, 8),
                Color3.fromRGB(34, 197, 94),
                Color3.fromRGB(59, 130, 246),
                Color3.fromRGB(139, 92, 246),
            },
            Rotation = 90,
        },

        Purple = {
            Colors = {
                Color3.fromRGB(139, 92, 246),
                Color3.fromRGB(168, 85, 247),
                Color3.fromRGB(236, 72, 153),
            },
            Rotation = 135,
        },

        Mint = {
            Colors = {
                Color3.fromRGB(110, 231, 183),
                Color3.fromRGB(52, 211, 153),
                Color3.fromRGB(20, 184, 166),
            },
            Rotation = 90,
        },
    }

    --// Apply gradient effect
    function Gradient.Apply(element, config)
        if not element then
            warn("Gradient.Apply: No element provided")
            return nil
        end

        -- Handle preset
        if type(config) == "string" then
            config = Gradient.Presets[config] or Gradient.Presets.Sunset
        end

        config = config or {}

        -- Merge with defaults
        for key, defaultValue in pairs(DefaultConfig) do
            if config[key] == nil then
                config[key] = defaultValue
            end
        end

        -- Build color sequence
        local colorKeypoints = {}
        for i, color in ipairs(config.Colors) do
            local time = (i - 1) / (#config.Colors - 1)
            table.insert(colorKeypoints, ColorSequenceKeypoint.new(time, color))
        end

        -- Create gradient
        local gradient = element:FindFirstChild("GradientEffect") or Instance.new("UIGradient")
        gradient.Name = "GradientEffect"
        gradient.Color = ColorSequence.new(colorKeypoints)
        gradient.Rotation = config.Rotation

        if config.Transparency > 0 then
            gradient.Transparency = NumberSequence.new(config.Transparency)
        end

        gradient.Parent = element

        -- Animation
        local connection = nil

        if config.Animated then
            if config.AnimationType == "Rotate" then
                connection = RunService.Heartbeat:Connect(function(dt)
                    gradient.Rotation = (gradient.Rotation + dt * config.AnimationSpeed * 60) % 360
                end)
            elseif config.AnimationType == "Shift" then
                local offset = 0
                connection = RunService.Heartbeat:Connect(function(dt)
                    offset = (offset + dt * config.AnimationSpeed * 0.5) % 2
                    gradient.Offset = Vector2.new(offset - 1, 0)
                end)
            elseif config.AnimationType == "Pulse" then
                task.spawn(function()
                    while gradient.Parent do
                        TweenService:Create(gradient, TweenInfo.new(config.AnimationSpeed / 2), {
                            Offset = Vector2.new(0.1, 0.1),
                        }):Play()
                        task.wait(config.AnimationSpeed / 2)

                        TweenService:Create(gradient, TweenInfo.new(config.AnimationSpeed / 2), {
                            Offset = Vector2.new(-0.1, -0.1),
                        }):Play()
                        task.wait(config.AnimationSpeed / 2)
                    end
                end)
            end
        end

        -- Return gradient handle
        return {
            Gradient = gradient,

            SetColors = function(colors)
                local newKeypoints = {}
                for i, color in ipairs(colors) do
                    local time = (i - 1) / (#colors - 1)
                    table.insert(newKeypoints, ColorSequenceKeypoint.new(time, color))
                end
                gradient.Color = ColorSequence.new(newKeypoints)
            end,

            SetRotation = function(rotation)
                gradient.Rotation = rotation
            end,

            SetTransparency = function(transparency)
                gradient.Transparency = NumberSequence.new(transparency)
            end,

            AnimateTo = function(newColors, duration)
                duration = duration or 0.5
                -- Note: Roblox doesn't support tweening ColorSequence directly
                -- So we do it manually
                local startColors = {}
                for _, kp in ipairs(gradient.Color.Keypoints) do
                    table.insert(startColors, kp.Value)
                end

                local startTime = os.clock()
                local tweenConn

                tweenConn = RunService.Heartbeat:Connect(function()
                    local elapsed = os.clock() - startTime
                    local progress = math.min(elapsed / duration, 1)

                    local interpolatedKeypoints = {}
                    for i, endColor in ipairs(newColors) do
                        local time = (i - 1) / (#newColors - 1)
                        local startColor = startColors[math.min(i, #startColors)] or startColors[#startColors]
                        local interpolated = startColor:Lerp(endColor, progress)
                        table.insert(interpolatedKeypoints, ColorSequenceKeypoint.new(time, interpolated))
                    end

                    gradient.Color = ColorSequence.new(interpolatedKeypoints)

                    if progress >= 1 then
                        tweenConn:Disconnect()
                    end
                end)
            end,

            StopAnimation = function()
                if connection then
                    connection:Disconnect()
                    connection = nil
                end
            end,

            Remove = function()
                if connection then
                    connection:Disconnect()
                end
                gradient:Destroy()
            end,
        }
    end

    --// Create mesh gradient (multiple overlapping gradients)
    function Gradient.ApplyMesh(element, config)
        config = config or {}

        local layers = config.Layers or 3
        local colors = config.Colors or Gradient.Presets.Sunset.Colors
        local gradients = {}

        for i = 1, layers do
            local layerColors = {}
            for j = 1, 2 do
                local colorIndex = ((i + j - 2) % #colors) + 1
                table.insert(layerColors, colors[colorIndex])
            end

            local overlay = Instance.new("Frame")
            overlay.Name = "MeshGradientLayer_" .. i
            overlay.Size = UDim2.new(1, 0, 1, 0)
            overlay.BackgroundTransparency = 0.5 + (i / layers) * 0.3
            overlay.BackgroundColor3 = Color3.new(1, 1, 1)
            overlay.BorderSizePixel = 0
            overlay.ZIndex = element.ZIndex + i

            local gradient = Instance.new("UIGradient")
            gradient.Color = ColorSequence.new(layerColors)
            gradient.Rotation = (360 / layers) * (i - 1)
            gradient.Parent = overlay

            -- Match corner
            local elementCorner = element:FindFirstChildOfClass("UICorner")
            if elementCorner then
                local corner = Instance.new("UICorner")
                corner.CornerRadius = elementCorner.CornerRadius
                corner.Parent = overlay
            end

            overlay.Parent = element
            table.insert(gradients, { Frame = overlay, Gradient = gradient })
        end

        return {
            Gradients = gradients,

            Remove = function()
                for _, g in ipairs(gradients) do
                    g.Frame:Destroy()
                end
            end,
        }
    end

    return Gradient


end


-- ============================================================================
-- Module: NexusUI/Effects/Particles
-- ============================================================================
NexusUI_Modules["NexusUI/Effects/Particles"] = function()
    local script = CreateMockScript("NexusUI/Effects/Particles")
    
    --[[
        NexusUI Particles Effect
        Particle systems for UI backgrounds
    ]]

    --// Services
    local RunService = game:GetService("RunService")

    --// Particles Module
    local Particles = {}
    Particles.ClassName = "ParticlesEffect"

    --// Active Systems
    local ActiveSystems = {}
    local SystemIdCounter = 0

    local function GenerateSystemId()
        SystemIdCounter = SystemIdCounter + 1
        return "particles_" .. SystemIdCounter
    end

    --// Default Configuration
    local DefaultConfig = {
        ParticleCount = 50,
        ParticleSize = { Min = 2, Max = 6 },
        ParticleColor = Color3.fromRGB(255, 255, 255),
        ParticleTransparency = { Min = 0.6, Max = 0.9 },
        Speed = { Min = 10, Max = 30 },
        Direction = Vector2.new(0, -1), -- Up
        Spread = 45, -- Degrees
        Lifetime = { Min = 3, Max = 8 },
        FadeIn = true,
        FadeOut = true,
        Glow = false,
        GlowColor = Color3.fromRGB(99, 102, 241),
        Shape = "Circle", -- Circle, Square, Star
    }

    --// Presets
    Particles.Presets = {
        Snow = {
            ParticleCount = 80,
            ParticleSize = { Min = 3, Max = 8 },
            ParticleColor = Color3.fromRGB(255, 255, 255),
            Speed = { Min = 20, Max = 50 },
            Direction = Vector2.new(0.2, 1),
            Spread = 20,
            Lifetime = { Min = 5, Max = 10 },
        },

        Stars = {
            ParticleCount = 30,
            ParticleSize = { Min = 2, Max = 5 },
            ParticleColor = Color3.fromRGB(255, 255, 200),
            ParticleTransparency = { Min = 0.3, Max = 0.8 },
            Speed = { Min = 0, Max = 0 },
            Glow = true,
            GlowColor = Color3.fromRGB(255, 255, 150),
        },

        Rain = {
            ParticleCount = 100,
            ParticleSize = { Min = 1, Max = 2 },
            ParticleColor = Color3.fromRGB(150, 200, 255),
            Speed = { Min = 100, Max = 200 },
            Direction = Vector2.new(0.1, 1),
            Spread = 5,
            Lifetime = { Min = 1, Max = 2 },
            Shape = "Square",
        },

        Fireflies = {
            ParticleCount = 20,
            ParticleSize = { Min = 3, Max = 6 },
            ParticleColor = Color3.fromRGB(255, 230, 100),
            Speed = { Min = 5, Max = 15 },
            Direction = Vector2.new(0, 0),
            Spread = 180,
            Lifetime = { Min = 4, Max = 8 },
            Glow = true,
            GlowColor = Color3.fromRGB(255, 200, 50),
        },

        Bubbles = {
            ParticleCount = 25,
            ParticleSize = { Min = 8, Max = 20 },
            ParticleColor = Color3.fromRGB(200, 230, 255),
            ParticleTransparency = { Min = 0.7, Max = 0.9 },
            Speed = { Min = 15, Max = 40 },
            Direction = Vector2.new(0, -1),
            Spread = 30,
            Lifetime = { Min = 4, Max = 7 },
        },

        Confetti = {
            ParticleCount = 60,
            ParticleSize = { Min = 4, Max = 10 },
            Speed = { Min = 30, Max = 80 },
            Direction = Vector2.new(0, 1),
            Spread = 60,
            Lifetime = { Min = 3, Max = 6 },
            Shape = "Square",
        },
    }

    --// Particle class
    local Particle = {}
    Particle.__index = Particle

    function Particle.new(parent, config, containerSize)
        local self = setmetatable({}, Particle)

        -- Random properties
        local size = math.random(config.ParticleSize.Min, config.ParticleSize.Max)
        local transparency = config.ParticleTransparency.Min + math.random() * (config.ParticleTransparency.Max - config.ParticleTransparency.Min)
        local speed = config.Speed.Min + math.random() * (config.Speed.Max - config.Speed.Min)
        local lifetime = config.Lifetime.Min + math.random() * (config.Lifetime.Max - config.Lifetime.Min)

        -- Calculate direction with spread
        local spreadRad = math.rad(config.Spread)
        local baseAngle = math.atan2(config.Direction.Y, config.Direction.X)
        local angle = baseAngle + (math.random() - 0.5) * spreadRad * 2
        local direction = Vector2.new(math.cos(angle), math.sin(angle))

        -- Random start position
        local startX = math.random(0, containerSize.X)
        local startY = math.random(0, containerSize.Y)

        -- Create particle frame
        self.Frame = Instance.new("Frame")
        self.Frame.Name = "Particle"
        self.Frame.Size = UDim2.new(0, size, 0, size)
        self.Frame.Position = UDim2.new(0, startX, 0, startY)
        self.Frame.AnchorPoint = Vector2.new(0.5, 0.5)
        self.Frame.BackgroundColor3 = config.ParticleColor
        self.Frame.BackgroundTransparency = transparency
        self.Frame.BorderSizePixel = 0
        self.Frame.ZIndex = parent.ZIndex + 1

        -- Shape
        if config.Shape == "Circle" then
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(1, 0)
            corner.Parent = self.Frame
        elseif config.Shape == "Star" then
            -- Approximate star with rotation
            self.Frame.Rotation = 45
        end

        self.Frame.Parent = parent

        -- Properties
        self.Config = config
        self.ContainerSize = containerSize
        self.Position = Vector2.new(startX, startY)
        self.Direction = direction
        self.Speed = speed
        self.Lifetime = lifetime
        self.Age = 0
        self.TargetTransparency = transparency
        self.Size = size

        return self
    end

    function Particle:Update(dt)
        self.Age = self.Age + dt

        -- Check lifetime
        if self.Age >= self.Lifetime then
            return true -- Should respawn
        end

        -- Move particle
        self.Position = self.Position + self.Direction * self.Speed * dt

        -- Wrap around container
        if self.Position.X < -self.Size then
            self.Position = Vector2.new(self.ContainerSize.X + self.Size, self.Position.Y)
        elseif self.Position.X > self.ContainerSize.X + self.Size then
            self.Position = Vector2.new(-self.Size, self.Position.Y)
        end

        if self.Position.Y < -self.Size then
            self.Position = Vector2.new(self.Position.X, self.ContainerSize.Y + self.Size)
        elseif self.Position.Y > self.ContainerSize.Y + self.Size then
            self.Position = Vector2.new(self.Position.X, -self.Size)
        end

        -- Update visual
        self.Frame.Position = UDim2.new(0, self.Position.X, 0, self.Position.Y)

        -- Fade effect
        local lifeProgress = self.Age / self.Lifetime
        local transparency = self.TargetTransparency

        if self.Config.FadeIn and lifeProgress < 0.1 then
            transparency = 1 - (lifeProgress / 0.1) * (1 - self.TargetTransparency)
        elseif self.Config.FadeOut and lifeProgress > 0.8 then
            local fadeProgress = (lifeProgress - 0.8) / 0.2
            transparency = self.TargetTransparency + fadeProgress * (1 - self.TargetTransparency)
        end

        self.Frame.BackgroundTransparency = transparency

        return false
    end

    function Particle:Respawn()
        self.Age = 0

        -- New random position at edge
        local side = math.random(1, 4)
        if side == 1 then -- Top
            self.Position = Vector2.new(math.random(0, self.ContainerSize.X), -self.Size)
        elseif side == 2 then -- Bottom
            self.Position = Vector2.new(math.random(0, self.ContainerSize.X), self.ContainerSize.Y + self.Size)
        elseif side == 3 then -- Left
            self.Position = Vector2.new(-self.Size, math.random(0, self.ContainerSize.Y))
        else -- Right
            self.Position = Vector2.new(self.ContainerSize.X + self.Size, math.random(0, self.ContainerSize.Y))
        end

        self.Frame.Position = UDim2.new(0, self.Position.X, 0, self.Position.Y)
    end

    function Particle:Destroy()
        self.Frame:Destroy()
    end

    --// Create particle system
    function Particles.Create(parent, config)
        if not parent then
            warn("Particles.Create: No parent provided")
            return nil
        end

        -- Handle preset
        if type(config) == "string" then
            config = Particles.Presets[config] or Particles.Presets.Snow
        end

        config = config or {}

        -- Merge with defaults
        for key, defaultValue in pairs(DefaultConfig) do
            if config[key] == nil then
                config[key] = defaultValue
            end
        end

        local systemId = GenerateSystemId()

        -- Create container
        local container = Instance.new("Frame")
        container.Name = "ParticleContainer"
        container.Size = UDim2.new(1, 0, 1, 0)
        container.BackgroundTransparency = 1
        container.ClipsDescendants = true
        container.ZIndex = parent.ZIndex
        container.Parent = parent

        -- Create particles
        local particles = {}
        local containerSize = container.AbsoluteSize

        for i = 1, config.ParticleCount do
            local particle = Particle.new(container, config, containerSize)
            table.insert(particles, particle)
        end

        -- Update loop
        local connection = RunService.Heartbeat:Connect(function(dt)
            containerSize = container.AbsoluteSize

            for _, particle in ipairs(particles) do
                particle.ContainerSize = containerSize
                local shouldRespawn = particle:Update(dt)

                if shouldRespawn then
                    particle:Respawn()
                end
            end
        end)

        -- Store system
        local systemData = {
            Id = systemId,
            Container = container,
            Particles = particles,
            Connection = connection,
            Config = config,
        }

        ActiveSystems[systemId] = systemData

        -- Return system handle
        return {
            Id = systemId,

            SetParticleCount = function(count)
                -- Add or remove particles
                while #particles < count do
                    local particle = Particle.new(container, config, containerSize)
                    table.insert(particles, particle)
                end

                while #particles > count do
                    local particle = table.remove(particles)
                    particle:Destroy()
                end
            end,

            SetSpeed = function(min, max)
                config.Speed = { Min = min, Max = max }
            end,

            SetColor = function(color)
                config.ParticleColor = color
                for _, particle in ipairs(particles) do
                    particle.Frame.BackgroundColor3 = color
                end
            end,

            Pause = function()
                if connection then
                    connection:Disconnect()
                    connection = nil
                end
            end,

            Resume = function()
                if not connection then
                    connection = RunService.Heartbeat:Connect(function(dt)
                        for _, particle in ipairs(particles) do
                            local shouldRespawn = particle:Update(dt)
                            if shouldRespawn then
                                particle:Respawn()
                            end
                        end
                    end)
                end
            end,

            Remove = function()
                Particles.Remove(systemId)
            end,
        }
    end

    --// Remove particle system
    function Particles.Remove(systemId)
        local systemData = ActiveSystems[systemId]
        if not systemData then return end

        if systemData.Connection then
            systemData.Connection:Disconnect()
        end

        for _, particle in ipairs(systemData.Particles) do
            particle:Destroy()
        end

        systemData.Container:Destroy()
        ActiveSystems[systemId] = nil
    end

    --// Remove all systems
    function Particles.RemoveAll()
        for systemId, _ in pairs(ActiveSystems) do
            Particles.Remove(systemId)
        end
    end

    return Particles


end


-- ============================================================================
-- Module: NexusUI/Effects/Ripple
-- ============================================================================
NexusUI_Modules["NexusUI/Effects/Ripple"] = function()
    local script = CreateMockScript("NexusUI/Effects/Ripple")
    
    --[[
        NexusUI Ripple Effect
        Material Design-style ripple effect
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")
    local UserInputService = game:GetService("UserInputService")

    --// Ripple Module
    local Ripple = {}
    Ripple.ClassName = "RippleEffect"

    --// Default Configuration
    local DefaultConfig = {
        Color = Color3.fromRGB(255, 255, 255),
        Transparency = 0.7,
        Duration = 0.6,
        MaxSize = 2, -- Multiplier of container size
        FadeDelay = 0.2,
    }

    --// Create single ripple
    function Ripple.Create(element, origin, config)
        if not element then
            warn("Ripple.Create: No element provided")
            return nil
        end

        config = config or {}

        -- Merge with defaults
        for key, defaultValue in pairs(DefaultConfig) do
            if config[key] == nil then
                config[key] = defaultValue
            end
        end

        -- Calculate origin position
        local elementPosition = element.AbsolutePosition
        local elementSize = element.AbsoluteSize

        local rippleX, rippleY

        if origin then
            if typeof(origin) == "Vector2" then
                rippleX = origin.X - elementPosition.X
                rippleY = origin.Y - elementPosition.Y
            elseif typeof(origin) == "UDim2" then
                rippleX = elementSize.X * origin.X.Scale + origin.X.Offset
                rippleY = elementSize.Y * origin.Y.Scale + origin.Y.Offset
            end
        else
            rippleX = elementSize.X / 2
            rippleY = elementSize.Y / 2
        end

        -- Calculate max ripple size (diagonal of element * multiplier)
        local maxSize = math.sqrt(elementSize.X ^ 2 + elementSize.Y ^ 2) * config.MaxSize

        -- Create ripple container
        local container = Instance.new("Frame")
        container.Name = "RippleContainer"
        container.Size = UDim2.new(1, 0, 1, 0)
        container.BackgroundTransparency = 1
        container.ClipsDescendants = true
        container.ZIndex = element.ZIndex + 10

        -- Match corner radius
        local elementCorner = element:FindFirstChildOfClass("UICorner")
        if elementCorner then
            local corner = Instance.new("UICorner")
            corner.CornerRadius = elementCorner.CornerRadius
            corner.Parent = container
        end

        container.Parent = element

        -- Create ripple circle
        local ripple = Instance.new("Frame")
        ripple.Name = "Ripple"
        ripple.Size = UDim2.new(0, 0, 0, 0)
        ripple.Position = UDim2.new(0, rippleX, 0, rippleY)
        ripple.AnchorPoint = Vector2.new(0.5, 0.5)
        ripple.BackgroundColor3 = config.Color
        ripple.BackgroundTransparency = config.Transparency
        ripple.BorderSizePixel = 0
        ripple.ZIndex = container.ZIndex + 1

        local rippleCorner = Instance.new("UICorner")
        rippleCorner.CornerRadius = UDim.new(1, 0)
        rippleCorner.Parent = ripple

        ripple.Parent = container

        -- Animate ripple
        local expandTween = TweenService:Create(ripple, TweenInfo.new(config.Duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            Size = UDim2.new(0, maxSize, 0, maxSize),
        })

        expandTween:Play()

        -- Fade out
        task.delay(config.FadeDelay, function()
            local fadeTween = TweenService:Create(ripple, TweenInfo.new(config.Duration - config.FadeDelay, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                BackgroundTransparency = 1,
            })

            fadeTween:Play()
            fadeTween.Completed:Connect(function()
                container:Destroy()
            end)
        end)

        return {
            Container = container,
            Ripple = ripple,

            Cancel = function()
                container:Destroy()
            end,
        }
    end

    --// Create ripple from mouse position
    function Ripple.CreateFromMouse(element, config)
        local mousePosition = UserInputService:GetMouseLocation()
        return Ripple.Create(element, mousePosition, config)
    end

    --// Add ripple effect to element (auto-triggers on click)
    function Ripple.AddTo(element, config)
        config = config or {}

        local connections = {}

        -- Handle InputBegan
        local inputBegan = element.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                local position = Vector2.new(input.Position.X, input.Position.Y)
                Ripple.Create(element, position, config)
            end
        end)

        table.insert(connections, inputBegan)

        return {
            Remove = function()
                for _, connection in ipairs(connections) do
                    connection:Disconnect()
                end
            end,
        }
    end

    --// Add hover ripple (subtle ripple on hover)
    function Ripple.AddHover(element, config)
        config = config or {
            Color = Color3.fromRGB(255, 255, 255),
            Transparency = 0.9,
            Duration = 0.3,
            MaxSize = 1.2,
        }

        local connections = {}
        local currentRipple = nil

        local mouseEnter = element.MouseEnter:Connect(function()
            -- Cancel previous ripple
            if currentRipple then
                currentRipple.Cancel()
            end

            currentRipple = Ripple.Create(element, UDim2.new(0.5, 0, 0.5, 0), config)
        end)

        local mouseLeave = element.MouseLeave:Connect(function()
            -- Let the current ripple fade naturally
            currentRipple = nil
        end)

        table.insert(connections, mouseEnter)
        table.insert(connections, mouseLeave)

        return {
            Remove = function()
                for _, connection in ipairs(connections) do
                    connection:Disconnect()
                end
            end,
        }
    end

    --// Multiple ripples (burst effect)
    function Ripple.Burst(element, count, config)
        count = count or 3
        config = config or {}

        local ripples = {}

        for i = 1, count do
            task.delay((i - 1) * 0.1, function()
                local ripple = Ripple.Create(element, UDim2.new(0.5, 0, 0.5, 0), {
                    Color = config.Color or Color3.fromRGB(255, 255, 255),
                    Transparency = (config.Transparency or 0.7) + (i - 1) * 0.1,
                    Duration = (config.Duration or 0.6) + (i - 1) * 0.1,
                    MaxSize = (config.MaxSize or 2) - (i - 1) * 0.3,
                })
                table.insert(ripples, ripple)
            end)
        end

        return ripples
    end

    return Ripple


end


-- ============================================================================
-- Module: NexusUI/Effects/init
-- ============================================================================
NexusUI_Modules["NexusUI/Effects/init"] = function()
    local script = CreateMockScript("NexusUI/Effects/init")
    
    --[[
        NexusUI Effects System
        Visual effects including liquid glass, blur, glow
    ]]

    --// Effects Module
    local Effects = {}

    -- Load sub-modules
    Effects.LiquidGlass = NexusRequire("NexusUI/Effects/LiquidGlass")
    Effects.Glassmorphism = NexusRequire("NexusUI/Effects/Glassmorphism")
    Effects.Blur = NexusRequire("NexusUI/Effects/Blur")
    Effects.Glow = NexusRequire("NexusUI/Effects/Glow")
    Effects.Shadow = NexusRequire("NexusUI/Effects/Shadow")
    Effects.Gradient = NexusRequire("NexusUI/Effects/Gradient")
    Effects.Particles = NexusRequire("NexusUI/Effects/Particles")
    Effects.Ripple = NexusRequire("NexusUI/Effects/Ripple")

    -- Quick access functions
    function Effects.ApplyLiquidGlass(element, config)
        return Effects.LiquidGlass.Apply(element, config)
    end

    function Effects.ApplyGlassmorphism(element, config)
        return Effects.Glassmorphism.Apply(element, config)
    end

    function Effects.ApplyBlur(element, config)
        return Effects.Blur.Apply(element, config)
    end

    function Effects.ApplyGlow(element, config)
        return Effects.Glow.Apply(element, config)
    end

    function Effects.ApplyShadow(element, config)
        return Effects.Shadow.Apply(element, config)
    end

    function Effects.ApplyGradient(element, config)
        return Effects.Gradient.Apply(element, config)
    end

    function Effects.CreateParticles(parent, config)
        return Effects.Particles.Create(parent, config)
    end

    function Effects.CreateRipple(element, origin)
        return Effects.Ripple.Create(element, origin)
    end

    return Effects


end


-- ============================================================================
-- Module: NexusUI/Components/Base
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Base"] = function()
    local script = CreateMockScript("NexusUI/Components/Base")
    
    --[[
        NexusUI Base Component
        Foundation class for all UI components
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Base Component Module
    local Base = {}
    Base.__index = Base
    Base.ClassName = "BaseComponent"

    --// Component ID Counter
    local ComponentIdCounter = 0

    local function GenerateComponentId()
        ComponentIdCounter = ComponentIdCounter + 1
        return "component_" .. ComponentIdCounter
    end

    --// Constructor
    function Base.new(config)
        local self = setmetatable({}, Base)

        config = config or {}

        -- Core properties
        self.Id = GenerateComponentId()
        self.Name = config.Name or self.ClassName
        self.Parent = nil
        self.Instance = nil
        self.Children = {}
        self.Connections = {}
        self.IsDestroyed = false
        self.IsVisible = true
        self.IsEnabled = true

        -- Theme reference
        self.ThemeManager = nil
        self.ThemeConnection = nil

        -- Animation settings
        self.AnimationDuration = config.AnimationDuration or 0.2
        self.AnimationEasing = config.AnimationEasing or Enum.EasingStyle.Quad

        -- Event signals
        self.OnDestroy = nil
        self.OnVisibilityChanged = nil
        self.OnEnabledChanged = nil

        -- Callbacks
        self._callbacks = {}

        return self
    end

    --// Create base frame
    function Base:_createBaseFrame(className, parent)
        className = className or "Frame"

        local frame = Instance.new(className)
        frame.Name = self.Name
        frame.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        frame.BackgroundTransparency = 0
        frame.BorderSizePixel = 0
        frame.Size = UDim2.new(0, 100, 0, 30)
        frame.Position = UDim2.new(0, 0, 0, 0)

        if parent then
            frame.Parent = parent
        end

        self.Instance = frame
        return frame
    end

    --// Apply base properties
    function Base:_applyProperties(config)
        if not self.Instance then return end

        local frame = self.Instance

        -- Size
        if config.Size then
            frame.Size = config.Size
        end

        -- Position
        if config.Position then
            frame.Position = config.Position
        end

        -- Anchor Point
        if config.AnchorPoint then
            frame.AnchorPoint = config.AnchorPoint
        end

        -- Background
        if config.BackgroundColor3 then
            frame.BackgroundColor3 = config.BackgroundColor3
        end

        if config.BackgroundTransparency then
            frame.BackgroundTransparency = config.BackgroundTransparency
        end

        -- ZIndex
        if config.ZIndex then
            frame.ZIndex = config.ZIndex
        end

        -- Visible
        if config.Visible ~= nil then
            frame.Visible = config.Visible
            self.IsVisible = config.Visible
        end

        -- Layout Order
        if config.LayoutOrder then
            frame.LayoutOrder = config.LayoutOrder
        end

        -- Corner Radius
        if config.CornerRadius then
            local corner = frame:FindFirstChildOfClass("UICorner") or Instance.new("UICorner")
            corner.CornerRadius = config.CornerRadius
            corner.Parent = frame
        end

        -- Padding
        if config.Padding then
            local padding = frame:FindFirstChildOfClass("UIPadding") or Instance.new("UIPadding")
            if typeof(config.Padding) == "UDim" then
                padding.PaddingTop = config.Padding
                padding.PaddingBottom = config.Padding
                padding.PaddingLeft = config.Padding
                padding.PaddingRight = config.Padding
            elseif typeof(config.Padding) == "table" then
                padding.PaddingTop = config.Padding.Top or UDim.new(0, 0)
                padding.PaddingBottom = config.Padding.Bottom or UDim.new(0, 0)
                padding.PaddingLeft = config.Padding.Left or UDim.new(0, 0)
                padding.PaddingRight = config.Padding.Right or UDim.new(0, 0)
            end
            padding.Parent = frame
        end
    end

    --// Setup theme connection
    function Base:_setupTheme(themeManager)
        if not themeManager then return end

        self.ThemeManager = themeManager

        -- Subscribe to theme changes
        self.ThemeConnection = themeManager.OnThemeChange(function(theme, previousTheme, animate)
            self:_applyTheme(theme, animate)
        end)

        -- Apply current theme
        local currentTheme = themeManager.GetCurrentTheme()
        if currentTheme then
            self:_applyTheme(currentTheme, false)
        end
    end

    --// Apply theme (override in subclasses)
    function Base:_applyTheme(theme, animate)
        -- Override in subclasses
    end

    --// Connect event
    function Base:_connect(signal, callback)
        local connection = signal:Connect(callback)
        table.insert(self.Connections, connection)
        return connection
    end

    --// Disconnect all
    function Base:_disconnectAll()
        for _, connection in ipairs(self.Connections) do
            if connection.Connected then
                connection:Disconnect()
            end
        end
        self.Connections = {}

        if self.ThemeConnection then
            self.ThemeConnection()
            self.ThemeConnection = nil
        end
    end

    --// Add child component
    function Base:AddChild(child)
        if child.Instance and self.Instance then
            child.Instance.Parent = self.Instance
            child.Parent = self
            table.insert(self.Children, child)
        end
        return child
    end

    --// Remove child component
    function Base:RemoveChild(child)
        for i, c in ipairs(self.Children) do
            if c == child then
                table.remove(self.Children, i)
                child.Parent = nil
                break
            end
        end
        return child
    end

    --// Get child by name
    function Base:GetChild(name)
        for _, child in ipairs(self.Children) do
            if child.Name == name then
                return child
            end
        end
        return nil
    end

    --// Get all children
    function Base:GetChildren()
        return self.Children
    end

    --// Set parent
    function Base:SetParent(parent)
        if self.Instance then
            if parent then
                if parent.Instance then
                    self.Instance.Parent = parent.Instance
                else
                    self.Instance.Parent = parent
                end
            else
                self.Instance.Parent = nil
            end
        end
        self.Parent = parent
        return self
    end

    --// Get parent
    function Base:GetParent()
        return self.Parent
    end

    --// Set visibility
    function Base:SetVisible(visible, animate)
        if self.IsVisible == visible then return self end

        self.IsVisible = visible

        if self.Instance then
            if animate then
                local targetTransparency = visible and 0 or 1
                TweenService:Create(self.Instance, TweenInfo.new(self.AnimationDuration), {
                    BackgroundTransparency = targetTransparency,
                }):Play()

                if not visible then
                    task.delay(self.AnimationDuration, function()
                        if not self.IsDestroyed then
                            self.Instance.Visible = false
                        end
                    end)
                else
                    self.Instance.Visible = true
                end
            else
                self.Instance.Visible = visible
            end
        end

        if self.OnVisibilityChanged then
            self.OnVisibilityChanged(visible)
        end

        return self
    end

    --// Get visibility
    function Base:IsVisibleState()
        return self.IsVisible
    end

    --// Show
    function Base:Show(animate)
        return self:SetVisible(true, animate)
    end

    --// Hide
    function Base:Hide(animate)
        return self:SetVisible(false, animate)
    end

    --// Toggle visibility
    function Base:ToggleVisibility(animate)
        return self:SetVisible(not self.IsVisible, animate)
    end

    --// Set enabled
    function Base:SetEnabled(enabled)
        if self.IsEnabled == enabled then return self end

        self.IsEnabled = enabled

        -- Override in subclasses to change appearance

        if self.OnEnabledChanged then
            self.OnEnabledChanged(enabled)
        end

        return self
    end

    --// Get enabled
    function Base:IsEnabledState()
        return self.IsEnabled
    end

    --// Set position
    function Base:SetPosition(position, animate)
        if not self.Instance then return self end

        if animate then
            TweenService:Create(self.Instance, TweenInfo.new(self.AnimationDuration, self.AnimationEasing), {
                Position = position,
            }):Play()
        else
            self.Instance.Position = position
        end

        return self
    end

    --// Get position
    function Base:GetPosition()
        if self.Instance then
            return self.Instance.Position
        end
        return UDim2.new(0, 0, 0, 0)
    end

    --// Set size
    function Base:SetSize(size, animate)
        if not self.Instance then return self end

        if animate then
            TweenService:Create(self.Instance, TweenInfo.new(self.AnimationDuration, self.AnimationEasing), {
                Size = size,
            }):Play()
        else
            self.Instance.Size = size
        end

        return self
    end

    --// Get size
    function Base:GetSize()
        if self.Instance then
            return self.Instance.Size
        end
        return UDim2.new(0, 0, 0, 0)
    end

    --// Get absolute size
    function Base:GetAbsoluteSize()
        if self.Instance then
            return self.Instance.AbsoluteSize
        end
        return Vector2.new(0, 0)
    end

    --// Get absolute position
    function Base:GetAbsolutePosition()
        if self.Instance then
            return self.Instance.AbsolutePosition
        end
        return Vector2.new(0, 0)
    end

    --// Set ZIndex
    function Base:SetZIndex(zIndex)
        if self.Instance then
            self.Instance.ZIndex = zIndex
        end
        return self
    end

    --// Set layout order
    function Base:SetLayoutOrder(order)
        if self.Instance then
            self.Instance.LayoutOrder = order
        end
        return self
    end

    --// On callback
    function Base:On(eventName, callback)
        if not self._callbacks[eventName] then
            self._callbacks[eventName] = {}
        end
        table.insert(self._callbacks[eventName], callback)
        return self
    end

    --// Fire callback
    function Base:_fire(eventName, ...)
        if self._callbacks[eventName] then
            for _, callback in ipairs(self._callbacks[eventName]) do
                pcall(callback, ...)
            end
        end
    end

    --// Get instance
    function Base:GetInstance()
        return self.Instance
    end

    --// Destroy
    function Base:Destroy()
        if self.IsDestroyed then return end

        self.IsDestroyed = true

        -- Fire destroy callback
        if self.OnDestroy then
            pcall(self.OnDestroy, self)
        end

        self:_fire("Destroy", self)

        -- Destroy children
        for _, child in ipairs(self.Children) do
            child:Destroy()
        end
        self.Children = {}

        -- Disconnect all
        self:_disconnectAll()

        -- Destroy instance
        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end

        -- Clear callbacks
        self._callbacks = {}

        -- Remove from parent
        if self.Parent and self.Parent.RemoveChild then
            self.Parent:RemoveChild(self)
        end
        self.Parent = nil
    end

    --// Clone (creates a new component with same properties)
    function Base:Clone()
        -- Override in subclasses
        warn("Clone not implemented for " .. self.ClassName)
        return nil
    end

    return Base


end


-- ============================================================================
-- Module: NexusUI/Components/Container
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Container"] = function()
    local script = CreateMockScript("NexusUI/Components/Container")
    
    --[[
        NexusUI Container Component
        Base class for components that can hold children
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Container Component Module
    local Container = setmetatable({}, { __index = Base })
    Container.__index = Container
    Container.ClassName = "Container"

    --// Constructor
    function Container.new(config)
        local self = setmetatable(Base.new(config), Container)

        config = config or {}

        -- Container-specific properties
        self.Layout = config.Layout or "None" -- None, List, Grid, Flex
        self.LayoutConfig = config.LayoutConfig or {}
        self.Scrollable = config.Scrollable or false
        self.AutoSize = config.AutoSize or false
        self.ContentPadding = config.ContentPadding or UDim.new(0, 8)
        self.ItemSpacing = config.ItemSpacing or UDim.new(0, 4)

        -- Layout instance
        self._layoutInstance = nil

        return self
    end

    --// Create container
    function Container:Create(parent)
        local frame = self:_createBaseFrame("Frame", parent)
        frame.ClipsDescendants = true

        -- Apply properties from config
        if self.Scrollable then
            -- Create scroll frame
            local scrollFrame = Instance.new("ScrollingFrame")
            scrollFrame.Name = "ScrollContent"
            scrollFrame.Size = UDim2.new(1, 0, 1, 0)
            scrollFrame.BackgroundTransparency = 1
            scrollFrame.BorderSizePixel = 0
            scrollFrame.ScrollBarThickness = 4
            scrollFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 110)
            scrollFrame.ScrollBarImageTransparency = 0.5
            scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
            scrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
            scrollFrame.Parent = frame

            self._contentFrame = scrollFrame
        else
            self._contentFrame = frame
        end

        -- Setup layout
        self:_setupLayout()

        return self
    end

    --// Setup layout
    function Container:_setupLayout()
        if not self._contentFrame then return end

        -- Remove existing layout
        if self._layoutInstance then
            self._layoutInstance:Destroy()
            self._layoutInstance = nil
        end

        if self.Layout == "List" then
            local list = Instance.new("UIListLayout")
            list.SortOrder = Enum.SortOrder.LayoutOrder
            list.Padding = self.ItemSpacing
            list.FillDirection = self.LayoutConfig.Direction or Enum.FillDirection.Vertical
            list.HorizontalAlignment = self.LayoutConfig.HorizontalAlignment or Enum.HorizontalAlignment.Left
            list.VerticalAlignment = self.LayoutConfig.VerticalAlignment or Enum.VerticalAlignment.Top
            list.Parent = self._contentFrame
            self._layoutInstance = list

            -- Auto size handling
            if self.AutoSize then
                self:_connect(list:GetPropertyChangedSignal("AbsoluteContentSize"), function()
                    self:_updateAutoSize()
                end)
            end

        elseif self.Layout == "Grid" then
            local grid = Instance.new("UIGridLayout")
            grid.SortOrder = Enum.SortOrder.LayoutOrder
            grid.CellSize = self.LayoutConfig.CellSize or UDim2.new(0, 100, 0, 100)
            grid.CellPadding = UDim2.new(self.ItemSpacing.Scale, self.ItemSpacing.Offset, self.ItemSpacing.Scale, self.ItemSpacing.Offset)
            grid.FillDirection = self.LayoutConfig.Direction or Enum.FillDirection.Horizontal
            grid.FillDirectionMaxCells = self.LayoutConfig.MaxCells or 0
            grid.HorizontalAlignment = self.LayoutConfig.HorizontalAlignment or Enum.HorizontalAlignment.Left
            grid.VerticalAlignment = self.LayoutConfig.VerticalAlignment or Enum.VerticalAlignment.Top
            grid.Parent = self._contentFrame
            self._layoutInstance = grid

            if self.AutoSize then
                self:_connect(grid:GetPropertyChangedSignal("AbsoluteContentSize"), function()
                    self:_updateAutoSize()
                end)
            end

        elseif self.Layout == "Flex" then
            -- Flex is implemented as a special list layout with flex grow
            local list = Instance.new("UIListLayout")
            list.SortOrder = Enum.SortOrder.LayoutOrder
            list.Padding = self.ItemSpacing
            list.FillDirection = self.LayoutConfig.Direction or Enum.FillDirection.Horizontal
            list.HorizontalAlignment = self.LayoutConfig.HorizontalAlignment or Enum.HorizontalAlignment.Left
            list.VerticalAlignment = self.LayoutConfig.VerticalAlignment or Enum.VerticalAlignment.Top
            list.Parent = self._contentFrame
            self._layoutInstance = list
        end

        -- Add padding
        if self.ContentPadding then
            local padding = self._contentFrame:FindFirstChildOfClass("UIPadding") or Instance.new("UIPadding")
            padding.PaddingTop = self.ContentPadding
            padding.PaddingBottom = self.ContentPadding
            padding.PaddingLeft = self.ContentPadding
            padding.PaddingRight = self.ContentPadding
            padding.Parent = self._contentFrame
        end
    end

    --// Update auto size
    function Container:_updateAutoSize()
        if not self._layoutInstance or not self.Instance then return end

        local contentSize = self._layoutInstance.AbsoluteContentSize

        if self.Scrollable and self._contentFrame:IsA("ScrollingFrame") then
            self._contentFrame.CanvasSize = UDim2.new(0, contentSize.X, 0, contentSize.Y)
        elseif self.AutoSize then
            -- Update container size
            local paddingOffset = 0
            local padding = self._contentFrame:FindFirstChildOfClass("UIPadding")
            if padding then
                paddingOffset = padding.PaddingTop.Offset + padding.PaddingBottom.Offset
            end

            self.Instance.Size = UDim2.new(
                self.Instance.Size.X.Scale,
                self.Instance.Size.X.Offset,
                0,
                contentSize.Y + paddingOffset
            )
        end
    end

    --// Set layout
    function Container:SetLayout(layoutType, config)
        self.Layout = layoutType
        self.LayoutConfig = config or {}
        self:_setupLayout()
        return self
    end

    --// Set scrollable
    function Container:SetScrollable(scrollable)
        if self.Scrollable == scrollable then return self end

        self.Scrollable = scrollable

        -- Rebuild content frame
        if self.Instance then
            local children = {}

            -- Store children
            for _, child in ipairs(self._contentFrame:GetChildren()) do
                if child:IsA("GuiObject") then
                    table.insert(children, child)
                end
            end

            -- Destroy old content frame (if it's a scroll frame)
            if self._contentFrame ~= self.Instance then
                self._contentFrame:Destroy()
            end

            -- Create new content frame
            if scrollable then
                local scrollFrame = Instance.new("ScrollingFrame")
                scrollFrame.Name = "ScrollContent"
                scrollFrame.Size = UDim2.new(1, 0, 1, 0)
                scrollFrame.BackgroundTransparency = 1
                scrollFrame.BorderSizePixel = 0
                scrollFrame.ScrollBarThickness = 4
                scrollFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 110)
                scrollFrame.ScrollBarImageTransparency = 0.5
                scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
                scrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
                scrollFrame.Parent = self.Instance

                self._contentFrame = scrollFrame
            else
                self._contentFrame = self.Instance
            end

            -- Re-parent children
            for _, child in ipairs(children) do
                child.Parent = self._contentFrame
            end

            -- Re-setup layout
            self:_setupLayout()
        end

        return self
    end

    --// Set item spacing
    function Container:SetItemSpacing(spacing)
        self.ItemSpacing = spacing

        if self._layoutInstance then
            if self._layoutInstance:IsA("UIListLayout") then
                self._layoutInstance.Padding = spacing
            elseif self._layoutInstance:IsA("UIGridLayout") then
                self._layoutInstance.CellPadding = UDim2.new(spacing.Scale, spacing.Offset, spacing.Scale, spacing.Offset)
            end
        end

        return self
    end

    --// Set content padding
    function Container:SetContentPadding(padding)
        self.ContentPadding = padding

        if self._contentFrame then
            local uiPadding = self._contentFrame:FindFirstChildOfClass("UIPadding")
            if uiPadding then
                uiPadding.PaddingTop = padding
                uiPadding.PaddingBottom = padding
                uiPadding.PaddingLeft = padding
                uiPadding.PaddingRight = padding
            end
        end

        return self
    end

    --// Add child (override to use content frame)
    function Container:AddChild(child)
        if child.Instance and self._contentFrame then
            child.Instance.Parent = self._contentFrame
            child.Parent = self
            table.insert(self.Children, child)
        end

        self:_updateAutoSize()

        return child
    end

    --// Clear all children
    function Container:ClearChildren()
        for i = #self.Children, 1, -1 do
            local child = self.Children[i]
            child:Destroy()
            table.remove(self.Children, i)
        end

        return self
    end

    --// Scroll to child
    function Container:ScrollToChild(child, animate)
        if not self.Scrollable or not self._contentFrame:IsA("ScrollingFrame") then return self end

        if child.Instance then
            local childPosition = child.Instance.AbsolutePosition
            local containerPosition = self._contentFrame.AbsolutePosition
            local offset = childPosition - containerPosition

            local targetScroll = Vector2.new(
                self._contentFrame.CanvasPosition.X,
                offset.Y
            )

            if animate then
                -- Animate scroll
                local startScroll = self._contentFrame.CanvasPosition
                local startTime = tick()
                local duration = 0.3

                local connection
                connection = game:GetService("RunService").Heartbeat:Connect(function()
                    local progress = math.min((tick() - startTime) / duration, 1)
                    local eased = 1 - (1 - progress) ^ 3 -- Ease out cubic

                    self._contentFrame.CanvasPosition = startScroll:Lerp(targetScroll, eased)

                    if progress >= 1 then
                        connection:Disconnect()
                    end
                end)
            else
                self._contentFrame.CanvasPosition = targetScroll
            end
        end

        return self
    end

    --// Scroll to top
    function Container:ScrollToTop(animate)
        if not self.Scrollable or not self._contentFrame:IsA("ScrollingFrame") then return self end

        if animate then
            local startScroll = self._contentFrame.CanvasPosition
            local targetScroll = Vector2.new(startScroll.X, 0)
            local startTime = tick()
            local duration = 0.3

            local connection
            connection = game:GetService("RunService").Heartbeat:Connect(function()
                local progress = math.min((tick() - startTime) / duration, 1)
                local eased = 1 - (1 - progress) ^ 3

                self._contentFrame.CanvasPosition = startScroll:Lerp(targetScroll, eased)

                if progress >= 1 then
                    connection:Disconnect()
                end
            end)
        else
            self._contentFrame.CanvasPosition = Vector2.new(self._contentFrame.CanvasPosition.X, 0)
        end

        return self
    end

    --// Scroll to bottom
    function Container:ScrollToBottom(animate)
        if not self.Scrollable or not self._contentFrame:IsA("ScrollingFrame") then return self end

        local maxScroll = self._contentFrame.CanvasSize.Y.Offset - self._contentFrame.AbsoluteSize.Y

        if animate then
            local startScroll = self._contentFrame.CanvasPosition
            local targetScroll = Vector2.new(startScroll.X, maxScroll)
            local startTime = tick()
            local duration = 0.3

            local connection
            connection = game:GetService("RunService").Heartbeat:Connect(function()
                local progress = math.min((tick() - startTime) / duration, 1)
                local eased = 1 - (1 - progress) ^ 3

                self._contentFrame.CanvasPosition = startScroll:Lerp(targetScroll, eased)

                if progress >= 1 then
                    connection:Disconnect()
                end
            end)
        else
            self._contentFrame.CanvasPosition = Vector2.new(self._contentFrame.CanvasPosition.X, maxScroll)
        end

        return self
    end

    --// Get content frame
    function Container:GetContentFrame()
        return self._contentFrame
    end

    --// Get content size
    function Container:GetContentSize()
        if self._layoutInstance then
            return self._layoutInstance.AbsoluteContentSize
        end
        return Vector2.new(0, 0)
    end

    return Container


end


-- ============================================================================
-- Module: NexusUI/Components/Button
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Button"] = function()
    local script = CreateMockScript("NexusUI/Components/Button")
    
    --[[
        NexusUI Button Component
        Interactive button with hover, press states, and ripple effect
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")
    local UserInputService = game:GetService("UserInputService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Button Component Module
    local Button = setmetatable({}, { __index = Base })
    Button.__index = Button
    Button.ClassName = "Button"

    --// Button Variants
    Button.Variant = {
        Primary = "Primary",
        Secondary = "Secondary",
        Accent = "Accent",
        Ghost = "Ghost",
        Outline = "Outline",
        Danger = "Danger",
        Success = "Success",
    }

    --// Button Sizes
    Button.Size = {
        Small = "Small",
        Medium = "Medium",
        Large = "Large",
    }

    --// Constructor
    function Button.new(config)
        local self = setmetatable(Base.new(config), Button)

        config = config or {}

        -- Button-specific properties
        self.Text = config.Text or "Button"
        self.Variant = config.Variant or Button.Variant.Primary
        self.ButtonSize = config.Size or Button.Size.Medium
        self.Icon = config.Icon -- Left icon
        self.IconRight = config.IconRight -- Right icon
        self.RippleEnabled = config.RippleEnabled ~= false
        self.Loading = false
        self.LoadingText = config.LoadingText or "Loading..."

        -- State
        self._isHovered = false
        self._isPressed = false

        -- Callbacks
        self.OnClick = config.OnClick
        self.OnHover = config.OnHover
        self.OnLeave = config.OnLeave

        return self
    end

    --// Get size dimensions
    function Button:_getSizeDimensions()
        if self.ButtonSize == Button.Size.Small then
            return { Height = 28, FontSize = 12, Padding = 8, IconSize = 14 }
        elseif self.ButtonSize == Button.Size.Large then
            return { Height = 44, FontSize = 16, Padding = 16, IconSize = 20 }
        else -- Medium
            return { Height = 36, FontSize = 14, Padding = 12, IconSize = 16 }
        end
    end

    --// Get variant colors
    function Button:_getVariantColors()
        local colors = {
            Primary = {
                Background = Color3.fromRGB(99, 102, 241),
                BackgroundHover = Color3.fromRGB(129, 140, 248),
                BackgroundPressed = Color3.fromRGB(79, 70, 229),
                Text = Color3.fromRGB(255, 255, 255),
                Border = nil,
            },
            Secondary = {
                Background = Color3.fromRGB(63, 63, 70),
                BackgroundHover = Color3.fromRGB(82, 82, 91),
                BackgroundPressed = Color3.fromRGB(52, 52, 58),
                Text = Color3.fromRGB(255, 255, 255),
                Border = nil,
            },
            Accent = {
                Background = Color3.fromRGB(236, 72, 153),
                BackgroundHover = Color3.fromRGB(244, 114, 182),
                BackgroundPressed = Color3.fromRGB(219, 39, 119),
                Text = Color3.fromRGB(255, 255, 255),
                Border = nil,
            },
            Ghost = {
                Background = Color3.fromRGB(0, 0, 0),
                BackgroundTransparency = 1,
                BackgroundHover = Color3.fromRGB(63, 63, 70),
                BackgroundHoverTransparency = 0.8,
                BackgroundPressed = Color3.fromRGB(52, 52, 58),
                BackgroundPressedTransparency = 0.7,
                Text = Color3.fromRGB(255, 255, 255),
                Border = nil,
            },
            Outline = {
                Background = Color3.fromRGB(0, 0, 0),
                BackgroundTransparency = 1,
                BackgroundHover = Color3.fromRGB(99, 102, 241),
                BackgroundHoverTransparency = 0.9,
                BackgroundPressed = Color3.fromRGB(99, 102, 241),
                BackgroundPressedTransparency = 0.8,
                Text = Color3.fromRGB(99, 102, 241),
                Border = Color3.fromRGB(99, 102, 241),
            },
            Danger = {
                Background = Color3.fromRGB(220, 38, 38),
                BackgroundHover = Color3.fromRGB(239, 68, 68),
                BackgroundPressed = Color3.fromRGB(185, 28, 28),
                Text = Color3.fromRGB(255, 255, 255),
                Border = nil,
            },
            Success = {
                Background = Color3.fromRGB(22, 163, 74),
                BackgroundHover = Color3.fromRGB(34, 197, 94),
                BackgroundPressed = Color3.fromRGB(21, 128, 61),
                Text = Color3.fromRGB(255, 255, 255),
                Border = nil,
            },
        }

        return colors[self.Variant] or colors.Primary
    end

    --// Create button
    function Button:Create(parent)
        local dimensions = self:_getSizeDimensions()
        local colors = self:_getVariantColors()

        -- Create button frame
        local button = Instance.new("TextButton")
        button.Name = self.Name
        button.Size = UDim2.new(0, 0, 0, dimensions.Height)
        button.AutomaticSize = Enum.AutomaticSize.X
        button.BackgroundColor3 = colors.Background
        button.BackgroundTransparency = colors.BackgroundTransparency or 0
        button.BorderSizePixel = 0
        button.Text = ""
        button.AutoButtonColor = false

        if parent then
            button.Parent = parent
        end

        self.Instance = button

        -- Corner radius
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = button

        -- Border (for outline variant)
        if colors.Border then
            local stroke = Instance.new("UIStroke")
            stroke.Color = colors.Border
            stroke.Thickness = 1
            stroke.Parent = button
            self._stroke = stroke
        end

        -- Padding
        local padding = Instance.new("UIPadding")
        padding.PaddingLeft = UDim.new(0, dimensions.Padding)
        padding.PaddingRight = UDim.new(0, dimensions.Padding)
        padding.Parent = button

        -- Content layout
        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.Padding = UDim.new(0, 6)
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Parent = button

        -- Left icon (if any)
        if self.Icon then
            local iconLabel = Instance.new("ImageLabel")
            iconLabel.Name = "IconLeft"
            iconLabel.Size = UDim2.new(0, dimensions.IconSize, 0, dimensions.IconSize)
            iconLabel.BackgroundTransparency = 1
            iconLabel.Image = self.Icon
            iconLabel.ImageColor3 = colors.Text
            iconLabel.LayoutOrder = 1
            iconLabel.Parent = button
            self._iconLeft = iconLabel
        end

        -- Text label
        local textLabel = Instance.new("TextLabel")
        textLabel.Name = "Text"
        textLabel.Size = UDim2.new(0, 0, 1, 0)
        textLabel.AutomaticSize = Enum.AutomaticSize.X
        textLabel.BackgroundTransparency = 1
        textLabel.Font = Enum.Font.GothamMedium
        textLabel.Text = self.Text
        textLabel.TextColor3 = colors.Text
        textLabel.TextSize = dimensions.FontSize
        textLabel.LayoutOrder = 2
        textLabel.Parent = button
        self._textLabel = textLabel

        -- Right icon (if any)
        if self.IconRight then
            local iconLabel = Instance.new("ImageLabel")
            iconLabel.Name = "IconRight"
            iconLabel.Size = UDim2.new(0, dimensions.IconSize, 0, dimensions.IconSize)
            iconLabel.BackgroundTransparency = 1
            iconLabel.Image = self.IconRight
            iconLabel.ImageColor3 = colors.Text
            iconLabel.LayoutOrder = 3
            iconLabel.Parent = button
            self._iconRight = iconLabel
        end

        -- Loading spinner (hidden by default)
        local spinner = Instance.new("ImageLabel")
        spinner.Name = "Spinner"
        spinner.Size = UDim2.new(0, dimensions.IconSize, 0, dimensions.IconSize)
        spinner.BackgroundTransparency = 1
        spinner.Image = "rbxassetid://6031094667" -- Circular spinner
        spinner.ImageColor3 = colors.Text
        spinner.Visible = false
        spinner.LayoutOrder = 0
        spinner.Parent = button
        self._spinner = spinner

        -- Setup interactions
        self:_setupInteractions(colors)

        return self
    end

    --// Setup interactions
    function Button:_setupInteractions(colors)
        local button = self.Instance

        -- Hover
        self:_connect(button.MouseEnter, function()
            if not self.IsEnabled or self.Loading then return end

            self._isHovered = true

            TweenService:Create(button, TweenInfo.new(0.15), {
                BackgroundColor3 = colors.BackgroundHover,
                BackgroundTransparency = colors.BackgroundHoverTransparency or 0,
            }):Play()

            if self.OnHover then
                self.OnHover()
            end

            self:_fire("Hover")
        end)

        -- Leave
        self:_connect(button.MouseLeave, function()
            if not self.IsEnabled or self.Loading then return end

            self._isHovered = false
            self._isPressed = false

            TweenService:Create(button, TweenInfo.new(0.15), {
                BackgroundColor3 = colors.Background,
                BackgroundTransparency = colors.BackgroundTransparency or 0,
            }):Play()

            if self.OnLeave then
                self.OnLeave()
            end

            self:_fire("Leave")
        end)

        -- Press
        self:_connect(button.MouseButton1Down, function()
            if not self.IsEnabled or self.Loading then return end

            self._isPressed = true

            TweenService:Create(button, TweenInfo.new(0.1), {
                BackgroundColor3 = colors.BackgroundPressed,
                BackgroundTransparency = colors.BackgroundPressedTransparency or 0,
            }):Play()

            -- Scale effect
            TweenService:Create(button, TweenInfo.new(0.1), {
                Size = UDim2.new(button.Size.X.Scale, button.Size.X.Offset, 0, self:_getSizeDimensions().Height - 2),
            }):Play()
        end)

        -- Release
        self:_connect(button.MouseButton1Up, function()
            if not self.IsEnabled or self.Loading then return end

            self._isPressed = false

            -- Reset scale
            TweenService:Create(button, TweenInfo.new(0.15), {
                Size = UDim2.new(button.Size.X.Scale, button.Size.X.Offset, 0, self:_getSizeDimensions().Height),
            }):Play()

            if self._isHovered then
                TweenService:Create(button, TweenInfo.new(0.15), {
                    BackgroundColor3 = colors.BackgroundHover,
                }):Play()
            end
        end)

        -- Click
        self:_connect(button.MouseButton1Click, function()
            if not self.IsEnabled or self.Loading then return end

            -- Ripple effect
            if self.RippleEnabled then
                self:_createRipple()
            end

            if self.OnClick then
                self.OnClick()
            end

            self:_fire("Click")
        end)
    end

    --// Create ripple effect
    function Button:_createRipple()
        local button = self.Instance
        local mousePosition = UserInputService:GetMouseLocation()
        local buttonPosition = button.AbsolutePosition

        local rippleX = mousePosition.X - buttonPosition.X
        local rippleY = mousePosition.Y - buttonPosition.Y - 36 -- Account for topbar

        local maxSize = math.max(button.AbsoluteSize.X, button.AbsoluteSize.Y) * 2

        local ripple = Instance.new("Frame")
        ripple.Name = "Ripple"
        ripple.AnchorPoint = Vector2.new(0.5, 0.5)
        ripple.Position = UDim2.new(0, rippleX, 0, rippleY)
        ripple.Size = UDim2.new(0, 0, 0, 0)
        ripple.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        ripple.BackgroundTransparency = 0.7
        ripple.BorderSizePixel = 0
        ripple.ZIndex = button.ZIndex + 10

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(1, 0)
        corner.Parent = ripple

        ripple.Parent = button

        TweenService:Create(ripple, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            Size = UDim2.new(0, maxSize, 0, maxSize),
            BackgroundTransparency = 1,
        }):Play()

        task.delay(0.5, function()
            ripple:Destroy()
        end)
    end

    --// Set text
    function Button:SetText(text)
        self.Text = text
        if self._textLabel then
            self._textLabel.Text = text
        end
        return self
    end

    --// Get text
    function Button:GetText()
        return self.Text
    end

    --// Set loading state
    function Button:SetLoading(loading)
        self.Loading = loading

        if self._spinner then
            self._spinner.Visible = loading

            if loading then
                -- Start spinning animation
                local startTime = os.clock()
                local spinConnection

                spinConnection = game:GetService("RunService").Heartbeat:Connect(function()
                    if not self._spinner or not self._spinner.Parent or not self.Loading then
                        spinConnection:Disconnect()
                        return
                    end

                    self._spinner.Rotation = (os.clock() - startTime) * 360
                end)
            end
        end

        if self._textLabel then
            self._textLabel.Text = loading and self.LoadingText or self.Text
        end

        return self
    end

    --// Set enabled (override)
    function Button:SetEnabled(enabled)
        Base.SetEnabled(self, enabled)

        if self.Instance then
            self.Instance.BackgroundTransparency = enabled and 0 or 0.5
        end

        if self._textLabel then
            self._textLabel.TextTransparency = enabled and 0 or 0.5
        end

        return self
    end

    --// Set variant
    function Button:SetVariant(variant)
        self.Variant = variant
        -- Note: Would need to recreate button or update colors
        return self
    end

    return Button


end


-- ============================================================================
-- Module: NexusUI/Components/Label
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Label"] = function()
    local script = CreateMockScript("NexusUI/Components/Label")
    
    --[[
        NexusUI Label Component
        Text display with various styles
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Label Component Module
    local Label = setmetatable({}, { __index = Base })
    Label.__index = Label
    Label.ClassName = "Label"

    --// Label Variants
    Label.Variant = {
        Default = "Default",
        Header = "Header",
        Title = "Title",
        Body = "Body",
        Caption = "Caption",
        Code = "Code",
        Muted = "Muted",
    }

    --// Constructor
    function Label.new(config)
        local self = setmetatable(Base.new(config), Label)

        config = config or {}

        self.Text = config.Text or "Label"
        self.Variant = config.Variant or Label.Variant.Body
        self.TextColor = config.TextColor
        self.TextSize = config.TextSize
        self.Font = config.Font
        self.TextXAlignment = config.TextXAlignment or Enum.TextXAlignment.Left
        self.TextYAlignment = config.TextYAlignment or Enum.TextYAlignment.Center
        self.TextWrapped = config.TextWrapped or false
        self.RichText = config.RichText or false
        self.MaxVisibleGraphemes = config.MaxVisibleGraphemes or -1

        return self
    end

    --// Get variant properties
    function Label:_getVariantProperties()
        local variants = {
            Default = {
                Font = Enum.Font.Gotham,
                TextSize = 14,
                TextColor3 = Color3.fromRGB(250, 250, 250),
            },
            Header = {
                Font = Enum.Font.GothamBold,
                TextSize = 28,
                TextColor3 = Color3.fromRGB(250, 250, 250),
            },
            Title = {
                Font = Enum.Font.GothamMedium,
                TextSize = 20,
                TextColor3 = Color3.fromRGB(250, 250, 250),
            },
            Body = {
                Font = Enum.Font.Gotham,
                TextSize = 14,
                TextColor3 = Color3.fromRGB(250, 250, 250),
            },
            Caption = {
                Font = Enum.Font.Gotham,
                TextSize = 12,
                TextColor3 = Color3.fromRGB(161, 161, 170),
            },
            Code = {
                Font = Enum.Font.RobotoMono,
                TextSize = 13,
                TextColor3 = Color3.fromRGB(167, 139, 250),
            },
            Muted = {
                Font = Enum.Font.Gotham,
                TextSize = 14,
                TextColor3 = Color3.fromRGB(113, 113, 122),
            },
        }

        return variants[self.Variant] or variants.Body
    end

    --// Create label
    function Label:Create(parent)
        local props = self:_getVariantProperties()

        local label = Instance.new("TextLabel")
        label.Name = self.Name
        label.Size = UDim2.new(0, 0, 0, 0)
        label.AutomaticSize = Enum.AutomaticSize.XY
        label.BackgroundTransparency = 1
        label.Font = self.Font or props.Font
        label.Text = self.Text
        label.TextColor3 = self.TextColor or props.TextColor3
        label.TextSize = self.TextSize or props.TextSize
        label.TextXAlignment = self.TextXAlignment
        label.TextYAlignment = self.TextYAlignment
        label.TextWrapped = self.TextWrapped
        label.RichText = self.RichText
        label.MaxVisibleGraphemes = self.MaxVisibleGraphemes

        if parent then
            label.Parent = parent
        end

        self.Instance = label
        return self
    end

    --// Set text
    function Label:SetText(text, animate)
        self.Text = text

        if self.Instance then
            if animate then
                -- Typewriter effect
                self.Instance.MaxVisibleGraphemes = 0
                self.Instance.Text = text

                local length = utf8.len(text) or #text
                for i = 1, length do
                    self.Instance.MaxVisibleGraphemes = i
                    task.wait(0.02)
                end
            else
                self.Instance.Text = text
            end
        end

        return self
    end

    --// Get text
    function Label:GetText()
        return self.Text
    end

    --// Set text color
    function Label:SetTextColor(color, animate)
        self.TextColor = color

        if self.Instance then
            if animate then
                TweenService:Create(self.Instance, TweenInfo.new(0.2), {
                    TextColor3 = color,
                }):Play()
            else
                self.Instance.TextColor3 = color
            end
        end

        return self
    end

    --// Set variant
    function Label:SetVariant(variant)
        self.Variant = variant

        if self.Instance then
            local props = self:_getVariantProperties()
            self.Instance.Font = self.Font or props.Font
            self.Instance.TextSize = self.TextSize or props.TextSize
            self.Instance.TextColor3 = self.TextColor or props.TextColor3
        end

        return self
    end

    return Label


end


-- ============================================================================
-- Module: NexusUI/Components/TextInput
-- ============================================================================
NexusUI_Modules["NexusUI/Components/TextInput"] = function()
    local script = CreateMockScript("NexusUI/Components/TextInput")
    
    --[[
        NexusUI TextInput Component
        Text input field with validation and styling
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")
    local UserInputService = game:GetService("UserInputService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// TextInput Component Module
    local TextInput = setmetatable({}, { __index = Base })
    TextInput.__index = TextInput
    TextInput.ClassName = "TextInput"

    --// Input Types
    TextInput.Type = {
        Text = "Text",
        Password = "Password",
        Number = "Number",
        Email = "Email",
        Search = "Search",
    }

    --// Constructor
    function TextInput.new(config)
        local self = setmetatable(Base.new(config), TextInput)

        config = config or {}

        self.Text = config.Text or ""
        self.Placeholder = config.Placeholder or "Enter text..."
        self.InputType = config.InputType or TextInput.Type.Text
        self.MaxLength = config.MaxLength or -1
        self.ClearTextOnFocus = config.ClearTextOnFocus or false
        self.MultiLine = config.MultiLine or false
        self.ReadOnly = config.ReadOnly or false
        self.Icon = config.Icon
        self.ClearButton = config.ClearButton ~= false

        -- Validation
        self.Validator = config.Validator
        self.ValidationMessage = config.ValidationMessage or ""
        self.IsValid = true

        -- Callbacks
        self.OnTextChanged = config.OnTextChanged
        self.OnFocus = config.OnFocus
        self.OnFocusLost = config.OnFocusLost
        self.OnSubmit = config.OnSubmit

        -- State
        self._isFocused = false

        return self
    end

    --// Create input
    function TextInput:Create(parent)
        -- Main container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(1, 0, 0, 40)
        container.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        container.BorderSizePixel = 0

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Corner
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = container

        -- Border stroke
        local stroke = Instance.new("UIStroke")
        stroke.Name = "BorderStroke"
        stroke.Color = Color3.fromRGB(63, 63, 70)
        stroke.Thickness = 1
        stroke.Parent = container
        self._stroke = stroke

        -- Padding
        local padding = Instance.new("UIPadding")
        padding.PaddingLeft = UDim.new(0, 12)
        padding.PaddingRight = UDim.new(0, 12)
        padding.Parent = container

        -- Layout
        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.Padding = UDim.new(0, 8)
        layout.Parent = container

        -- Icon (if any)
        if self.Icon then
            local icon = Instance.new("ImageLabel")
            icon.Name = "Icon"
            icon.Size = UDim2.new(0, 16, 0, 16)
            icon.BackgroundTransparency = 1
            icon.Image = self.Icon
            icon.ImageColor3 = Color3.fromRGB(113, 113, 122)
            icon.LayoutOrder = 1
            icon.Parent = container
            self._icon = icon
        end

        -- Text box
        local textBox = Instance.new("TextBox")
        textBox.Name = "Input"
        textBox.Size = UDim2.new(1, -50, 1, 0)
        textBox.BackgroundTransparency = 1
        textBox.Font = Enum.Font.Gotham
        textBox.Text = self.Text
        textBox.PlaceholderText = self.Placeholder
        textBox.PlaceholderColor3 = Color3.fromRGB(113, 113, 122)
        textBox.TextColor3 = Color3.fromRGB(250, 250, 250)
        textBox.TextSize = 14
        textBox.TextXAlignment = Enum.TextXAlignment.Left
        textBox.ClearTextOnFocus = self.ClearTextOnFocus
        textBox.MultiLine = self.MultiLine
        textBox.TextEditable = not self.ReadOnly
        textBox.LayoutOrder = 2
        textBox.Parent = container
        self._textBox = textBox

        -- Clear button
        if self.ClearButton then
            local clearBtn = Instance.new("ImageButton")
            clearBtn.Name = "ClearButton"
            clearBtn.Size = UDim2.new(0, 16, 0, 16)
            clearBtn.BackgroundTransparency = 1
            clearBtn.Image = "rbxassetid://6031094678" -- X icon
            clearBtn.ImageColor3 = Color3.fromRGB(113, 113, 122)
            clearBtn.Visible = #self.Text > 0
            clearBtn.LayoutOrder = 3
            clearBtn.Parent = container
            self._clearButton = clearBtn

            self:_connect(clearBtn.MouseButton1Click, function()
                self:SetText("")
                textBox:CaptureFocus()
            end)

            self:_connect(clearBtn.MouseEnter, function()
                TweenService:Create(clearBtn, TweenInfo.new(0.1), {
                    ImageColor3 = Color3.fromRGB(250, 250, 250),
                }):Play()
            end)

            self:_connect(clearBtn.MouseLeave, function()
                TweenService:Create(clearBtn, TweenInfo.new(0.1), {
                    ImageColor3 = Color3.fromRGB(113, 113, 122),
                }):Play()
            end)
        end

        -- Password mask
        if self.InputType == TextInput.Type.Password then
            textBox.Text = string.rep("●", #self.Text)
        end

        -- Setup interactions
        self:_setupInteractions()

        return self
    end

    --// Setup interactions
    function TextInput:_setupInteractions()
        local textBox = self._textBox
        local stroke = self._stroke

        -- Focus
        self:_connect(textBox.Focused, function()
            self._isFocused = true

            TweenService:Create(stroke, TweenInfo.new(0.15), {
                Color = Color3.fromRGB(99, 102, 241),
            }):Play()

            TweenService:Create(self.Instance, TweenInfo.new(0.15), {
                BackgroundColor3 = Color3.fromRGB(35, 35, 42),
            }):Play()

            if self.OnFocus then
                self.OnFocus()
            end

            self:_fire("Focus")
        end)

        -- Focus lost
        self:_connect(textBox.FocusLost, function(enterPressed)
            self._isFocused = false

            local borderColor = self.IsValid and Color3.fromRGB(63, 63, 70) or Color3.fromRGB(239, 68, 68)

            TweenService:Create(stroke, TweenInfo.new(0.15), {
                Color = borderColor,
            }):Play()

            TweenService:Create(self.Instance, TweenInfo.new(0.15), {
                BackgroundColor3 = Color3.fromRGB(30, 30, 35),
            }):Play()

            if self.OnFocusLost then
                self.OnFocusLost(enterPressed)
            end

            if enterPressed and self.OnSubmit then
                self.OnSubmit(self.Text)
            end

            self:_fire("FocusLost", enterPressed)
        end)

        -- Text changed
        self:_connect(textBox:GetPropertyChangedSignal("Text"), function()
            local text = textBox.Text

            -- Handle password type
            if self.InputType == TextInput.Type.Password then
                local realText = self.Text
                local newLen = #text
                local oldLen = #realText

                if newLen > oldLen then
                    -- Characters added
                    local addedChars = string.sub(text, oldLen + 1)
                    addedChars = string.gsub(addedChars, "●", "")
                    realText = realText .. addedChars
                elseif newLen < oldLen then
                    -- Characters removed
                    realText = string.sub(realText, 1, newLen)
                end

                self.Text = realText
                textBox.Text = string.rep("●", #realText)
            else
                -- Max length
                if self.MaxLength > 0 and #text > self.MaxLength then
                    textBox.Text = string.sub(text, 1, self.MaxLength)
                    return
                end

                -- Number type
                if self.InputType == TextInput.Type.Number then
                    local filtered = string.gsub(text, "[^%d%.%-]", "")
                    if filtered ~= text then
                        textBox.Text = filtered
                        return
                    end
                end

                self.Text = text
            end

            -- Validate
            self:_validate()

            -- Update clear button visibility
            if self._clearButton then
                self._clearButton.Visible = #self.Text > 0
            end

            if self.OnTextChanged then
                self.OnTextChanged(self.Text)
            end

            self:_fire("TextChanged", self.Text)
        end)

        -- Hover effects
        self:_connect(self.Instance.MouseEnter, function()
            if not self._isFocused then
                TweenService:Create(stroke, TweenInfo.new(0.15), {
                    Color = Color3.fromRGB(82, 82, 91),
                }):Play()
            end
        end)

        self:_connect(self.Instance.MouseLeave, function()
            if not self._isFocused then
                local borderColor = self.IsValid and Color3.fromRGB(63, 63, 70) or Color3.fromRGB(239, 68, 68)
                TweenService:Create(stroke, TweenInfo.new(0.15), {
                    Color = borderColor,
                }):Play()
            end
        end)
    end

    --// Validate
    function TextInput:_validate()
        if self.Validator then
            local isValid, message = self.Validator(self.Text)
            self.IsValid = isValid
            self.ValidationMessage = message or ""

            if self._stroke and not self._isFocused then
                self._stroke.Color = isValid and Color3.fromRGB(63, 63, 70) or Color3.fromRGB(239, 68, 68)
            end

            return isValid
        end

        self.IsValid = true
        return true
    end

    --// Set text
    function TextInput:SetText(text)
        self.Text = text

        if self._textBox then
            if self.InputType == TextInput.Type.Password then
                self._textBox.Text = string.rep("●", #text)
            else
                self._textBox.Text = text
            end
        end

        return self
    end

    --// Get text
    function TextInput:GetText()
        return self.Text
    end

    --// Set placeholder
    function TextInput:SetPlaceholder(placeholder)
        self.Placeholder = placeholder

        if self._textBox then
            self._textBox.PlaceholderText = placeholder
        end

        return self
    end

    --// Focus
    function TextInput:Focus()
        if self._textBox then
            self._textBox:CaptureFocus()
        end
        return self
    end

    --// Clear focus
    function TextInput:ClearFocus()
        if self._textBox then
            self._textBox:ReleaseFocus()
        end
        return self
    end

    --// Set read only
    function TextInput:SetReadOnly(readOnly)
        self.ReadOnly = readOnly

        if self._textBox then
            self._textBox.TextEditable = not readOnly
        end

        return self
    end

    --// Set validator
    function TextInput:SetValidator(validator)
        self.Validator = validator
        self:_validate()
        return self
    end

    --// Select all
    function TextInput:SelectAll()
        if self._textBox then
            self._textBox.SelectionStart = 1
            self._textBox.CursorPosition = #self.Text + 1
        end
        return self
    end

    return TextInput


end


-- ============================================================================
-- Module: NexusUI/Components/Toggle
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Toggle"] = function()
    local script = CreateMockScript("NexusUI/Components/Toggle")
    
    --[[
        NexusUI Toggle Component
        On/Off switch with smooth animations
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Toggle Component Module
    local Toggle = setmetatable({}, { __index = Base })
    Toggle.__index = Toggle
    Toggle.ClassName = "Toggle"

    --// Constructor
    function Toggle.new(config)
        local self = setmetatable(Base.new(config), Toggle)

        config = config or {}

        self.Value = config.Value or false
        self.Label = config.Label
        self.LabelPosition = config.LabelPosition or "Left" -- Left, Right
        self.Size = config.Size or "Medium" -- Small, Medium, Large
        self.ColorOn = config.ColorOn or Color3.fromRGB(99, 102, 241)
        self.ColorOff = config.ColorOff or Color3.fromRGB(63, 63, 70)

        -- Callbacks
        self.OnToggle = config.OnToggle
        self.OnOn = config.OnOn
        self.OnOff = config.OnOff

        return self
    end

    --// Get size dimensions
    function Toggle:_getSizeDimensions()
        if self.Size == "Small" then
            return { Width = 36, Height = 20, KnobSize = 14, KnobPadding = 3 }
        elseif self.Size == "Large" then
            return { Width = 56, Height = 30, KnobSize = 24, KnobPadding = 3 }
        else -- Medium
            return { Width = 44, Height = 24, KnobSize = 18, KnobPadding = 3 }
        end
    end

    --// Create toggle
    function Toggle:Create(parent)
        local dims = self:_getSizeDimensions()

        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(0, 0, 0, dims.Height)
        container.AutomaticSize = Enum.AutomaticSize.X
        container.BackgroundTransparency = 1

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Layout
        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.Padding = UDim.new(0, 10)
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Parent = container

        -- Label (if provided and position is left)
        if self.Label and self.LabelPosition == "Left" then
            local label = Instance.new("TextLabel")
            label.Name = "Label"
            label.Size = UDim2.new(0, 0, 0, dims.Height)
            label.AutomaticSize = Enum.AutomaticSize.X
            label.BackgroundTransparency = 1
            label.Font = Enum.Font.Gotham
            label.Text = self.Label
            label.TextColor3 = Color3.fromRGB(250, 250, 250)
            label.TextSize = 14
            label.TextXAlignment = Enum.TextXAlignment.Left
            label.LayoutOrder = 1
            label.Parent = container
            self._label = label
        end

        -- Toggle track
        local track = Instance.new("TextButton")
        track.Name = "Track"
        track.Size = UDim2.new(0, dims.Width, 0, dims.Height)
        track.BackgroundColor3 = self.Value and self.ColorOn or self.ColorOff
        track.BorderSizePixel = 0
        track.Text = ""
        track.AutoButtonColor = false
        track.LayoutOrder = 2
        track.Parent = container
        self._track = track

        -- Track corner
        local trackCorner = Instance.new("UICorner")
        trackCorner.CornerRadius = UDim.new(1, 0)
        trackCorner.Parent = track

        -- Knob
        local knobPosition = self.Value and 
            UDim2.new(1, -dims.KnobPadding - dims.KnobSize, 0.5, 0) or 
            UDim2.new(0, dims.KnobPadding, 0.5, 0)

        local knob = Instance.new("Frame")
        knob.Name = "Knob"
        knob.Size = UDim2.new(0, dims.KnobSize, 0, dims.KnobSize)
        knob.Position = knobPosition
        knob.AnchorPoint = Vector2.new(0, 0.5)
        knob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        knob.BorderSizePixel = 0
        knob.Parent = track
        self._knob = knob

        -- Knob corner
        local knobCorner = Instance.new("UICorner")
        knobCorner.CornerRadius = UDim.new(1, 0)
        knobCorner.Parent = knob

        -- Knob shadow
        local knobShadow = Instance.new("ImageLabel")
        knobShadow.Name = "Shadow"
        knobShadow.Size = UDim2.new(1, 8, 1, 8)
        knobShadow.Position = UDim2.new(0.5, 0, 0.5, 2)
        knobShadow.AnchorPoint = Vector2.new(0.5, 0.5)
        knobShadow.BackgroundTransparency = 1
        knobShadow.Image = "rbxassetid://6015897843"
        knobShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
        knobShadow.ImageTransparency = 0.7
        knobShadow.ScaleType = Enum.ScaleType.Slice
        knobShadow.SliceCenter = Rect.new(49, 49, 450, 450)
        knobShadow.ZIndex = knob.ZIndex - 1
        knobShadow.Parent = knob

        -- Label (if provided and position is right)
        if self.Label and self.LabelPosition == "Right" then
            local label = Instance.new("TextLabel")
            label.Name = "Label"
            label.Size = UDim2.new(0, 0, 0, dims.Height)
            label.AutomaticSize = Enum.AutomaticSize.X
            label.BackgroundTransparency = 1
            label.Font = Enum.Font.Gotham
            label.Text = self.Label
            label.TextColor3 = Color3.fromRGB(250, 250, 250)
            label.TextSize = 14
            label.TextXAlignment = Enum.TextXAlignment.Left
            label.LayoutOrder = 3
            label.Parent = container
            self._label = label
        end

        -- Setup interactions
        self:_setupInteractions()

        return self
    end

    --// Setup interactions
    function Toggle:_setupInteractions()
        local track = self._track
        local dims = self:_getSizeDimensions()

        -- Click
        self:_connect(track.MouseButton1Click, function()
            if not self.IsEnabled then return end
            self:Toggle()
        end)

        -- Hover
        self:_connect(track.MouseEnter, function()
            if not self.IsEnabled then return end

            TweenService:Create(self._knob, TweenInfo.new(0.15), {
                Size = UDim2.new(0, dims.KnobSize + 2, 0, dims.KnobSize + 2),
            }):Play()
        end)

        self:_connect(track.MouseLeave, function()
            TweenService:Create(self._knob, TweenInfo.new(0.15), {
                Size = UDim2.new(0, dims.KnobSize, 0, dims.KnobSize),
            }):Play()
        end)
    end

    --// Toggle
    function Toggle:Toggle(animate)
        self:SetValue(not self.Value, animate)
        return self
    end

    --// Set value
    function Toggle:SetValue(value, animate)
        if self.Value == value then return self end

        local oldValue = self.Value
        self.Value = value
        animate = animate ~= false

        local dims = self:_getSizeDimensions()
        local targetPosition = value and 
            UDim2.new(1, -dims.KnobPadding - dims.KnobSize, 0.5, 0) or 
            UDim2.new(0, dims.KnobPadding, 0.5, 0)
        local targetColor = value and self.ColorOn or self.ColorOff

        if animate then
            TweenService:Create(self._knob, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                Position = targetPosition,
            }):Play()

            TweenService:Create(self._track, TweenInfo.new(0.15), {
                BackgroundColor3 = targetColor,
            }):Play()
        else
            self._knob.Position = targetPosition
            self._track.BackgroundColor3 = targetColor
        end

        -- Callbacks
        if self.OnToggle then
            self.OnToggle(value, oldValue)
        end

        if value and self.OnOn then
            self.OnOn()
        elseif not value and self.OnOff then
            self.OnOff()
        end

        self:_fire("Toggle", value, oldValue)

        return self
    end

    --// Get value
    function Toggle:GetValue()
        return self.Value
    end

    --// Set label
    function Toggle:SetLabel(label)
        self.Label = label

        if self._label then
            self._label.Text = label
        end

        return self
    end

    --// Set colors
    function Toggle:SetColors(colorOn, colorOff)
        self.ColorOn = colorOn or self.ColorOn
        self.ColorOff = colorOff or self.ColorOff

        if self._track then
            self._track.BackgroundColor3 = self.Value and self.ColorOn or self.ColorOff
        end

        return self
    end

    --// Set enabled (override)
    function Toggle:SetEnabled(enabled)
        Base.SetEnabled(self, enabled)

        if self._track then
            self._track.BackgroundTransparency = enabled and 0 or 0.5
        end

        if self._knob then
            self._knob.BackgroundTransparency = enabled and 0 or 0.3
        end

        if self._label then
            self._label.TextTransparency = enabled and 0 or 0.5
        end

        return self
    end

    return Toggle


end


-- ============================================================================
-- Module: NexusUI/Components/Checkbox
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Checkbox"] = function()
    local script = CreateMockScript("NexusUI/Components/Checkbox")
    
    --[[
        NexusUI Checkbox Component
        Checkable box with optional label
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Checkbox Component Module
    local Checkbox = setmetatable({}, { __index = Base })
    Checkbox.__index = Checkbox
    Checkbox.ClassName = "Checkbox"

    --// Constructor
    function Checkbox.new(config)
        local self = setmetatable(Base.new(config), Checkbox)

        config = config or {}

        self.Checked = config.Checked or false
        self.Label = config.Label
        self.LabelPosition = config.LabelPosition or "Right"
        self.Size = config.Size or 20
        self.ColorChecked = config.ColorChecked or Color3.fromRGB(99, 102, 241)
        self.ColorUnchecked = config.ColorUnchecked or Color3.fromRGB(63, 63, 70)
        self.Indeterminate = config.Indeterminate or false

        -- Callbacks
        self.OnChange = config.OnChange
        self.OnChecked = config.OnChecked
        self.OnUnchecked = config.OnUnchecked

        return self
    end

    --// Create checkbox
    function Checkbox:Create(parent)
        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(0, 0, 0, self.Size)
        container.AutomaticSize = Enum.AutomaticSize.X
        container.BackgroundTransparency = 1

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Layout
        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.Padding = UDim.new(0, 8)
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Parent = container

        -- Label (left)
        if self.Label and self.LabelPosition == "Left" then
            local label = Instance.new("TextLabel")
            label.Name = "Label"
            label.Size = UDim2.new(0, 0, 0, self.Size)
            label.AutomaticSize = Enum.AutomaticSize.X
            label.BackgroundTransparency = 1
            label.Font = Enum.Font.Gotham
            label.Text = self.Label
            label.TextColor3 = Color3.fromRGB(250, 250, 250)
            label.TextSize = 14
            label.LayoutOrder = 1
            label.Parent = container
            self._label = label
        end

        -- Checkbox button
        local box = Instance.new("TextButton")
        box.Name = "Box"
        box.Size = UDim2.new(0, self.Size, 0, self.Size)
        box.BackgroundColor3 = self.Checked and self.ColorChecked or self.ColorUnchecked
        box.BorderSizePixel = 0
        box.Text = ""
        box.AutoButtonColor = false
        box.LayoutOrder = 2
        box.Parent = container
        self._box = box

        -- Corner
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 4)
        corner.Parent = box

        -- Border
        local stroke = Instance.new("UIStroke")
        stroke.Color = self.Checked and self.ColorChecked or Color3.fromRGB(82, 82, 91)
        stroke.Thickness = 2
        stroke.Parent = box
        self._stroke = stroke

        -- Checkmark
        local checkmark = Instance.new("ImageLabel")
        checkmark.Name = "Checkmark"
        checkmark.Size = UDim2.new(0.7, 0, 0.7, 0)
        checkmark.Position = UDim2.new(0.5, 0, 0.5, 0)
        checkmark.AnchorPoint = Vector2.new(0.5, 0.5)
        checkmark.BackgroundTransparency = 1
        checkmark.Image = "rbxassetid://6031094667" -- Checkmark
        checkmark.ImageColor3 = Color3.fromRGB(255, 255, 255)
        checkmark.ImageTransparency = self.Checked and 0 or 1
        checkmark.ScaleType = Enum.ScaleType.Fit
        checkmark.Parent = box
        self._checkmark = checkmark

        -- Indeterminate line
        local indeterminate = Instance.new("Frame")
        indeterminate.Name = "Indeterminate"
        indeterminate.Size = UDim2.new(0.6, 0, 0, 2)
        indeterminate.Position = UDim2.new(0.5, 0, 0.5, 0)
        indeterminate.AnchorPoint = Vector2.new(0.5, 0.5)
        indeterminate.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        indeterminate.BorderSizePixel = 0
        indeterminate.Visible = self.Indeterminate
        indeterminate.Parent = box
        self._indeterminate = indeterminate

        -- Label (right)
        if self.Label and self.LabelPosition == "Right" then
            local label = Instance.new("TextLabel")
            label.Name = "Label"
            label.Size = UDim2.new(0, 0, 0, self.Size)
            label.AutomaticSize = Enum.AutomaticSize.X
            label.BackgroundTransparency = 1
            label.Font = Enum.Font.Gotham
            label.Text = self.Label
            label.TextColor3 = Color3.fromRGB(250, 250, 250)
            label.TextSize = 14
            label.LayoutOrder = 3
            label.Parent = container
            self._label = label
        end

        -- Setup interactions
        self:_setupInteractions()

        return self
    end

    --// Setup interactions
    function Checkbox:_setupInteractions()
        local box = self._box

        -- Click
        self:_connect(box.MouseButton1Click, function()
            if not self.IsEnabled then return end
            self:Toggle()
        end)

        -- Hover
        self:_connect(box.MouseEnter, function()
            if not self.IsEnabled then return end

            if not self.Checked then
                TweenService:Create(self._stroke, TweenInfo.new(0.15), {
                    Color = Color3.fromRGB(113, 113, 122),
                }):Play()
            end

            TweenService:Create(box, TweenInfo.new(0.15), {
                Size = UDim2.new(0, self.Size + 2, 0, self.Size + 2),
            }):Play()
        end)

        self:_connect(box.MouseLeave, function()
            if not self.Checked then
                TweenService:Create(self._stroke, TweenInfo.new(0.15), {
                    Color = Color3.fromRGB(82, 82, 91),
                }):Play()
            end

            TweenService:Create(box, TweenInfo.new(0.15), {
                Size = UDim2.new(0, self.Size, 0, self.Size),
            }):Play()
        end)
    end

    --// Toggle
    function Checkbox:Toggle()
        self:SetChecked(not self.Checked)
        return self
    end

    --// Set checked
    function Checkbox:SetChecked(checked, animate)
        if self.Checked == checked then return self end

        local oldValue = self.Checked
        self.Checked = checked
        self.Indeterminate = false
        animate = animate ~= false

        local duration = animate and 0.15 or 0

        -- Update visuals
        TweenService:Create(self._box, TweenInfo.new(duration), {
            BackgroundColor3 = checked and self.ColorChecked or self.ColorUnchecked,
        }):Play()

        TweenService:Create(self._stroke, TweenInfo.new(duration), {
            Color = checked and self.ColorChecked or Color3.fromRGB(82, 82, 91),
        }):Play()

        TweenService:Create(self._checkmark, TweenInfo.new(duration), {
            ImageTransparency = checked and 0 or 1,
        }):Play()

        self._indeterminate.Visible = false

        -- Scale animation for check
        if checked and animate then
            self._checkmark.Size = UDim2.new(0.3, 0, 0.3, 0)
            TweenService:Create(self._checkmark, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                Size = UDim2.new(0.7, 0, 0.7, 0),
            }):Play()
        end

        -- Callbacks
        if self.OnChange then
            self.OnChange(checked, oldValue)
        end

        if checked and self.OnChecked then
            self.OnChecked()
        elseif not checked and self.OnUnchecked then
            self.OnUnchecked()
        end

        self:_fire("Change", checked, oldValue)

        return self
    end

    --// Get checked
    function Checkbox:GetChecked()
        return self.Checked
    end

    --// Set indeterminate
    function Checkbox:SetIndeterminate(indeterminate)
        self.Indeterminate = indeterminate

        if indeterminate then
            self._checkmark.ImageTransparency = 1
            self._indeterminate.Visible = true
            self._box.BackgroundColor3 = self.ColorChecked
            self._stroke.Color = self.ColorChecked
        else
            self._indeterminate.Visible = false
        end

        return self
    end

    --// Set label
    function Checkbox:SetLabel(label)
        self.Label = label

        if self._label then
            self._label.Text = label
        end

        return self
    end

    return Checkbox


end


-- ============================================================================
-- Module: NexusUI/Components/Slider
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Slider"] = function()
    local script = CreateMockScript("NexusUI/Components/Slider")
    
    --[[
        NexusUI Slider Component
        Range slider with value display
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Slider Component Module
    local Slider = setmetatable({}, { __index = Base })
    Slider.__index = Slider
    Slider.ClassName = "Slider"

    --// Constructor
    function Slider.new(config)
        local self = setmetatable(Base.new(config), Slider)

        config = config or {}

        self.Value = config.Value or 50
        self.Min = config.Min or 0
        self.Max = config.Max or 100
        self.Step = config.Step or 1
        self.Label = config.Label
        self.ShowValue = config.ShowValue ~= false
        self.ValueFormat = config.ValueFormat or "%.0f"
        self.ValueSuffix = config.ValueSuffix or ""
        self.TrackColor = config.TrackColor or Color3.fromRGB(63, 63, 70)
        self.FillColor = config.FillColor or Color3.fromRGB(99, 102, 241)
        self.KnobColor = config.KnobColor or Color3.fromRGB(255, 255, 255)

        -- Callbacks
        self.OnValueChanged = config.OnValueChanged
        self.OnDragStart = config.OnDragStart
        self.OnDragEnd = config.OnDragEnd

        -- State
        self._isDragging = false

        return self
    end

    --// Create slider
    function Slider:Create(parent)
        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(1, 0, 0, 50)
        container.BackgroundTransparency = 1

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Header row (label + value)
        if self.Label or self.ShowValue then
            local header = Instance.new("Frame")
            header.Name = "Header"
            header.Size = UDim2.new(1, 0, 0, 20)
            header.BackgroundTransparency = 1
            header.Parent = container

            if self.Label then
                local label = Instance.new("TextLabel")
                label.Name = "Label"
                label.Size = UDim2.new(0.5, 0, 1, 0)
                label.BackgroundTransparency = 1
                label.Font = Enum.Font.Gotham
                label.Text = self.Label
                label.TextColor3 = Color3.fromRGB(250, 250, 250)
                label.TextSize = 14
                label.TextXAlignment = Enum.TextXAlignment.Left
                label.Parent = header
                self._label = label
            end

            if self.ShowValue then
                local valueLabel = Instance.new("TextLabel")
                valueLabel.Name = "Value"
                valueLabel.Size = UDim2.new(0.5, 0, 1, 0)
                valueLabel.Position = UDim2.new(0.5, 0, 0, 0)
                valueLabel.BackgroundTransparency = 1
                valueLabel.Font = Enum.Font.GothamMedium
                valueLabel.Text = self:_formatValue(self.Value)
                valueLabel.TextColor3 = Color3.fromRGB(161, 161, 170)
                valueLabel.TextSize = 14
                valueLabel.TextXAlignment = Enum.TextXAlignment.Right
                valueLabel.Parent = header
                self._valueLabel = valueLabel
            end
        end

        -- Track container
        local trackContainer = Instance.new("Frame")
        trackContainer.Name = "TrackContainer"
        trackContainer.Size = UDim2.new(1, 0, 0, 20)
        trackContainer.Position = UDim2.new(0, 0, 1, -20)
        trackContainer.BackgroundTransparency = 1
        trackContainer.Parent = container

        -- Track
        local track = Instance.new("Frame")
        track.Name = "Track"
        track.Size = UDim2.new(1, 0, 0, 6)
        track.Position = UDim2.new(0, 0, 0.5, 0)
        track.AnchorPoint = Vector2.new(0, 0.5)
        track.BackgroundColor3 = self.TrackColor
        track.BorderSizePixel = 0
        track.Parent = trackContainer
        self._track = track

        local trackCorner = Instance.new("UICorner")
        trackCorner.CornerRadius = UDim.new(1, 0)
        trackCorner.Parent = track

        -- Fill
        local fill = Instance.new("Frame")
        fill.Name = "Fill"
        fill.Size = UDim2.new(self:_getProgress(), 0, 1, 0)
        fill.BackgroundColor3 = self.FillColor
        fill.BorderSizePixel = 0
        fill.Parent = track
        self._fill = fill

        local fillCorner = Instance.new("UICorner")
        fillCorner.CornerRadius = UDim.new(1, 0)
        fillCorner.Parent = fill

        -- Knob
        local knob = Instance.new("Frame")
        knob.Name = "Knob"
        knob.Size = UDim2.new(0, 18, 0, 18)
        knob.Position = UDim2.new(self:_getProgress(), 0, 0.5, 0)
        knob.AnchorPoint = Vector2.new(0.5, 0.5)
        knob.BackgroundColor3 = self.KnobColor
        knob.BorderSizePixel = 0
        knob.ZIndex = 2
        knob.Parent = trackContainer
        self._knob = knob

        local knobCorner = Instance.new("UICorner")
        knobCorner.CornerRadius = UDim.new(1, 0)
        knobCorner.Parent = knob

        -- Knob shadow
        local knobShadow = Instance.new("ImageLabel")
        knobShadow.Name = "Shadow"
        knobShadow.Size = UDim2.new(1, 12, 1, 12)
        knobShadow.Position = UDim2.new(0.5, 0, 0.5, 2)
        knobShadow.AnchorPoint = Vector2.new(0.5, 0.5)
        knobShadow.BackgroundTransparency = 1
        knobShadow.Image = "rbxassetid://6015897843"
        knobShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
        knobShadow.ImageTransparency = 0.6
        knobShadow.ScaleType = Enum.ScaleType.Slice
        knobShadow.SliceCenter = Rect.new(49, 49, 450, 450)
        knobShadow.ZIndex = 1
        knobShadow.Parent = knob

        -- Click area (invisible button for easier interaction)
        local clickArea = Instance.new("TextButton")
        clickArea.Name = "ClickArea"
        clickArea.Size = UDim2.new(1, 0, 1, 0)
        clickArea.BackgroundTransparency = 1
        clickArea.Text = ""
        clickArea.ZIndex = 3
        clickArea.Parent = trackContainer
        self._clickArea = clickArea

        -- Setup interactions
        self:_setupInteractions()

        return self
    end

    --// Format value
    function Slider:_formatValue(value)
        return string.format(self.ValueFormat, value) .. self.ValueSuffix
    end

    --// Get progress (0-1)
    function Slider:_getProgress()
        return (self.Value - self.Min) / (self.Max - self.Min)
    end

    --// Value from progress
    function Slider:_valueFromProgress(progress)
        local rawValue = self.Min + (self.Max - self.Min) * progress

        -- Apply step
        if self.Step > 0 then
            rawValue = math.floor(rawValue / self.Step + 0.5) * self.Step
        end

        return math.clamp(rawValue, self.Min, self.Max)
    end

    --// Setup interactions
    function Slider:_setupInteractions()
        local clickArea = self._clickArea
        local track = self._track

        -- Update from mouse position
        local function updateFromMouse()
            local mousePos = UserInputService:GetMouseLocation()
            local trackPos = track.AbsolutePosition
            local trackSize = track.AbsoluteSize

            local relativeX = mousePos.X - trackPos.X
            local progress = math.clamp(relativeX / trackSize.X, 0, 1)
            local newValue = self:_valueFromProgress(progress)

            self:SetValue(newValue, false)
        end

        -- Mouse down
        self:_connect(clickArea.MouseButton1Down, function()
            if not self.IsEnabled then return end

            self._isDragging = true

            TweenService:Create(self._knob, TweenInfo.new(0.1), {
                Size = UDim2.new(0, 22, 0, 22),
            }):Play()

            if self.OnDragStart then
                self.OnDragStart(self.Value)
            end

            self:_fire("DragStart", self.Value)

            updateFromMouse()
        end)

        -- Mouse move (while dragging)
        local moveConnection
        self:_connect(clickArea.MouseButton1Down, function()
            if moveConnection then
                moveConnection:Disconnect()
            end

            moveConnection = RunService.Heartbeat:Connect(function()
                if self._isDragging then
                    updateFromMouse()
                end
            end)
        end)

        -- Mouse up
        self:_connect(UserInputService.InputEnded, function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 and self._isDragging then
                self._isDragging = false

                if moveConnection then
                    moveConnection:Disconnect()
                    moveConnection = nil
                end

                TweenService:Create(self._knob, TweenInfo.new(0.1), {
                    Size = UDim2.new(0, 18, 0, 18),
                }):Play()

                if self.OnDragEnd then
                    self.OnDragEnd(self.Value)
                end

                self:_fire("DragEnd", self.Value)
            end
        end)

        -- Hover
        self:_connect(clickArea.MouseEnter, function()
            if not self.IsEnabled then return end

            if not self._isDragging then
                TweenService:Create(self._knob, TweenInfo.new(0.1), {
                    Size = UDim2.new(0, 20, 0, 20),
                }):Play()
            end
        end)

        self:_connect(clickArea.MouseLeave, function()
            if not self._isDragging then
                TweenService:Create(self._knob, TweenInfo.new(0.1), {
                    Size = UDim2.new(0, 18, 0, 18),
                }):Play()
            end
        end)
    end

    --// Set value
    function Slider:SetValue(value, animate)
        value = math.clamp(value, self.Min, self.Max)

        -- Apply step
        if self.Step > 0 then
            value = math.floor(value / self.Step + 0.5) * self.Step
        end

        if math.abs(self.Value - value) < 0.001 then return self end

        local oldValue = self.Value
        self.Value = value
        animate = animate ~= false and not self._isDragging

        local progress = self:_getProgress()
        local duration = animate and 0.15 or 0

        -- Update visuals
        TweenService:Create(self._fill, TweenInfo.new(duration), {
            Size = UDim2.new(progress, 0, 1, 0),
        }):Play()

        TweenService:Create(self._knob, TweenInfo.new(duration), {
            Position = UDim2.new(progress, 0, 0.5, 0),
        }):Play()

        -- Update value label
        if self._valueLabel then
            self._valueLabel.Text = self:_formatValue(value)
        end

        -- Callback
        if self.OnValueChanged then
            self.OnValueChanged(value, oldValue)
        end

        self:_fire("ValueChanged", value, oldValue)

        return self
    end

    --// Get value
    function Slider:GetValue()
        return self.Value
    end

    --// Set range
    function Slider:SetRange(min, max)
        self.Min = min
        self.Max = max
        self:SetValue(math.clamp(self.Value, min, max))
        return self
    end

    --// Set step
    function Slider:SetStep(step)
        self.Step = step
        return self
    end

    --// Set colors
    function Slider:SetColors(trackColor, fillColor, knobColor)
        if trackColor then
            self.TrackColor = trackColor
            self._track.BackgroundColor3 = trackColor
        end

        if fillColor then
            self.FillColor = fillColor
            self._fill.BackgroundColor3 = fillColor
        end

        if knobColor then
            self.KnobColor = knobColor
            self._knob.BackgroundColor3 = knobColor
        end

        return self
    end

    return Slider


end


-- ============================================================================
-- Module: NexusUI/Components/ProgressBar
-- ============================================================================
NexusUI_Modules["NexusUI/Components/ProgressBar"] = function()
    local script = CreateMockScript("NexusUI/Components/ProgressBar")
    
    --[[
        NexusUI ProgressBar Component
        Progress indicator with various styles
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")
    local RunService = game:GetService("RunService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// ProgressBar Component Module
    local ProgressBar = setmetatable({}, { __index = Base })
    ProgressBar.__index = ProgressBar
    ProgressBar.ClassName = "ProgressBar"

    --// Style variants
    ProgressBar.Style = {
        Default = "Default",
        Striped = "Striped",
        Animated = "Animated",
        Gradient = "Gradient",
    }

    --// Constructor
    function ProgressBar.new(config)
        local self = setmetatable(Base.new(config), ProgressBar)

        config = config or {}

        self.Value = config.Value or 0
        self.Max = config.Max or 100
        self.Style = config.Style or ProgressBar.Style.Default
        self.ShowLabel = config.ShowLabel or false
        self.LabelFormat = config.LabelFormat or "%.0f%%"
        self.Height = config.Height or 8
        self.TrackColor = config.TrackColor or Color3.fromRGB(39, 39, 42)
        self.FillColor = config.FillColor or Color3.fromRGB(99, 102, 241)
        self.FillColorSecondary = config.FillColorSecondary or Color3.fromRGB(139, 92, 246)
        self.Indeterminate = config.Indeterminate or false
        self.AnimationSpeed = config.AnimationSpeed or 1

        -- State
        self._animationConnection = nil

        return self
    end

    --// Create progress bar
    function ProgressBar:Create(parent)
        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(1, 0, 0, self.Height)
        container.BackgroundTransparency = 1

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Track
        local track = Instance.new("Frame")
        track.Name = "Track"
        track.Size = UDim2.new(1, 0, 1, 0)
        track.BackgroundColor3 = self.TrackColor
        track.BorderSizePixel = 0
        track.ClipsDescendants = true
        track.Parent = container
        self._track = track

        local trackCorner = Instance.new("UICorner")
        trackCorner.CornerRadius = UDim.new(1, 0)
        trackCorner.Parent = track

        -- Fill
        local fill = Instance.new("Frame")
        fill.Name = "Fill"
        fill.Size = UDim2.new(self:_getProgress(), 0, 1, 0)
        fill.BackgroundColor3 = self.FillColor
        fill.BorderSizePixel = 0
        fill.Parent = track
        self._fill = fill

        local fillCorner = Instance.new("UICorner")
        fillCorner.CornerRadius = UDim.new(1, 0)
        fillCorner.Parent = fill

        -- Apply style
        self:_applyStyle()

        -- Start animations if needed
        if self.Indeterminate then
            self:_startIndeterminateAnimation()
        elseif self.Style == ProgressBar.Style.Animated then
            self:_startStripedAnimation()
        end

        return self
    end

    --// Get progress (0-1)
    function ProgressBar:_getProgress()
        return math.clamp(self.Value / self.Max, 0, 1)
    end

    --// Apply style
    function ProgressBar:_applyStyle()
        -- Clear existing gradients/patterns
        for _, child in ipairs(self._fill:GetChildren()) do
            if child:IsA("UIGradient") or child.Name == "Stripes" then
                child:Destroy()
            end
        end

        if self.Style == ProgressBar.Style.Gradient then
            local gradient = Instance.new("UIGradient")
            gradient.Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, self.FillColor),
                ColorSequenceKeypoint.new(1, self.FillColorSecondary),
            })
            gradient.Rotation = 90
            gradient.Parent = self._fill

        elseif self.Style == ProgressBar.Style.Striped or self.Style == ProgressBar.Style.Animated then
            -- Create stripes with image
            local stripes = Instance.new("ImageLabel")
            stripes.Name = "Stripes"
            stripes.Size = UDim2.new(2, 0, 1, 0)
            stripes.Position = UDim2.new(0, 0, 0, 0)
            stripes.BackgroundTransparency = 1
            stripes.Image = "rbxassetid://6034818372" -- Diagonal stripes pattern
            stripes.ImageColor3 = Color3.fromRGB(255, 255, 255)
            stripes.ImageTransparency = 0.85
            stripes.ScaleType = Enum.ScaleType.Tile
            stripes.TileSize = UDim2.new(0, 30, 0, 30)
            stripes.Parent = self._fill
            self._stripes = stripes
        end
    end

    --// Start indeterminate animation
    function ProgressBar:_startIndeterminateAnimation()
        self:_stopAnimations()

        self._fill.Size = UDim2.new(0.3, 0, 1, 0)

        self._animationConnection = RunService.Heartbeat:Connect(function(dt)
            local currentX = self._fill.Position.X.Scale
            local newX = currentX + dt * self.AnimationSpeed

            if newX > 1 then
                newX = -0.3
            end

            self._fill.Position = UDim2.new(newX, 0, 0, 0)
        end)
    end

    --// Start striped animation
    function ProgressBar:_startStripedAnimation()
        self:_stopAnimations()

        if not self._stripes then return end

        self._animationConnection = RunService.Heartbeat:Connect(function(dt)
            local currentX = self._stripes.Position.X.Offset
            local newX = currentX - dt * 50 * self.AnimationSpeed

            if newX < -30 then
                newX = 0
            end

            self._stripes.Position = UDim2.new(0, newX, 0, 0)
        end)
    end

    --// Stop animations
    function ProgressBar:_stopAnimations()
        if self._animationConnection then
            self._animationConnection:Disconnect()
            self._animationConnection = nil
        end
    end

    --// Set value
    function ProgressBar:SetValue(value, animate)
        value = math.clamp(value, 0, self.Max)

        if self.Indeterminate then return self end

        local oldValue = self.Value
        self.Value = value
        animate = animate ~= false

        local progress = self:_getProgress()
        local duration = animate and 0.3 or 0

        TweenService:Create(self._fill, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            Size = UDim2.new(progress, 0, 1, 0),
        }):Play()

        self:_fire("ValueChanged", value, oldValue)

        return self
    end

    --// Get value
    function ProgressBar:GetValue()
        return self.Value
    end

    --// Increment
    function ProgressBar:Increment(amount)
        return self:SetValue(self.Value + (amount or 1))
    end

    --// Decrement
    function ProgressBar:Decrement(amount)
        return self:SetValue(self.Value - (amount or 1))
    end

    --// Set indeterminate
    function ProgressBar:SetIndeterminate(indeterminate)
        self.Indeterminate = indeterminate

        if indeterminate then
            self:_startIndeterminateAnimation()
        else
            self:_stopAnimations()
            self._fill.Position = UDim2.new(0, 0, 0, 0)
            self:SetValue(self.Value, false)
        end

        return self
    end

    --// Set style
    function ProgressBar:SetStyle(style)
        self.Style = style
        self:_applyStyle()

        if style == ProgressBar.Style.Animated and not self.Indeterminate then
            self:_startStripedAnimation()
        elseif not self.Indeterminate then
            self:_stopAnimations()
        end

        return self
    end

    --// Set colors
    function ProgressBar:SetColors(fillColor, fillColorSecondary, trackColor)
        if fillColor then
            self.FillColor = fillColor
            self._fill.BackgroundColor3 = fillColor
        end

        if fillColorSecondary then
            self.FillColorSecondary = fillColorSecondary
        end

        if trackColor then
            self.TrackColor = trackColor
            self._track.BackgroundColor3 = trackColor
        end

        -- Re-apply style for gradient
        if self.Style == ProgressBar.Style.Gradient then
            self:_applyStyle()
        end

        return self
    end

    --// Destroy override
    function ProgressBar:Destroy()
        self:_stopAnimations()
        Base.Destroy(self)
    end

    return ProgressBar


end


-- ============================================================================
-- Module: NexusUI/Components/Divider
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Divider"] = function()
    local script = CreateMockScript("NexusUI/Components/Divider")
    
    --[[
        NexusUI Divider Component
        Visual separator between content
    ]]

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Divider Component Module
    local Divider = setmetatable({}, { __index = Base })
    Divider.__index = Divider
    Divider.ClassName = "Divider"

    --// Divider Orientation
    Divider.Orientation = {
        Horizontal = "Horizontal",
        Vertical = "Vertical",
    }

    --// Constructor
    function Divider.new(config)
        local self = setmetatable(Base.new(config), Divider)

        config = config or {}

        self.Orientation = config.Orientation or Divider.Orientation.Horizontal
        self.Thickness = config.Thickness or 1
        self.Color = config.Color or Color3.fromRGB(63, 63, 70)
        self.Text = config.Text
        self.TextPosition = config.TextPosition or "Center" -- Left, Center, Right
        self.Margin = config.Margin or 0

        return self
    end

    --// Create divider
    function Divider:Create(parent)
        local isHorizontal = self.Orientation == Divider.Orientation.Horizontal

        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.BackgroundTransparency = 1

        if isHorizontal then
            container.Size = UDim2.new(1, 0, 0, self.Text and 20 or self.Thickness)
        else
            container.Size = UDim2.new(0, self.Thickness, 1, 0)
        end

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        if self.Text and isHorizontal then
            -- Divider with text
            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Horizontal
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.Padding = UDim.new(0, 12)
            layout.Parent = container

            -- Left line
            local leftLine = Instance.new("Frame")
            leftLine.Name = "LeftLine"
            leftLine.BackgroundColor3 = self.Color
            leftLine.BorderSizePixel = 0
            leftLine.LayoutOrder = 1
            leftLine.Parent = container
            self._leftLine = leftLine

            -- Text
            local text = Instance.new("TextLabel")
            text.Name = "Text"
            text.Size = UDim2.new(0, 0, 0, 0)
            text.AutomaticSize = Enum.AutomaticSize.XY
            text.BackgroundTransparency = 1
            text.Font = Enum.Font.Gotham
            text.Text = self.Text
            text.TextColor3 = Color3.fromRGB(113, 113, 122)
            text.TextSize = 12
            text.LayoutOrder = 2
            text.Parent = container
            self._text = text

            -- Right line
            local rightLine = Instance.new("Frame")
            rightLine.Name = "RightLine"
            rightLine.BackgroundColor3 = self.Color
            rightLine.BorderSizePixel = 0
            rightLine.LayoutOrder = 3
            rightLine.Parent = container
            self._rightLine = rightLine

            -- Calculate line sizes based on text position
            self:_updateLinePositions()

        else
            -- Simple line
            local line = Instance.new("Frame")
            line.Name = "Line"
            line.Size = UDim2.new(1, 0, 1, 0)
            line.BackgroundColor3 = self.Color
            line.BorderSizePixel = 0
            line.Parent = container
            self._line = line
        end

        return self
    end

    --// Update line positions based on text position
    function Divider:_updateLinePositions()
        if not self._leftLine or not self._rightLine then return end

        if self.TextPosition == "Left" then
            self._leftLine.Size = UDim2.new(0, 20, 0, self.Thickness)
            self._rightLine.Size = UDim2.new(1, -100, 0, self.Thickness)
        elseif self.TextPosition == "Right" then
            self._leftLine.Size = UDim2.new(1, -100, 0, self.Thickness)
            self._rightLine.Size = UDim2.new(0, 20, 0, self.Thickness)
        else -- Center
            self._leftLine.Size = UDim2.new(0.5, -40, 0, self.Thickness)
            self._rightLine.Size = UDim2.new(0.5, -40, 0, self.Thickness)
        end
    end

    --// Set color
    function Divider:SetColor(color)
        self.Color = color

        if self._line then
            self._line.BackgroundColor3 = color
        end

        if self._leftLine then
            self._leftLine.BackgroundColor3 = color
        end

        if self._rightLine then
            self._rightLine.BackgroundColor3 = color
        end

        return self
    end

    --// Set text
    function Divider:SetText(text)
        self.Text = text

        if self._text then
            self._text.Text = text
        end

        return self
    end

    return Divider


end


-- ============================================================================
-- Module: NexusUI/Components/Spacer
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Spacer"] = function()
    local script = CreateMockScript("NexusUI/Components/Spacer")
    
    --[[
        NexusUI Spacer Component
        Flexible space between components
    ]]

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Spacer Component Module
    local Spacer = setmetatable({}, { __index = Base })
    Spacer.__index = Spacer
    Spacer.ClassName = "Spacer"

    --// Constructor
    function Spacer.new(config)
        local self = setmetatable(Base.new(config), Spacer)

        config = config or {}

        self.Width = config.Width or 0
        self.Height = config.Height or 0
        self.Flex = config.Flex or 0 -- For flexible spacing in layouts

        return self
    end

    --// Create spacer
    function Spacer:Create(parent)
        local spacer = Instance.new("Frame")
        spacer.Name = self.Name
        spacer.BackgroundTransparency = 1
        spacer.BorderSizePixel = 0

        if self.Flex > 0 then
            -- Flexible spacer (grows to fill space)
            spacer.Size = UDim2.new(self.Flex, 0, self.Flex, 0)
        else
            -- Fixed spacer
            spacer.Size = UDim2.new(0, self.Width, 0, self.Height)
        end

        if parent then
            spacer.Parent = parent
        end

        self.Instance = spacer

        return self
    end

    --// Set size
    function Spacer:SetSize(width, height)
        self.Width = width or self.Width
        self.Height = height or self.Height

        if self.Instance and self.Flex == 0 then
            self.Instance.Size = UDim2.new(0, self.Width, 0, self.Height)
        end

        return self
    end

    --// Set flex
    function Spacer:SetFlex(flex)
        self.Flex = flex

        if self.Instance then
            if flex > 0 then
                self.Instance.Size = UDim2.new(flex, 0, flex, 0)
            else
                self.Instance.Size = UDim2.new(0, self.Width, 0, self.Height)
            end
        end

        return self
    end

    return Spacer


end


-- ============================================================================
-- Module: NexusUI/Components/Icon
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Icon"] = function()
    local script = CreateMockScript("NexusUI/Components/Icon")
    
    --[[
        NexusUI Icon Component
        Roblox icon display with easy customization
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Icon Component Module
    local Icon = setmetatable({}, { __index = Base })
    Icon.__index = Icon
    Icon.ClassName = "Icon"

    --// Built-in icon library (Roblox asset IDs)
    Icon.Library = {
        -- Navigation
        Home = "rbxassetid://7733964719",
        Menu = "rbxassetid://7733960805",
        Close = "rbxassetid://7072725342",
        Back = "rbxassetid://7072706620",
        Forward = "rbxassetid://7072706796",
        Up = "rbxassetid://7072725612",
        Down = "rbxassetid://7072706223",

        -- Actions
        Search = "rbxassetid://7072718929",
        Settings = "rbxassetid://7059346373",
        Edit = "rbxassetid://7072706435",
        Delete = "rbxassetid://7072706189",
        Add = "rbxassetid://7072706044",
        Remove = "rbxassetid://7072718651",
        Refresh = "rbxassetid://7072718464",
        Copy = "rbxassetid://7072706104",

        -- Status
        Check = "rbxassetid://7072706016",
        Warning = "rbxassetid://7072725760",
        Error = "rbxassetid://7072706350",
        Info = "rbxassetid://7072718185",

        -- Media
        Play = "rbxassetid://7072718281",
        Pause = "rbxassetid://7072718165",
        Stop = "rbxassetid://7072725252",
        Volume = "rbxassetid://7072725693",
        Mute = "rbxassetid://7072718013",

        -- User
        User = "rbxassetid://7072725516",
        Users = "rbxassetid://7072725573",

        -- Files
        File = "rbxassetid://7072706527",
        Folder = "rbxassetid://7072706609",
        Image = "rbxassetid://7072718089",
        Download = "rbxassetid://7072706290",
        Upload = "rbxassetid://7072725470",

        -- Communication
        Chat = "rbxassetid://7072705970",
        Mail = "rbxassetid://7072717874",
        Send = "rbxassetid://7072718820",

        -- Misc
        Star = "rbxassetid://7072725131",
        Heart = "rbxassetid://7072717960",
        Lock = "rbxassetid://7072717802",
        Unlock = "rbxassetid://7072725399",
        Eye = "rbxassetid://7072706494",
        EyeOff = "rbxassetid://7072706461",
        Link = "rbxassetid://7072717730",
        Maximize = "rbxassetid://7072717952",
        Minimize = "rbxassetid://7072717970",

        -- Gaming
        Gamepad = "rbxassetid://7072706686",
        Sword = "rbxassetid://7072725310",
        Shield = "rbxassetid://7072718985",
        Coin = "rbxassetid://7072706072",
        Trophy = "rbxassetid://7072725363",
    }

    --// Constructor
    function Icon.new(config)
        local self = setmetatable(Base.new(config), Icon)

        config = config or {}

        self.IconName = config.Icon -- Name from library
        self.IconId = config.IconId -- Direct asset ID
        self.IconSize = config.Size or 24
        self.Color = config.Color or Color3.fromRGB(250, 250, 250)
        self.Clickable = config.Clickable or false
        self.HoverColor = config.HoverColor or Color3.fromRGB(99, 102, 241)

        -- Callbacks
        self.OnClick = config.OnClick

        return self
    end

    --// Create icon
    function Icon:Create(parent)
        local iconId = self.IconId or Icon.Library[self.IconName] or Icon.Library.Info

        -- Icon container
        local container

        if self.Clickable then
            container = Instance.new("ImageButton")
            container.AutoButtonColor = false
        else
            container = Instance.new("ImageLabel")
        end

        container.Name = self.Name
        container.Size = UDim2.new(0, self.IconSize, 0, self.IconSize)
        container.BackgroundTransparency = 1
        container.Image = iconId
        container.ImageColor3 = self.Color
        container.ScaleType = Enum.ScaleType.Fit

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Setup interactions
        if self.Clickable then
            self:_setupInteractions()
        end

        return self
    end

    --// Setup interactions
    function Icon:_setupInteractions()
        local container = self.Instance

        -- Hover
        self:_connect(container.MouseEnter, function()
            TweenService:Create(container, TweenInfo.new(0.15), {
                ImageColor3 = self.HoverColor,
            }):Play()
        end)

        self:_connect(container.MouseLeave, function()
            TweenService:Create(container, TweenInfo.new(0.15), {
                ImageColor3 = self.Color,
            }):Play()
        end)

        -- Click
        self:_connect(container.MouseButton1Click, function()
            if self.OnClick then
                self.OnClick()
            end

            self:_fire("Click")
        end)

        -- Press effect
        self:_connect(container.MouseButton1Down, function()
            TweenService:Create(container, TweenInfo.new(0.05), {
                Size = UDim2.new(0, self.IconSize * 0.9, 0, self.IconSize * 0.9),
            }):Play()
        end)

        self:_connect(container.MouseButton1Up, function()
            TweenService:Create(container, TweenInfo.new(0.1, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                Size = UDim2.new(0, self.IconSize, 0, self.IconSize),
            }):Play()
        end)
    end

    --// Set icon by name
    function Icon:SetIcon(iconName)
        self.IconName = iconName
        local iconId = Icon.Library[iconName]

        if iconId and self.Instance then
            self.Instance.Image = iconId
        end

        return self
    end

    --// Set icon by ID
    function Icon:SetIconId(iconId)
        self.IconId = iconId

        if self.Instance then
            self.Instance.Image = iconId
        end

        return self
    end

    --// Set color
    function Icon:SetColor(color)
        self.Color = color

        if self.Instance then
            self.Instance.ImageColor3 = color
        end

        return self
    end

    --// Set size
    function Icon:SetSize(size)
        self.IconSize = size

        if self.Instance then
            self.Instance.Size = UDim2.new(0, size, 0, size)
        end

        return self
    end

    --// Animate rotation
    function Icon:Spin(duration, loops)
        if not self.Instance then return self end

        duration = duration or 1
        loops = loops or math.huge

        task.spawn(function()
            for i = 1, loops do
                TweenService:Create(self.Instance, TweenInfo.new(duration, Enum.EasingStyle.Linear), {
                    Rotation = self.Instance.Rotation + 360,
                }):Play()
                task.wait(duration)
            end
        end)

        return self
    end

    --// Pulse animation
    function Icon:Pulse()
        if not self.Instance then return self end

        local originalSize = self.IconSize

        TweenService:Create(self.Instance, TweenInfo.new(0.15), {
            Size = UDim2.new(0, originalSize * 1.2, 0, originalSize * 1.2),
        }):Play()

        task.delay(0.15, function()
            TweenService:Create(self.Instance, TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                Size = UDim2.new(0, originalSize, 0, originalSize),
            }):Play()
        end)

        return self
    end

    return Icon


end


-- ============================================================================
-- Module: NexusUI/Components/Avatar
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Avatar"] = function()
    local script = CreateMockScript("NexusUI/Components/Avatar")
    
    --[[
        NexusUI Avatar Component
        User avatar display with various shapes
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")
    local Players = game:GetService("Players")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Avatar Component Module
    local Avatar = setmetatable({}, { __index = Base })
    Avatar.__index = Avatar
    Avatar.ClassName = "Avatar"

    --// Avatar Shapes
    Avatar.Shape = {
        Circle = "Circle",
        Square = "Square",
        Rounded = "Rounded",
    }

    --// Avatar Sizes
    Avatar.Size = {
        XS = 24,
        SM = 32,
        MD = 40,
        LG = 56,
        XL = 80,
    }

    --// Constructor
    function Avatar.new(config)
        local self = setmetatable(Base.new(config), Avatar)

        config = config or {}

        self.Image = config.Image
        self.UserId = config.UserId
        self.Initials = config.Initials
        self.AvatarSize = config.Size or Avatar.Size.MD
        self.Shape = config.Shape or Avatar.Shape.Circle
        self.BorderColor = config.BorderColor
        self.BorderWidth = config.BorderWidth or 0
        self.StatusIndicator = config.StatusIndicator -- "online", "offline", "away", "busy"
        self.FallbackColor = config.FallbackColor or Color3.fromRGB(99, 102, 241)

        return self
    end

    --// Get status color
    function Avatar:_getStatusColor()
        local colors = {
            online = Color3.fromRGB(34, 197, 94),
            offline = Color3.fromRGB(113, 113, 122),
            away = Color3.fromRGB(245, 158, 11),
            busy = Color3.fromRGB(239, 68, 68),
        }

        return colors[self.StatusIndicator] or Color3.fromRGB(113, 113, 122)
    end

    --// Get corner radius
    function Avatar:_getCornerRadius()
        if self.Shape == Avatar.Shape.Circle then
            return UDim.new(1, 0)
        elseif self.Shape == Avatar.Shape.Square then
            return UDim.new(0, 0)
        else -- Rounded
            return UDim.new(0, 8)
        end
    end

    --// Create avatar
    function Avatar:Create(parent)
        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(0, self.AvatarSize, 0, self.AvatarSize)
        container.BackgroundTransparency = 1

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Avatar frame
        local avatar = Instance.new("Frame")
        avatar.Name = "Avatar"
        avatar.Size = UDim2.new(1, 0, 1, 0)
        avatar.BackgroundColor3 = self.FallbackColor
        avatar.BorderSizePixel = 0
        avatar.ClipsDescendants = true
        avatar.Parent = container
        self._avatar = avatar

        -- Corner
        local corner = Instance.new("UICorner")
        corner.CornerRadius = self:_getCornerRadius()
        corner.Parent = avatar

        -- Border
        if self.BorderWidth > 0 then
            local stroke = Instance.new("UIStroke")
            stroke.Color = self.BorderColor or Color3.fromRGB(255, 255, 255)
            stroke.Thickness = self.BorderWidth
            stroke.Parent = avatar
            self._stroke = stroke
        end

        -- Image
        local image = Instance.new("ImageLabel")
        image.Name = "Image"
        image.Size = UDim2.new(1, 0, 1, 0)
        image.BackgroundTransparency = 1
        image.ImageTransparency = 1
        image.ScaleType = Enum.ScaleType.Crop
        image.Parent = avatar
        self._image = image

        local imageCorner = Instance.new("UICorner")
        imageCorner.CornerRadius = self:_getCornerRadius()
        imageCorner.Parent = image

        -- Initials (fallback)
        local initials = Instance.new("TextLabel")
        initials.Name = "Initials"
        initials.Size = UDim2.new(1, 0, 1, 0)
        initials.BackgroundTransparency = 1
        initials.Font = Enum.Font.GothamBold
        initials.Text = self.Initials or ""
        initials.TextColor3 = Color3.fromRGB(255, 255, 255)
        initials.TextSize = self.AvatarSize * 0.4
        initials.Parent = avatar
        self._initials = initials

        -- Status indicator
        if self.StatusIndicator then
            local statusSize = math.max(self.AvatarSize * 0.25, 8)

            local status = Instance.new("Frame")
            status.Name = "Status"
            status.Size = UDim2.new(0, statusSize, 0, statusSize)
            status.Position = UDim2.new(1, -statusSize * 0.3, 1, -statusSize * 0.3)
            status.AnchorPoint = Vector2.new(1, 1)
            status.BackgroundColor3 = self:_getStatusColor()
            status.BorderSizePixel = 0
            status.ZIndex = 2
            status.Parent = container
            self._status = status

            local statusCorner = Instance.new("UICorner")
            statusCorner.CornerRadius = UDim.new(1, 0)
            statusCorner.Parent = status

            -- Status border
            local statusBorder = Instance.new("UIStroke")
            statusBorder.Color = Color3.fromRGB(30, 30, 35)
            statusBorder.Thickness = 2
            statusBorder.Parent = status
        end

        -- Load image
        self:_loadImage()

        return self
    end

    --// Load image
    function Avatar:_loadImage()
        local imageUrl = self.Image

        -- If UserId provided, get thumbnail
        if self.UserId and not self.Image then
            imageUrl = Players:GetUserThumbnailAsync(
                self.UserId,
                Enum.ThumbnailType.HeadShot,
                Enum.ThumbnailSize.Size100x100
            )
        end

        if imageUrl then
            self._image.Image = imageUrl

            -- Fade in when loaded
            TweenService:Create(self._image, TweenInfo.new(0.2), {
                ImageTransparency = 0,
            }):Play()

            -- Hide initials
            self._initials.Visible = false
        else
            -- Show initials as fallback
            self._initials.Visible = true
            self._image.Visible = false
        end
    end

    --// Set image
    function Avatar:SetImage(image)
        self.Image = image
        self:_loadImage()
        return self
    end

    --// Set user ID
    function Avatar:SetUserId(userId)
        self.UserId = userId
        self.Image = nil
        self:_loadImage()
        return self
    end

    --// Set initials
    function Avatar:SetInitials(initials)
        self.Initials = initials

        if self._initials then
            self._initials.Text = initials
        end

        return self
    end

    --// Set status
    function Avatar:SetStatus(status)
        self.StatusIndicator = status

        if self._status then
            TweenService:Create(self._status, TweenInfo.new(0.2), {
                BackgroundColor3 = self:_getStatusColor(),
            }):Play()
        end

        return self
    end

    --// Set shape
    function Avatar:SetShape(shape)
        self.Shape = shape
        local radius = self:_getCornerRadius()

        if self._avatar then
            for _, child in ipairs(self._avatar:GetChildren()) do
                if child:IsA("UICorner") then
                    child.CornerRadius = radius
                end
            end
        end

        return self
    end

    --// Show online pulse
    function Avatar:ShowOnlinePulse()
        if not self._status then return self end

        local ring = Instance.new("Frame")
        ring.Name = "PulseRing"
        ring.Size = UDim2.new(1, 0, 1, 0)
        ring.Position = UDim2.new(0.5, 0, 0.5, 0)
        ring.AnchorPoint = Vector2.new(0.5, 0.5)
        ring.BackgroundColor3 = self:_getStatusColor()
        ring.BackgroundTransparency = 0.5
        ring.BorderSizePixel = 0
        ring.ZIndex = self._status.ZIndex - 1
        ring.Parent = self._status

        local ringCorner = Instance.new("UICorner")
        ringCorner.CornerRadius = UDim.new(1, 0)
        ringCorner.Parent = ring

        -- Pulse animation
        local function pulse()
            ring.Size = UDim2.new(1, 0, 1, 0)
            ring.BackgroundTransparency = 0.5

            TweenService:Create(ring, TweenInfo.new(1.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                Size = UDim2.new(2.5, 0, 2.5, 0),
                BackgroundTransparency = 1,
            }):Play()
        end

        pulse()
        task.spawn(function()
            while ring and ring.Parent do
                task.wait(1.5)
                if ring and ring.Parent then
                    pulse()
                end
            end
        end)

        return self
    end

    return Avatar


end


-- ============================================================================
-- Module: NexusUI/Components/Badge
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Badge"] = function()
    local script = CreateMockScript("NexusUI/Components/Badge")
    
    --[[
        NexusUI Badge Component
        Small status indicator or label
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Badge Component Module
    local Badge = setmetatable({}, { __index = Base })
    Badge.__index = Badge
    Badge.ClassName = "Badge"

    --// Badge Variants
    Badge.Variant = {
        Default = "Default",
        Primary = "Primary",
        Secondary = "Secondary",
        Success = "Success",
        Warning = "Warning",
        Danger = "Danger",
        Info = "Info",
        Outline = "Outline",
        Dot = "Dot",
    }

    --// Constructor
    function Badge.new(config)
        local self = setmetatable(Base.new(config), Badge)

        config = config or {}

        self.Text = config.Text or "Badge"
        self.Variant = config.Variant or Badge.Variant.Primary
        self.Icon = config.Icon
        self.Pulse = config.Pulse or false
        self.Count = config.Count
        self.MaxCount = config.MaxCount or 99

        return self
    end

    --// Get variant colors
    function Badge:_getVariantColors()
        local variants = {
            Default = {
                Background = Color3.fromRGB(63, 63, 70),
                Text = Color3.fromRGB(250, 250, 250),
            },
            Primary = {
                Background = Color3.fromRGB(99, 102, 241),
                Text = Color3.fromRGB(255, 255, 255),
            },
            Secondary = {
                Background = Color3.fromRGB(82, 82, 91),
                Text = Color3.fromRGB(250, 250, 250),
            },
            Success = {
                Background = Color3.fromRGB(34, 197, 94),
                Text = Color3.fromRGB(255, 255, 255),
            },
            Warning = {
                Background = Color3.fromRGB(245, 158, 11),
                Text = Color3.fromRGB(0, 0, 0),
            },
            Danger = {
                Background = Color3.fromRGB(239, 68, 68),
                Text = Color3.fromRGB(255, 255, 255),
            },
            Info = {
                Background = Color3.fromRGB(59, 130, 246),
                Text = Color3.fromRGB(255, 255, 255),
            },
            Outline = {
                Background = Color3.fromRGB(0, 0, 0),
                BackgroundTransparency = 1,
                Text = Color3.fromRGB(250, 250, 250),
                BorderColor = Color3.fromRGB(82, 82, 91),
            },
            Dot = {
                Background = Color3.fromRGB(239, 68, 68),
                Text = Color3.fromRGB(255, 255, 255),
            },
        }

        return variants[self.Variant] or variants.Default
    end

    --// Create badge
    function Badge:Create(parent)
        local colors = self:_getVariantColors()
        local isDot = self.Variant == Badge.Variant.Dot

        -- Badge container
        local badge = Instance.new("Frame")
        badge.Name = self.Name
        badge.BackgroundColor3 = colors.Background
        badge.BackgroundTransparency = colors.BackgroundTransparency or 0
        badge.BorderSizePixel = 0

        if isDot then
            badge.Size = UDim2.new(0, 8, 0, 8)
        else
            badge.Size = UDim2.new(0, 0, 0, 22)
            badge.AutomaticSize = Enum.AutomaticSize.X
        end

        if parent then
            badge.Parent = parent
        end

        self.Instance = badge

        -- Corner
        local corner = Instance.new("UICorner")
        corner.CornerRadius = isDot and UDim.new(1, 0) or UDim.new(0, 11)
        corner.Parent = badge

        -- Padding
        if not isDot then
            local padding = Instance.new("UIPadding")
            padding.PaddingLeft = UDim.new(0, 8)
            padding.PaddingRight = UDim.new(0, 8)
            padding.Parent = badge

            -- Layout
            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Horizontal
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.Padding = UDim.new(0, 4)
            layout.Parent = badge

            -- Icon
            if self.Icon then
                local icon = Instance.new("ImageLabel")
                icon.Name = "Icon"
                icon.Size = UDim2.new(0, 12, 0, 12)
                icon.BackgroundTransparency = 1
                icon.Image = self.Icon
                icon.ImageColor3 = colors.Text
                icon.LayoutOrder = 1
                icon.Parent = badge
                self._icon = icon
            end

            -- Text
            local displayText = self.Text
            if self.Count then
                displayText = self.Count > self.MaxCount and (tostring(self.MaxCount) .. "+") or tostring(self.Count)
            end

            local text = Instance.new("TextLabel")
            text.Name = "Text"
            text.Size = UDim2.new(0, 0, 1, 0)
            text.AutomaticSize = Enum.AutomaticSize.X
            text.BackgroundTransparency = 1
            text.Font = Enum.Font.GothamMedium
            text.Text = displayText
            text.TextColor3 = colors.Text
            text.TextSize = 12
            text.LayoutOrder = 2
            text.Parent = badge
            self._text = text
        end

        -- Border for outline
        if self.Variant == Badge.Variant.Outline then
            local stroke = Instance.new("UIStroke")
            stroke.Color = colors.BorderColor
            stroke.Thickness = 1
            stroke.Parent = badge
        end

        -- Pulse animation
        if self.Pulse then
            self:_startPulse()
        end

        return self
    end

    --// Start pulse animation
    function Badge:_startPulse()
        -- Pulse ring
        local ring = Instance.new("Frame")
        ring.Name = "PulseRing"
        ring.Size = UDim2.new(1, 0, 1, 0)
        ring.Position = UDim2.new(0.5, 0, 0.5, 0)
        ring.AnchorPoint = Vector2.new(0.5, 0.5)
        ring.BackgroundColor3 = self.Instance.BackgroundColor3
        ring.BackgroundTransparency = 0.5
        ring.BorderSizePixel = 0
        ring.ZIndex = self.Instance.ZIndex - 1
        ring.Parent = self.Instance
        self._pulseRing = ring

        local ringCorner = Instance.new("UICorner")
        ringCorner.CornerRadius = UDim.new(1, 0)
        ringCorner.Parent = ring

        -- Pulse animation loop
        local function pulse()
            ring.Size = UDim2.new(1, 0, 1, 0)
            ring.BackgroundTransparency = 0.5

            TweenService:Create(ring, TweenInfo.new(1.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                Size = UDim2.new(2.5, 0, 2.5, 0),
                BackgroundTransparency = 1,
            }):Play()
        end

        pulse()
        self._pulseConnection = task.spawn(function()
            while self.Instance and self.Instance.Parent do
                task.wait(1.5)
                pulse()
            end
        end)
    end

    --// Stop pulse
    function Badge:_stopPulse()
        if self._pulseConnection then
            task.cancel(self._pulseConnection)
            self._pulseConnection = nil
        end

        if self._pulseRing then
            self._pulseRing:Destroy()
            self._pulseRing = nil
        end
    end

    --// Set text
    function Badge:SetText(text)
        self.Text = text

        if self._text then
            self._text.Text = text
        end

        return self
    end

    --// Set count
    function Badge:SetCount(count)
        self.Count = count

        if self._text then
            local displayText = count > self.MaxCount and (tostring(self.MaxCount) .. "+") or tostring(count)
            self._text.Text = displayText
        end

        return self
    end

    --// Set variant
    function Badge:SetVariant(variant)
        self.Variant = variant
        local colors = self:_getVariantColors()

        self.Instance.BackgroundColor3 = colors.Background
        self.Instance.BackgroundTransparency = colors.BackgroundTransparency or 0

        if self._text then
            self._text.TextColor3 = colors.Text
        end

        if self._icon then
            self._icon.ImageColor3 = colors.Text
        end

        return self
    end

    --// Set pulse
    function Badge:SetPulse(pulse)
        self.Pulse = pulse

        if pulse then
            self:_startPulse()
        else
            self:_stopPulse()
        end

        return self
    end

    --// Destroy override
    function Badge:Destroy()
        self:_stopPulse()
        Base.Destroy(self)
    end

    return Badge


end


-- ============================================================================
-- Module: NexusUI/Components/Tooltip
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Tooltip"] = function()
    local script = CreateMockScript("NexusUI/Components/Tooltip")
    
    --[[
        NexusUI Tooltip Component
        Contextual information on hover
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Tooltip Component Module
    local Tooltip = setmetatable({}, { __index = Base })
    Tooltip.__index = Tooltip
    Tooltip.ClassName = "Tooltip"

    --// Tooltip Positions
    Tooltip.Position = {
        Top = "Top",
        Bottom = "Bottom",
        Left = "Left",
        Right = "Right",
        Cursor = "Cursor",
    }

    --// Constructor
    function Tooltip.new(config)
        local self = setmetatable(Base.new(config), Tooltip)

        config = config or {}

        self.Text = config.Text or "Tooltip"
        self.TargetInstance = config.Target
        self.TooltipPosition = config.Position or Tooltip.Position.Top
        self.Delay = config.Delay or 0.5
        self.MaxWidth = config.MaxWidth or 200
        self.ShowArrow = config.ShowArrow ~= false
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
        self.TextColor = config.TextColor or Color3.fromRGB(250, 250, 250)

        -- State
        self._visible = false
        self._delayThread = nil
        self._followConnection = nil

        return self
    end

    --// Create tooltip
    function Tooltip:Create(parent)
        -- Get screen gui
        local screenGui = parent
        while screenGui and not screenGui:IsA("ScreenGui") do
            screenGui = screenGui.Parent
        end

        if not screenGui then
            screenGui = Instance.new("ScreenGui")
            screenGui.Parent = game:GetService("CoreGui")
        end

        -- Tooltip container
        local tooltip = Instance.new("Frame")
        tooltip.Name = self.Name
        tooltip.Size = UDim2.new(0, 0, 0, 0)
        tooltip.AutomaticSize = Enum.AutomaticSize.XY
        tooltip.BackgroundColor3 = self.BackgroundColor
        tooltip.BorderSizePixel = 0
        tooltip.Visible = false
        tooltip.ZIndex = 9999
        tooltip.Parent = screenGui
        self.Instance = tooltip

        -- Corner
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 6)
        corner.Parent = tooltip

        -- Shadow
        local shadow = Instance.new("ImageLabel")
        shadow.Name = "Shadow"
        shadow.Size = UDim2.new(1, 16, 1, 16)
        shadow.Position = UDim2.new(0.5, 0, 0.5, 4)
        shadow.AnchorPoint = Vector2.new(0.5, 0.5)
        shadow.BackgroundTransparency = 1
        shadow.Image = "rbxassetid://6015897843"
        shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
        shadow.ImageTransparency = 0.5
        shadow.ScaleType = Enum.ScaleType.Slice
        shadow.SliceCenter = Rect.new(49, 49, 450, 450)
        shadow.ZIndex = tooltip.ZIndex - 1
        shadow.Parent = tooltip

        -- Padding
        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, 8)
        padding.PaddingBottom = UDim.new(0, 8)
        padding.PaddingLeft = UDim.new(0, 12)
        padding.PaddingRight = UDim.new(0, 12)
        padding.Parent = tooltip

        -- Size constraint
        local constraint = Instance.new("UISizeConstraint")
        constraint.MaxSize = Vector2.new(self.MaxWidth, math.huge)
        constraint.Parent = tooltip

        -- Text
        local text = Instance.new("TextLabel")
        text.Name = "Text"
        text.Size = UDim2.new(0, 0, 0, 0)
        text.AutomaticSize = Enum.AutomaticSize.XY
        text.BackgroundTransparency = 1
        text.Font = Enum.Font.Gotham
        text.Text = self.Text
        text.TextColor3 = self.TextColor
        text.TextSize = 12
        text.TextWrapped = true
        text.TextXAlignment = Enum.TextXAlignment.Center
        text.ZIndex = tooltip.ZIndex
        text.Parent = tooltip
        self._text = text

        -- Arrow (if enabled)
        if self.ShowArrow then
            local arrow = Instance.new("ImageLabel")
            arrow.Name = "Arrow"
            arrow.Size = UDim2.new(0, 12, 0, 6)
            arrow.BackgroundTransparency = 1
            arrow.Image = "rbxassetid://4292963604" -- Triangle
            arrow.ImageColor3 = self.BackgroundColor
            arrow.ZIndex = tooltip.ZIndex
            arrow.Parent = tooltip
            self._arrow = arrow
        end

        -- Bind to target
        if self.TargetInstance then
            self:BindTo(self.TargetInstance)
        end

        return self
    end

    --// Update position
    function Tooltip:_updatePosition()
        if not self.TargetInstance or not self.Instance then return end

        local targetPos = self.TargetInstance.AbsolutePosition
        local targetSize = self.TargetInstance.AbsoluteSize
        local tooltipSize = self.Instance.AbsoluteSize

        local x, y = 0, 0
        local arrowRotation = 0
        local arrowX, arrowY = 0.5, 0

        if self.TooltipPosition == Tooltip.Position.Top then
            x = targetPos.X + targetSize.X / 2 - tooltipSize.X / 2
            y = targetPos.Y - tooltipSize.Y - 8
            arrowRotation = 180
            arrowX, arrowY = 0.5, 1

        elseif self.TooltipPosition == Tooltip.Position.Bottom then
            x = targetPos.X + targetSize.X / 2 - tooltipSize.X / 2
            y = targetPos.Y + targetSize.Y + 8
            arrowRotation = 0
            arrowX, arrowY = 0.5, -0.5

        elseif self.TooltipPosition == Tooltip.Position.Left then
            x = targetPos.X - tooltipSize.X - 8
            y = targetPos.Y + targetSize.Y / 2 - tooltipSize.Y / 2
            arrowRotation = 90
            arrowX, arrowY = 1, 0.5

        elseif self.TooltipPosition == Tooltip.Position.Right then
            x = targetPos.X + targetSize.X + 8
            y = targetPos.Y + targetSize.Y / 2 - tooltipSize.Y / 2
            arrowRotation = -90
            arrowX, arrowY = -0.5, 0.5

        elseif self.TooltipPosition == Tooltip.Position.Cursor then
            local mouse = UserInputService:GetMouseLocation()
            x = mouse.X + 12
            y = mouse.Y + 12
        end

        -- Keep on screen
        local viewportSize = workspace.CurrentCamera.ViewportSize
        x = math.clamp(x, 4, viewportSize.X - tooltipSize.X - 4)
        y = math.clamp(y, 4, viewportSize.Y - tooltipSize.Y - 4)

        self.Instance.Position = UDim2.new(0, x, 0, y)

        -- Update arrow
        if self._arrow and self.TooltipPosition ~= Tooltip.Position.Cursor then
            self._arrow.Rotation = arrowRotation
            self._arrow.AnchorPoint = Vector2.new(arrowX, arrowY)

            if self.TooltipPosition == Tooltip.Position.Top then
                self._arrow.Position = UDim2.new(0.5, 0, 1, 0)
            elseif self.TooltipPosition == Tooltip.Position.Bottom then
                self._arrow.Position = UDim2.new(0.5, 0, 0, 0)
            elseif self.TooltipPosition == Tooltip.Position.Left then
                self._arrow.Position = UDim2.new(1, 0, 0.5, 0)
            elseif self.TooltipPosition == Tooltip.Position.Right then
                self._arrow.Position = UDim2.new(0, 0, 0.5, 0)
            end
        end
    end

    --// Show
    function Tooltip:Show(animate)
        if self._visible then return self end

        self._visible = true
        animate = animate ~= false

        self:_updatePosition()
        self.Instance.Visible = true

        if animate then
            self.Instance.BackgroundTransparency = 1
            if self._text then self._text.TextTransparency = 1 end

            TweenService:Create(self.Instance, TweenInfo.new(0.15), {
                BackgroundTransparency = 0,
            }):Play()

            if self._text then
                TweenService:Create(self._text, TweenInfo.new(0.15), {
                    TextTransparency = 0,
                }):Play()
            end
        end

        -- Start following if cursor mode
        if self.TooltipPosition == Tooltip.Position.Cursor then
            self._followConnection = RunService.Heartbeat:Connect(function()
                self:_updatePosition()
            end)
        end

        self:_fire("Show")
        return self
    end

    --// Hide
    function Tooltip:Hide(animate)
        if not self._visible then return self end

        self._visible = false
        animate = animate ~= false

        -- Stop following
        if self._followConnection then
            self._followConnection:Disconnect()
            self._followConnection = nil
        end

        if animate then
            TweenService:Create(self.Instance, TweenInfo.new(0.1), {
                BackgroundTransparency = 1,
            }):Play()

            if self._text then
                TweenService:Create(self._text, TweenInfo.new(0.1), {
                    TextTransparency = 1,
                }):Play()
            end

            task.delay(0.1, function()
                if not self._visible then
                    self.Instance.Visible = false
                end
            end)
        else
            self.Instance.Visible = false
        end

        self:_fire("Hide")
        return self
    end

    --// Bind to instance
    function Tooltip:BindTo(instance)
        self.TargetInstance = instance

        -- Mouse enter
        self:_connect(instance.MouseEnter, function()
            -- Cancel existing delay
            if self._delayThread then
                task.cancel(self._delayThread)
            end

            -- Start delay
            self._delayThread = task.delay(self.Delay, function()
                self:Show()
            end)
        end)

        -- Mouse leave
        self:_connect(instance.MouseLeave, function()
            -- Cancel delay
            if self._delayThread then
                task.cancel(self._delayThread)
                self._delayThread = nil
            end

            self:Hide()
        end)

        return self
    end

    --// Set text
    function Tooltip:SetText(text)
        self.Text = text

        if self._text then
            self._text.Text = text
        end

        return self
    end

    --// Set position
    function Tooltip:SetPosition(position)
        self.TooltipPosition = position
        self:_updatePosition()
        return self
    end

    --// Destroy override
    function Tooltip:Destroy()
        if self._delayThread then
            task.cancel(self._delayThread)
        end

        if self._followConnection then
            self._followConnection:Disconnect()
        end

        Base.Destroy(self)
    end

    return Tooltip


end


-- ============================================================================
-- Module: NexusUI/Components/Image
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Image"] = function()
    local script = CreateMockScript("NexusUI/Components/Image")
    
    --[[
        NexusUI Image Component
        Image display with loading states
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")
    local ContentProvider = game:GetService("ContentProvider")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Image Component Module
    local Image = setmetatable({}, { __index = Base })
    Image.__index = Image
    Image.ClassName = "Image"

    --// Image Fit Modes
    Image.Fit = {
        Cover = "Cover",
        Contain = "Contain",
        Fill = "Fill",
        None = "None",
    }

    --// Constructor
    function Image.new(config)
        local self = setmetatable(Base.new(config), Image)

        config = config or {}

        self.Source = config.Source or ""
        self.FitMode = config.FitMode or Image.Fit.Cover
        self.CornerRadius = config.CornerRadius or 0
        self.FallbackImage = config.FallbackImage
        self.FallbackColor = config.FallbackColor or Color3.fromRGB(39, 39, 42)
        self.ShowLoading = config.ShowLoading or false
        self.Tint = config.Tint or Color3.fromRGB(255, 255, 255)
        self.AspectRatio = config.AspectRatio -- e.g., 16/9

        -- State
        self._isLoaded = false
        self._hasError = false

        return self
    end

    --// Create image
    function Image:Create(parent)
        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(1, 0, 0, 200)
        container.BackgroundColor3 = self.FallbackColor
        container.BorderSizePixel = 0
        container.ClipsDescendants = true

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Corner radius
        if self.CornerRadius > 0 then
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, self.CornerRadius)
            corner.Parent = container
        end

        -- Aspect ratio constraint
        if self.AspectRatio then
            local ratio = Instance.new("UIAspectRatioConstraint")
            ratio.AspectRatio = self.AspectRatio
            ratio.Parent = container
        end

        -- Image
        local image = Instance.new("ImageLabel")
        image.Name = "Image"
        image.BackgroundTransparency = 1
        image.ImageColor3 = self.Tint
        image.ImageTransparency = 1
        image.Parent = container
        self._image = image

        -- Apply fit mode
        self:_applyFitMode()

        -- Corner for image
        if self.CornerRadius > 0 then
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, self.CornerRadius)
            corner.Parent = image
        end

        -- Loading indicator
        if self.ShowLoading then
            local loading = Instance.new("Frame")
            loading.Name = "Loading"
            loading.Size = UDim2.new(0, 30, 0, 30)
            loading.Position = UDim2.new(0.5, 0, 0.5, 0)
            loading.AnchorPoint = Vector2.new(0.5, 0.5)
            loading.BackgroundTransparency = 1
            loading.Parent = container
            self._loading = loading

            -- Spinner
            local spinner = Instance.new("ImageLabel")
            spinner.Name = "Spinner"
            spinner.Size = UDim2.new(1, 0, 1, 0)
            spinner.BackgroundTransparency = 1
            spinner.Image = "rbxassetid://6034818372" -- Spinner icon
            spinner.ImageColor3 = Color3.fromRGB(161, 161, 170)
            spinner.Parent = loading
            self._spinner = spinner

            -- Start spinning
            self:_startSpinner()
        end

        -- Load image
        if self.Source ~= "" then
            self:SetSource(self.Source)
        end

        return self
    end

    --// Apply fit mode
    function Image:_applyFitMode()
        if not self._image then return end

        if self.FitMode == Image.Fit.Cover then
            self._image.Size = UDim2.new(1, 0, 1, 0)
            self._image.Position = UDim2.new(0, 0, 0, 0)
            self._image.ScaleType = Enum.ScaleType.Crop

        elseif self.FitMode == Image.Fit.Contain then
            self._image.Size = UDim2.new(1, 0, 1, 0)
            self._image.Position = UDim2.new(0, 0, 0, 0)
            self._image.ScaleType = Enum.ScaleType.Fit

        elseif self.FitMode == Image.Fit.Fill then
            self._image.Size = UDim2.new(1, 0, 1, 0)
            self._image.Position = UDim2.new(0, 0, 0, 0)
            self._image.ScaleType = Enum.ScaleType.Stretch

        elseif self.FitMode == Image.Fit.None then
            self._image.Position = UDim2.new(0.5, 0, 0.5, 0)
            self._image.AnchorPoint = Vector2.new(0.5, 0.5)
            self._image.ScaleType = Enum.ScaleType.Fit
            self._image.AutomaticSize = Enum.AutomaticSize.XY
        end
    end

    --// Start spinner animation
    function Image:_startSpinner()
        if not self._spinner then return end

        task.spawn(function()
            while self._spinner and self._spinner.Parent and not self._isLoaded do
                self._spinner.Rotation = self._spinner.Rotation + 5
                task.wait(0.02)
            end
        end)
    end

    --// Stop spinner
    function Image:_stopSpinner()
        if self._loading then
            TweenService:Create(self._loading, TweenInfo.new(0.2), {
                -- Can't tween Visible, so we tween transparency
            }):Play()

            task.delay(0.2, function()
                if self._loading then
                    self._loading.Visible = false
                end
            end)
        end
    end

    --// Set source
    function Image:SetSource(source)
        self.Source = source
        self._isLoaded = false
        self._hasError = false

        if self._image then
            self._image.ImageTransparency = 1

            -- Show loading
            if self._loading then
                self._loading.Visible = true
                self:_startSpinner()
            end

            -- Preload image
            task.spawn(function()
                local success = pcall(function()
                    ContentProvider:PreloadAsync({source})
                end)

                if success then
                    self._image.Image = source
                    self._isLoaded = true

                    -- Fade in
                    TweenService:Create(self._image, TweenInfo.new(0.3), {
                        ImageTransparency = 0,
                    }):Play()

                    self:_stopSpinner()
                    self:_fire("Loaded")

                else
                    self._hasError = true

                    -- Show fallback
                    if self.FallbackImage then
                        self._image.Image = self.FallbackImage
                        TweenService:Create(self._image, TweenInfo.new(0.3), {
                            ImageTransparency = 0,
                        }):Play()
                    end

                    self:_stopSpinner()
                    self:_fire("Error")
                end
            end)
        end

        return self
    end

    --// Set tint
    function Image:SetTint(color)
        self.Tint = color

        if self._image then
            self._image.ImageColor3 = color
        end

        return self
    end

    --// Set fit mode
    function Image:SetFitMode(mode)
        self.FitMode = mode
        self:_applyFitMode()
        return self
    end

    --// Set corner radius
    function Image:SetCornerRadius(radius)
        self.CornerRadius = radius

        local containers = {self.Instance, self._image}
        for _, container in ipairs(containers) do
            if container then
                local corner = container:FindFirstChildOfClass("UICorner")
                if corner then
                    corner.CornerRadius = UDim.new(0, radius)
                elseif radius > 0 then
                    corner = Instance.new("UICorner")
                    corner.CornerRadius = UDim.new(0, radius)
                    corner.Parent = container
                end
            end
        end

        return self
    end

    --// Is loaded
    function Image:IsLoaded()
        return self._isLoaded
    end

    --// Has error
    function Image:HasError()
        return self._hasError
    end

    return Image


end


-- ============================================================================
-- Module: NexusUI/Components/Dropdown
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Dropdown"] = function()
    local script = CreateMockScript("NexusUI/Components/Dropdown")
    
    --[[
        NexusUI Dropdown Component
        Selectable dropdown menu
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Dropdown Component Module
    local Dropdown = setmetatable({}, { __index = Base })
    Dropdown.__index = Dropdown
    Dropdown.ClassName = "Dropdown"

    --// Constructor
    function Dropdown.new(config)
        local self = setmetatable(Base.new(config), Dropdown)

        config = config or {}

        self.Options = config.Options or {} -- Array of {Text, Value, Icon, Disabled}
        self.SelectedIndex = config.SelectedIndex or 0
        self.Placeholder = config.Placeholder or "Select..."
        self.Label = config.Label
        self.Searchable = config.Searchable or false
        self.MaxVisibleItems = config.MaxVisibleItems or 6
        self.DropdownWidth = config.DropdownWidth -- nil = same as button

        -- Callbacks
        self.OnSelect = config.OnSelect
        self.OnOpen = config.OnOpen
        self.OnClose = config.OnClose

        -- State
        self._isOpen = false
        self._filteredOptions = {}
        self._optionButtons = {}

        return self
    end

    --// Create dropdown
    function Dropdown:Create(parent)
        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(1, 0, 0, 40)
        container.BackgroundTransparency = 1
        container.ClipsDescendants = false

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Button
        local button = Instance.new("TextButton")
        button.Name = "Button"
        button.Size = UDim2.new(1, 0, 1, 0)
        button.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        button.BorderSizePixel = 0
        button.Text = ""
        button.AutoButtonColor = false
        button.Parent = container
        self._button = button

        local buttonCorner = Instance.new("UICorner")
        buttonCorner.CornerRadius = UDim.new(0, 8)
        buttonCorner.Parent = button

        local buttonStroke = Instance.new("UIStroke")
        buttonStroke.Color = Color3.fromRGB(63, 63, 70)
        buttonStroke.Thickness = 1
        buttonStroke.Parent = button
        self._buttonStroke = buttonStroke

        local buttonPadding = Instance.new("UIPadding")
        buttonPadding.PaddingLeft = UDim.new(0, 12)
        buttonPadding.PaddingRight = UDim.new(0, 12)
        buttonPadding.Parent = button

        local buttonLayout = Instance.new("UIListLayout")
        buttonLayout.FillDirection = Enum.FillDirection.Horizontal
        buttonLayout.VerticalAlignment = Enum.VerticalAlignment.Center
        buttonLayout.HorizontalAlignment = Enum.HorizontalAlignment.SpaceBetween
        buttonLayout.Parent = button

        -- Selected text
        local selectedText = Instance.new("TextLabel")
        selectedText.Name = "SelectedText"
        selectedText.Size = UDim2.new(1, -20, 1, 0)
        selectedText.BackgroundTransparency = 1
        selectedText.Font = Enum.Font.Gotham
        selectedText.TextColor3 = self.SelectedIndex > 0 and Color3.fromRGB(250, 250, 250) or Color3.fromRGB(113, 113, 122)
        selectedText.TextSize = 14
        selectedText.TextXAlignment = Enum.TextXAlignment.Left
        selectedText.TextTruncate = Enum.TextTruncate.AtEnd
        selectedText.LayoutOrder = 1
        selectedText.Parent = button
        self._selectedText = selectedText

        -- Update selected text
        self:_updateSelectedText()

        -- Arrow icon
        local arrow = Instance.new("ImageLabel")
        arrow.Name = "Arrow"
        arrow.Size = UDim2.new(0, 14, 0, 14)
        arrow.BackgroundTransparency = 1
        arrow.Image = "rbxassetid://7072706223"
        arrow.ImageColor3 = Color3.fromRGB(161, 161, 170)
        arrow.LayoutOrder = 2
        arrow.Parent = button
        self._arrow = arrow

        -- Dropdown panel
        local panel = Instance.new("Frame")
        panel.Name = "Panel"
        panel.Size = UDim2.new(self.DropdownWidth and 0 or 1, self.DropdownWidth or 0, 0, 0)
        panel.Position = UDim2.new(0, 0, 1, 4)
        panel.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        panel.BorderSizePixel = 0
        panel.Visible = false
        panel.ZIndex = 100
        panel.ClipsDescendants = true
        panel.Parent = container
        self._panel = panel

        local panelCorner = Instance.new("UICorner")
        panelCorner.CornerRadius = UDim.new(0, 8)
        panelCorner.Parent = panel

        local panelStroke = Instance.new("UIStroke")
        panelStroke.Color = Color3.fromRGB(63, 63, 70)
        panelStroke.Thickness = 1
        panelStroke.Parent = panel

        -- Shadow
        local shadow = Instance.new("ImageLabel")
        shadow.Name = "Shadow"
        shadow.Size = UDim2.new(1, 16, 1, 16)
        shadow.Position = UDim2.new(0.5, 0, 0.5, 4)
        shadow.AnchorPoint = Vector2.new(0.5, 0.5)
        shadow.BackgroundTransparency = 1
        shadow.Image = "rbxassetid://6015897843"
        shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
        shadow.ImageTransparency = 0.5
        shadow.ScaleType = Enum.ScaleType.Slice
        shadow.SliceCenter = Rect.new(49, 49, 450, 450)
        shadow.ZIndex = panel.ZIndex - 1
        shadow.Parent = panel

        -- Search input (if searchable)
        if self.Searchable then
            local searchContainer = Instance.new("Frame")
            searchContainer.Name = "SearchContainer"
            searchContainer.Size = UDim2.new(1, 0, 0, 36)
            searchContainer.BackgroundTransparency = 1
            searchContainer.Parent = panel

            local searchPadding = Instance.new("UIPadding")
            searchPadding.PaddingTop = UDim.new(0, 6)
            searchPadding.PaddingLeft = UDim.new(0, 6)
            searchPadding.PaddingRight = UDim.new(0, 6)
            searchPadding.Parent = searchContainer

            local searchBox = Instance.new("TextBox")
            searchBox.Name = "SearchBox"
            searchBox.Size = UDim2.new(1, 0, 0, 30)
            searchBox.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
            searchBox.BorderSizePixel = 0
            searchBox.Font = Enum.Font.Gotham
            searchBox.Text = ""
            searchBox.PlaceholderText = "Search..."
            searchBox.PlaceholderColor3 = Color3.fromRGB(113, 113, 122)
            searchBox.TextColor3 = Color3.fromRGB(250, 250, 250)
            searchBox.TextSize = 13
            searchBox.ClearTextOnFocus = false
            searchBox.Parent = searchContainer
            self._searchBox = searchBox

            local searchCorner = Instance.new("UICorner")
            searchCorner.CornerRadius = UDim.new(0, 6)
            searchCorner.Parent = searchBox

            local searchBoxPadding = Instance.new("UIPadding")
            searchBoxPadding.PaddingLeft = UDim.new(0, 8)
            searchBoxPadding.Parent = searchBox

            -- Search text changed
            self:_connect(searchBox:GetPropertyChangedSignal("Text"), function()
                self:_filterOptions(searchBox.Text)
            end)
        end

        -- Options scroll frame
        local optionsFrame = Instance.new("ScrollingFrame")
        optionsFrame.Name = "Options"
        optionsFrame.Size = UDim2.new(1, 0, 1, self.Searchable and -42 or -6)
        optionsFrame.Position = UDim2.new(0, 0, 0, self.Searchable and 42 or 3)
        optionsFrame.BackgroundTransparency = 1
        optionsFrame.BorderSizePixel = 0
        optionsFrame.ScrollBarThickness = 4
        optionsFrame.ScrollBarImageColor3 = Color3.fromRGB(82, 82, 91)
        optionsFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
        optionsFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
        optionsFrame.ZIndex = panel.ZIndex
        optionsFrame.Parent = panel
        self._optionsFrame = optionsFrame

        local optionsPadding = Instance.new("UIPadding")
        optionsPadding.PaddingTop = UDim.new(0, 3)
        optionsPadding.PaddingBottom = UDim.new(0, 3)
        optionsPadding.PaddingLeft = UDim.new(0, 6)
        optionsPadding.PaddingRight = UDim.new(0, 6)
        optionsPadding.Parent = optionsFrame

        local optionsLayout = Instance.new("UIListLayout")
        optionsLayout.Padding = UDim.new(0, 2)
        optionsLayout.SortOrder = Enum.SortOrder.LayoutOrder
        optionsLayout.Parent = optionsFrame

        -- Create option buttons
        self:_createOptions()

        -- Setup interactions
        self:_setupInteractions()

        return self
    end

    --// Update selected text
    function Dropdown:_updateSelectedText()
        if self.SelectedIndex > 0 and self.Options[self.SelectedIndex] then
            local option = self.Options[self.SelectedIndex]
            self._selectedText.Text = option.Text or option
            self._selectedText.TextColor3 = Color3.fromRGB(250, 250, 250)
        else
            self._selectedText.Text = self.Placeholder
            self._selectedText.TextColor3 = Color3.fromRGB(113, 113, 122)
        end
    end

    --// Create option buttons
    function Dropdown:_createOptions()
        -- Clear existing
        for _, btn in ipairs(self._optionButtons) do
            btn:Destroy()
        end
        self._optionButtons = {}

        local options = #self._filteredOptions > 0 and self._filteredOptions or self.Options

        for i, option in ipairs(options) do
            local optionData = type(option) == "table" and option or { Text = option, Value = option }
            local isSelected = self:_getOptionIndex(optionData) == self.SelectedIndex

            local btn = Instance.new("TextButton")
            btn.Name = "Option" .. i
            btn.Size = UDim2.new(1, 0, 0, 32)
            btn.BackgroundColor3 = isSelected and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(39, 39, 42)
            btn.BackgroundTransparency = isSelected and 0 or 1
            btn.BorderSizePixel = 0
            btn.AutoButtonColor = false
            btn.LayoutOrder = i
            btn.ZIndex = self._panel.ZIndex
            btn.Parent = self._optionsFrame

            local btnCorner = Instance.new("UICorner")
            btnCorner.CornerRadius = UDim.new(0, 6)
            btnCorner.Parent = btn

            local btnPadding = Instance.new("UIPadding")
            btnPadding.PaddingLeft = UDim.new(0, 8)
            btnPadding.PaddingRight = UDim.new(0, 8)
            btnPadding.Parent = btn

            local btnLayout = Instance.new("UIListLayout")
            btnLayout.FillDirection = Enum.FillDirection.Horizontal
            btnLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            btnLayout.Padding = UDim.new(0, 8)
            btnLayout.Parent = btn

            -- Icon (if provided)
            if optionData.Icon then
                local icon = Instance.new("ImageLabel")
                icon.Size = UDim2.new(0, 14, 0, 14)
                icon.BackgroundTransparency = 1
                icon.Image = optionData.Icon
                icon.ImageColor3 = isSelected and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(161, 161, 170)
                icon.ZIndex = btn.ZIndex
                icon.LayoutOrder = 1
                icon.Parent = btn
            end

            -- Text
            local text = Instance.new("TextLabel")
            text.Size = UDim2.new(1, optionData.Icon and -22 or 0, 1, 0)
            text.BackgroundTransparency = 1
            text.Font = Enum.Font.Gotham
            text.Text = optionData.Text
            text.TextColor3 = isSelected and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(250, 250, 250)
            text.TextSize = 13
            text.TextXAlignment = Enum.TextXAlignment.Left
            text.TextTruncate = Enum.TextTruncate.AtEnd
            text.ZIndex = btn.ZIndex
            text.LayoutOrder = 2
            text.Parent = btn

            -- Check mark (if selected)
            if isSelected then
                local check = Instance.new("ImageLabel")
                check.Size = UDim2.new(0, 14, 0, 14)
                check.Position = UDim2.new(1, -22, 0.5, 0)
                check.AnchorPoint = Vector2.new(0, 0.5)
                check.BackgroundTransparency = 1
                check.Image = "rbxassetid://6031094667"
                check.ImageColor3 = Color3.fromRGB(255, 255, 255)
                check.ZIndex = btn.ZIndex
                check.Parent = btn
            end

            -- Click handler
            self:_connect(btn.MouseButton1Click, function()
                if optionData.Disabled then return end

                local realIndex = self:_getOptionIndex(optionData)
                self:SetSelectedIndex(realIndex)
                self:Close()
            end)

            -- Hover
            self:_connect(btn.MouseEnter, function()
                if not isSelected then
                    TweenService:Create(btn, TweenInfo.new(0.1), {
                        BackgroundTransparency = 0,
                    }):Play()
                end
            end)

            self:_connect(btn.MouseLeave, function()
                if not isSelected then
                    TweenService:Create(btn, TweenInfo.new(0.1), {
                        BackgroundTransparency = 1,
                    }):Play()
                end
            end)

            table.insert(self._optionButtons, btn)
        end
    end

    --// Get option index in original array
    function Dropdown:_getOptionIndex(optionData)
        for i, opt in ipairs(self.Options) do
            local data = type(opt) == "table" and opt or { Text = opt, Value = opt }
            if data.Text == optionData.Text and data.Value == optionData.Value then
                return i
            end
        end
        return 0
    end

    --// Filter options
    function Dropdown:_filterOptions(query)
        self._filteredOptions = {}
        query = string.lower(query)

        if query == "" then
            self:_createOptions()
            return
        end

        for _, option in ipairs(self.Options) do
            local text = type(option) == "table" and option.Text or option
            if string.find(string.lower(text), query, 1, true) then
                table.insert(self._filteredOptions, option)
            end
        end

        self:_createOptions()
    end

    --// Setup interactions
    function Dropdown:_setupInteractions()
        -- Toggle on button click
        self:_connect(self._button.MouseButton1Click, function()
            if self._isOpen then
                self:Close()
            else
                self:Open()
            end
        end)

        -- Hover
        self:_connect(self._button.MouseEnter, function()
            if not self._isOpen then
                TweenService:Create(self._buttonStroke, TweenInfo.new(0.15), {
                    Color = Color3.fromRGB(82, 82, 91),
                }):Play()
            end
        end)

        self:_connect(self._button.MouseLeave, function()
            if not self._isOpen then
                TweenService:Create(self._buttonStroke, TweenInfo.new(0.15), {
                    Color = Color3.fromRGB(63, 63, 70),
                }):Play()
            end
        end)
    end

    --// Open dropdown
    function Dropdown:Open()
        if self._isOpen then return self end

        self._isOpen = true
        self._panel.Visible = true

        -- Calculate height
        local itemHeight = 32
        local padding = self.Searchable and 48 or 6
        local maxHeight = self.MaxVisibleItems * itemHeight + padding
        local contentHeight = #self.Options * itemHeight + padding
        local panelHeight = math.min(contentHeight, maxHeight)

        -- Animate open
        self._panel.Size = UDim2.new(self.DropdownWidth and 0 or 1, self.DropdownWidth or 0, 0, 0)
        TweenService:Create(self._panel, TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
            Size = UDim2.new(self.DropdownWidth and 0 or 1, self.DropdownWidth or 0, 0, panelHeight),
        }):Play()

        -- Rotate arrow
        TweenService:Create(self._arrow, TweenInfo.new(0.15), {
            Rotation = 180,
        }):Play()

        TweenService:Create(self._buttonStroke, TweenInfo.new(0.15), {
            Color = Color3.fromRGB(99, 102, 241),
        }):Play()

        -- Focus search if searchable
        if self.Searchable and self._searchBox then
            self._searchBox:CaptureFocus()
        end

        if self.OnOpen then
            self.OnOpen()
        end

        self:_fire("Open")

        return self
    end

    --// Close dropdown
    function Dropdown:Close()
        if not self._isOpen then return self end

        self._isOpen = false

        -- Animate close
        TweenService:Create(self._panel, TweenInfo.new(0.1), {
            Size = UDim2.new(self.DropdownWidth and 0 or 1, self.DropdownWidth or 0, 0, 0),
        }):Play()

        task.delay(0.1, function()
            if not self._isOpen then
                self._panel.Visible = false
            end
        end)

        -- Rotate arrow back
        TweenService:Create(self._arrow, TweenInfo.new(0.15), {
            Rotation = 0,
        }):Play()

        TweenService:Create(self._buttonStroke, TweenInfo.new(0.15), {
            Color = Color3.fromRGB(63, 63, 70),
        }):Play()

        -- Clear search
        if self.Searchable and self._searchBox then
            self._searchBox.Text = ""
            self._filteredOptions = {}
        end

        if self.OnClose then
            self.OnClose()
        end

        self:_fire("Close")

        return self
    end

    --// Set selected index
    function Dropdown:SetSelectedIndex(index)
        if index == self.SelectedIndex then return self end

        local oldIndex = self.SelectedIndex
        self.SelectedIndex = index

        self:_updateSelectedText()
        self:_createOptions()

        local option = self.Options[index]
        local value = type(option) == "table" and (option.Value or option.Text) or option

        if self.OnSelect then
            self.OnSelect(index, value, oldIndex)
        end

        self:_fire("Select", index, value, oldIndex)

        return self
    end

    --// Set selected value
    function Dropdown:SetSelectedValue(value)
        for i, option in ipairs(self.Options) do
            local optValue = type(option) == "table" and (option.Value or option.Text) or option
            if optValue == value then
                return self:SetSelectedIndex(i)
            end
        end
        return self
    end

    --// Get selected value
    function Dropdown:GetSelectedValue()
        if self.SelectedIndex > 0 and self.Options[self.SelectedIndex] then
            local option = self.Options[self.SelectedIndex]
            return type(option) == "table" and (option.Value or option.Text) or option
        end
        return nil
    end

    --// Set options
    function Dropdown:SetOptions(options)
        self.Options = options
        self.SelectedIndex = 0
        self._filteredOptions = {}

        self:_updateSelectedText()
        self:_createOptions()

        return self
    end

    return Dropdown


end


-- ============================================================================
-- Module: NexusUI/Components/MultiSelect
-- ============================================================================
NexusUI_Modules["NexusUI/Components/MultiSelect"] = function()
    local script = CreateMockScript("NexusUI/Components/MultiSelect")
    
    --[[
        NexusUI MultiSelect Component
        Multi-selection dropdown
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// MultiSelect Component Module
    local MultiSelect = setmetatable({}, { __index = Base })
    MultiSelect.__index = MultiSelect
    MultiSelect.ClassName = "MultiSelect"

    --// Constructor
    function MultiSelect.new(config)
        local self = setmetatable(Base.new(config), MultiSelect)

        config = config or {}

        self.Options = config.Options or {}
        self.SelectedIndices = config.SelectedIndices or {}
        self.Placeholder = config.Placeholder or "Select items..."
        self.MaxSelections = config.MaxSelections or -1
        self.ShowTags = config.ShowTags ~= false
        self.MaxVisibleItems = config.MaxVisibleItems or 6

        -- Callbacks
        self.OnChange = config.OnChange

        -- State
        self._isOpen = false
        self._optionButtons = {}

        return self
    end

    --// Create multi-select
    function MultiSelect:Create(parent)
        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(1, 0, 0, 40)
        container.BackgroundTransparency = 1
        container.ClipsDescendants = false

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Button
        local button = Instance.new("TextButton")
        button.Name = "Button"
        button.Size = UDim2.new(1, 0, 1, 0)
        button.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        button.BorderSizePixel = 0
        button.Text = ""
        button.AutoButtonColor = false
        button.Parent = container
        self._button = button

        local buttonCorner = Instance.new("UICorner")
        buttonCorner.CornerRadius = UDim.new(0, 8)
        buttonCorner.Parent = button

        local buttonStroke = Instance.new("UIStroke")
        buttonStroke.Color = Color3.fromRGB(63, 63, 70)
        buttonStroke.Thickness = 1
        buttonStroke.Parent = button
        self._buttonStroke = buttonStroke

        local buttonPadding = Instance.new("UIPadding")
        buttonPadding.PaddingLeft = UDim.new(0, 12)
        buttonPadding.PaddingRight = UDim.new(0, 12)
        buttonPadding.Parent = button

        -- Tags container
        local tagsContainer = Instance.new("Frame")
        tagsContainer.Name = "Tags"
        tagsContainer.Size = UDim2.new(1, -30, 1, 0)
        tagsContainer.BackgroundTransparency = 1
        tagsContainer.ClipsDescendants = true
        tagsContainer.Parent = button
        self._tagsContainer = tagsContainer

        local tagsLayout = Instance.new("UIListLayout")
        tagsLayout.FillDirection = Enum.FillDirection.Horizontal
        tagsLayout.VerticalAlignment = Enum.VerticalAlignment.Center
        tagsLayout.Padding = UDim.new(0, 4)
        tagsLayout.Parent = tagsContainer

        -- Placeholder
        local placeholder = Instance.new("TextLabel")
        placeholder.Name = "Placeholder"
        placeholder.Size = UDim2.new(1, 0, 1, 0)
        placeholder.BackgroundTransparency = 1
        placeholder.Font = Enum.Font.Gotham
        placeholder.Text = self.Placeholder
        placeholder.TextColor3 = Color3.fromRGB(113, 113, 122)
        placeholder.TextSize = 14
        placeholder.TextXAlignment = Enum.TextXAlignment.Left
        placeholder.Parent = tagsContainer
        self._placeholder = placeholder

        -- Arrow
        local arrow = Instance.new("ImageLabel")
        arrow.Name = "Arrow"
        arrow.Size = UDim2.new(0, 14, 0, 14)
        arrow.Position = UDim2.new(1, -14, 0.5, 0)
        arrow.AnchorPoint = Vector2.new(1, 0.5)
        arrow.BackgroundTransparency = 1
        arrow.Image = "rbxassetid://7072706223"
        arrow.ImageColor3 = Color3.fromRGB(161, 161, 170)
        arrow.Parent = button
        self._arrow = arrow

        -- Panel
        local panel = Instance.new("Frame")
        panel.Name = "Panel"
        panel.Size = UDim2.new(1, 0, 0, 0)
        panel.Position = UDim2.new(0, 0, 1, 4)
        panel.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        panel.BorderSizePixel = 0
        panel.Visible = false
        panel.ZIndex = 100
        panel.ClipsDescendants = true
        panel.Parent = container
        self._panel = panel

        local panelCorner = Instance.new("UICorner")
        panelCorner.CornerRadius = UDim.new(0, 8)
        panelCorner.Parent = panel

        local panelStroke = Instance.new("UIStroke")
        panelStroke.Color = Color3.fromRGB(63, 63, 70)
        panelStroke.Thickness = 1
        panelStroke.Parent = panel

        -- Options scroll frame
        local optionsFrame = Instance.new("ScrollingFrame")
        optionsFrame.Name = "Options"
        optionsFrame.Size = UDim2.new(1, 0, 1, -6)
        optionsFrame.Position = UDim2.new(0, 0, 0, 3)
        optionsFrame.BackgroundTransparency = 1
        optionsFrame.BorderSizePixel = 0
        optionsFrame.ScrollBarThickness = 4
        optionsFrame.ScrollBarImageColor3 = Color3.fromRGB(82, 82, 91)
        optionsFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
        optionsFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
        optionsFrame.ZIndex = panel.ZIndex
        optionsFrame.Parent = panel
        self._optionsFrame = optionsFrame

        local optionsPadding = Instance.new("UIPadding")
        optionsPadding.PaddingTop = UDim.new(0, 3)
        optionsPadding.PaddingBottom = UDim.new(0, 3)
        optionsPadding.PaddingLeft = UDim.new(0, 6)
        optionsPadding.PaddingRight = UDim.new(0, 6)
        optionsPadding.Parent = optionsFrame

        local optionsLayout = Instance.new("UIListLayout")
        optionsLayout.Padding = UDim.new(0, 2)
        optionsLayout.Parent = optionsFrame

        -- Create options
        self:_createOptions()
        self:_updateTags()

        -- Setup interactions
        self:_setupInteractions()

        return self
    end

    --// Create option buttons
    function MultiSelect:_createOptions()
        for _, btn in ipairs(self._optionButtons) do
            btn:Destroy()
        end
        self._optionButtons = {}

        for i, option in ipairs(self.Options) do
            local optionData = type(option) == "table" and option or { Text = option, Value = option }
            local isSelected = table.find(self.SelectedIndices, i) ~= nil

            local btn = Instance.new("TextButton")
            btn.Name = "Option" .. i
            btn.Size = UDim2.new(1, 0, 0, 32)
            btn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
            btn.BackgroundTransparency = isSelected and 0 or 1
            btn.BorderSizePixel = 0
            btn.Text = ""
            btn.AutoButtonColor = false
            btn.ZIndex = self._panel.ZIndex
            btn.Parent = self._optionsFrame

            local btnCorner = Instance.new("UICorner")
            btnCorner.CornerRadius = UDim.new(0, 6)
            btnCorner.Parent = btn

            local btnPadding = Instance.new("UIPadding")
            btnPadding.PaddingLeft = UDim.new(0, 8)
            btnPadding.PaddingRight = UDim.new(0, 8)
            btnPadding.Parent = btn

            local btnLayout = Instance.new("UIListLayout")
            btnLayout.FillDirection = Enum.FillDirection.Horizontal
            btnLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            btnLayout.Padding = UDim.new(0, 8)
            btnLayout.Parent = btn

            -- Checkbox
            local checkbox = Instance.new("Frame")
            checkbox.Name = "Checkbox"
            checkbox.Size = UDim2.new(0, 16, 0, 16)
            checkbox.BackgroundColor3 = isSelected and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(63, 63, 70)
            checkbox.BorderSizePixel = 0
            checkbox.ZIndex = btn.ZIndex
            checkbox.LayoutOrder = 1
            checkbox.Parent = btn

            local checkboxCorner = Instance.new("UICorner")
            checkboxCorner.CornerRadius = UDim.new(0, 4)
            checkboxCorner.Parent = checkbox

            -- Checkmark
            local checkmark = Instance.new("ImageLabel")
            checkmark.Size = UDim2.new(0.7, 0, 0.7, 0)
            checkmark.Position = UDim2.new(0.5, 0, 0.5, 0)
            checkmark.AnchorPoint = Vector2.new(0.5, 0.5)
            checkmark.BackgroundTransparency = 1
            checkmark.Image = "rbxassetid://6031094667"
            checkmark.ImageColor3 = Color3.fromRGB(255, 255, 255)
            checkmark.ImageTransparency = isSelected and 0 or 1
            checkmark.ZIndex = btn.ZIndex
            checkmark.Parent = checkbox

            -- Text
            local text = Instance.new("TextLabel")
            text.Size = UDim2.new(1, -24, 1, 0)
            text.BackgroundTransparency = 1
            text.Font = Enum.Font.Gotham
            text.Text = optionData.Text
            text.TextColor3 = Color3.fromRGB(250, 250, 250)
            text.TextSize = 13
            text.TextXAlignment = Enum.TextXAlignment.Left
            text.ZIndex = btn.ZIndex
            text.LayoutOrder = 2
            text.Parent = btn

            -- Click handler
            self:_connect(btn.MouseButton1Click, function()
                self:_toggleOption(i)
            end)

            -- Hover
            self:_connect(btn.MouseEnter, function()
                if not isSelected then
                    TweenService:Create(btn, TweenInfo.new(0.1), {
                        BackgroundTransparency = 0.5,
                    }):Play()
                end
            end)

            self:_connect(btn.MouseLeave, function()
                if not isSelected then
                    TweenService:Create(btn, TweenInfo.new(0.1), {
                        BackgroundTransparency = 1,
                    }):Play()
                end
            end)

            table.insert(self._optionButtons, btn)
        end
    end

    --// Toggle option
    function MultiSelect:_toggleOption(index)
        local existingPos = table.find(self.SelectedIndices, index)

        if existingPos then
            -- Deselect
            table.remove(self.SelectedIndices, existingPos)
        else
            -- Check max selections
            if self.MaxSelections > 0 and #self.SelectedIndices >= self.MaxSelections then
                return
            end

            table.insert(self.SelectedIndices, index)
        end

        self:_createOptions()
        self:_updateTags()

        if self.OnChange then
            self.OnChange(self.SelectedIndices, self:GetSelectedValues())
        end

        self:_fire("Change", self.SelectedIndices, self:GetSelectedValues())
    end

    --// Update tags
    function MultiSelect:_updateTags()
        -- Clear existing tags
        for _, child in ipairs(self._tagsContainer:GetChildren()) do
            if child:IsA("Frame") then
                child:Destroy()
            end
        end

        if #self.SelectedIndices == 0 then
            self._placeholder.Visible = true
            return
        end

        self._placeholder.Visible = false

        if self.ShowTags then
            for i, index in ipairs(self.SelectedIndices) do
                if i > 3 then
                    -- Show "+X more" tag
                    local moreTag = Instance.new("Frame")
                    moreTag.Name = "MoreTag"
                    moreTag.Size = UDim2.new(0, 0, 0, 24)
                    moreTag.AutomaticSize = Enum.AutomaticSize.X
                    moreTag.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
                    moreTag.BorderSizePixel = 0
                    moreTag.Parent = self._tagsContainer

                    local tagCorner = Instance.new("UICorner")
                    tagCorner.CornerRadius = UDim.new(0, 4)
                    tagCorner.Parent = moreTag

                    local tagPadding = Instance.new("UIPadding")
                    tagPadding.PaddingLeft = UDim.new(0, 6)
                    tagPadding.PaddingRight = UDim.new(0, 6)
                    tagPadding.Parent = moreTag

                    local tagText = Instance.new("TextLabel")
                    tagText.Size = UDim2.new(0, 0, 1, 0)
                    tagText.AutomaticSize = Enum.AutomaticSize.X
                    tagText.BackgroundTransparency = 1
                    tagText.Font = Enum.Font.GothamMedium
                    tagText.Text = "+" .. (#self.SelectedIndices - 3) .. " more"
                    tagText.TextColor3 = Color3.fromRGB(250, 250, 250)
                    tagText.TextSize = 11
                    tagText.Parent = moreTag
                    break
                end

                local option = self.Options[index]
                local text = type(option) == "table" and option.Text or option

                local tag = Instance.new("Frame")
                tag.Name = "Tag" .. i
                tag.Size = UDim2.new(0, 0, 0, 24)
                tag.AutomaticSize = Enum.AutomaticSize.X
                tag.BackgroundColor3 = Color3.fromRGB(99, 102, 241)
                tag.BorderSizePixel = 0
                tag.Parent = self._tagsContainer

                local tagCorner = Instance.new("UICorner")
                tagCorner.CornerRadius = UDim.new(0, 4)
                tagCorner.Parent = tag

                local tagPadding = Instance.new("UIPadding")
                tagPadding.PaddingLeft = UDim.new(0, 6)
                tagPadding.PaddingRight = UDim.new(0, 6)
                tagPadding.Parent = tag

                local tagText = Instance.new("TextLabel")
                tagText.Size = UDim2.new(0, 0, 1, 0)
                tagText.AutomaticSize = Enum.AutomaticSize.X
                tagText.BackgroundTransparency = 1
                tagText.Font = Enum.Font.GothamMedium
                tagText.Text = text
                tagText.TextColor3 = Color3.fromRGB(255, 255, 255)
                tagText.TextSize = 11
                tagText.Parent = tag
            end
        else
            -- Just show count
            self._placeholder.Text = #self.SelectedIndices .. " selected"
            self._placeholder.TextColor3 = Color3.fromRGB(250, 250, 250)
            self._placeholder.Visible = true
        end
    end

    --// Setup interactions
    function MultiSelect:_setupInteractions()
        self:_connect(self._button.MouseButton1Click, function()
            if self._isOpen then
                self:Close()
            else
                self:Open()
            end
        end)

        self:_connect(self._button.MouseEnter, function()
            if not self._isOpen then
                TweenService:Create(self._buttonStroke, TweenInfo.new(0.15), {
                    Color = Color3.fromRGB(82, 82, 91),
                }):Play()
            end
        end)

        self:_connect(self._button.MouseLeave, function()
            if not self._isOpen then
                TweenService:Create(self._buttonStroke, TweenInfo.new(0.15), {
                    Color = Color3.fromRGB(63, 63, 70),
                }):Play()
            end
        end)
    end

    --// Open
    function MultiSelect:Open()
        if self._isOpen then return self end

        self._isOpen = true
        self._panel.Visible = true

        local itemHeight = 32
        local maxHeight = self.MaxVisibleItems * itemHeight + 12
        local contentHeight = #self.Options * itemHeight + 12
        local panelHeight = math.min(contentHeight, maxHeight)

        TweenService:Create(self._panel, TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
            Size = UDim2.new(1, 0, 0, panelHeight),
        }):Play()

        TweenService:Create(self._arrow, TweenInfo.new(0.15), {
            Rotation = 180,
        }):Play()

        TweenService:Create(self._buttonStroke, TweenInfo.new(0.15), {
            Color = Color3.fromRGB(99, 102, 241),
        }):Play()

        return self
    end

    --// Close
    function MultiSelect:Close()
        if not self._isOpen then return self end

        self._isOpen = false

        TweenService:Create(self._panel, TweenInfo.new(0.1), {
            Size = UDim2.new(1, 0, 0, 0),
        }):Play()

        task.delay(0.1, function()
            if not self._isOpen then
                self._panel.Visible = false
            end
        end)

        TweenService:Create(self._arrow, TweenInfo.new(0.15), {
            Rotation = 0,
        }):Play()

        TweenService:Create(self._buttonStroke, TweenInfo.new(0.15), {
            Color = Color3.fromRGB(63, 63, 70),
        }):Play()

        return self
    end

    --// Get selected values
    function MultiSelect:GetSelectedValues()
        local values = {}
        for _, index in ipairs(self.SelectedIndices) do
            local option = self.Options[index]
            local value = type(option) == "table" and (option.Value or option.Text) or option
            table.insert(values, value)
        end
        return values
    end

    --// Set selected indices
    function MultiSelect:SetSelectedIndices(indices)
        self.SelectedIndices = indices or {}
        self:_createOptions()
        self:_updateTags()
        return self
    end

    --// Select all
    function MultiSelect:SelectAll()
        self.SelectedIndices = {}
        for i = 1, #self.Options do
            if self.MaxSelections < 0 or i <= self.MaxSelections then
                table.insert(self.SelectedIndices, i)
            end
        end
        self:_createOptions()
        self:_updateTags()
        return self
    end

    --// Clear selection
    function MultiSelect:ClearSelection()
        self.SelectedIndices = {}
        self:_createOptions()
        self:_updateTags()
        return self
    end

    return MultiSelect


end


-- ============================================================================
-- Module: NexusUI/Components/ColorPicker
-- ============================================================================
NexusUI_Modules["NexusUI/Components/ColorPicker"] = function()
    local script = CreateMockScript("NexusUI/Components/ColorPicker")
    
    --[[
        NexusUI ColorPicker Component
        Interactive color selection
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// ColorPicker Component Module
    local ColorPicker = setmetatable({}, { __index = Base })
    ColorPicker.__index = ColorPicker
    ColorPicker.ClassName = "ColorPicker"

    --// Constructor
    function ColorPicker.new(config)
        local self = setmetatable(Base.new(config), ColorPicker)

        config = config or {}

        self.Color = config.Color or Color3.fromRGB(255, 255, 255)
        self.Label = config.Label
        self.ShowAlpha = config.ShowAlpha or false
        self.Alpha = config.Alpha or 1
        self.ShowPresets = config.ShowPresets ~= false
        self.Presets = config.Presets or {
            Color3.fromRGB(239, 68, 68),   -- Red
            Color3.fromRGB(249, 115, 22),  -- Orange
            Color3.fromRGB(245, 158, 11),  -- Amber
            Color3.fromRGB(234, 179, 8),   -- Yellow
            Color3.fromRGB(132, 204, 22),  -- Lime
            Color3.fromRGB(34, 197, 94),   -- Green
            Color3.fromRGB(20, 184, 166),  -- Teal
            Color3.fromRGB(6, 182, 212),   -- Cyan
            Color3.fromRGB(59, 130, 246),  -- Blue
            Color3.fromRGB(99, 102, 241),  -- Indigo
            Color3.fromRGB(139, 92, 246),  -- Violet
            Color3.fromRGB(168, 85, 247),  -- Purple
            Color3.fromRGB(236, 72, 153),  -- Pink
            Color3.fromRGB(244, 63, 94),   -- Rose
            Color3.fromRGB(255, 255, 255), -- White
            Color3.fromRGB(0, 0, 0),       -- Black
        }

        -- Callbacks
        self.OnColorChanged = config.OnColorChanged

        -- State
        self._isExpanded = false
        self._hue = 0
        self._saturation = 1
        self._value = 1
        self._draggingPicker = false
        self._draggingHue = false

        -- Initialize HSV from color
        self:_updateHSVFromColor()

        return self
    end

    --// Update HSV from color
    function ColorPicker:_updateHSVFromColor()
        local h, s, v = Color3.toHSV(self.Color)
        self._hue = h
        self._saturation = s
        self._value = v
    end

    --// Update color from HSV
    function ColorPicker:_updateColorFromHSV()
        self.Color = Color3.fromHSV(self._hue, self._saturation, self._value)
    end

    --// Create color picker
    function ColorPicker:Create(parent)
        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(1, 0, 0, 36)
        container.BackgroundTransparency = 1
        container.ClipsDescendants = false

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Header
        local header = Instance.new("Frame")
        header.Name = "Header"
        header.Size = UDim2.new(1, 0, 0, 36)
        header.BackgroundTransparency = 1
        header.Parent = container

        local headerLayout = Instance.new("UIListLayout")
        headerLayout.FillDirection = Enum.FillDirection.Horizontal
        headerLayout.VerticalAlignment = Enum.VerticalAlignment.Center
        headerLayout.HorizontalAlignment = Enum.HorizontalAlignment.SpaceBetween
        headerLayout.Parent = header

        -- Label
        if self.Label then
            local label = Instance.new("TextLabel")
            label.Name = "Label"
            label.Size = UDim2.new(0.5, 0, 1, 0)
            label.BackgroundTransparency = 1
            label.Font = Enum.Font.Gotham
            label.Text = self.Label
            label.TextColor3 = Color3.fromRGB(250, 250, 250)
            label.TextSize = 14
            label.TextXAlignment = Enum.TextXAlignment.Left
            label.LayoutOrder = 1
            label.Parent = header
        end

        -- Color preview button
        local previewButton = Instance.new("TextButton")
        previewButton.Name = "Preview"
        previewButton.Size = UDim2.new(0, 60, 0, 28)
        previewButton.BackgroundColor3 = self.Color
        previewButton.BorderSizePixel = 0
        previewButton.Text = ""
        previewButton.AutoButtonColor = false
        previewButton.LayoutOrder = 2
        previewButton.Parent = header
        self._previewButton = previewButton

        local previewCorner = Instance.new("UICorner")
        previewCorner.CornerRadius = UDim.new(0, 6)
        previewCorner.Parent = previewButton

        local previewStroke = Instance.new("UIStroke")
        previewStroke.Color = Color3.fromRGB(63, 63, 70)
        previewStroke.Thickness = 1
        previewStroke.Parent = previewButton

        -- Expanded panel
        local panel = Instance.new("Frame")
        panel.Name = "Panel"
        panel.Size = UDim2.new(1, 0, 0, 200)
        panel.Position = UDim2.new(0, 0, 0, 40)
        panel.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        panel.BorderSizePixel = 0
        panel.Visible = false
        panel.ZIndex = 100
        panel.Parent = container
        self._panel = panel

        local panelCorner = Instance.new("UICorner")
        panelCorner.CornerRadius = UDim.new(0, 8)
        panelCorner.Parent = panel

        local panelStroke = Instance.new("UIStroke")
        panelStroke.Color = Color3.fromRGB(63, 63, 70)
        panelStroke.Thickness = 1
        panelStroke.Parent = panel

        local panelPadding = Instance.new("UIPadding")
        panelPadding.PaddingTop = UDim.new(0, 12)
        panelPadding.PaddingBottom = UDim.new(0, 12)
        panelPadding.PaddingLeft = UDim.new(0, 12)
        panelPadding.PaddingRight = UDim.new(0, 12)
        panelPadding.Parent = panel

        -- Saturation/Value picker
        local picker = Instance.new("Frame")
        picker.Name = "Picker"
        picker.Size = UDim2.new(1, -30, 0, 120)
        picker.BackgroundColor3 = Color3.fromHSV(self._hue, 1, 1)
        picker.BorderSizePixel = 0
        picker.Parent = panel
        self._picker = picker

        local pickerCorner = Instance.new("UICorner")
        pickerCorner.CornerRadius = UDim.new(0, 6)
        pickerCorner.Parent = picker

        -- White gradient (saturation)
        local whiteGradient = Instance.new("UIGradient")
        whiteGradient.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255), Color3.fromRGB(255, 255, 255))
        whiteGradient.Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 0),
            NumberSequenceKeypoint.new(1, 1),
        })
        whiteGradient.Parent = picker

        -- Black gradient overlay (value)
        local blackOverlay = Instance.new("Frame")
        blackOverlay.Size = UDim2.new(1, 0, 1, 0)
        blackOverlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        blackOverlay.BackgroundTransparency = 0
        blackOverlay.BorderSizePixel = 0
        blackOverlay.Parent = picker

        local blackOverlayCorner = Instance.new("UICorner")
        blackOverlayCorner.CornerRadius = UDim.new(0, 6)
        blackOverlayCorner.Parent = blackOverlay

        local blackGradient = Instance.new("UIGradient")
        blackGradient.Color = ColorSequence.new(Color3.fromRGB(0, 0, 0), Color3.fromRGB(0, 0, 0))
        blackGradient.Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 1),
            NumberSequenceKeypoint.new(1, 0),
        })
        blackGradient.Rotation = 90
        blackGradient.Parent = blackOverlay

        -- Picker cursor
        local pickerCursor = Instance.new("Frame")
        pickerCursor.Name = "Cursor"
        pickerCursor.Size = UDim2.new(0, 14, 0, 14)
        pickerCursor.Position = UDim2.new(self._saturation, 0, 1 - self._value, 0)
        pickerCursor.AnchorPoint = Vector2.new(0.5, 0.5)
        pickerCursor.BackgroundColor3 = self.Color
        pickerCursor.BorderSizePixel = 0
        pickerCursor.ZIndex = 10
        pickerCursor.Parent = picker
        self._pickerCursor = pickerCursor

        local cursorCorner = Instance.new("UICorner")
        cursorCorner.CornerRadius = UDim.new(1, 0)
        cursorCorner.Parent = pickerCursor

        local cursorStroke = Instance.new("UIStroke")
        cursorStroke.Color = Color3.fromRGB(255, 255, 255)
        cursorStroke.Thickness = 2
        cursorStroke.Parent = pickerCursor

        -- Hue slider
        local hueSlider = Instance.new("Frame")
        hueSlider.Name = "HueSlider"
        hueSlider.Size = UDim2.new(0, 16, 0, 120)
        hueSlider.Position = UDim2.new(1, -16, 0, 0)
        hueSlider.BorderSizePixel = 0
        hueSlider.Parent = panel
        self._hueSlider = hueSlider

        local hueCorner = Instance.new("UICorner")
        hueCorner.CornerRadius = UDim.new(0, 8)
        hueCorner.Parent = hueSlider

        -- Hue gradient
        local hueGradient = Instance.new("UIGradient")
        hueGradient.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromHSV(0, 1, 1)),
            ColorSequenceKeypoint.new(0.167, Color3.fromHSV(0.167, 1, 1)),
            ColorSequenceKeypoint.new(0.333, Color3.fromHSV(0.333, 1, 1)),
            ColorSequenceKeypoint.new(0.5, Color3.fromHSV(0.5, 1, 1)),
            ColorSequenceKeypoint.new(0.667, Color3.fromHSV(0.667, 1, 1)),
            ColorSequenceKeypoint.new(0.833, Color3.fromHSV(0.833, 1, 1)),
            ColorSequenceKeypoint.new(1, Color3.fromHSV(1, 1, 1)),
        })
        hueGradient.Rotation = 90
        hueGradient.Parent = hueSlider

        -- Hue cursor
        local hueCursor = Instance.new("Frame")
        hueCursor.Name = "HueCursor"
        hueCursor.Size = UDim2.new(1, 4, 0, 6)
        hueCursor.Position = UDim2.new(0.5, 0, self._hue, 0)
        hueCursor.AnchorPoint = Vector2.new(0.5, 0.5)
        hueCursor.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        hueCursor.BorderSizePixel = 0
        hueCursor.ZIndex = 10
        hueCursor.Parent = hueSlider
        self._hueCursor = hueCursor

        local hueCursorCorner = Instance.new("UICorner")
        hueCursorCorner.CornerRadius = UDim.new(0, 3)
        hueCursorCorner.Parent = hueCursor

        -- Presets
        if self.ShowPresets then
            local presetsContainer = Instance.new("Frame")
            presetsContainer.Name = "Presets"
            presetsContainer.Size = UDim2.new(1, 0, 0, 24)
            presetsContainer.Position = UDim2.new(0, 0, 0, 130)
            presetsContainer.BackgroundTransparency = 1
            presetsContainer.Parent = panel

            local presetsLayout = Instance.new("UIListLayout")
            presetsLayout.FillDirection = Enum.FillDirection.Horizontal
            presetsLayout.Padding = UDim.new(0, 4)
            presetsLayout.Parent = presetsContainer

            for i, presetColor in ipairs(self.Presets) do
                local preset = Instance.new("TextButton")
                preset.Size = UDim2.new(0, 16, 0, 16)
                preset.BackgroundColor3 = presetColor
                preset.BorderSizePixel = 0
                preset.Text = ""
                preset.Parent = presetsContainer

                local presetCorner = Instance.new("UICorner")
                presetCorner.CornerRadius = UDim.new(0, 4)
                presetCorner.Parent = preset

                self:_connect(preset.MouseButton1Click, function()
                    self:SetColor(presetColor)
                end)
            end
        end

        -- Setup interactions
        self:_setupInteractions()

        return self
    end

    --// Setup interactions
    function ColorPicker:_setupInteractions()
        -- Toggle panel
        self:_connect(self._previewButton.MouseButton1Click, function()
            self:_togglePanel()
        end)

        -- Picker interactions
        local picker = self._picker

        local function updatePickerFromMouse()
            local mousePos = UserInputService:GetMouseLocation()
            local pickerPos = picker.AbsolutePosition
            local pickerSize = picker.AbsoluteSize

            local relX = math.clamp((mousePos.X - pickerPos.X) / pickerSize.X, 0, 1)
            local relY = math.clamp((mousePos.Y - pickerPos.Y) / pickerSize.Y, 0, 1)

            self._saturation = relX
            self._value = 1 - relY

            self:_updateColorFromHSV()
            self:_updateVisuals()
        end

        self:_connect(picker.InputBegan, function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                self._draggingPicker = true
                updatePickerFromMouse()
            end
        end)

        -- Hue slider interactions
        local hueSlider = self._hueSlider

        local function updateHueFromMouse()
            local mousePos = UserInputService:GetMouseLocation()
            local sliderPos = hueSlider.AbsolutePosition
            local sliderSize = hueSlider.AbsoluteSize

            local relY = math.clamp((mousePos.Y - sliderPos.Y) / sliderSize.Y, 0, 1)

            self._hue = relY

            self:_updateColorFromHSV()
            self:_updateVisuals()
        end

        self:_connect(hueSlider.InputBegan, function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                self._draggingHue = true
                updateHueFromMouse()
            end
        end)

        -- Global mouse move/up
        self:_connect(UserInputService.InputChanged, function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                if self._draggingPicker then
                    updatePickerFromMouse()
                elseif self._draggingHue then
                    updateHueFromMouse()
                end
            end
        end)

        self:_connect(UserInputService.InputEnded, function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                self._draggingPicker = false
                self._draggingHue = false
            end
        end)
    end

    --// Toggle panel
    function ColorPicker:_togglePanel()
        self._isExpanded = not self._isExpanded
        self._panel.Visible = self._isExpanded

        if self._isExpanded then
            self.Instance.Size = UDim2.new(1, 0, 0, 250)
        else
            self.Instance.Size = UDim2.new(1, 0, 0, 36)
        end
    end

    --// Update visuals
    function ColorPicker:_updateVisuals()
        -- Update preview
        self._previewButton.BackgroundColor3 = self.Color

        -- Update picker background
        self._picker.BackgroundColor3 = Color3.fromHSV(self._hue, 1, 1)

        -- Update cursors
        self._pickerCursor.Position = UDim2.new(self._saturation, 0, 1 - self._value, 0)
        self._pickerCursor.BackgroundColor3 = self.Color

        self._hueCursor.Position = UDim2.new(0.5, 0, self._hue, 0)

        -- Fire callback
        if self.OnColorChanged then
            self.OnColorChanged(self.Color)
        end

        self:_fire("ColorChanged", self.Color)
    end

    --// Set color
    function ColorPicker:SetColor(color)
        self.Color = color
        self:_updateHSVFromColor()
        self:_updateVisuals()
        return self
    end

    --// Get color
    function ColorPicker:GetColor()
        return self.Color
    end

    --// Get color with alpha
    function ColorPicker:GetColorWithAlpha()
        return self.Color, self.Alpha
    end

    return ColorPicker


end


-- ============================================================================
-- Module: NexusUI/Components/Table
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Table"] = function()
    local script = CreateMockScript("NexusUI/Components/Table")
    
    --[[
        NexusUI Table Component
        Data table with sorting and selection
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Table Component Module
    local Table = setmetatable({}, { __index = Base })
    Table.__index = Table
    Table.ClassName = "Table"

    --// Constructor
    function Table.new(config)
        local self = setmetatable(Base.new(config), Table)

        config = config or {}

        self.Columns = config.Columns or {} -- Array of {Key, Header, Width, Sortable, Render}
        self.Data = config.Data or {}
        self.Selectable = config.Selectable or false
        self.MultiSelect = config.MultiSelect or false
        self.Striped = config.Striped or false
        self.Bordered = config.Bordered or false
        self.RowHeight = config.RowHeight or 40
        self.HeaderHeight = config.HeaderHeight or 44

        -- Callbacks
        self.OnRowClick = config.OnRowClick
        self.OnSelectionChange = config.OnSelectionChange
        self.OnSort = config.OnSort

        -- State
        self._selectedRows = {}
        self._sortColumn = nil
        self._sortDirection = "asc"
        self._rows = {}

        return self
    end

    --// Create table
    function Table:Create(parent)
        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(1, 0, 0, 300)
        container.BackgroundColor3 = Color3.fromRGB(24, 24, 27)
        container.BorderSizePixel = 0
        container.ClipsDescendants = true

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = container

        if self.Bordered then
            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(63, 63, 70)
            stroke.Thickness = 1
            stroke.Parent = container
        end

        -- Header
        local header = Instance.new("Frame")
        header.Name = "Header"
        header.Size = UDim2.new(1, 0, 0, self.HeaderHeight)
        header.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        header.BorderSizePixel = 0
        header.Parent = container
        self._header = header

        local headerCorner = Instance.new("UICorner")
        headerCorner.CornerRadius = UDim.new(0, 8)
        headerCorner.Parent = header

        -- Fix bottom corners of header
        local headerFix = Instance.new("Frame")
        headerFix.Size = UDim2.new(1, 0, 0.5, 0)
        headerFix.Position = UDim2.new(0, 0, 0.5, 0)
        headerFix.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        headerFix.BorderSizePixel = 0
        headerFix.ZIndex = header.ZIndex - 1
        headerFix.Parent = header

        local headerLayout = Instance.new("UIListLayout")
        headerLayout.FillDirection = Enum.FillDirection.Horizontal
        headerLayout.VerticalAlignment = Enum.VerticalAlignment.Center
        headerLayout.Parent = header

        -- Create header cells
        self:_createHeaderCells()

        -- Body scroll frame
        local body = Instance.new("ScrollingFrame")
        body.Name = "Body"
        body.Size = UDim2.new(1, 0, 1, -self.HeaderHeight)
        body.Position = UDim2.new(0, 0, 0, self.HeaderHeight)
        body.BackgroundTransparency = 1
        body.BorderSizePixel = 0
        body.ScrollBarThickness = 6
        body.ScrollBarImageColor3 = Color3.fromRGB(82, 82, 91)
        body.CanvasSize = UDim2.new(0, 0, 0, 0)
        body.AutomaticCanvasSize = Enum.AutomaticSize.Y
        body.Parent = container
        self._body = body

        local bodyLayout = Instance.new("UIListLayout")
        bodyLayout.SortOrder = Enum.SortOrder.LayoutOrder
        bodyLayout.Parent = body

        -- Create rows
        self:_createRows()

        return self
    end

    --// Create header cells
    function Table:_createHeaderCells()
        for _, child in ipairs(self._header:GetChildren()) do
            if child:IsA("TextButton") or child:IsA("Frame") then
                child:Destroy()
            end
        end

        for i, column in ipairs(self.Columns) do
            local cell

            if column.Sortable then
                cell = Instance.new("TextButton")
                cell.AutoButtonColor = false
                cell.Text = ""
            else
                cell = Instance.new("Frame")
            end

            cell.Name = "HeaderCell" .. i
            cell.Size = column.Width and UDim2.new(0, column.Width, 1, 0) or UDim2.new(1 / #self.Columns, 0, 1, 0)
            cell.BackgroundTransparency = 1
            cell.LayoutOrder = i
            cell.Parent = self._header

            local padding = Instance.new("UIPadding")
            padding.PaddingLeft = UDim.new(0, 12)
            padding.PaddingRight = UDim.new(0, 12)
            padding.Parent = cell

            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Horizontal
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.Padding = UDim.new(0, 6)
            layout.Parent = cell

            local text = Instance.new("TextLabel")
            text.Name = "Text"
            text.Size = UDim2.new(1, column.Sortable and -20 or 0, 1, 0)
            text.BackgroundTransparency = 1
            text.Font = Enum.Font.GothamMedium
            text.Text = column.Header or column.Key
            text.TextColor3 = Color3.fromRGB(161, 161, 170)
            text.TextSize = 12
            text.TextXAlignment = Enum.TextXAlignment.Left
            text.LayoutOrder = 1
            text.Parent = cell

            if column.Sortable then
                local sortIcon = Instance.new("ImageLabel")
                sortIcon.Name = "SortIcon"
                sortIcon.Size = UDim2.new(0, 12, 0, 12)
                sortIcon.BackgroundTransparency = 1
                sortIcon.Image = "rbxassetid://7072706223"
                sortIcon.ImageColor3 = Color3.fromRGB(113, 113, 122)
                sortIcon.ImageTransparency = self._sortColumn == column.Key and 0 or 0.5
                sortIcon.Rotation = self._sortDirection == "desc" and 180 or 0
                sortIcon.LayoutOrder = 2
                sortIcon.Parent = cell

                self:_connect(cell.MouseButton1Click, function()
                    self:_toggleSort(column.Key)
                end)

                self:_connect(cell.MouseEnter, function()
                    TweenService:Create(sortIcon, TweenInfo.new(0.1), {
                        ImageTransparency = 0,
                    }):Play()
                end)

                self:_connect(cell.MouseLeave, function()
                    if self._sortColumn ~= column.Key then
                        TweenService:Create(sortIcon, TweenInfo.new(0.1), {
                            ImageTransparency = 0.5,
                        }):Play()
                    end
                end)
            end
        end
    end

    --// Toggle sort
    function Table:_toggleSort(columnKey)
        if self._sortColumn == columnKey then
            self._sortDirection = self._sortDirection == "asc" and "desc" or "asc"
        else
            self._sortColumn = columnKey
            self._sortDirection = "asc"
        end

        self:_createHeaderCells()
        self:_sortData()
        self:_createRows()

        if self.OnSort then
            self.OnSort(columnKey, self._sortDirection)
        end
    end

    --// Sort data
    function Table:_sortData()
        if not self._sortColumn then return end

        table.sort(self.Data, function(a, b)
            local valA = a[self._sortColumn]
            local valB = b[self._sortColumn]

            if type(valA) == "string" and type(valB) == "string" then
                if self._sortDirection == "asc" then
                    return valA:lower() < valB:lower()
                else
                    return valA:lower() > valB:lower()
                end
            else
                if self._sortDirection == "asc" then
                    return valA < valB
                else
                    return valA > valB
                end
            end
        end)
    end

    --// Create rows
    function Table:_createRows()
        for _, row in ipairs(self._rows) do
            row:Destroy()
        end
        self._rows = {}

        for i, rowData in ipairs(self.Data) do
            local isSelected = table.find(self._selectedRows, i) ~= nil

            local row = Instance.new("TextButton")
            row.Name = "Row" .. i
            row.Size = UDim2.new(1, 0, 0, self.RowHeight)
            row.BackgroundColor3 = self.Striped and i % 2 == 0 and Color3.fromRGB(27, 27, 30) or Color3.fromRGB(24, 24, 27)
            row.BackgroundTransparency = isSelected and 0.8 or 0
            row.BorderSizePixel = 0
            row.Text = ""
            row.AutoButtonColor = false
            row.LayoutOrder = i
            row.Parent = self._body

            if isSelected then
                row.BackgroundColor3 = Color3.fromRGB(99, 102, 241)
            end

            local rowLayout = Instance.new("UIListLayout")
            rowLayout.FillDirection = Enum.FillDirection.Horizontal
            rowLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            rowLayout.Parent = row

            -- Hover indicator
            local hover = Instance.new("Frame")
            hover.Name = "Hover"
            hover.Size = UDim2.new(1, 0, 1, 0)
            hover.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            hover.BackgroundTransparency = 1
            hover.BorderSizePixel = 0
            hover.ZIndex = row.ZIndex - 1
            hover.Parent = row

            -- Create cells
            for j, column in ipairs(self.Columns) do
                local cell = Instance.new("Frame")
                cell.Name = "Cell" .. j
                cell.Size = column.Width and UDim2.new(0, column.Width, 1, 0) or UDim2.new(1 / #self.Columns, 0, 1, 0)
                cell.BackgroundTransparency = 1
                cell.LayoutOrder = j
                cell.Parent = row

                local padding = Instance.new("UIPadding")
                padding.PaddingLeft = UDim.new(0, 12)
                padding.PaddingRight = UDim.new(0, 12)
                padding.Parent = cell

                local value = rowData[column.Key]

                if column.Render then
                    -- Custom render function
                    column.Render(cell, value, rowData, i)
                else
                    local text = Instance.new("TextLabel")
                    text.Size = UDim2.new(1, 0, 1, 0)
                    text.BackgroundTransparency = 1
                    text.Font = Enum.Font.Gotham
                    text.Text = tostring(value or "")
                    text.TextColor3 = Color3.fromRGB(250, 250, 250)
                    text.TextSize = 13
                    text.TextXAlignment = Enum.TextXAlignment.Left
                    text.TextTruncate = Enum.TextTruncate.AtEnd
                    text.Parent = cell
                end
            end

            -- Interactions
            if self.Selectable then
                self:_connect(row.MouseButton1Click, function()
                    self:_toggleRowSelection(i)
                end)
            end

            self:_connect(row.MouseEnter, function()
                if not isSelected then
                    TweenService:Create(hover, TweenInfo.new(0.1), {
                        BackgroundTransparency = 0.95,
                    }):Play()
                end
            end)

            self:_connect(row.MouseLeave, function()
                TweenService:Create(hover, TweenInfo.new(0.1), {
                    BackgroundTransparency = 1,
                }):Play()
            end)

            if self.OnRowClick then
                self:_connect(row.MouseButton1Click, function()
                    self.OnRowClick(i, rowData)
                end)
            end

            table.insert(self._rows, row)
        end
    end

    --// Toggle row selection
    function Table:_toggleRowSelection(index)
        local existingPos = table.find(self._selectedRows, index)

        if existingPos then
            table.remove(self._selectedRows, existingPos)
        else
            if self.MultiSelect then
                table.insert(self._selectedRows, index)
            else
                self._selectedRows = { index }
            end
        end

        self:_createRows()

        if self.OnSelectionChange then
            self.OnSelectionChange(self._selectedRows, self:GetSelectedData())
        end
    end

    --// Get selected data
    function Table:GetSelectedData()
        local data = {}
        for _, index in ipairs(self._selectedRows) do
            table.insert(data, self.Data[index])
        end
        return data
    end

    --// Set data
    function Table:SetData(data)
        self.Data = data
        self._selectedRows = {}

        if self._sortColumn then
            self:_sortData()
        end

        self:_createRows()
        return self
    end

    --// Add row
    function Table:AddRow(rowData)
        table.insert(self.Data, rowData)

        if self._sortColumn then
            self:_sortData()
        end

        self:_createRows()
        return self
    end

    --// Remove row
    function Table:RemoveRow(index)
        table.remove(self.Data, index)

        -- Update selection
        for i, selectedIndex in ipairs(self._selectedRows) do
            if selectedIndex == index then
                table.remove(self._selectedRows, i)
            elseif selectedIndex > index then
                self._selectedRows[i] = selectedIndex - 1
            end
        end

        self:_createRows()
        return self
    end

    --// Clear selection
    function Table:ClearSelection()
        self._selectedRows = {}
        self:_createRows()
        return self
    end

    --// Select all
    function Table:SelectAll()
        if not self.MultiSelect then return self end

        self._selectedRows = {}
        for i = 1, #self.Data do
            table.insert(self._selectedRows, i)
        end

        self:_createRows()
        return self
    end

    return Table


end


-- ============================================================================
-- Module: NexusUI/Components/Pagination
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Pagination"] = function()
    local script = CreateMockScript("NexusUI/Components/Pagination")
    
    --[[
        NexusUI Pagination Component
        Page navigation controls
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Pagination Component Module
    local Pagination = setmetatable({}, { __index = Base })
    Pagination.__index = Pagination
    Pagination.ClassName = "Pagination"

    --// Constructor
    function Pagination.new(config)
        local self = setmetatable(Base.new(config), Pagination)

        config = config or {}

        self.CurrentPage = config.CurrentPage or 1
        self.TotalPages = config.TotalPages or 1
        self.VisiblePages = config.VisiblePages or 5
        self.ShowFirstLast = config.ShowFirstLast ~= false
        self.ShowPrevNext = config.ShowPrevNext ~= false

        -- Callbacks
        self.OnPageChange = config.OnPageChange

        -- State
        self._pageButtons = {}

        return self
    end

    --// Create pagination
    function Pagination:Create(parent)
        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(0, 0, 0, 36)
        container.AutomaticSize = Enum.AutomaticSize.X
        container.BackgroundTransparency = 1

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.Padding = UDim.new(0, 4)
        layout.Parent = container

        -- Build pagination
        self:_buildPagination()

        return self
    end

    --// Build pagination
    function Pagination:_buildPagination()
        -- Clear existing
        for _, btn in ipairs(self._pageButtons) do
            btn:Destroy()
        end
        self._pageButtons = {}

        local layoutOrder = 0

        -- First page button
        if self.ShowFirstLast then
            layoutOrder = layoutOrder + 1
            self:_createNavButton("First", "⟪", layoutOrder, function()
                self:GoToPage(1)
            end, self.CurrentPage == 1)
        end

        -- Previous button
        if self.ShowPrevNext then
            layoutOrder = layoutOrder + 1
            self:_createNavButton("Prev", "←", layoutOrder, function()
                self:PrevPage()
            end, self.CurrentPage == 1)
        end

        -- Page numbers
        local startPage, endPage = self:_getPageRange()

        -- Ellipsis before
        if startPage > 1 then
            layoutOrder = layoutOrder + 1
            self:_createEllipsis(layoutOrder)
        end

        -- Page buttons
        for page = startPage, endPage do
            layoutOrder = layoutOrder + 1
            self:_createPageButton(page, layoutOrder)
        end

        -- Ellipsis after
        if endPage < self.TotalPages then
            layoutOrder = layoutOrder + 1
            self:_createEllipsis(layoutOrder)
        end

        -- Next button
        if self.ShowPrevNext then
            layoutOrder = layoutOrder + 1
            self:_createNavButton("Next", "→", layoutOrder, function()
                self:NextPage()
            end, self.CurrentPage == self.TotalPages)
        end

        -- Last page button
        if self.ShowFirstLast then
            layoutOrder = layoutOrder + 1
            self:_createNavButton("Last", "⟫", layoutOrder, function()
                self:GoToPage(self.TotalPages)
            end, self.CurrentPage == self.TotalPages)
        end
    end

    --// Get page range
    function Pagination:_getPageRange()
        local half = math.floor(self.VisiblePages / 2)
        local startPage = math.max(1, self.CurrentPage - half)
        local endPage = math.min(self.TotalPages, startPage + self.VisiblePages - 1)

        -- Adjust start if we're near the end
        if endPage - startPage + 1 < self.VisiblePages then
            startPage = math.max(1, endPage - self.VisiblePages + 1)
        end

        return startPage, endPage
    end

    --// Create page button
    function Pagination:_createPageButton(page, layoutOrder)
        local isSelected = page == self.CurrentPage

        local btn = Instance.new("TextButton")
        btn.Name = "Page" .. page
        btn.Size = UDim2.new(0, 36, 0, 36)
        btn.BackgroundColor3 = isSelected and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(39, 39, 42)
        btn.BackgroundTransparency = isSelected and 0 or 1
        btn.BorderSizePixel = 0
        btn.Font = Enum.Font.GothamMedium
        btn.Text = tostring(page)
        btn.TextColor3 = isSelected and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(250, 250, 250)
        btn.TextSize = 13
        btn.AutoButtonColor = false
        btn.LayoutOrder = layoutOrder
        btn.Parent = self.Instance

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 6)
        corner.Parent = btn

        if not isSelected then
            self:_connect(btn.MouseButton1Click, function()
                self:GoToPage(page)
            end)

            self:_connect(btn.MouseEnter, function()
                TweenService:Create(btn, TweenInfo.new(0.1), {
                    BackgroundTransparency = 0.5,
                }):Play()
            end)

            self:_connect(btn.MouseLeave, function()
                TweenService:Create(btn, TweenInfo.new(0.1), {
                    BackgroundTransparency = 1,
                }):Play()
            end)
        end

        table.insert(self._pageButtons, btn)
    end

    --// Create nav button
    function Pagination:_createNavButton(name, text, layoutOrder, callback, disabled)
        local btn = Instance.new("TextButton")
        btn.Name = name
        btn.Size = UDim2.new(0, 36, 0, 36)
        btn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
        btn.BackgroundTransparency = 1
        btn.BorderSizePixel = 0
        btn.Font = Enum.Font.GothamBold
        btn.Text = text
        btn.TextColor3 = disabled and Color3.fromRGB(82, 82, 91) or Color3.fromRGB(250, 250, 250)
        btn.TextSize = 14
        btn.AutoButtonColor = false
        btn.LayoutOrder = layoutOrder
        btn.Parent = self.Instance

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 6)
        corner.Parent = btn

        if not disabled then
            self:_connect(btn.MouseButton1Click, callback)

            self:_connect(btn.MouseEnter, function()
                TweenService:Create(btn, TweenInfo.new(0.1), {
                    BackgroundTransparency = 0.5,
                }):Play()
            end)

            self:_connect(btn.MouseLeave, function()
                TweenService:Create(btn, TweenInfo.new(0.1), {
                    BackgroundTransparency = 1,
                }):Play()
            end)
        end

        table.insert(self._pageButtons, btn)
    end

    --// Create ellipsis
    function Pagination:_createEllipsis(layoutOrder)
        local ellipsis = Instance.new("TextLabel")
        ellipsis.Name = "Ellipsis"
        ellipsis.Size = UDim2.new(0, 20, 0, 36)
        ellipsis.BackgroundTransparency = 1
        ellipsis.Font = Enum.Font.GothamBold
        ellipsis.Text = "..."
        ellipsis.TextColor3 = Color3.fromRGB(113, 113, 122)
        ellipsis.TextSize = 14
        ellipsis.LayoutOrder = layoutOrder
        ellipsis.Parent = self.Instance

        table.insert(self._pageButtons, ellipsis)
    end

    --// Go to page
    function Pagination:GoToPage(page)
        page = math.clamp(page, 1, self.TotalPages)

        if page == self.CurrentPage then return self end

        local oldPage = self.CurrentPage
        self.CurrentPage = page

        self:_buildPagination()

        if self.OnPageChange then
            self.OnPageChange(page, oldPage)
        end

        self:_fire("PageChange", page, oldPage)

        return self
    end

    --// Next page
    function Pagination:NextPage()
        return self:GoToPage(self.CurrentPage + 1)
    end

    --// Previous page
    function Pagination:PrevPage()
        return self:GoToPage(self.CurrentPage - 1)
    end

    --// Set total pages
    function Pagination:SetTotalPages(totalPages)
        self.TotalPages = math.max(1, totalPages)

        if self.CurrentPage > self.TotalPages then
            self.CurrentPage = self.TotalPages
        end

        self:_buildPagination()
        return self
    end

    --// Get current page
    function Pagination:GetCurrentPage()
        return self.CurrentPage
    end

    return Pagination


end


-- ============================================================================
-- Module: NexusUI/Components/Window
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Window"] = function()
    local script = CreateMockScript("NexusUI/Components/Window")
    
    --[[
        NexusUI Window Component
        Draggable, resizable window container
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")
    local UserInputService = game:GetService("UserInputService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Window Component Module
    local Window = setmetatable({}, { __index = Base })
    Window.__index = Window
    Window.ClassName = "Window"

    --// Constructor
    function Window.new(config)
        local self = setmetatable(Base.new(config), Window)

        config = config or {}

        self.Title = config.Title or "Window"
        self.Icon = config.Icon
        self.Width = config.Width or 400
        self.Height = config.Height or 300
        self.MinWidth = config.MinWidth or 200
        self.MinHeight = config.MinHeight or 150
        self.Draggable = config.Draggable ~= false
        self.Resizable = config.Resizable or false
        self.Closable = config.Closable ~= false
        self.Minimizable = config.Minimizable or false
        self.Maximizable = config.Maximizable or false
        self.ShowHeader = config.ShowHeader ~= false
        self.StartPosition = config.StartPosition or "Center" -- Center, TopLeft, Custom
        self.CustomPosition = config.CustomPosition -- UDim2 for custom position

        -- Callbacks
        self.OnClose = config.OnClose
        self.OnMinimize = config.OnMinimize
        self.OnMaximize = config.OnMaximize
        self.OnRestore = config.OnRestore
        self.OnDrag = config.OnDrag
        self.OnResize = config.OnResize

        -- State
        self._isMinimized = false
        self._isMaximized = false
        self._isDragging = false
        self._isResizing = false
        self._dragOffset = Vector2.new(0, 0)
        self._originalSize = nil
        self._originalPosition = nil

        return self
    end

    --// Create window
    function Window:Create(parent)
        -- Main frame
        local window = Instance.new("Frame")
        window.Name = self.Name
        window.Size = UDim2.new(0, self.Width, 0, self.Height)
        window.BackgroundColor3 = Color3.fromRGB(24, 24, 27)
        window.BorderSizePixel = 0
        window.ClipsDescendants = true

        if parent then
            window.Parent = parent
        end

        self.Instance = window

        -- Position window
        self:_positionWindow()

        -- Corner
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 10)
        corner.Parent = window

        -- Shadow
        local shadow = Instance.new("ImageLabel")
        shadow.Name = "Shadow"
        shadow.Size = UDim2.new(1, 30, 1, 30)
        shadow.Position = UDim2.new(0.5, 0, 0.5, 8)
        shadow.AnchorPoint = Vector2.new(0.5, 0.5)
        shadow.BackgroundTransparency = 1
        shadow.Image = "rbxassetid://6015897843"
        shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
        shadow.ImageTransparency = 0.4
        shadow.ScaleType = Enum.ScaleType.Slice
        shadow.SliceCenter = Rect.new(49, 49, 450, 450)
        shadow.ZIndex = window.ZIndex - 1
        shadow.Parent = window

        -- Border
        local stroke = Instance.new("UIStroke")
        stroke.Color = Color3.fromRGB(63, 63, 70)
        stroke.Thickness = 1
        stroke.Parent = window

        -- Header
        if self.ShowHeader then
            local header = Instance.new("Frame")
            header.Name = "Header"
            header.Size = UDim2.new(1, 0, 0, 44)
            header.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            header.BorderSizePixel = 0
            header.Parent = window
            self._header = header

            local headerCorner = Instance.new("UICorner")
            headerCorner.CornerRadius = UDim.new(0, 10)
            headerCorner.Parent = header

            -- Fix bottom corners
            local headerFix = Instance.new("Frame")
            headerFix.Size = UDim2.new(1, 0, 0.5, 0)
            headerFix.Position = UDim2.new(0, 0, 0.5, 0)
            headerFix.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            headerFix.BorderSizePixel = 0
            headerFix.ZIndex = header.ZIndex - 1
            headerFix.Parent = header

            local headerPadding = Instance.new("UIPadding")
            headerPadding.PaddingLeft = UDim.new(0, 16)
            headerPadding.PaddingRight = UDim.new(0, 12)
            headerPadding.Parent = header

            local headerLayout = Instance.new("UIListLayout")
            headerLayout.FillDirection = Enum.FillDirection.Horizontal
            headerLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            headerLayout.HorizontalAlignment = Enum.HorizontalAlignment.SpaceBetween
            headerLayout.Parent = header

            -- Left content
            local leftContent = Instance.new("Frame")
            leftContent.Size = UDim2.new(1, -100, 1, 0)
            leftContent.BackgroundTransparency = 1
            leftContent.LayoutOrder = 1
            leftContent.Parent = header

            local leftLayout = Instance.new("UIListLayout")
            leftLayout.FillDirection = Enum.FillDirection.Horizontal
            leftLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            leftLayout.Padding = UDim.new(0, 10)
            leftLayout.Parent = leftContent

            -- Icon
            if self.Icon then
                local icon = Instance.new("ImageLabel")
                icon.Size = UDim2.new(0, 18, 0, 18)
                icon.BackgroundTransparency = 1
                icon.Image = self.Icon
                icon.ImageColor3 = Color3.fromRGB(161, 161, 170)
                icon.LayoutOrder = 1
                icon.Parent = leftContent
            end

            -- Title
            local title = Instance.new("TextLabel")
            title.Name = "Title"
            title.Size = UDim2.new(1, self.Icon and -28 or 0, 1, 0)
            title.BackgroundTransparency = 1
            title.Font = Enum.Font.GothamMedium
            title.Text = self.Title
            title.TextColor3 = Color3.fromRGB(250, 250, 250)
            title.TextSize = 14
            title.TextXAlignment = Enum.TextXAlignment.Left
            title.TextTruncate = Enum.TextTruncate.AtEnd
            title.LayoutOrder = 2
            title.Parent = leftContent
            self._title = title

            -- Buttons container
            local buttons = Instance.new("Frame")
            buttons.Size = UDim2.new(0, 0, 0, 28)
            buttons.AutomaticSize = Enum.AutomaticSize.X
            buttons.BackgroundTransparency = 1
            buttons.LayoutOrder = 2
            buttons.Parent = header

            local buttonsLayout = Instance.new("UIListLayout")
            buttonsLayout.FillDirection = Enum.FillDirection.Horizontal
            buttonsLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            buttonsLayout.Padding = UDim.new(0, 4)
            buttonsLayout.Parent = buttons

            -- Minimize button
            if self.Minimizable then
                local minimizeBtn = self:_createHeaderButton("Minimize", "_", buttons, 1)
                self:_connect(minimizeBtn.MouseButton1Click, function()
                    self:ToggleMinimize()
                end)
            end

            -- Maximize button
            if self.Maximizable then
                local maximizeBtn = self:_createHeaderButton("Maximize", "□", buttons, 2)
                self._maximizeBtn = maximizeBtn
                self:_connect(maximizeBtn.MouseButton1Click, function()
                    self:ToggleMaximize()
                end)
            end

            -- Close button
            if self.Closable then
                local closeBtn = self:_createHeaderButton("Close", "×", buttons, 3, true)
                self:_connect(closeBtn.MouseButton1Click, function()
                    self:Close()
                end)
            end

            -- Drag handler
            if self.Draggable then
                self:_setupDragging()
            end
        end

        -- Content
        local content = Instance.new("Frame")
        content.Name = "Content"
        content.Size = UDim2.new(1, 0, 1, self.ShowHeader and -44 or 0)
        content.Position = UDim2.new(0, 0, 0, self.ShowHeader and 44 or 0)
        content.BackgroundTransparency = 1
        content.Parent = window
        self._content = content

        -- Resize handle
        if self.Resizable then
            self:_createResizeHandle()
        end

        return self
    end

    --// Position window
    function Window:_positionWindow()
        if self.StartPosition == "Center" then
            self.Instance.Position = UDim2.new(0.5, -self.Width/2, 0.5, -self.Height/2)
        elseif self.StartPosition == "TopLeft" then
            self.Instance.Position = UDim2.new(0, 20, 0, 20)
        elseif self.StartPosition == "Custom" and self.CustomPosition then
            self.Instance.Position = self.CustomPosition
        end
    end

    --// Create header button
    function Window:_createHeaderButton(name, text, parent, order, isClose)
        local btn = Instance.new("TextButton")
        btn.Name = name
        btn.Size = UDim2.new(0, 28, 0, 28)
        btn.BackgroundColor3 = isClose and Color3.fromRGB(239, 68, 68) or Color3.fromRGB(63, 63, 70)
        btn.BackgroundTransparency = 1
        btn.BorderSizePixel = 0
        btn.Font = Enum.Font.GothamBold
        btn.Text = text
        btn.TextColor3 = Color3.fromRGB(161, 161, 170)
        btn.TextSize = text == "×" and 22 or 16
        btn.AutoButtonColor = false
        btn.LayoutOrder = order
        btn.Parent = parent

        local btnCorner = Instance.new("UICorner")
        btnCorner.CornerRadius = UDim.new(0, 6)
        btnCorner.Parent = btn

        self:_connect(btn.MouseEnter, function()
            TweenService:Create(btn, TweenInfo.new(0.1), {
                BackgroundTransparency = 0,
                TextColor3 = Color3.fromRGB(255, 255, 255),
            }):Play()
        end)

        self:_connect(btn.MouseLeave, function()
            TweenService:Create(btn, TweenInfo.new(0.1), {
                BackgroundTransparency = 1,
                TextColor3 = Color3.fromRGB(161, 161, 170),
            }):Play()
        end)

        return btn
    end

    --// Setup dragging
    function Window:_setupDragging()
        local header = self._header

        self:_connect(header.InputBegan, function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                self._isDragging = true
                local mousePos = UserInputService:GetMouseLocation()
                local windowPos = self.Instance.AbsolutePosition
                self._dragOffset = mousePos - windowPos

                -- Bring to front
                self.Instance.ZIndex = 100
            end
        end)

        self:_connect(UserInputService.InputChanged, function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement and self._isDragging then
                local mousePos = UserInputService:GetMouseLocation()
                local newPos = mousePos - self._dragOffset

                self.Instance.Position = UDim2.new(0, newPos.X, 0, newPos.Y)

                if self.OnDrag then
                    self.OnDrag(newPos)
                end
            end
        end)

        self:_connect(UserInputService.InputEnded, function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                self._isDragging = false
            end
        end)
    end

    --// Create resize handle
    function Window:_createResizeHandle()
        local handle = Instance.new("TextButton")
        handle.Name = "ResizeHandle"
        handle.Size = UDim2.new(0, 16, 0, 16)
        handle.Position = UDim2.new(1, -16, 1, -16)
        handle.BackgroundTransparency = 1
        handle.Text = ""
        handle.Parent = self.Instance

        -- Resize indicator
        local indicator = Instance.new("ImageLabel")
        indicator.Size = UDim2.new(0, 12, 0, 12)
        indicator.Position = UDim2.new(0.5, 0, 0.5, 0)
        indicator.AnchorPoint = Vector2.new(0.5, 0.5)
        indicator.BackgroundTransparency = 1
        indicator.Image = "rbxassetid://6034818372" -- Resize grip
        indicator.ImageColor3 = Color3.fromRGB(82, 82, 91)
        indicator.Rotation = 45
        indicator.Parent = handle

        self:_connect(handle.InputBegan, function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                self._isResizing = true
                self._resizeStartPos = UserInputService:GetMouseLocation()
                self._resizeStartSize = self.Instance.AbsoluteSize
            end
        end)

        self:_connect(UserInputService.InputChanged, function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement and self._isResizing then
                local mousePos = UserInputService:GetMouseLocation()
                local delta = mousePos - self._resizeStartPos

                local newWidth = math.max(self.MinWidth, self._resizeStartSize.X + delta.X)
                local newHeight = math.max(self.MinHeight, self._resizeStartSize.Y + delta.Y)

                self.Instance.Size = UDim2.new(0, newWidth, 0, newHeight)

                if self.OnResize then
                    self.OnResize(newWidth, newHeight)
                end
            end
        end)

        self:_connect(UserInputService.InputEnded, function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                self._isResizing = false
            end
        end)
    end

    --// Close
    function Window:Close(animate)
        animate = animate ~= false

        if self.OnClose then
            local shouldClose = self.OnClose()
            if shouldClose == false then return self end
        end

        if animate then
            TweenService:Create(self.Instance, TweenInfo.new(0.15), {
                Size = UDim2.new(0, self.Width * 0.9, 0, self.Height * 0.9),
                BackgroundTransparency = 1,
            }):Play()

            task.delay(0.15, function()
                self.Instance.Visible = false
            end)
        else
            self.Instance.Visible = false
        end

        self:_fire("Close")
        return self
    end

    --// Show
    function Window:Show(animate)
        animate = animate ~= false

        self.Instance.Visible = true

        if animate then
            self.Instance.Size = UDim2.new(0, self.Width * 0.9, 0, self.Height * 0.9)
            self.Instance.BackgroundTransparency = 1

            TweenService:Create(self.Instance, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                Size = UDim2.new(0, self.Width, 0, self.Height),
                BackgroundTransparency = 0,
            }):Play()
        end

        self:_fire("Show")
        return self
    end

    --// Toggle minimize
    function Window:ToggleMinimize()
        self._isMinimized = not self._isMinimized

        if self._isMinimized then
            self._originalSize = self.Instance.Size
            TweenService:Create(self.Instance, TweenInfo.new(0.2), {
                Size = UDim2.new(0, self.Width, 0, 44),
            }):Play()

            if self.OnMinimize then self.OnMinimize() end
        else
            TweenService:Create(self.Instance, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                Size = self._originalSize or UDim2.new(0, self.Width, 0, self.Height),
            }):Play()

            if self.OnRestore then self.OnRestore() end
        end

        return self
    end

    --// Toggle maximize
    function Window:ToggleMaximize()
        self._isMaximized = not self._isMaximized

        if self._isMaximized then
            self._originalSize = self.Instance.Size
            self._originalPosition = self.Instance.Position

            TweenService:Create(self.Instance, TweenInfo.new(0.2), {
                Size = UDim2.new(1, -20, 1, -20),
                Position = UDim2.new(0, 10, 0, 10),
            }):Play()

            if self._maximizeBtn then
                self._maximizeBtn.Text = "❐"
            end

            if self.OnMaximize then self.OnMaximize() end
        else
            TweenService:Create(self.Instance, TweenInfo.new(0.2), {
                Size = self._originalSize,
                Position = self._originalPosition,
            }):Play()

            if self._maximizeBtn then
                self._maximizeBtn.Text = "□"
            end

            if self.OnRestore then self.OnRestore() end
        end

        return self
    end

    --// Set title
    function Window:SetTitle(title)
        self.Title = title
        if self._title then
            self._title.Text = title
        end
        return self
    end

    --// Get content frame
    function Window:GetContent()
        return self._content
    end

    return Window


end


-- ============================================================================
-- Module: NexusUI/Components/Modal
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Modal"] = function()
    local script = CreateMockScript("NexusUI/Components/Modal")
    
    --[[
        NexusUI Modal Component
        Modal dialog with overlay
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Modal Component Module
    local Modal = setmetatable({}, { __index = Base })
    Modal.__index = Modal
    Modal.ClassName = "Modal"

    --// Constructor
    function Modal.new(config)
        local self = setmetatable(Base.new(config), Modal)

        config = config or {}

        self.Title = config.Title or "Modal"
        self.Width = config.Width or 400
        self.Height = config.Height or "auto"
        self.CloseOnOverlayClick = config.CloseOnOverlayClick ~= false
        self.ShowCloseButton = config.ShowCloseButton ~= false
        self.OverlayColor = config.OverlayColor or Color3.fromRGB(0, 0, 0)
        self.OverlayTransparency = config.OverlayTransparency or 0.5

        -- Callbacks
        self.OnOpen = config.OnOpen
        self.OnClose = config.OnClose

        -- State
        self._isOpen = false

        return self
    end

    --// Create modal
    function Modal:Create(parent)
        -- Get screen gui
        local screenGui = parent
        while screenGui and not screenGui:IsA("ScreenGui") do
            screenGui = screenGui.Parent
        end

        if not screenGui then
            screenGui = Instance.new("ScreenGui")
            screenGui.Parent = game:GetService("CoreGui")
        end

        -- Overlay
        local overlay = Instance.new("TextButton")
        overlay.Name = self.Name .. "_Overlay"
        overlay.Size = UDim2.new(1, 0, 1, 0)
        overlay.BackgroundColor3 = self.OverlayColor
        overlay.BackgroundTransparency = 1
        overlay.BorderSizePixel = 0
        overlay.Text = ""
        overlay.AutoButtonColor = false
        overlay.Visible = false
        overlay.ZIndex = 1000
        overlay.Parent = screenGui
        self._overlay = overlay

        if self.CloseOnOverlayClick then
            self:_connect(overlay.MouseButton1Click, function()
                self:Close()
            end)
        end

        -- Modal container
        local modal = Instance.new("Frame")
        modal.Name = self.Name
        modal.Size = self.Height == "auto" and UDim2.new(0, self.Width, 0, 0) or UDim2.new(0, self.Width, 0, self.Height)
        modal.AutomaticSize = self.Height == "auto" and Enum.AutomaticSize.Y or Enum.AutomaticSize.None
        modal.Position = UDim2.new(0.5, 0, 0.5, 0)
        modal.AnchorPoint = Vector2.new(0.5, 0.5)
        modal.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        modal.BorderSizePixel = 0
        modal.Visible = false
        modal.ZIndex = 1001
        modal.Parent = screenGui
        self.Instance = modal

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 12)
        corner.Parent = modal

        local stroke = Instance.new("UIStroke")
        stroke.Color = Color3.fromRGB(63, 63, 70)
        stroke.Thickness = 1
        stroke.Parent = modal

        -- Shadow
        local shadow = Instance.new("ImageLabel")
        shadow.Name = "Shadow"
        shadow.Size = UDim2.new(1, 40, 1, 40)
        shadow.Position = UDim2.new(0.5, 0, 0.5, 10)
        shadow.AnchorPoint = Vector2.new(0.5, 0.5)
        shadow.BackgroundTransparency = 1
        shadow.Image = "rbxassetid://6015897843"
        shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
        shadow.ImageTransparency = 0.3
        shadow.ScaleType = Enum.ScaleType.Slice
        shadow.SliceCenter = Rect.new(49, 49, 450, 450)
        shadow.ZIndex = modal.ZIndex - 1
        shadow.Parent = modal

        -- Header
        local header = Instance.new("Frame")
        header.Name = "Header"
        header.Size = UDim2.new(1, 0, 0, 56)
        header.BackgroundTransparency = 1
        header.Parent = modal

        local headerPadding = Instance.new("UIPadding")
        headerPadding.PaddingLeft = UDim.new(0, 20)
        headerPadding.PaddingRight = UDim.new(0, 16)
        headerPadding.Parent = header

        local headerLayout = Instance.new("UIListLayout")
        headerLayout.FillDirection = Enum.FillDirection.Horizontal
        headerLayout.VerticalAlignment = Enum.VerticalAlignment.Center
        headerLayout.HorizontalAlignment = Enum.HorizontalAlignment.SpaceBetween
        headerLayout.Parent = header

        -- Title
        local title = Instance.new("TextLabel")
        title.Name = "Title"
        title.Size = UDim2.new(1, -40, 1, 0)
        title.BackgroundTransparency = 1
        title.Font = Enum.Font.GothamBold
        title.Text = self.Title
        title.TextColor3 = Color3.fromRGB(250, 250, 250)
        title.TextSize = 18
        title.TextXAlignment = Enum.TextXAlignment.Left
        title.LayoutOrder = 1
        title.Parent = header
        self._title = title

        -- Close button
        if self.ShowCloseButton then
            local closeBtn = Instance.new("TextButton")
            closeBtn.Name = "CloseBtn"
            closeBtn.Size = UDim2.new(0, 32, 0, 32)
            closeBtn.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
            closeBtn.BackgroundTransparency = 1
            closeBtn.BorderSizePixel = 0
            closeBtn.Font = Enum.Font.GothamBold
            closeBtn.Text = "×"
            closeBtn.TextColor3 = Color3.fromRGB(161, 161, 170)
            closeBtn.TextSize = 24
            closeBtn.AutoButtonColor = false
            closeBtn.LayoutOrder = 2
            closeBtn.ZIndex = modal.ZIndex
            closeBtn.Parent = header

            local closeBtnCorner = Instance.new("UICorner")
            closeBtnCorner.CornerRadius = UDim.new(0, 8)
            closeBtnCorner.Parent = closeBtn

            self:_connect(closeBtn.MouseButton1Click, function()
                self:Close()
            end)

            self:_connect(closeBtn.MouseEnter, function()
                TweenService:Create(closeBtn, TweenInfo.new(0.1), {
                    BackgroundTransparency = 0,
                    TextColor3 = Color3.fromRGB(255, 255, 255),
                }):Play()
            end)

            self:_connect(closeBtn.MouseLeave, function()
                TweenService:Create(closeBtn, TweenInfo.new(0.1), {
                    BackgroundTransparency = 1,
                    TextColor3 = Color3.fromRGB(161, 161, 170),
                }):Play()
            end)
        end

        -- Content
        local content = Instance.new("Frame")
        content.Name = "Content"
        content.Size = UDim2.new(1, 0, 0, 0)
        content.AutomaticSize = Enum.AutomaticSize.Y
        content.Position = UDim2.new(0, 0, 0, 56)
        content.BackgroundTransparency = 1
        content.Parent = modal
        self._content = content

        local contentPadding = Instance.new("UIPadding")
        contentPadding.PaddingLeft = UDim.new(0, 20)
        contentPadding.PaddingRight = UDim.new(0, 20)
        contentPadding.PaddingBottom = UDim.new(0, 20)
        contentPadding.Parent = content

        return self
    end

    --// Open
    function Modal:Open(animate)
        if self._isOpen then return self end

        self._isOpen = true
        animate = animate ~= false

        self._overlay.Visible = true
        self.Instance.Visible = true

        if animate then
            -- Fade in overlay
            TweenService:Create(self._overlay, TweenInfo.new(0.2), {
                BackgroundTransparency = self.OverlayTransparency,
            }):Play()

            -- Scale in modal
            self.Instance.Size = self.Height == "auto" and UDim2.new(0, self.Width * 0.9, 0, 0) or UDim2.new(0, self.Width * 0.9, 0, self.Height * 0.9)
            self.Instance.BackgroundTransparency = 1

            TweenService:Create(self.Instance, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                Size = self.Height == "auto" and UDim2.new(0, self.Width, 0, 0) or UDim2.new(0, self.Width, 0, self.Height),
                BackgroundTransparency = 0,
            }):Play()
        else
            self._overlay.BackgroundTransparency = self.OverlayTransparency
        end

        if self.OnOpen then
            self.OnOpen()
        end

        self:_fire("Open")

        return self
    end

    --// Close
    function Modal:Close(animate)
        if not self._isOpen then return self end

        self._isOpen = false
        animate = animate ~= false

        if self.OnClose then
            local shouldClose = self.OnClose()
            if shouldClose == false then
                self._isOpen = true
                return self
            end
        end

        if animate then
            TweenService:Create(self._overlay, TweenInfo.new(0.15), {
                BackgroundTransparency = 1,
            }):Play()

            TweenService:Create(self.Instance, TweenInfo.new(0.15), {
                Size = self.Height == "auto" and UDim2.new(0, self.Width * 0.9, 0, 0) or UDim2.new(0, self.Width * 0.9, 0, self.Height * 0.9),
                BackgroundTransparency = 1,
            }):Play()

            task.delay(0.15, function()
                if not self._isOpen then
                    self._overlay.Visible = false
                    self.Instance.Visible = false
                end
            end)
        else
            self._overlay.Visible = false
            self.Instance.Visible = false
        end

        self:_fire("Close")

        return self
    end

    --// Toggle
    function Modal:Toggle()
        if self._isOpen then
            self:Close()
        else
            self:Open()
        end
        return self
    end

    --// Is open
    function Modal:IsOpen()
        return self._isOpen
    end

    --// Set title
    function Modal:SetTitle(title)
        self.Title = title
        if self._title then
            self._title.Text = title
        end
        return self
    end

    --// Get content frame
    function Modal:GetContent()
        return self._content
    end

    --// Destroy override
    function Modal:Destroy()
        if self._overlay then
            self._overlay:Destroy()
        end
        Base.Destroy(self)
    end

    return Modal


end


-- ============================================================================
-- Module: NexusUI/Components/Dialog
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Dialog"] = function()
    local script = CreateMockScript("NexusUI/Components/Dialog")
    
    --[[
        NexusUI Dialog Component
        Confirmation/alert dialog
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Dialog Component Module
    local Dialog = setmetatable({}, { __index = Base })
    Dialog.__index = Dialog
    Dialog.ClassName = "Dialog"

    --// Dialog Types
    Dialog.Type = {
        Info = "Info",
        Success = "Success",
        Warning = "Warning",
        Error = "Error",
        Confirm = "Confirm",
    }

    --// Constructor
    function Dialog.new(config)
        local self = setmetatable(Base.new(config), Dialog)

        config = config or {}

        self.Title = config.Title or "Dialog"
        self.Message = config.Message or ""
        self.DialogType = config.Type or Dialog.Type.Info
        self.Buttons = config.Buttons or {} -- Array of {Text, Variant, OnClick}
        self.ShowIcon = config.ShowIcon ~= false
        self.Width = config.Width or 360

        -- Callbacks
        self.OnClose = config.OnClose

        -- State
        self._isOpen = false

        return self
    end

    --// Get type icon and color
    function Dialog:_getTypeStyle()
        local styles = {
            Info = {
                Icon = "rbxassetid://7072718185",
                Color = Color3.fromRGB(59, 130, 246),
            },
            Success = {
                Icon = "rbxassetid://7072706016",
                Color = Color3.fromRGB(34, 197, 94),
            },
            Warning = {
                Icon = "rbxassetid://7072725760",
                Color = Color3.fromRGB(245, 158, 11),
            },
            Error = {
                Icon = "rbxassetid://7072706350",
                Color = Color3.fromRGB(239, 68, 68),
            },
            Confirm = {
                Icon = "rbxassetid://7072718185",
                Color = Color3.fromRGB(99, 102, 241),
            },
        }

        return styles[self.DialogType] or styles.Info
    end

    --// Create dialog
    function Dialog:Create(parent)
        -- Get screen gui
        local screenGui = parent
        while screenGui and not screenGui:IsA("ScreenGui") do
            screenGui = screenGui.Parent
        end

        if not screenGui then
            screenGui = Instance.new("ScreenGui")
            screenGui.Parent = game:GetService("CoreGui")
        end

        -- Overlay
        local overlay = Instance.new("TextButton")
        overlay.Name = self.Name .. "_Overlay"
        overlay.Size = UDim2.new(1, 0, 1, 0)
        overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        overlay.BackgroundTransparency = 1
        overlay.BorderSizePixel = 0
        overlay.Text = ""
        overlay.AutoButtonColor = false
        overlay.Visible = false
        overlay.ZIndex = 2000
        overlay.Parent = screenGui
        self._overlay = overlay

        local style = self:_getTypeStyle()

        -- Dialog container
        local dialog = Instance.new("Frame")
        dialog.Name = self.Name
        dialog.Size = UDim2.new(0, self.Width, 0, 0)
        dialog.AutomaticSize = Enum.AutomaticSize.Y
        dialog.Position = UDim2.new(0.5, 0, 0.5, 0)
        dialog.AnchorPoint = Vector2.new(0.5, 0.5)
        dialog.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        dialog.BorderSizePixel = 0
        dialog.Visible = false
        dialog.ZIndex = 2001
        dialog.Parent = screenGui
        self.Instance = dialog

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 12)
        corner.Parent = dialog

        local stroke = Instance.new("UIStroke")
        stroke.Color = Color3.fromRGB(63, 63, 70)
        stroke.Thickness = 1
        stroke.Parent = dialog

        -- Shadow
        local shadow = Instance.new("ImageLabel")
        shadow.Name = "Shadow"
        shadow.Size = UDim2.new(1, 40, 1, 40)
        shadow.Position = UDim2.new(0.5, 0, 0.5, 10)
        shadow.AnchorPoint = Vector2.new(0.5, 0.5)
        shadow.BackgroundTransparency = 1
        shadow.Image = "rbxassetid://6015897843"
        shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
        shadow.ImageTransparency = 0.3
        shadow.ScaleType = Enum.ScaleType.Slice
        shadow.SliceCenter = Rect.new(49, 49, 450, 450)
        shadow.ZIndex = dialog.ZIndex - 1
        shadow.Parent = dialog

        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, 24)
        padding.PaddingBottom = UDim.new(0, 20)
        padding.PaddingLeft = UDim.new(0, 24)
        padding.PaddingRight = UDim.new(0, 24)
        padding.Parent = dialog

        local layout = Instance.new("UIListLayout")
        layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        layout.Padding = UDim.new(0, 16)
        layout.Parent = dialog

        -- Icon
        if self.ShowIcon then
            local iconContainer = Instance.new("Frame")
            iconContainer.Size = UDim2.new(0, 48, 0, 48)
            iconContainer.BackgroundColor3 = style.Color
            iconContainer.BackgroundTransparency = 0.9
            iconContainer.BorderSizePixel = 0
            iconContainer.LayoutOrder = 1
            iconContainer.Parent = dialog

            local iconCorner = Instance.new("UICorner")
            iconCorner.CornerRadius = UDim.new(1, 0)
            iconCorner.Parent = iconContainer

            local icon = Instance.new("ImageLabel")
            icon.Size = UDim2.new(0, 24, 0, 24)
            icon.Position = UDim2.new(0.5, 0, 0.5, 0)
            icon.AnchorPoint = Vector2.new(0.5, 0.5)
            icon.BackgroundTransparency = 1
            icon.Image = style.Icon
            icon.ImageColor3 = style.Color
            icon.Parent = iconContainer
        end

        -- Title
        local title = Instance.new("TextLabel")
        title.Size = UDim2.new(1, 0, 0, 0)
        title.AutomaticSize = Enum.AutomaticSize.Y
        title.BackgroundTransparency = 1
        title.Font = Enum.Font.GothamBold
        title.Text = self.Title
        title.TextColor3 = Color3.fromRGB(250, 250, 250)
        title.TextSize = 18
        title.TextWrapped = true
        title.LayoutOrder = 2
        title.Parent = dialog
        self._title = title

        -- Message
        local message = Instance.new("TextLabel")
        message.Size = UDim2.new(1, 0, 0, 0)
        message.AutomaticSize = Enum.AutomaticSize.Y
        message.BackgroundTransparency = 1
        message.Font = Enum.Font.Gotham
        message.Text = self.Message
        message.TextColor3 = Color3.fromRGB(161, 161, 170)
        message.TextSize = 14
        message.TextWrapped = true
        message.LayoutOrder = 3
        message.Parent = dialog
        self._message = message

        -- Buttons
        if #self.Buttons > 0 then
            local buttonsContainer = Instance.new("Frame")
            buttonsContainer.Size = UDim2.new(1, 0, 0, 40)
            buttonsContainer.BackgroundTransparency = 1
            buttonsContainer.LayoutOrder = 4
            buttonsContainer.Parent = dialog

            local buttonsLayout = Instance.new("UIListLayout")
            buttonsLayout.FillDirection = Enum.FillDirection.Horizontal
            buttonsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            buttonsLayout.Padding = UDim.new(0, 8)
            buttonsLayout.Parent = buttonsContainer

            for i, buttonConfig in ipairs(self.Buttons) do
                local btn = Instance.new("TextButton")
                btn.Size = UDim2.new(0, 100, 0, 40)
                btn.AutomaticSize = Enum.AutomaticSize.X
                btn.BorderSizePixel = 0
                btn.Font = Enum.Font.GothamMedium
                btn.Text = buttonConfig.Text or "Button"
                btn.TextSize = 14
                btn.AutoButtonColor = false
                btn.LayoutOrder = i
                btn.ZIndex = dialog.ZIndex
                btn.Parent = buttonsContainer

                local btnCorner = Instance.new("UICorner")
                btnCorner.CornerRadius = UDim.new(0, 8)
                btnCorner.Parent = btn

                local btnPadding = Instance.new("UIPadding")
                btnPadding.PaddingLeft = UDim.new(0, 20)
                btnPadding.PaddingRight = UDim.new(0, 20)
                btnPadding.Parent = btn

                -- Apply variant
                if buttonConfig.Variant == "Primary" or (i == #self.Buttons and not buttonConfig.Variant) then
                    btn.BackgroundColor3 = Color3.fromRGB(99, 102, 241)
                    btn.TextColor3 = Color3.fromRGB(255, 255, 255)
                elseif buttonConfig.Variant == "Danger" then
                    btn.BackgroundColor3 = Color3.fromRGB(239, 68, 68)
                    btn.TextColor3 = Color3.fromRGB(255, 255, 255)
                else -- Secondary/Default
                    btn.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
                    btn.TextColor3 = Color3.fromRGB(250, 250, 250)
                end

                self:_connect(btn.MouseButton1Click, function()
                    if buttonConfig.OnClick then
                        buttonConfig.OnClick()
                    end
                    self:Close()
                end)

                self:_connect(btn.MouseEnter, function()
                    TweenService:Create(btn, TweenInfo.new(0.1), {
                        BackgroundTransparency = 0.2,
                    }):Play()
                end)

                self:_connect(btn.MouseLeave, function()
                    TweenService:Create(btn, TweenInfo.new(0.1), {
                        BackgroundTransparency = 0,
                    }):Play()
                end)
            end
        end

        return self
    end

    --// Show
    function Dialog:Show()
        if self._isOpen then return self end

        self._isOpen = true
        self._overlay.Visible = true
        self.Instance.Visible = true

        TweenService:Create(self._overlay, TweenInfo.new(0.2), {
            BackgroundTransparency = 0.5,
        }):Play()

        self.Instance.Position = UDim2.new(0.5, 0, 0.5, 20)
        self.Instance.BackgroundTransparency = 1

        TweenService:Create(self.Instance, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
            Position = UDim2.new(0.5, 0, 0.5, 0),
            BackgroundTransparency = 0,
        }):Play()

        return self
    end

    --// Close
    function Dialog:Close()
        if not self._isOpen then return self end

        self._isOpen = false

        TweenService:Create(self._overlay, TweenInfo.new(0.15), {
            BackgroundTransparency = 1,
        }):Play()

        TweenService:Create(self.Instance, TweenInfo.new(0.15), {
            Position = UDim2.new(0.5, 0, 0.5, 20),
            BackgroundTransparency = 1,
        }):Play()

        task.delay(0.15, function()
            if not self._isOpen then
                self._overlay.Visible = false
                self.Instance.Visible = false
            end
        end)

        if self.OnClose then
            self.OnClose()
        end

        return self
    end

    --// Static helpers
    function Dialog.Alert(title, message, onClose)
        local dialog = Dialog.new({
            Title = title,
            Message = message,
            Type = Dialog.Type.Info,
            Buttons = {{ Text = "OK", Variant = "Primary" }},
            OnClose = onClose,
        })
        dialog:Create()
        dialog:Show()
        return dialog
    end

    function Dialog.Confirm(title, message, onConfirm, onCancel)
        local dialog = Dialog.new({
            Title = title,
            Message = message,
            Type = Dialog.Type.Confirm,
            Buttons = {
                { Text = "Cancel", Variant = "Secondary", OnClick = onCancel },
                { Text = "Confirm", Variant = "Primary", OnClick = onConfirm },
            },
        })
        dialog:Create()
        dialog:Show()
        return dialog
    end

    function Dialog.Error(title, message, onClose)
        local dialog = Dialog.new({
            Title = title,
            Message = message,
            Type = Dialog.Type.Error,
            Buttons = {{ Text = "OK", Variant = "Primary" }},
            OnClose = onClose,
        })
        dialog:Create()
        dialog:Show()
        return dialog
    end

    --// Destroy override
    function Dialog:Destroy()
        if self._overlay then
            self._overlay:Destroy()
        end
        Base.Destroy(self)
    end

    return Dialog


end


-- ============================================================================
-- Module: NexusUI/Components/Drawer
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Drawer"] = function()
    local script = CreateMockScript("NexusUI/Components/Drawer")
    
    --[[
        NexusUI Drawer Component
        Slide-out panel from edge
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")
    local UserInputService = game:GetService("UserInputService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Drawer Component Module
    local Drawer = setmetatable({}, { __index = Base })
    Drawer.__index = Drawer
    Drawer.ClassName = "Drawer"

    --// Drawer Positions
    Drawer.Position = {
        Left = "Left",
        Right = "Right",
        Top = "Top",
        Bottom = "Bottom",
    }

    --// Constructor
    function Drawer.new(config)
        local self = setmetatable(Base.new(config), Drawer)

        config = config or {}

        self.DrawerPosition = config.Position or Drawer.Position.Left
        self.Width = config.Width or 300
        self.Height = config.Height or 300
        self.ShowOverlay = config.ShowOverlay ~= false
        self.CloseOnOverlayClick = config.CloseOnOverlayClick ~= false
        self.OverlayTransparency = config.OverlayTransparency or 0.5

        -- Callbacks
        self.OnOpen = config.OnOpen
        self.OnClose = config.OnClose

        -- State
        self._isOpen = false

        return self
    end

    --// Create drawer
    function Drawer:Create(parent)
        -- Get screen gui
        local screenGui = parent
        while screenGui and not screenGui:IsA("ScreenGui") do
            screenGui = screenGui.Parent
        end

        if not screenGui then
            screenGui = Instance.new("ScreenGui")
            screenGui.Parent = game:GetService("CoreGui")
        end

        -- Overlay
        if self.ShowOverlay then
            local overlay = Instance.new("TextButton")
            overlay.Name = self.Name .. "_Overlay"
            overlay.Size = UDim2.new(1, 0, 1, 0)
            overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            overlay.BackgroundTransparency = 1
            overlay.BorderSizePixel = 0
            overlay.Text = ""
            overlay.AutoButtonColor = false
            overlay.Visible = false
            overlay.ZIndex = 900
            overlay.Parent = screenGui
            self._overlay = overlay

            if self.CloseOnOverlayClick then
                self:_connect(overlay.MouseButton1Click, function()
                    self:Close()
                end)
            end
        end

        -- Drawer
        local drawer = Instance.new("Frame")
        drawer.Name = self.Name
        drawer.BackgroundColor3 = Color3.fromRGB(24, 24, 27)
        drawer.BorderSizePixel = 0
        drawer.Visible = false
        drawer.ZIndex = 901
        drawer.Parent = screenGui
        self.Instance = drawer

        -- Position and size based on drawer position
        self:_applyPosition()

        -- Border
        local stroke = Instance.new("UIStroke")
        stroke.Color = Color3.fromRGB(63, 63, 70)
        stroke.Thickness = 1
        stroke.Parent = drawer

        -- Content
        local content = Instance.new("Frame")
        content.Name = "Content"
        content.Size = UDim2.new(1, 0, 1, 0)
        content.BackgroundTransparency = 1
        content.Parent = drawer
        self._content = content

        local contentPadding = Instance.new("UIPadding")
        contentPadding.PaddingTop = UDim.new(0, 16)
        contentPadding.PaddingBottom = UDim.new(0, 16)
        contentPadding.PaddingLeft = UDim.new(0, 16)
        contentPadding.PaddingRight = UDim.new(0, 16)
        contentPadding.Parent = content

        return self
    end

    --// Apply position
    function Drawer:_applyPosition()
        local drawer = self.Instance

        if self.DrawerPosition == Drawer.Position.Left then
            drawer.Size = UDim2.new(0, self.Width, 1, 0)
            drawer.Position = UDim2.new(0, -self.Width, 0, 0)
            self._openPosition = UDim2.new(0, 0, 0, 0)
            self._closedPosition = UDim2.new(0, -self.Width, 0, 0)

        elseif self.DrawerPosition == Drawer.Position.Right then
            drawer.Size = UDim2.new(0, self.Width, 1, 0)
            drawer.Position = UDim2.new(1, 0, 0, 0)
            self._openPosition = UDim2.new(1, -self.Width, 0, 0)
            self._closedPosition = UDim2.new(1, 0, 0, 0)

        elseif self.DrawerPosition == Drawer.Position.Top then
            drawer.Size = UDim2.new(1, 0, 0, self.Height)
            drawer.Position = UDim2.new(0, 0, 0, -self.Height)
            self._openPosition = UDim2.new(0, 0, 0, 0)
            self._closedPosition = UDim2.new(0, 0, 0, -self.Height)

        elseif self.DrawerPosition == Drawer.Position.Bottom then
            drawer.Size = UDim2.new(1, 0, 0, self.Height)
            drawer.Position = UDim2.new(0, 0, 1, 0)
            self._openPosition = UDim2.new(0, 0, 1, -self.Height)
            self._closedPosition = UDim2.new(0, 0, 1, 0)
        end
    end

    --// Open
    function Drawer:Open(animate)
        if self._isOpen then return self end

        self._isOpen = true
        animate = animate ~= false

        if self._overlay then
            self._overlay.Visible = true
        end
        self.Instance.Visible = true

        if animate then
            if self._overlay then
                TweenService:Create(self._overlay, TweenInfo.new(0.25), {
                    BackgroundTransparency = self.OverlayTransparency,
                }):Play()
            end

            TweenService:Create(self.Instance, TweenInfo.new(0.25, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {
                Position = self._openPosition,
            }):Play()
        else
            if self._overlay then
                self._overlay.BackgroundTransparency = self.OverlayTransparency
            end
            self.Instance.Position = self._openPosition
        end

        if self.OnOpen then
            self.OnOpen()
        end

        self:_fire("Open")

        return self
    end

    --// Close
    function Drawer:Close(animate)
        if not self._isOpen then return self end

        self._isOpen = false
        animate = animate ~= false

        if animate then
            if self._overlay then
                TweenService:Create(self._overlay, TweenInfo.new(0.2), {
                    BackgroundTransparency = 1,
                }):Play()
            end

            TweenService:Create(self.Instance, TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {
                Position = self._closedPosition,
            }):Play()

            task.delay(0.2, function()
                if not self._isOpen then
                    if self._overlay then
                        self._overlay.Visible = false
                    end
                    self.Instance.Visible = false
                end
            end)
        else
            if self._overlay then
                self._overlay.Visible = false
            end
            self.Instance.Visible = false
            self.Instance.Position = self._closedPosition
        end

        if self.OnClose then
            self.OnClose()
        end

        self:_fire("Close")

        return self
    end

    --// Toggle
    function Drawer:Toggle()
        if self._isOpen then
            self:Close()
        else
            self:Open()
        end
        return self
    end

    --// Is open
    function Drawer:IsOpen()
        return self._isOpen
    end

    --// Get content
    function Drawer:GetContent()
        return self._content
    end

    --// Destroy override
    function Drawer:Destroy()
        if self._overlay then
            self._overlay:Destroy()
        end
        Base.Destroy(self)
    end

    return Drawer


end


-- ============================================================================
-- Module: NexusUI/Components/Panel
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Panel"] = function()
    local script = CreateMockScript("NexusUI/Components/Panel")
    
    --[[
        NexusUI Panel Component
        Simple container panel
    ]]

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Panel Component Module
    local Panel = setmetatable({}, { __index = Base })
    Panel.__index = Panel
    Panel.ClassName = "Panel"

    --// Constructor
    function Panel.new(config)
        local self = setmetatable(Base.new(config), Panel)

        config = config or {}

        self.Padding = config.Padding or 16
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(30, 30, 35)
        self.CornerRadius = config.CornerRadius or 8
        self.Border = config.Border or false
        self.BorderColor = config.BorderColor or Color3.fromRGB(63, 63, 70)
        self.Shadow = config.Shadow or false
        self.AutoSize = config.AutoSize or false

        return self
    end

    --// Create panel
    function Panel:Create(parent)
        -- Panel container
        local panel = Instance.new("Frame")
        panel.Name = self.Name
        panel.Size = self.AutoSize and UDim2.new(0, 0, 0, 0) or UDim2.new(1, 0, 0, 200)
        panel.AutomaticSize = self.AutoSize and Enum.AutomaticSize.XY or Enum.AutomaticSize.None
        panel.BackgroundColor3 = self.BackgroundColor
        panel.BorderSizePixel = 0

        if parent then
            panel.Parent = parent
        end

        self.Instance = panel

        -- Corner
        if self.CornerRadius > 0 then
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, self.CornerRadius)
            corner.Parent = panel
        end

        -- Border
        if self.Border then
            local stroke = Instance.new("UIStroke")
            stroke.Color = self.BorderColor
            stroke.Thickness = 1
            stroke.Parent = panel
            self._stroke = stroke
        end

        -- Shadow
        if self.Shadow then
            local shadow = Instance.new("ImageLabel")
            shadow.Name = "Shadow"
            shadow.Size = UDim2.new(1, 20, 1, 20)
            shadow.Position = UDim2.new(0.5, 0, 0.5, 6)
            shadow.AnchorPoint = Vector2.new(0.5, 0.5)
            shadow.BackgroundTransparency = 1
            shadow.Image = "rbxassetid://6015897843"
            shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
            shadow.ImageTransparency = 0.6
            shadow.ScaleType = Enum.ScaleType.Slice
            shadow.SliceCenter = Rect.new(49, 49, 450, 450)
            shadow.ZIndex = panel.ZIndex - 1
            shadow.Parent = panel
        end

        -- Padding
        if self.Padding > 0 then
            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, self.Padding)
            padding.PaddingBottom = UDim.new(0, self.Padding)
            padding.PaddingLeft = UDim.new(0, self.Padding)
            padding.PaddingRight = UDim.new(0, self.Padding)
            padding.Parent = panel
            self._padding = padding
        end

        return self
    end

    --// Set background color
    function Panel:SetBackgroundColor(color)
        self.BackgroundColor = color
        if self.Instance then
            self.Instance.BackgroundColor3 = color
        end
        return self
    end

    --// Set padding
    function Panel:SetPadding(padding)
        self.Padding = padding

        if self._padding then
            self._padding.PaddingTop = UDim.new(0, padding)
            self._padding.PaddingBottom = UDim.new(0, padding)
            self._padding.PaddingLeft = UDim.new(0, padding)
            self._padding.PaddingRight = UDim.new(0, padding)
        end

        return self
    end

    --// Set border
    function Panel:SetBorder(enabled, color)
        self.Border = enabled
        if color then self.BorderColor = color end

        if self._stroke then
            self._stroke.Color = self.BorderColor
            self._stroke.Thickness = enabled and 1 or 0
        elseif enabled then
            local stroke = Instance.new("UIStroke")
            stroke.Color = self.BorderColor
            stroke.Thickness = 1
            stroke.Parent = self.Instance
            self._stroke = stroke
        end

        return self
    end

    return Panel


end


-- ============================================================================
-- Module: NexusUI/Components/Card
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Card"] = function()
    local script = CreateMockScript("NexusUI/Components/Card")
    
    --[[
        NexusUI Card Component
        Content card container
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Card Component Module
    local Card = setmetatable({}, { __index = Base })
    Card.__index = Card
    Card.ClassName = "Card"

    --// Card Variants
    Card.Variant = {
        Default = "Default",
        Elevated = "Elevated",
        Outlined = "Outlined",
        Filled = "Filled",
    }

    --// Constructor
    function Card.new(config)
        local self = setmetatable(Base.new(config), Card)

        config = config or {}

        self.Title = config.Title
        self.Subtitle = config.Subtitle
        self.HeaderImage = config.HeaderImage
        self.HeaderHeight = config.HeaderHeight or 150
        self.Variant = config.Variant or Card.Variant.Default
        self.Clickable = config.Clickable or false
        self.Width = config.Width -- nil = fill parent
        self.Padding = config.Padding or 16

        -- Callbacks
        self.OnClick = config.OnClick

        return self
    end

    --// Create card
    function Card:Create(parent)
        -- Card container
        local card

        if self.Clickable then
            card = Instance.new("TextButton")
            card.Text = ""
            card.AutoButtonColor = false
        else
            card = Instance.new("Frame")
        end

        card.Name = self.Name
        card.Size = self.Width and UDim2.new(0, self.Width, 0, 0) or UDim2.new(1, 0, 0, 0)
        card.AutomaticSize = Enum.AutomaticSize.Y
        card.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        card.BorderSizePixel = 0

        if parent then
            card.Parent = parent
        end

        self.Instance = card

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 12)
        corner.Parent = card

        -- Apply variant styles
        self:_applyVariant()

        -- Header image
        if self.HeaderImage then
            local headerImage = Instance.new("ImageLabel")
            headerImage.Name = "HeaderImage"
            headerImage.Size = UDim2.new(1, 0, 0, self.HeaderHeight)
            headerImage.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
            headerImage.BorderSizePixel = 0
            headerImage.Image = self.HeaderImage
            headerImage.ScaleType = Enum.ScaleType.Crop
            headerImage.Parent = card
            self._headerImage = headerImage

            local headerCorner = Instance.new("UICorner")
            headerCorner.CornerRadius = UDim.new(0, 12)
            headerCorner.Parent = headerImage

            -- Fix bottom corners
            local headerFix = Instance.new("Frame")
            headerFix.Size = UDim2.new(1, 0, 0, 12)
            headerFix.Position = UDim2.new(0, 0, 1, -12)
            headerFix.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
            headerFix.BorderSizePixel = 0
            headerFix.ZIndex = headerImage.ZIndex - 1
            headerFix.Parent = headerImage
        end

        -- Body
        local body = Instance.new("Frame")
        body.Name = "Body"
        body.Size = UDim2.new(1, 0, 0, 0)
        body.AutomaticSize = Enum.AutomaticSize.Y
        body.Position = self.HeaderImage and UDim2.new(0, 0, 0, self.HeaderHeight) or UDim2.new(0, 0, 0, 0)
        body.BackgroundTransparency = 1
        body.Parent = card
        self._body = body

        local bodyPadding = Instance.new("UIPadding")
        bodyPadding.PaddingTop = UDim.new(0, self.Padding)
        bodyPadding.PaddingBottom = UDim.new(0, self.Padding)
        bodyPadding.PaddingLeft = UDim.new(0, self.Padding)
        bodyPadding.PaddingRight = UDim.new(0, self.Padding)
        bodyPadding.Parent = body

        local bodyLayout = Instance.new("UIListLayout")
        bodyLayout.Padding = UDim.new(0, 8)
        bodyLayout.Parent = body

        -- Title
        if self.Title then
            local title = Instance.new("TextLabel")
            title.Name = "Title"
            title.Size = UDim2.new(1, 0, 0, 0)
            title.AutomaticSize = Enum.AutomaticSize.Y
            title.BackgroundTransparency = 1
            title.Font = Enum.Font.GothamBold
            title.Text = self.Title
            title.TextColor3 = Color3.fromRGB(250, 250, 250)
            title.TextSize = 16
            title.TextXAlignment = Enum.TextXAlignment.Left
            title.TextWrapped = true
            title.LayoutOrder = 1
            title.Parent = body
            self._title = title
        end

        -- Subtitle
        if self.Subtitle then
            local subtitle = Instance.new("TextLabel")
            subtitle.Name = "Subtitle"
            subtitle.Size = UDim2.new(1, 0, 0, 0)
            subtitle.AutomaticSize = Enum.AutomaticSize.Y
            subtitle.BackgroundTransparency = 1
            subtitle.Font = Enum.Font.Gotham
            subtitle.Text = self.Subtitle
            subtitle.TextColor3 = Color3.fromRGB(113, 113, 122)
            subtitle.TextSize = 13
            subtitle.TextXAlignment = Enum.TextXAlignment.Left
            subtitle.TextWrapped = true
            subtitle.LayoutOrder = 2
            subtitle.Parent = body
            self._subtitle = subtitle
        end

        -- Content container
        local content = Instance.new("Frame")
        content.Name = "Content"
        content.Size = UDim2.new(1, 0, 0, 0)
        content.AutomaticSize = Enum.AutomaticSize.Y
        content.BackgroundTransparency = 1
        content.LayoutOrder = 3
        content.Parent = body
        self._content = content

        -- Clickable interactions
        if self.Clickable then
            self:_setupClickable()
        end

        return self
    end

    --// Apply variant
    function Card:_applyVariant()
        local card = self.Instance

        if self.Variant == Card.Variant.Elevated then
            -- Shadow
            local shadow = Instance.new("ImageLabel")
            shadow.Name = "Shadow"
            shadow.Size = UDim2.new(1, 20, 1, 20)
            shadow.Position = UDim2.new(0.5, 0, 0.5, 6)
            shadow.AnchorPoint = Vector2.new(0.5, 0.5)
            shadow.BackgroundTransparency = 1
            shadow.Image = "rbxassetid://6015897843"
            shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
            shadow.ImageTransparency = 0.6
            shadow.ScaleType = Enum.ScaleType.Slice
            shadow.SliceCenter = Rect.new(49, 49, 450, 450)
            shadow.ZIndex = card.ZIndex - 1
            shadow.Parent = card
            self._shadow = shadow

        elseif self.Variant == Card.Variant.Outlined then
            card.BackgroundTransparency = 1

            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(63, 63, 70)
            stroke.Thickness = 1
            stroke.Parent = card

        elseif self.Variant == Card.Variant.Filled then
            card.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
        end
    end

    --// Setup clickable
    function Card:_setupClickable()
        local card = self.Instance

        self:_connect(card.MouseButton1Click, function()
            if self.OnClick then
                self.OnClick()
            end
            self:_fire("Click")
        end)

        self:_connect(card.MouseEnter, function()
            if self.Variant == Card.Variant.Elevated and self._shadow then
                TweenService:Create(self._shadow, TweenInfo.new(0.15), {
                    ImageTransparency = 0.4,
                    Position = UDim2.new(0.5, 0, 0.5, 10),
                }):Play()
            end

            TweenService:Create(card, TweenInfo.new(0.15), {
                BackgroundColor3 = Color3.fromRGB(35, 35, 40),
            }):Play()
        end)

        self:_connect(card.MouseLeave, function()
            if self.Variant == Card.Variant.Elevated and self._shadow then
                TweenService:Create(self._shadow, TweenInfo.new(0.15), {
                    ImageTransparency = 0.6,
                    Position = UDim2.new(0.5, 0, 0.5, 6),
                }):Play()
            end

            TweenService:Create(card, TweenInfo.new(0.15), {
                BackgroundColor3 = Color3.fromRGB(30, 30, 35),
            }):Play()
        end)
    end

    --// Set title
    function Card:SetTitle(title)
        self.Title = title
        if self._title then
            self._title.Text = title
        end
        return self
    end

    --// Set subtitle
    function Card:SetSubtitle(subtitle)
        self.Subtitle = subtitle
        if self._subtitle then
            self._subtitle.Text = subtitle
        end
        return self
    end

    --// Set header image
    function Card:SetHeaderImage(image)
        self.HeaderImage = image
        if self._headerImage then
            self._headerImage.Image = image
        end
        return self
    end

    --// Get content frame
    function Card:GetContent()
        return self._content
    end

    --// Get body frame
    function Card:GetBody()
        return self._body
    end

    return Card


end


-- ============================================================================
-- Module: NexusUI/Components/Accordion
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Accordion"] = function()
    local script = CreateMockScript("NexusUI/Components/Accordion")
    
    --[[
        NexusUI Accordion Component
        Collapsible content sections
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Accordion Component Module
    local Accordion = setmetatable({}, { __index = Base })
    Accordion.__index = Accordion
    Accordion.ClassName = "Accordion"

    --// Constructor
    function Accordion.new(config)
        local self = setmetatable(Base.new(config), Accordion)

        config = config or {}

        self.Items = config.Items or {} -- Array of {Title, Content, Icon, DefaultExpanded}
        self.AllowMultiple = config.AllowMultiple or false
        self.Bordered = config.Bordered ~= false

        -- Callbacks
        self.OnExpand = config.OnExpand
        self.OnCollapse = config.OnCollapse

        -- State
        self._expandedItems = {}
        self._itemElements = {}

        return self
    end

    --// Create accordion
    function Accordion:Create(parent)
        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(1, 0, 0, 0)
        container.AutomaticSize = Enum.AutomaticSize.Y
        container.BackgroundTransparency = 1

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        local layout = Instance.new("UIListLayout")
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Padding = UDim.new(0, 2)
        layout.Parent = container

        -- Build items
        self:_buildItems()

        return self
    end

    --// Build items
    function Accordion:_buildItems()
        -- Clear existing
        for _, element in pairs(self._itemElements) do
            if element.Instance then
                element.Instance:Destroy()
            end
        end
        self._itemElements = {}

        for i, item in ipairs(self.Items) do
            local isExpanded = self._expandedItems[i] or (item.DefaultExpanded and self._expandedItems[i] == nil)

            if item.DefaultExpanded and self._expandedItems[i] == nil then
                self._expandedItems[i] = true
            end

            local itemFrame = Instance.new("Frame")
            itemFrame.Name = "Item" .. i
            itemFrame.Size = UDim2.new(1, 0, 0, 0)
            itemFrame.AutomaticSize = Enum.AutomaticSize.Y
            itemFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            itemFrame.BorderSizePixel = 0
            itemFrame.LayoutOrder = i
            itemFrame.Parent = self.Instance

            local itemCorner = Instance.new("UICorner")
            itemCorner.CornerRadius = UDim.new(0, 8)
            itemCorner.Parent = itemFrame

            if self.Bordered then
                local itemStroke = Instance.new("UIStroke")
                itemStroke.Color = Color3.fromRGB(63, 63, 70)
                itemStroke.Thickness = 1
                itemStroke.Parent = itemFrame
            end

            -- Header
            local header = Instance.new("TextButton")
            header.Name = "Header"
            header.Size = UDim2.new(1, 0, 0, 48)
            header.BackgroundTransparency = 1
            header.Text = ""
            header.AutoButtonColor = false
            header.Parent = itemFrame

            local headerPadding = Instance.new("UIPadding")
            headerPadding.PaddingLeft = UDim.new(0, 16)
            headerPadding.PaddingRight = UDim.new(0, 16)
            headerPadding.Parent = header

            local headerLayout = Instance.new("UIListLayout")
            headerLayout.FillDirection = Enum.FillDirection.Horizontal
            headerLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            headerLayout.HorizontalAlignment = Enum.HorizontalAlignment.SpaceBetween
            headerLayout.Parent = header

            -- Left content
            local leftContent = Instance.new("Frame")
            leftContent.Size = UDim2.new(1, -30, 1, 0)
            leftContent.BackgroundTransparency = 1
            leftContent.LayoutOrder = 1
            leftContent.Parent = header

            local leftLayout = Instance.new("UIListLayout")
            leftLayout.FillDirection = Enum.FillDirection.Horizontal
            leftLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            leftLayout.Padding = UDim.new(0, 10)
            leftLayout.Parent = leftContent

            if item.Icon then
                local icon = Instance.new("ImageLabel")
                icon.Size = UDim2.new(0, 18, 0, 18)
                icon.BackgroundTransparency = 1
                icon.Image = item.Icon
                icon.ImageColor3 = Color3.fromRGB(161, 161, 170)
                icon.LayoutOrder = 1
                icon.Parent = leftContent
            end

            local title = Instance.new("TextLabel")
            title.Size = UDim2.new(1, item.Icon and -28 or 0, 1, 0)
            title.BackgroundTransparency = 1
            title.Font = Enum.Font.GothamMedium
            title.Text = item.Title
            title.TextColor3 = Color3.fromRGB(250, 250, 250)
            title.TextSize = 14
            title.TextXAlignment = Enum.TextXAlignment.Left
            title.LayoutOrder = 2
            title.Parent = leftContent

            -- Arrow
            local arrow = Instance.new("ImageLabel")
            arrow.Name = "Arrow"
            arrow.Size = UDim2.new(0, 16, 0, 16)
            arrow.BackgroundTransparency = 1
            arrow.Image = "rbxassetid://7072706223"
            arrow.ImageColor3 = Color3.fromRGB(161, 161, 170)
            arrow.Rotation = isExpanded and 180 or 0
            arrow.LayoutOrder = 2
            arrow.Parent = header

            -- Content
            local content = Instance.new("Frame")
            content.Name = "Content"
            content.Size = UDim2.new(1, 0, 0, 0)
            content.AutomaticSize = isExpanded and Enum.AutomaticSize.Y or Enum.AutomaticSize.None
            content.BackgroundTransparency = 1
            content.ClipsDescendants = true
            content.Parent = itemFrame

            local contentPadding = Instance.new("UIPadding")
            contentPadding.PaddingLeft = UDim.new(0, 16)
            contentPadding.PaddingRight = UDim.new(0, 16)
            contentPadding.PaddingBottom = isExpanded and UDim.new(0, 16) or UDim.new(0, 0)
            contentPadding.Parent = content

            -- Content text or custom content
            if type(item.Content) == "string" then
                local contentText = Instance.new("TextLabel")
                contentText.Size = UDim2.new(1, 0, 0, 0)
                contentText.AutomaticSize = Enum.AutomaticSize.Y
                contentText.BackgroundTransparency = 1
                contentText.Font = Enum.Font.Gotham
                contentText.Text = item.Content
                contentText.TextColor3 = Color3.fromRGB(161, 161, 170)
                contentText.TextSize = 13
                contentText.TextXAlignment = Enum.TextXAlignment.Left
                contentText.TextWrapped = true
                contentText.Parent = content
            end

            -- Interactions
            self:_connect(header.MouseButton1Click, function()
                self:_toggleItem(i)
            end)

            self:_connect(header.MouseEnter, function()
                TweenService:Create(arrow, TweenInfo.new(0.15), {
                    ImageColor3 = Color3.fromRGB(250, 250, 250),
                }):Play()
            end)

            self:_connect(header.MouseLeave, function()
                TweenService:Create(arrow, TweenInfo.new(0.15), {
                    ImageColor3 = Color3.fromRGB(161, 161, 170),
                }):Play()
            end)

            self._itemElements[i] = {
                Instance = itemFrame,
                Header = header,
                Content = content,
                ContentPadding = contentPadding,
                Arrow = arrow,
                Item = item,
            }
        end
    end

    --// Toggle item
    function Accordion:_toggleItem(index)
        local element = self._itemElements[index]
        if not element then return end

        local isExpanded = self._expandedItems[index]

        if isExpanded then
            -- Collapse
            self._expandedItems[index] = false

            TweenService:Create(element.Arrow, TweenInfo.new(0.2), {
                Rotation = 0,
            }):Play()

            element.Content.AutomaticSize = Enum.AutomaticSize.None
            TweenService:Create(element.Content, TweenInfo.new(0.2), {
                Size = UDim2.new(1, 0, 0, 0),
            }):Play()

            element.ContentPadding.PaddingBottom = UDim.new(0, 0)

            if self.OnCollapse then
                self.OnCollapse(index, element.Item)
            end

            self:_fire("Collapse", index, element.Item)
        else
            -- Expand (collapse others if not AllowMultiple)
            if not self.AllowMultiple then
                for i, _ in pairs(self._expandedItems) do
                    if self._expandedItems[i] then
                        self:_toggleItem(i)
                    end
                end
            end

            self._expandedItems[index] = true

            TweenService:Create(element.Arrow, TweenInfo.new(0.2), {
                Rotation = 180,
            }):Play()

            element.ContentPadding.PaddingBottom = UDim.new(0, 16)
            element.Content.AutomaticSize = Enum.AutomaticSize.Y

            if self.OnExpand then
                self.OnExpand(index, element.Item)
            end

            self:_fire("Expand", index, element.Item)
        end
    end

    --// Expand item
    function Accordion:ExpandItem(index)
        if not self._expandedItems[index] then
            self:_toggleItem(index)
        end
        return self
    end

    --// Collapse item
    function Accordion:CollapseItem(index)
        if self._expandedItems[index] then
            self:_toggleItem(index)
        end
        return self
    end

    --// Expand all
    function Accordion:ExpandAll()
        for i = 1, #self.Items do
            self:ExpandItem(i)
        end
        return self
    end

    --// Collapse all
    function Accordion:CollapseAll()
        for i = 1, #self.Items do
            self:CollapseItem(i)
        end
        return self
    end

    --// Set items
    function Accordion:SetItems(items)
        self.Items = items
        self._expandedItems = {}
        self:_buildItems()
        return self
    end

    --// Get content frame (for custom content)
    function Accordion:GetContentFrame(index)
        local element = self._itemElements[index]
        return element and element.Content
    end

    return Accordion


end


-- ============================================================================
-- Module: NexusUI/Components/init
-- ============================================================================
NexusUI_Modules["NexusUI/Components/init"] = function()
    local script = CreateMockScript("NexusUI/Components/init")
    
    --[[
        NexusUI Components Module
        All UI components
    ]]

    --// Components Module
    local Components = {}

    -- Base classes
    Components.Base = NexusRequire("NexusUI/Components/Base")
    Components.Container = NexusRequire("NexusUI/Components/Container")

    -- Basic components
    Components.Label = NexusRequire("NexusUI/Components/Label")
    Components.Button = NexusRequire("NexusUI/Components/Button")
    Components.TextInput = NexusRequire("NexusUI/Components/TextInput")
    Components.TextArea = NexusRequire("NexusUI/Components/TextArea")
    Components.NumberInput = NexusRequire("NexusUI/Components/NumberInput")
    Components.SearchInput = NexusRequire("NexusUI/Components/SearchInput")
    Components.Toggle = NexusRequire("NexusUI/Components/Toggle")
    Components.Switch = NexusRequire("NexusUI/Components/Switch")
    Components.Checkbox = NexusRequire("NexusUI/Components/Checkbox")
    Components.RadioButton = NexusRequire("NexusUI/Components/RadioButton")
    Components.Slider = NexusRequire("NexusUI/Components/Slider")
    Components.RangeSlider = NexusRequire("NexusUI/Components/RangeSlider")
    Components.ProgressBar = NexusRequire("NexusUI/Components/ProgressBar")
    Components.Badge = NexusRequire("NexusUI/Components/Badge")
    Components.Avatar = NexusRequire("NexusUI/Components/Avatar")
    Components.Tooltip = NexusRequire("NexusUI/Components/Tooltip")
    Components.Divider = NexusRequire("NexusUI/Components/Divider")
    Components.Spacer = NexusRequire("NexusUI/Components/Spacer")
    Components.Image = NexusRequire("NexusUI/Components/Image")
    Components.Icon = NexusRequire("NexusUI/Components/Icon")
    Components.Keybind = NexusRequire("NexusUI/Components/Keybind")
    Components.ColorPicker = NexusRequire("NexusUI/Components/ColorPicker")
    Components.SegmentedControl = NexusRequire("NexusUI/Components/SegmentedControl")

    -- Advanced components
    Components.Dropdown = NexusRequire("NexusUI/Components/Dropdown")
    Components.MultiSelect = NexusRequire("NexusUI/Components/MultiSelect")
    Components.Table = NexusRequire("NexusUI/Components/Table")
    Components.TreeView = NexusRequire("NexusUI/Components/TreeView")
    Components.Accordion = NexusRequire("NexusUI/Components/Accordion")
    Components.Tabs = NexusRequire("NexusUI/Components/Tabs")
    Components.List = NexusRequire("NexusUI/Components/List")
    Components.VirtualList = NexusRequire("NexusUI/Components/VirtualList")
    Components.Pagination = NexusRequire("NexusUI/Components/Pagination")
    Components.ContextMenu = NexusRequire("NexusUI/Components/ContextMenu")
    Components.Calendar = NexusRequire("NexusUI/Components/Calendar")

    -- Container components
    Components.Window = NexusRequire("NexusUI/Components/Window")
    Components.Modal = NexusRequire("NexusUI/Components/Modal")
    Components.Dialog = NexusRequire("NexusUI/Components/Dialog")
    Components.Card = NexusRequire("NexusUI/Components/Card")
    Components.Panel = NexusRequire("NexusUI/Components/Panel")
    Components.ScrollView = NexusRequire("NexusUI/Components/ScrollView")
    Components.Drawer = NexusRequire("NexusUI/Components/Drawer")
    Components.Sidebar = NexusRequire("NexusUI/Components/Sidebar")
    Components.TopBar = NexusRequire("NexusUI/Components/TopBar")
    Components.Section = NexusRequire("NexusUI/Components/Section")

    return Components


end


-- ============================================================================
-- Module: NexusUI/Notifications/Toast
-- ============================================================================
NexusUI_Modules["NexusUI/Notifications/Toast"] = function()
    local script = CreateMockScript("NexusUI/Notifications/Toast")
    
    --[[
        NexusUI Toast Component
        Lightweight notification toast
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Toast Component Module
    local Toast = {}
    Toast.__index = Toast
    Toast.ClassName = "Toast"

    --// Toast Types
    Toast.Type = {
        Default = "Default",
        Success = "Success",
        Error = "Error",
        Warning = "Warning",
        Info = "Info",
        Loading = "Loading",
    }

    --// Constructor
    function Toast.new(config)
        local self = setmetatable({}, Toast)

        config = config or {}

        self.Message = config.Message or "Toast message"
        self.ToastType = config.Type or Toast.Type.Default
        self.Duration = config.Duration or 3
        self.Position = config.Position or "TopRight" -- TopRight, TopLeft, TopCenter, BottomRight, BottomLeft, BottomCenter
        self.ShowIcon = config.ShowIcon ~= false
        self.Closable = config.Closable ~= false
        self.Action = config.Action -- {Text, OnClick}

        -- Callbacks
        self.OnClose = config.OnClose

        -- State
        self._isVisible = false
        self._connections = {}

        return self
    end

    --// Get type style
    function Toast:_getTypeStyle()
        local styles = {
            Default = {
                Background = Color3.fromRGB(39, 39, 42),
                Border = Color3.fromRGB(63, 63, 70),
                Text = Color3.fromRGB(250, 250, 250),
                Icon = nil,
                IconColor = nil,
            },
            Success = {
                Background = Color3.fromRGB(20, 83, 45),
                Border = Color3.fromRGB(34, 197, 94),
                Text = Color3.fromRGB(187, 247, 208),
                Icon = "rbxassetid://7072706016",
                IconColor = Color3.fromRGB(34, 197, 94),
            },
            Error = {
                Background = Color3.fromRGB(127, 29, 29),
                Border = Color3.fromRGB(239, 68, 68),
                Text = Color3.fromRGB(254, 202, 202),
                Icon = "rbxassetid://7072706350",
                IconColor = Color3.fromRGB(239, 68, 68),
            },
            Warning = {
                Background = Color3.fromRGB(120, 53, 15),
                Border = Color3.fromRGB(245, 158, 11),
                Text = Color3.fromRGB(254, 243, 199),
                Icon = "rbxassetid://7072725760",
                IconColor = Color3.fromRGB(245, 158, 11),
            },
            Info = {
                Background = Color3.fromRGB(30, 58, 138),
                Border = Color3.fromRGB(59, 130, 246),
                Text = Color3.fromRGB(191, 219, 254),
                Icon = "rbxassetid://7072718185",
                IconColor = Color3.fromRGB(59, 130, 246),
            },
            Loading = {
                Background = Color3.fromRGB(39, 39, 42),
                Border = Color3.fromRGB(99, 102, 241),
                Text = Color3.fromRGB(250, 250, 250),
                Icon = "rbxassetid://6034818372",
                IconColor = Color3.fromRGB(99, 102, 241),
            },
        }

        return styles[self.ToastType] or styles.Default
    end

    --// Create toast
    function Toast:Create(parent)
        local style = self:_getTypeStyle()

        -- Toast container
        local toast = Instance.new("Frame")
        toast.Name = "Toast"
        toast.Size = UDim2.new(0, 0, 0, 44)
        toast.AutomaticSize = Enum.AutomaticSize.X
        toast.BackgroundColor3 = style.Background
        toast.BorderSizePixel = 0
        toast.Visible = false

        if parent then
            toast.Parent = parent
        end

        self.Instance = toast

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 10)
        corner.Parent = toast

        local stroke = Instance.new("UIStroke")
        stroke.Color = style.Border
        stroke.Thickness = 1
        stroke.Transparency = 0.5
        stroke.Parent = toast

        local padding = Instance.new("UIPadding")
        padding.PaddingLeft = UDim.new(0, 14)
        padding.PaddingRight = UDim.new(0, 14)
        padding.Parent = toast

        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.Padding = UDim.new(0, 10)
        layout.Parent = toast

        local sizeConstraint = Instance.new("UISizeConstraint")
        sizeConstraint.MinSize = Vector2.new(150, 44)
        sizeConstraint.MaxSize = Vector2.new(400, 44)
        sizeConstraint.Parent = toast

        -- Icon
        if self.ShowIcon and style.Icon then
            local icon = Instance.new("ImageLabel")
            icon.Name = "Icon"
            icon.Size = UDim2.new(0, 18, 0, 18)
            icon.BackgroundTransparency = 1
            icon.Image = style.Icon
            icon.ImageColor3 = style.IconColor
            icon.LayoutOrder = 1
            icon.Parent = toast
            self._icon = icon

            -- Spinning animation for loading
            if self.ToastType == Toast.Type.Loading then
                task.spawn(function()
                    while self._icon and self._icon.Parent do
                        self._icon.Rotation = self._icon.Rotation + 5
                        task.wait(0.02)
                    end
                end)
            end
        end

        -- Message
        local message = Instance.new("TextLabel")
        message.Name = "Message"
        message.Size = UDim2.new(0, 0, 1, 0)
        message.AutomaticSize = Enum.AutomaticSize.X
        message.BackgroundTransparency = 1
        message.Font = Enum.Font.GothamMedium
        message.Text = self.Message
        message.TextColor3 = style.Text
        message.TextSize = 13
        message.LayoutOrder = 2
        message.Parent = toast
        self._message = message

        -- Action button
        if self.Action then
            local actionBtn = Instance.new("TextButton")
            actionBtn.Size = UDim2.new(0, 0, 0, 26)
            actionBtn.AutomaticSize = Enum.AutomaticSize.X
            actionBtn.BackgroundColor3 = style.Border
            actionBtn.BackgroundTransparency = 0.8
            actionBtn.BorderSizePixel = 0
            actionBtn.Font = Enum.Font.GothamMedium
            actionBtn.Text = self.Action.Text
            actionBtn.TextColor3 = style.Text
            actionBtn.TextSize = 12
            actionBtn.AutoButtonColor = false
            actionBtn.LayoutOrder = 3
            actionBtn.Parent = toast

            local actionCorner = Instance.new("UICorner")
            actionCorner.CornerRadius = UDim.new(0, 6)
            actionCorner.Parent = actionBtn

            local actionPadding = Instance.new("UIPadding")
            actionPadding.PaddingLeft = UDim.new(0, 10)
            actionPadding.PaddingRight = UDim.new(0, 10)
            actionPadding.Parent = actionBtn

            table.insert(self._connections, actionBtn.MouseButton1Click:Connect(function()
                if self.Action.OnClick then
                    self.Action.OnClick()
                end
                self:Hide()
            end))
        end

        -- Close button
        if self.Closable then
            local closeBtn = Instance.new("ImageButton")
            closeBtn.Name = "CloseBtn"
            closeBtn.Size = UDim2.new(0, 18, 0, 18)
            closeBtn.BackgroundTransparency = 1
            closeBtn.Image = "rbxassetid://7072725342"
            closeBtn.ImageColor3 = style.Text
            closeBtn.ImageTransparency = 0.5
            closeBtn.LayoutOrder = 4
            closeBtn.Parent = toast

            table.insert(self._connections, closeBtn.MouseButton1Click:Connect(function()
                self:Hide()
            end))

            table.insert(self._connections, closeBtn.MouseEnter:Connect(function()
                TweenService:Create(closeBtn, TweenInfo.new(0.1), {
                    ImageTransparency = 0,
                }):Play()
            end))

            table.insert(self._connections, closeBtn.MouseLeave:Connect(function()
                TweenService:Create(closeBtn, TweenInfo.new(0.1), {
                    ImageTransparency = 0.5,
                }):Play()
            end))
        end

        return self
    end

    --// Show
    function Toast:Show(animate)
        if self._isVisible then return self end

        self._isVisible = true
        animate = animate ~= false

        self.Instance.Visible = true

        if animate then
            self.Instance.Position = UDim2.new(0, 0, 0, -50)
            self.Instance.BackgroundTransparency = 1

            TweenService:Create(self.Instance, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                Position = UDim2.new(0, 0, 0, 0),
                BackgroundTransparency = 0,
            }):Play()
        end

        -- Auto hide after duration
        if self.Duration > 0 and self.ToastType ~= Toast.Type.Loading then
            task.delay(self.Duration, function()
                self:Hide()
            end)
        end

        return self
    end

    --// Hide
    function Toast:Hide(animate)
        if not self._isVisible then return self end

        self._isVisible = false
        animate = animate ~= false

        if animate then
            TweenService:Create(self.Instance, TweenInfo.new(0.2), {
                Position = UDim2.new(0, 0, 0, -20),
                BackgroundTransparency = 1,
            }):Play()

            task.delay(0.2, function()
                if not self._isVisible then
                    self.Instance.Visible = false
                    if self.OnClose then
                        self.OnClose()
                    end
                end
            end)
        else
            self.Instance.Visible = false
            if self.OnClose then
                self.OnClose()
            end
        end

        return self
    end

    --// Update message
    function Toast:SetMessage(message)
        self.Message = message
        if self._message then
            self._message.Text = message
        end
        return self
    end

    --// Update type
    function Toast:SetType(toastType)
        self.ToastType = toastType
        -- Note: Would need to rebuild to change type visually
        return self
    end

    --// Destroy
    function Toast:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return Toast


end


-- ============================================================================
-- Module: NexusUI/Notifications/Notification
-- ============================================================================
NexusUI_Modules["NexusUI/Notifications/Notification"] = function()
    local script = CreateMockScript("NexusUI/Notifications/Notification")
    
    --[[
        NexusUI Notification Component
        Rich notification with title, description, and actions
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Notification Component Module
    local Notification = {}
    Notification.__index = Notification
    Notification.ClassName = "Notification"

    --// Notification Types
    Notification.Type = {
        Default = "Default",
        Success = "Success",
        Error = "Error",
        Warning = "Warning",
        Info = "Info",
    }

    --// Constructor
    function Notification.new(config)
        local self = setmetatable({}, Notification)

        config = config or {}

        self.Title = config.Title or "Notification"
        self.Message = config.Message or ""
        self.NotificationType = config.Type or Notification.Type.Default
        self.Duration = config.Duration or 5
        self.ShowIcon = config.ShowIcon ~= false
        self.ShowProgress = config.ShowProgress or false
        self.Closable = config.Closable ~= false
        self.Actions = config.Actions or {} -- Array of {Text, OnClick, Primary}
        self.Avatar = config.Avatar -- Image URL for avatar
        self.Icon = config.Icon -- Custom icon override

        -- Callbacks
        self.OnClose = config.OnClose
        self.OnClick = config.OnClick

        -- State
        self._isVisible = false
        self._connections = {}
        self._progressThread = nil

        return self
    end

    --// Get type style
    function Notification:_getTypeStyle()
        local styles = {
            Default = {
                AccentColor = Color3.fromRGB(99, 102, 241),
                Icon = "rbxassetid://7072718185",
            },
            Success = {
                AccentColor = Color3.fromRGB(34, 197, 94),
                Icon = "rbxassetid://7072706016",
            },
            Error = {
                AccentColor = Color3.fromRGB(239, 68, 68),
                Icon = "rbxassetid://7072706350",
            },
            Warning = {
                AccentColor = Color3.fromRGB(245, 158, 11),
                Icon = "rbxassetid://7072725760",
            },
            Info = {
                AccentColor = Color3.fromRGB(59, 130, 246),
                Icon = "rbxassetid://7072718185",
            },
        }

        return styles[self.NotificationType] or styles.Default
    end

    --// Create notification
    function Notification:Create(parent)
        local style = self:_getTypeStyle()

        -- Notification container
        local notification = Instance.new("Frame")
        notification.Name = "Notification"
        notification.Size = UDim2.new(0, 320, 0, 0)
        notification.AutomaticSize = Enum.AutomaticSize.Y
        notification.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        notification.BorderSizePixel = 0
        notification.Visible = false

        if parent then
            notification.Parent = parent
        end

        self.Instance = notification

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 12)
        corner.Parent = notification

        local stroke = Instance.new("UIStroke")
        stroke.Color = Color3.fromRGB(63, 63, 70)
        stroke.Thickness = 1
        stroke.Parent = notification

        -- Shadow
        local shadow = Instance.new("ImageLabel")
        shadow.Size = UDim2.new(1, 20, 1, 20)
        shadow.Position = UDim2.new(0.5, 0, 0.5, 6)
        shadow.AnchorPoint = Vector2.new(0.5, 0.5)
        shadow.BackgroundTransparency = 1
        shadow.Image = "rbxassetid://6015897843"
        shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
        shadow.ImageTransparency = 0.5
        shadow.ScaleType = Enum.ScaleType.Slice
        shadow.SliceCenter = Rect.new(49, 49, 450, 450)
        shadow.ZIndex = notification.ZIndex - 1
        shadow.Parent = notification

        -- Accent bar
        local accentBar = Instance.new("Frame")
        accentBar.Size = UDim2.new(0, 4, 1, 0)
        accentBar.BackgroundColor3 = style.AccentColor
        accentBar.BorderSizePixel = 0
        accentBar.Parent = notification

        local accentCorner = Instance.new("UICorner")
        accentCorner.CornerRadius = UDim.new(0, 2)
        accentCorner.Parent = accentBar

        -- Content container
        local content = Instance.new("Frame")
        content.Size = UDim2.new(1, -12, 0, 0)
        content.AutomaticSize = Enum.AutomaticSize.Y
        content.Position = UDim2.new(0, 12, 0, 0)
        content.BackgroundTransparency = 1
        content.Parent = notification

        local contentPadding = Instance.new("UIPadding")
        contentPadding.PaddingTop = UDim.new(0, 14)
        contentPadding.PaddingBottom = UDim.new(0, 14)
        contentPadding.PaddingLeft = UDim.new(0, 10)
        contentPadding.PaddingRight = UDim.new(0, 10)
        contentPadding.Parent = content

        -- Header row
        local header = Instance.new("Frame")
        header.Size = UDim2.new(1, 0, 0, 24)
        header.BackgroundTransparency = 1
        header.Parent = content

        local headerLayout = Instance.new("UIListLayout")
        headerLayout.FillDirection = Enum.FillDirection.Horizontal
        headerLayout.VerticalAlignment = Enum.VerticalAlignment.Center
        headerLayout.Padding = UDim.new(0, 10)
        headerLayout.Parent = header

        -- Icon or Avatar
        if self.Avatar then
            local avatar = Instance.new("ImageLabel")
            avatar.Size = UDim2.new(0, 24, 0, 24)
            avatar.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
            avatar.Image = self.Avatar
            avatar.ScaleType = Enum.ScaleType.Crop
            avatar.LayoutOrder = 1
            avatar.Parent = header

            local avatarCorner = Instance.new("UICorner")
            avatarCorner.CornerRadius = UDim.new(1, 0)
            avatarCorner.Parent = avatar

        elseif self.ShowIcon then
            local iconContainer = Instance.new("Frame")
            iconContainer.Size = UDim2.new(0, 24, 0, 24)
            iconContainer.BackgroundColor3 = style.AccentColor
            iconContainer.BackgroundTransparency = 0.85
            iconContainer.BorderSizePixel = 0
            iconContainer.LayoutOrder = 1
            iconContainer.Parent = header

            local iconCorner = Instance.new("UICorner")
            iconCorner.CornerRadius = UDim.new(0, 6)
            iconCorner.Parent = iconContainer

            local icon = Instance.new("ImageLabel")
            icon.Size = UDim2.new(0.6, 0, 0.6, 0)
            icon.Position = UDim2.new(0.5, 0, 0.5, 0)
            icon.AnchorPoint = Vector2.new(0.5, 0.5)
            icon.BackgroundTransparency = 1
            icon.Image = self.Icon or style.Icon
            icon.ImageColor3 = style.AccentColor
            icon.Parent = iconContainer
        end

        -- Title
        local title = Instance.new("TextLabel")
        title.Size = UDim2.new(1, self.Closable and -58 or -34, 1, 0)
        title.BackgroundTransparency = 1
        title.Font = Enum.Font.GothamMedium
        title.Text = self.Title
        title.TextColor3 = Color3.fromRGB(250, 250, 250)
        title.TextSize = 14
        title.TextXAlignment = Enum.TextXAlignment.Left
        title.TextTruncate = Enum.TextTruncate.AtEnd
        title.LayoutOrder = 2
        title.Parent = header

        -- Close button
        if self.Closable then
            local closeBtn = Instance.new("ImageButton")
            closeBtn.Size = UDim2.new(0, 20, 0, 20)
            closeBtn.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
            closeBtn.BackgroundTransparency = 1
            closeBtn.Image = "rbxassetid://7072725342"
            closeBtn.ImageColor3 = Color3.fromRGB(161, 161, 170)
            closeBtn.LayoutOrder = 3
            closeBtn.Parent = header

            local closeBtnCorner = Instance.new("UICorner")
            closeBtnCorner.CornerRadius = UDim.new(0, 4)
            closeBtnCorner.Parent = closeBtn

            table.insert(self._connections, closeBtn.MouseButton1Click:Connect(function()
                self:Hide()
            end))

            table.insert(self._connections, closeBtn.MouseEnter:Connect(function()
                TweenService:Create(closeBtn, TweenInfo.new(0.1), {
                    BackgroundTransparency = 0,
                    ImageColor3 = Color3.fromRGB(250, 250, 250),
                }):Play()
            end))

            table.insert(self._connections, closeBtn.MouseLeave:Connect(function()
                TweenService:Create(closeBtn, TweenInfo.new(0.1), {
                    BackgroundTransparency = 1,
                    ImageColor3 = Color3.fromRGB(161, 161, 170),
                }):Play()
            end))
        end

        -- Message
        if self.Message and self.Message ~= "" then
            local message = Instance.new("TextLabel")
            message.Size = UDim2.new(1, 0, 0, 0)
            message.AutomaticSize = Enum.AutomaticSize.Y
            message.Position = UDim2.new(0, 0, 0, 30)
            message.BackgroundTransparency = 1
            message.Font = Enum.Font.Gotham
            message.Text = self.Message
            message.TextColor3 = Color3.fromRGB(161, 161, 170)
            message.TextSize = 13
            message.TextXAlignment = Enum.TextXAlignment.Left
            message.TextWrapped = true
            message.Parent = content
            self._messageLabel = message
        end

        -- Actions
        if #self.Actions > 0 then
            local actionsContainer = Instance.new("Frame")
            actionsContainer.Size = UDim2.new(1, 0, 0, 32)
            actionsContainer.Position = UDim2.new(0, 0, 0, self.Message and self.Message ~= "" and 60 or 30)
            actionsContainer.BackgroundTransparency = 1
            actionsContainer.Parent = content

            local actionsLayout = Instance.new("UIListLayout")
            actionsLayout.FillDirection = Enum.FillDirection.Horizontal
            actionsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
            actionsLayout.Padding = UDim.new(0, 8)
            actionsLayout.Parent = actionsContainer

            for i, action in ipairs(self.Actions) do
                local btn = Instance.new("TextButton")
                btn.Size = UDim2.new(0, 0, 0, 28)
                btn.AutomaticSize = Enum.AutomaticSize.X
                btn.BackgroundColor3 = action.Primary and style.AccentColor or Color3.fromRGB(63, 63, 70)
                btn.BackgroundTransparency = action.Primary and 0 or 1
                btn.BorderSizePixel = 0
                btn.Font = Enum.Font.GothamMedium
                btn.Text = action.Text
                btn.TextColor3 = action.Primary and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(161, 161, 170)
                btn.TextSize = 12
                btn.AutoButtonColor = false
                btn.LayoutOrder = i
                btn.Parent = actionsContainer

                local btnCorner = Instance.new("UICorner")
                btnCorner.CornerRadius = UDim.new(0, 6)
                btnCorner.Parent = btn

                local btnPadding = Instance.new("UIPadding")
                btnPadding.PaddingLeft = UDim.new(0, 12)
                btnPadding.PaddingRight = UDim.new(0, 12)
                btnPadding.Parent = btn

                table.insert(self._connections, btn.MouseButton1Click:Connect(function()
                    if action.OnClick then
                        action.OnClick()
                    end
                    self:Hide()
                end))

                table.insert(self._connections, btn.MouseEnter:Connect(function()
                    TweenService:Create(btn, TweenInfo.new(0.1), {
                        BackgroundTransparency = 0,
                    }):Play()
                end))

                table.insert(self._connections, btn.MouseLeave:Connect(function()
                    TweenService:Create(btn, TweenInfo.new(0.1), {
                        BackgroundTransparency = action.Primary and 0 or 1,
                    }):Play()
                end))
            end
        end

        -- Progress bar
        if self.ShowProgress and self.Duration > 0 then
            local progressTrack = Instance.new("Frame")
            progressTrack.Size = UDim2.new(1, -8, 0, 3)
            progressTrack.Position = UDim2.new(0.5, 0, 1, -6)
            progressTrack.AnchorPoint = Vector2.new(0.5, 0)
            progressTrack.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
            progressTrack.BorderSizePixel = 0
            progressTrack.Parent = notification

            local progressCorner = Instance.new("UICorner")
            progressCorner.CornerRadius = UDim.new(1, 0)
            progressCorner.Parent = progressTrack

            local progressFill = Instance.new("Frame")
            progressFill.Size = UDim2.new(1, 0, 1, 0)
            progressFill.BackgroundColor3 = style.AccentColor
            progressFill.BorderSizePixel = 0
            progressFill.Parent = progressTrack
            self._progressFill = progressFill

            local progressFillCorner = Instance.new("UICorner")
            progressFillCorner.CornerRadius = UDim.new(1, 0)
            progressFillCorner.Parent = progressFill
        end

        return self
    end

    --// Show
    function Notification:Show(animate)
        if self._isVisible then return self end

        self._isVisible = true
        animate = animate ~= false

        self.Instance.Visible = true

        if animate then
            self.Instance.Position = UDim2.new(1, 0, 0, 0)
            self.Instance.BackgroundTransparency = 1

            TweenService:Create(self.Instance, TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {
                Position = UDim2.new(0, 0, 0, 0),
                BackgroundTransparency = 0,
            }):Play()
        end

        -- Progress and auto-hide
        if self.Duration > 0 then
            if self._progressFill then
                TweenService:Create(self._progressFill, TweenInfo.new(self.Duration, Enum.EasingStyle.Linear), {
                    Size = UDim2.new(0, 0, 1, 0),
                }):Play()
            end

            task.delay(self.Duration, function()
                self:Hide()
            end)
        end

        return self
    end

    --// Hide
    function Notification:Hide(animate)
        if not self._isVisible then return self end

        self._isVisible = false
        animate = animate ~= false

        if animate then
            TweenService:Create(self.Instance, TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {
                Position = UDim2.new(1, 0, 0, 0),
                BackgroundTransparency = 1,
            }):Play()

            task.delay(0.2, function()
                if not self._isVisible then
                    self.Instance.Visible = false
                    if self.OnClose then
                        self.OnClose()
                    end
                end
            end)
        else
            self.Instance.Visible = false
            if self.OnClose then
                self.OnClose()
            end
        end

        return self
    end

    --// Destroy
    function Notification:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return Notification


end


-- ============================================================================
-- Module: NexusUI/Notifications/Alert
-- ============================================================================
NexusUI_Modules["NexusUI/Notifications/Alert"] = function()
    local script = CreateMockScript("NexusUI/Notifications/Alert")
    
    --[[
        NexusUI Alert Component
        Inline alert/callout component
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Alert Component Module
    local Alert = {}
    Alert.__index = Alert
    Alert.ClassName = "Alert"

    --// Alert Types
    Alert.Type = {
        Default = "Default",
        Success = "Success",
        Error = "Error",
        Warning = "Warning",
        Info = "Info",
    }

    --// Constructor
    function Alert.new(config)
        local self = setmetatable({}, Alert)

        config = config or {}

        self.Title = config.Title
        self.Message = config.Message or "Alert message"
        self.AlertType = config.Type or Alert.Type.Default
        self.Closable = config.Closable or false
        self.ShowIcon = config.ShowIcon ~= false
        self.Bordered = config.Bordered ~= false

        -- Callbacks
        self.OnClose = config.OnClose

        -- State
        self._connections = {}

        return self
    end

    --// Get type style
    function Alert:_getTypeStyle()
        local styles = {
            Default = {
                Background = Color3.fromRGB(39, 39, 42),
                Border = Color3.fromRGB(63, 63, 70),
                Text = Color3.fromRGB(250, 250, 250),
                Icon = "rbxassetid://7072718185",
                IconColor = Color3.fromRGB(161, 161, 170),
            },
            Success = {
                Background = Color3.fromRGB(20, 83, 45),
                Border = Color3.fromRGB(34, 197, 94),
                Text = Color3.fromRGB(187, 247, 208),
                Icon = "rbxassetid://7072706016",
                IconColor = Color3.fromRGB(34, 197, 94),
            },
            Error = {
                Background = Color3.fromRGB(127, 29, 29),
                Border = Color3.fromRGB(239, 68, 68),
                Text = Color3.fromRGB(254, 202, 202),
                Icon = "rbxassetid://7072706350",
                IconColor = Color3.fromRGB(239, 68, 68),
            },
            Warning = {
                Background = Color3.fromRGB(120, 53, 15),
                Border = Color3.fromRGB(245, 158, 11),
                Text = Color3.fromRGB(254, 243, 199),
                Icon = "rbxassetid://7072725760",
                IconColor = Color3.fromRGB(245, 158, 11),
            },
            Info = {
                Background = Color3.fromRGB(30, 58, 138),
                Border = Color3.fromRGB(59, 130, 246),
                Text = Color3.fromRGB(191, 219, 254),
                Icon = "rbxassetid://7072718185",
                IconColor = Color3.fromRGB(59, 130, 246),
            },
        }

        return styles[self.AlertType] or styles.Default
    end

    --// Create alert
    function Alert:Create(parent)
        local style = self:_getTypeStyle()

        -- Alert container
        local alert = Instance.new("Frame")
        alert.Name = "Alert"
        alert.Size = UDim2.new(1, 0, 0, 0)
        alert.AutomaticSize = Enum.AutomaticSize.Y
        alert.BackgroundColor3 = style.Background
        alert.BackgroundTransparency = 0.5
        alert.BorderSizePixel = 0

        if parent then
            alert.Parent = parent
        end

        self.Instance = alert

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = alert

        if self.Bordered then
            local stroke = Instance.new("UIStroke")
            stroke.Color = style.Border
            stroke.Thickness = 1
            stroke.Parent = alert
        end

        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, 12)
        padding.PaddingBottom = UDim.new(0, 12)
        padding.PaddingLeft = UDim.new(0, 14)
        padding.PaddingRight = UDim.new(0, 14)
        padding.Parent = alert

        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.VerticalAlignment = Enum.VerticalAlignment.Top
        layout.Padding = UDim.new(0, 12)
        layout.Parent = alert

        -- Icon
        if self.ShowIcon then
            local icon = Instance.new("ImageLabel")
            icon.Size = UDim2.new(0, 18, 0, 18)
            icon.BackgroundTransparency = 1
            icon.Image = style.Icon
            icon.ImageColor3 = style.IconColor
            icon.LayoutOrder = 1
            icon.Parent = alert
        end

        -- Text container
        local textContainer = Instance.new("Frame")
        textContainer.Size = UDim2.new(1, self.Closable and -56 or -30, 0, 0)
        textContainer.AutomaticSize = Enum.AutomaticSize.Y
        textContainer.BackgroundTransparency = 1
        textContainer.LayoutOrder = 2
        textContainer.Parent = alert

        local textLayout = Instance.new("UIListLayout")
        textLayout.Padding = UDim.new(0, 4)
        textLayout.Parent = textContainer

        -- Title
        if self.Title then
            local title = Instance.new("TextLabel")
            title.Size = UDim2.new(1, 0, 0, 0)
            title.AutomaticSize = Enum.AutomaticSize.Y
            title.BackgroundTransparency = 1
            title.Font = Enum.Font.GothamMedium
            title.Text = self.Title
            title.TextColor3 = style.Text
            title.TextSize = 14
            title.TextXAlignment = Enum.TextXAlignment.Left
            title.TextWrapped = true
            title.LayoutOrder = 1
            title.Parent = textContainer
            self._title = title
        end

        -- Message
        local message = Instance.new("TextLabel")
        message.Size = UDim2.new(1, 0, 0, 0)
        message.AutomaticSize = Enum.AutomaticSize.Y
        message.BackgroundTransparency = 1
        message.Font = Enum.Font.Gotham
        message.Text = self.Message
        message.TextColor3 = style.Text
        message.TextTransparency = self.Title and 0.2 or 0
        message.TextSize = 13
        message.TextXAlignment = Enum.TextXAlignment.Left
        message.TextWrapped = true
        message.LayoutOrder = 2
        message.Parent = textContainer
        self._message = message

        -- Close button
        if self.Closable then
            local closeBtn = Instance.new("ImageButton")
            closeBtn.Size = UDim2.new(0, 18, 0, 18)
            closeBtn.BackgroundTransparency = 1
            closeBtn.Image = "rbxassetid://7072725342"
            closeBtn.ImageColor3 = style.Text
            closeBtn.ImageTransparency = 0.3
            closeBtn.LayoutOrder = 3
            closeBtn.Parent = alert

            table.insert(self._connections, closeBtn.MouseButton1Click:Connect(function()
                self:Hide()
            end))

            table.insert(self._connections, closeBtn.MouseEnter:Connect(function()
                TweenService:Create(closeBtn, TweenInfo.new(0.1), {
                    ImageTransparency = 0,
                }):Play()
            end))

            table.insert(self._connections, closeBtn.MouseLeave:Connect(function()
                TweenService:Create(closeBtn, TweenInfo.new(0.1), {
                    ImageTransparency = 0.3,
                }):Play()
            end))
        end

        return self
    end

    --// Show
    function Alert:Show(animate)
        self.Instance.Visible = true
        animate = animate ~= false

        if animate then
            self.Instance.BackgroundTransparency = 1
            TweenService:Create(self.Instance, TweenInfo.new(0.2), {
                BackgroundTransparency = 0.5,
            }):Play()
        end

        return self
    end

    --// Hide
    function Alert:Hide(animate)
        animate = animate ~= false

        if animate then
            TweenService:Create(self.Instance, TweenInfo.new(0.15), {
                BackgroundTransparency = 1,
            }):Play()

            task.delay(0.15, function()
                self.Instance.Visible = false
                if self.OnClose then
                    self.OnClose()
                end
            end)
        else
            self.Instance.Visible = false
            if self.OnClose then
                self.OnClose()
            end
        end

        return self
    end

    --// Set message
    function Alert:SetMessage(message)
        self.Message = message
        if self._message then
            self._message.Text = message
        end
        return self
    end

    --// Set title
    function Alert:SetTitle(title)
        self.Title = title
        if self._title then
            self._title.Text = title
        end
        return self
    end

    --// Destroy
    function Alert:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return Alert


end


-- ============================================================================
-- Module: NexusUI/Notifications/Manager
-- ============================================================================
NexusUI_Modules["NexusUI/Notifications/Manager"] = function()
    local script = CreateMockScript("NexusUI/Notifications/Manager")
    
    --[[
        NexusUI Notification Manager
        Manages all notifications and toasts
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Toast = NexusRequire("NexusUI/Toast")
    local Notification = NexusRequire("NexusUI/Notification")

    --// Manager Module
    local Manager = {}
    Manager.__index = Manager
    Manager.ClassName = "NotificationManager"

    --// Position configurations
    local POSITIONS = {
        TopRight = {
            Position = UDim2.new(1, -20, 0, 20),
            AnchorPoint = Vector2.new(1, 0),
            Direction = 1,
        },
        TopLeft = {
            Position = UDim2.new(0, 20, 0, 20),
            AnchorPoint = Vector2.new(0, 0),
            Direction = 1,
        },
        TopCenter = {
            Position = UDim2.new(0.5, 0, 0, 20),
            AnchorPoint = Vector2.new(0.5, 0),
            Direction = 1,
        },
        BottomRight = {
            Position = UDim2.new(1, -20, 1, -20),
            AnchorPoint = Vector2.new(1, 1),
            Direction = -1,
        },
        BottomLeft = {
            Position = UDim2.new(0, 20, 1, -20),
            AnchorPoint = Vector2.new(0, 1),
            Direction = -1,
        },
        BottomCenter = {
            Position = UDim2.new(0.5, 0, 1, -20),
            AnchorPoint = Vector2.new(0.5, 1),
            Direction = -1,
        },
    }

    --// Constructor
    function Manager.new(config)
        local self = setmetatable({}, Manager)

        config = config or {}

        self.MaxVisible = config.MaxVisible or 5
        self.Gap = config.Gap or 10
        self.ToastPosition = config.ToastPosition or "TopRight"
        self.NotificationPosition = config.NotificationPosition or "TopRight"

        -- State
        self._toasts = {}
        self._notifications = {}
        self._screenGui = nil
        self._toastContainer = nil
        self._notificationContainer = nil

        return self
    end

    --// Create manager
    function Manager:Create(parent)
        -- Get or create screen gui
        if parent and parent:IsA("ScreenGui") then
            self._screenGui = parent
        else
            self._screenGui = Instance.new("ScreenGui")
            self._screenGui.Name = "NexusUI_Notifications"
            self._screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
            self._screenGui.DisplayOrder = 999
            self._screenGui.Parent = game:GetService("CoreGui")
        end

        -- Toast container
        local toastConfig = POSITIONS[self.ToastPosition]
        self._toastContainer = Instance.new("Frame")
        self._toastContainer.Name = "ToastContainer"
        self._toastContainer.Size = UDim2.new(0, 400, 0, 0)
        self._toastContainer.AutomaticSize = Enum.AutomaticSize.Y
        self._toastContainer.Position = toastConfig.Position
        self._toastContainer.AnchorPoint = toastConfig.AnchorPoint
        self._toastContainer.BackgroundTransparency = 1
        self._toastContainer.Parent = self._screenGui

        local toastLayout = Instance.new("UIListLayout")
        toastLayout.Padding = UDim.new(0, self.Gap)
        toastLayout.HorizontalAlignment = string.find(self.ToastPosition, "Right") and Enum.HorizontalAlignment.Right or 
            (string.find(self.ToastPosition, "Left") and Enum.HorizontalAlignment.Left or Enum.HorizontalAlignment.Center)
        toastLayout.VerticalAlignment = toastConfig.Direction == 1 and Enum.VerticalAlignment.Top or Enum.VerticalAlignment.Bottom
        toastLayout.SortOrder = Enum.SortOrder.LayoutOrder
        toastLayout.Parent = self._toastContainer

        -- Notification container
        local notifConfig = POSITIONS[self.NotificationPosition]
        self._notificationContainer = Instance.new("Frame")
        self._notificationContainer.Name = "NotificationContainer"
        self._notificationContainer.Size = UDim2.new(0, 340, 0, 0)
        self._notificationContainer.AutomaticSize = Enum.AutomaticSize.Y
        self._notificationContainer.Position = notifConfig.Position
        self._notificationContainer.AnchorPoint = notifConfig.AnchorPoint
        self._notificationContainer.BackgroundTransparency = 1
        self._notificationContainer.Parent = self._screenGui

        local notifLayout = Instance.new("UIListLayout")
        notifLayout.Padding = UDim.new(0, self.Gap)
        notifLayout.HorizontalAlignment = string.find(self.NotificationPosition, "Right") and Enum.HorizontalAlignment.Right or 
            (string.find(self.NotificationPosition, "Left") and Enum.HorizontalAlignment.Left or Enum.HorizontalAlignment.Center)
        notifLayout.VerticalAlignment = notifConfig.Direction == 1 and Enum.VerticalAlignment.Top or Enum.VerticalAlignment.Bottom
        notifLayout.SortOrder = Enum.SortOrder.LayoutOrder
        notifLayout.Parent = self._notificationContainer

        return self
    end

    --// Show toast
    function Manager:Toast(message, toastType, duration)
        local toast = Toast.new({
            Message = message,
            Type = toastType or "Default",
            Duration = duration or 3,
            OnClose = function()
                self:_removeToast(toast)
            end,
        })

        toast:Create(self._toastContainer)
        toast.Instance.LayoutOrder = #self._toasts + 1

        table.insert(self._toasts, toast)

        -- Remove oldest if over max
        while #self._toasts > self.MaxVisible do
            local oldest = table.remove(self._toasts, 1)
            oldest:Hide()
        end

        toast:Show()

        return toast
    end

    --// Show notification
    function Manager:Notify(title, message, notifType, duration)
        local notification = Notification.new({
            Title = title,
            Message = message,
            Type = notifType or "Default",
            Duration = duration or 5,
            ShowProgress = true,
            OnClose = function()
                self:_removeNotification(notification)
            end,
        })

        notification:Create(self._notificationContainer)
        notification.Instance.LayoutOrder = #self._notifications + 1

        table.insert(self._notifications, notification)

        -- Remove oldest if over max
        while #self._notifications > self.MaxVisible do
            local oldest = table.remove(self._notifications, 1)
            oldest:Hide()
        end

        notification:Show()

        return notification
    end

    --// Show alert (in a modal-like way)
    function Manager:Alert(title, message, alertType)
        -- Create simple alert dialog
        local overlay = Instance.new("TextButton")
        overlay.Size = UDim2.new(1, 0, 1, 0)
        overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        overlay.BackgroundTransparency = 0.5
        overlay.BorderSizePixel = 0
        overlay.Text = ""
        overlay.ZIndex = 1000
        overlay.Parent = self._screenGui

        local alertContainer = Instance.new("Frame")
        alertContainer.Size = UDim2.new(0, 360, 0, 0)
        alertContainer.AutomaticSize = Enum.AutomaticSize.Y
        alertContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
        alertContainer.AnchorPoint = Vector2.new(0.5, 0.5)
        alertContainer.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        alertContainer.BorderSizePixel = 0
        alertContainer.ZIndex = 1001
        alertContainer.Parent = self._screenGui

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 12)
        corner.Parent = alertContainer

        local stroke = Instance.new("UIStroke")
        stroke.Color = Color3.fromRGB(63, 63, 70)
        stroke.Thickness = 1
        stroke.Parent = alertContainer

        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, 20)
        padding.PaddingBottom = UDim.new(0, 20)
        padding.PaddingLeft = UDim.new(0, 20)
        padding.PaddingRight = UDim.new(0, 20)
        padding.Parent = alertContainer

        local layout = Instance.new("UIListLayout")
        layout.Padding = UDim.new(0, 12)
        layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        layout.Parent = alertContainer

        -- Icon based on type
        local iconColors = {
            Success = Color3.fromRGB(34, 197, 94),
            Error = Color3.fromRGB(239, 68, 68),
            Warning = Color3.fromRGB(245, 158, 11),
            Info = Color3.fromRGB(59, 130, 246),
        }
        local iconImages = {
            Success = "rbxassetid://7072706016",
            Error = "rbxassetid://7072706350",
            Warning = "rbxassetid://7072725760",
            Info = "rbxassetid://7072718185",
        }

        local iconColor = iconColors[alertType] or Color3.fromRGB(99, 102, 241)
        local iconImage = iconImages[alertType] or "rbxassetid://7072718185"

        local iconContainer = Instance.new("Frame")
        iconContainer.Size = UDim2.new(0, 48, 0, 48)
        iconContainer.BackgroundColor3 = iconColor
        iconContainer.BackgroundTransparency = 0.9
        iconContainer.BorderSizePixel = 0
        iconContainer.LayoutOrder = 1
        iconContainer.Parent = alertContainer

        local iconCorner = Instance.new("UICorner")
        iconCorner.CornerRadius = UDim.new(1, 0)
        iconCorner.Parent = iconContainer

        local icon = Instance.new("ImageLabel")
        icon.Size = UDim2.new(0.5, 0, 0.5, 0)
        icon.Position = UDim2.new(0.5, 0, 0.5, 0)
        icon.AnchorPoint = Vector2.new(0.5, 0.5)
        icon.BackgroundTransparency = 1
        icon.Image = iconImage
        icon.ImageColor3 = iconColor
        icon.Parent = iconContainer

        -- Title
        local titleLabel = Instance.new("TextLabel")
        titleLabel.Size = UDim2.new(1, 0, 0, 0)
        titleLabel.AutomaticSize = Enum.AutomaticSize.Y
        titleLabel.BackgroundTransparency = 1
        titleLabel.Font = Enum.Font.GothamBold
        titleLabel.Text = title or "Alert"
        titleLabel.TextColor3 = Color3.fromRGB(250, 250, 250)
        titleLabel.TextSize = 18
        titleLabel.TextWrapped = true
        titleLabel.LayoutOrder = 2
        titleLabel.Parent = alertContainer

        -- Message
        local messageLabel = Instance.new("TextLabel")
        messageLabel.Size = UDim2.new(1, 0, 0, 0)
        messageLabel.AutomaticSize = Enum.AutomaticSize.Y
        messageLabel.BackgroundTransparency = 1
        messageLabel.Font = Enum.Font.Gotham
        messageLabel.Text = message or ""
        messageLabel.TextColor3 = Color3.fromRGB(161, 161, 170)
        messageLabel.TextSize = 14
        messageLabel.TextWrapped = true
        messageLabel.LayoutOrder = 3
        messageLabel.Parent = alertContainer

        -- OK Button
        local okBtn = Instance.new("TextButton")
        okBtn.Size = UDim2.new(1, 0, 0, 40)
        okBtn.BackgroundColor3 = iconColor
        okBtn.BorderSizePixel = 0
        okBtn.Font = Enum.Font.GothamMedium
        okBtn.Text = "OK"
        okBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
        okBtn.TextSize = 14
        okBtn.AutoButtonColor = false
        okBtn.LayoutOrder = 4
        okBtn.Parent = alertContainer

        local okCorner = Instance.new("UICorner")
        okCorner.CornerRadius = UDim.new(0, 8)
        okCorner.Parent = okBtn

        local function close()
            TweenService:Create(overlay, TweenInfo.new(0.15), {
                BackgroundTransparency = 1,
            }):Play()

            TweenService:Create(alertContainer, TweenInfo.new(0.15), {
                Position = UDim2.new(0.5, 0, 0.5, 20),
                BackgroundTransparency = 1,
            }):Play()

            task.delay(0.15, function()
                overlay:Destroy()
                alertContainer:Destroy()
            end)
        end

        okBtn.MouseButton1Click:Connect(close)
        overlay.MouseButton1Click:Connect(close)

        -- Animate in
        overlay.BackgroundTransparency = 1
        alertContainer.Position = UDim2.new(0.5, 0, 0.5, 20)
        alertContainer.BackgroundTransparency = 1

        TweenService:Create(overlay, TweenInfo.new(0.2), {
            BackgroundTransparency = 0.5,
        }):Play()

        TweenService:Create(alertContainer, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
            Position = UDim2.new(0.5, 0, 0.5, 0),
            BackgroundTransparency = 0,
        }):Play()
    end

    --// Remove toast from tracking
    function Manager:_removeToast(toast)
        for i, t in ipairs(self._toasts) do
            if t == toast then
                table.remove(self._toasts, i)
                break
            end
        end
    end

    --// Remove notification from tracking
    function Manager:_removeNotification(notification)
        for i, n in ipairs(self._notifications) do
            if n == notification then
                table.remove(self._notifications, i)
                break
            end
        end
    end

    --// Clear all toasts
    function Manager:ClearToasts()
        for _, toast in ipairs(self._toasts) do
            toast:Hide(false)
        end
        self._toasts = {}
        return self
    end

    --// Clear all notifications
    function Manager:ClearNotifications()
        for _, notification in ipairs(self._notifications) do
            notification:Hide(false)
        end
        self._notifications = {}
        return self
    end

    --// Clear all
    function Manager:ClearAll()
        self:ClearToasts()
        self:ClearNotifications()
        return self
    end

    --// Destroy
    function Manager:Destroy()
        self:ClearAll()

        if self._screenGui then
            self._screenGui:Destroy()
            self._screenGui = nil
        end
    end

    return Manager


end


-- ============================================================================
-- Module: NexusUI/Notifications/Banner
-- ============================================================================
NexusUI_Modules["NexusUI/Notifications/Banner"] = function()
    local script = CreateMockScript("NexusUI/Notifications/Banner")
    
    --[[
        NexusUI Banner Component
        Full-width banner notification
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Banner Component Module
    local Banner = {}
    Banner.__index = Banner
    Banner.ClassName = "Banner"

    --// Banner Types
    Banner.Type = {
        Default = "Default",
        Success = "Success",
        Error = "Error",
        Warning = "Warning",
        Info = "Info",
    }

    --// Banner Positions
    Banner.Position = {
        Top = "Top",
        Bottom = "Bottom",
    }

    --// Constructor
    function Banner.new(config)
        local self = setmetatable({}, Banner)

        config = config or {}

        self.Message = config.Message or "Banner message"
        self.BannerType = config.Type or Banner.Type.Default
        self.BannerPosition = config.Position or Banner.Position.Top
        self.Closable = config.Closable ~= false
        self.ShowIcon = config.ShowIcon ~= false
        self.Action = config.Action -- {Text, OnClick}

        -- Callbacks
        self.OnClose = config.OnClose

        -- State
        self._isVisible = false
        self._connections = {}

        return self
    end

    --// Get type style
    function Banner:_getTypeStyle()
        local styles = {
            Default = {
                Background = Color3.fromRGB(39, 39, 42),
                Text = Color3.fromRGB(250, 250, 250),
                Icon = "rbxassetid://7072718185",
                IconColor = Color3.fromRGB(161, 161, 170),
            },
            Success = {
                Background = Color3.fromRGB(20, 83, 45),
                Text = Color3.fromRGB(187, 247, 208),
                Icon = "rbxassetid://7072706016",
                IconColor = Color3.fromRGB(34, 197, 94),
            },
            Error = {
                Background = Color3.fromRGB(127, 29, 29),
                Text = Color3.fromRGB(254, 202, 202),
                Icon = "rbxassetid://7072706350",
                IconColor = Color3.fromRGB(239, 68, 68),
            },
            Warning = {
                Background = Color3.fromRGB(120, 53, 15),
                Text = Color3.fromRGB(254, 243, 199),
                Icon = "rbxassetid://7072725760",
                IconColor = Color3.fromRGB(245, 158, 11),
            },
            Info = {
                Background = Color3.fromRGB(30, 58, 138),
                Text = Color3.fromRGB(191, 219, 254),
                Icon = "rbxassetid://7072718185",
                IconColor = Color3.fromRGB(59, 130, 246),
            },
        }

        return styles[self.BannerType] or styles.Default
    end

    --// Create banner
    function Banner:Create(parent)
        local style = self:_getTypeStyle()

        -- Banner container
        local banner = Instance.new("Frame")
        banner.Name = "Banner"
        banner.Size = UDim2.new(1, 0, 0, 44)
        banner.BackgroundColor3 = style.Background
        banner.BorderSizePixel = 0
        banner.Visible = false

        if self.BannerPosition == Banner.Position.Top then
            banner.Position = UDim2.new(0, 0, 0, -44)
        else
            banner.Position = UDim2.new(0, 0, 1, 0)
        end

        if parent then
            banner.Parent = parent
        end

        self.Instance = banner

        local padding = Instance.new("UIPadding")
        padding.PaddingLeft = UDim.new(0, 20)
        padding.PaddingRight = UDim.new(0, 20)
        padding.Parent = banner

        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        layout.Padding = UDim.new(0, 12)
        layout.Parent = banner

        -- Icon
        if self.ShowIcon then
            local icon = Instance.new("ImageLabel")
            icon.Size = UDim2.new(0, 18, 0, 18)
            icon.BackgroundTransparency = 1
            icon.Image = style.Icon
            icon.ImageColor3 = style.IconColor
            icon.LayoutOrder = 1
            icon.Parent = banner
        end

        -- Message
        local message = Instance.new("TextLabel")
        message.Size = UDim2.new(0, 0, 1, 0)
        message.AutomaticSize = Enum.AutomaticSize.X
        message.BackgroundTransparency = 1
        message.Font = Enum.Font.GothamMedium
        message.Text = self.Message
        message.TextColor3 = style.Text
        message.TextSize = 14
        message.LayoutOrder = 2
        message.Parent = banner
        self._message = message

        -- Action button
        if self.Action then
            local actionBtn = Instance.new("TextButton")
            actionBtn.Size = UDim2.new(0, 0, 0, 28)
            actionBtn.AutomaticSize = Enum.AutomaticSize.X
            actionBtn.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            actionBtn.BackgroundTransparency = 0.85
            actionBtn.BorderSizePixel = 0
            actionBtn.Font = Enum.Font.GothamMedium
            actionBtn.Text = self.Action.Text
            actionBtn.TextColor3 = style.Text
            actionBtn.TextSize = 12
            actionBtn.AutoButtonColor = false
            actionBtn.LayoutOrder = 3
            actionBtn.Parent = banner

            local actionCorner = Instance.new("UICorner")
            actionCorner.CornerRadius = UDim.new(0, 6)
            actionCorner.Parent = actionBtn

            local actionPadding = Instance.new("UIPadding")
            actionPadding.PaddingLeft = UDim.new(0, 12)
            actionPadding.PaddingRight = UDim.new(0, 12)
            actionPadding.Parent = actionBtn

            table.insert(self._connections, actionBtn.MouseButton1Click:Connect(function()
                if self.Action.OnClick then
                    self.Action.OnClick()
                end
            end))
        end

        -- Close button
        if self.Closable then
            local closeBtn = Instance.new("ImageButton")
            closeBtn.Size = UDim2.new(0, 20, 0, 20)
            closeBtn.Position = UDim2.new(1, -30, 0.5, 0)
            closeBtn.AnchorPoint = Vector2.new(0, 0.5)
            closeBtn.BackgroundTransparency = 1
            closeBtn.Image = "rbxassetid://7072725342"
            closeBtn.ImageColor3 = style.Text
            closeBtn.ImageTransparency = 0.3
            closeBtn.Parent = banner

            table.insert(self._connections, closeBtn.MouseButton1Click:Connect(function()
                self:Hide()
            end))

            table.insert(self._connections, closeBtn.MouseEnter:Connect(function()
                TweenService:Create(closeBtn, TweenInfo.new(0.1), {
                    ImageTransparency = 0,
                }):Play()
            end))

            table.insert(self._connections, closeBtn.MouseLeave:Connect(function()
                TweenService:Create(closeBtn, TweenInfo.new(0.1), {
                    ImageTransparency = 0.3,
                }):Play()
            end))
        end

        return self
    end

    --// Show
    function Banner:Show(animate)
        if self._isVisible then return self end

        self._isVisible = true
        animate = animate ~= false

        self.Instance.Visible = true

        local targetPosition = self.BannerPosition == Banner.Position.Top and 
            UDim2.new(0, 0, 0, 0) or UDim2.new(0, 0, 1, -44)

        if animate then
            TweenService:Create(self.Instance, TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {
                Position = targetPosition,
            }):Play()
        else
            self.Instance.Position = targetPosition
        end

        return self
    end

    --// Hide
    function Banner:Hide(animate)
        if not self._isVisible then return self end

        self._isVisible = false
        animate = animate ~= false

        local targetPosition = self.BannerPosition == Banner.Position.Top and 
            UDim2.new(0, 0, 0, -44) or UDim2.new(0, 0, 1, 0)

        if animate then
            TweenService:Create(self.Instance, TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {
                Position = targetPosition,
            }):Play()

            task.delay(0.2, function()
                if not self._isVisible then
                    self.Instance.Visible = false
                    if self.OnClose then
                        self.OnClose()
                    end
                end
            end)
        else
            self.Instance.Visible = false
            if self.OnClose then
                self.OnClose()
            end
        end

        return self
    end

    --// Set message
    function Banner:SetMessage(message)
        self.Message = message
        if self._message then
            self._message.Text = message
        end
        return self
    end

    --// Destroy
    function Banner:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return Banner


end


-- ============================================================================
-- Module: NexusUI/Notifications/Snackbar
-- ============================================================================
NexusUI_Modules["NexusUI/Notifications/Snackbar"] = function()
    local script = CreateMockScript("NexusUI/Notifications/Snackbar")
    
    --[[
        NexusUI Snackbar Component
        Bottom-aligned snackbar notification
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Snackbar Component Module
    local Snackbar = {}
    Snackbar.__index = Snackbar
    Snackbar.ClassName = "Snackbar"

    --// Constructor
    function Snackbar.new(config)
        local self = setmetatable({}, Snackbar)

        config = config or {}

        self.Message = config.Message or "Snackbar message"
        self.Duration = config.Duration or 4
        self.Action = config.Action -- {Text, OnClick}

        -- Callbacks
        self.OnClose = config.OnClose

        -- State
        self._isVisible = false
        self._connections = {}

        return self
    end

    --// Create snackbar
    function Snackbar:Create(parent)
        -- Snackbar container
        local snackbar = Instance.new("Frame")
        snackbar.Name = "Snackbar"
        snackbar.Size = UDim2.new(0, 0, 0, 48)
        snackbar.AutomaticSize = Enum.AutomaticSize.X
        snackbar.Position = UDim2.new(0.5, 0, 1, 0)
        snackbar.AnchorPoint = Vector2.new(0.5, 0)
        snackbar.BackgroundColor3 = Color3.fromRGB(50, 50, 55)
        snackbar.BorderSizePixel = 0
        snackbar.Visible = false

        if parent then
            snackbar.Parent = parent
        end

        self.Instance = snackbar

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 10)
        corner.Parent = snackbar

        -- Shadow
        local shadow = Instance.new("ImageLabel")
        shadow.Size = UDim2.new(1, 16, 1, 16)
        shadow.Position = UDim2.new(0.5, 0, 0.5, 4)
        shadow.AnchorPoint = Vector2.new(0.5, 0.5)
        shadow.BackgroundTransparency = 1
        shadow.Image = "rbxassetid://6015897843"
        shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
        shadow.ImageTransparency = 0.5
        shadow.ScaleType = Enum.ScaleType.Slice
        shadow.SliceCenter = Rect.new(49, 49, 450, 450)
        shadow.ZIndex = snackbar.ZIndex - 1
        shadow.Parent = snackbar

        local padding = Instance.new("UIPadding")
        padding.PaddingLeft = UDim.new(0, 16)
        padding.PaddingRight = UDim.new(0, 16)
        padding.Parent = snackbar

        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.Padding = UDim.new(0, 20)
        layout.Parent = snackbar

        local sizeConstraint = Instance.new("UISizeConstraint")
        sizeConstraint.MinSize = Vector2.new(200, 48)
        sizeConstraint.MaxSize = Vector2.new(500, 48)
        sizeConstraint.Parent = snackbar

        -- Message
        local message = Instance.new("TextLabel")
        message.Size = UDim2.new(0, 0, 1, 0)
        message.AutomaticSize = Enum.AutomaticSize.X
        message.BackgroundTransparency = 1
        message.Font = Enum.Font.GothamMedium
        message.Text = self.Message
        message.TextColor3 = Color3.fromRGB(250, 250, 250)
        message.TextSize = 14
        message.LayoutOrder = 1
        message.Parent = snackbar
        self._message = message

        -- Action button
        if self.Action then
            local actionBtn = Instance.new("TextButton")
            actionBtn.Size = UDim2.new(0, 0, 0, 32)
            actionBtn.AutomaticSize = Enum.AutomaticSize.X
            actionBtn.BackgroundTransparency = 1
            actionBtn.BorderSizePixel = 0
            actionBtn.Font = Enum.Font.GothamBold
            actionBtn.Text = string.upper(self.Action.Text)
            actionBtn.TextColor3 = Color3.fromRGB(139, 92, 246)
            actionBtn.TextSize = 13
            actionBtn.AutoButtonColor = false
            actionBtn.LayoutOrder = 2
            actionBtn.Parent = snackbar

            table.insert(self._connections, actionBtn.MouseButton1Click:Connect(function()
                if self.Action.OnClick then
                    self.Action.OnClick()
                end
                self:Hide()
            end))

            table.insert(self._connections, actionBtn.MouseEnter:Connect(function()
                TweenService:Create(actionBtn, TweenInfo.new(0.1), {
                    TextColor3 = Color3.fromRGB(167, 139, 250),
                }):Play()
            end))

            table.insert(self._connections, actionBtn.MouseLeave:Connect(function()
                TweenService:Create(actionBtn, TweenInfo.new(0.1), {
                    TextColor3 = Color3.fromRGB(139, 92, 246),
                }):Play()
            end))
        end

        return self
    end

    --// Show
    function Snackbar:Show(animate)
        if self._isVisible then return self end

        self._isVisible = true
        animate = animate ~= false

        self.Instance.Visible = true

        if animate then
            TweenService:Create(self.Instance, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                Position = UDim2.new(0.5, 0, 1, -68),
            }):Play()
        else
            self.Instance.Position = UDim2.new(0.5, 0, 1, -68)
        end

        -- Auto hide
        if self.Duration > 0 then
            task.delay(self.Duration, function()
                self:Hide()
            end)
        end

        return self
    end

    --// Hide
    function Snackbar:Hide(animate)
        if not self._isVisible then return self end

        self._isVisible = false
        animate = animate ~= false

        if animate then
            TweenService:Create(self.Instance, TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {
                Position = UDim2.new(0.5, 0, 1, 0),
            }):Play()

            task.delay(0.2, function()
                if not self._isVisible then
                    self.Instance.Visible = false
                    if self.OnClose then
                        self.OnClose()
                    end
                end
            end)
        else
            self.Instance.Visible = false
            if self.OnClose then
                self.OnClose()
            end
        end

        return self
    end

    --// Set message
    function Snackbar:SetMessage(message)
        self.Message = message
        if self._message then
            self._message.Text = message
        end
        return self
    end

    --// Destroy
    function Snackbar:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return Snackbar


end


-- ============================================================================
-- Module: NexusUI/Notifications/init
-- ============================================================================
NexusUI_Modules["NexusUI/Notifications/init"] = function()
    local script = CreateMockScript("NexusUI/Notifications/init")
    
    --[[
        NexusUI Notifications Module
        Toast, notification, and alert system
    ]]

    --// Notifications Module
    local Notifications = {}

    Notifications.Toast = NexusRequire("NexusUI/Notifications/Toast")
    Notifications.Notification = NexusRequire("NexusUI/Notifications/Notification")
    Notifications.Alert = NexusRequire("NexusUI/Notifications/Alert")
    Notifications.Manager = NexusRequire("NexusUI/Notifications/Manager")
    Notifications.Banner = NexusRequire("NexusUI/Notifications/Banner")
    Notifications.Snackbar = NexusRequire("NexusUI/Notifications/Snackbar")

    -- Quick access to manager
    local _manager

    function Notifications.getManager()
        if not _manager then
            _manager = Notifications.Manager.new()
            _manager:Create()
        end
        return _manager
    end

    -- Convenience methods
    function Notifications.toast(message, type, duration)
        return Notifications.getManager():Toast(message, type, duration)
    end

    function Notifications.notify(title, message, type, duration)
        return Notifications.getManager():Notify(title, message, type, duration)
    end

    function Notifications.alert(title, message, type)
        return Notifications.getManager():Alert(title, message, type)
    end

    function Notifications.success(message)
        return Notifications.toast(message, "Success")
    end

    function Notifications.error(message)
        return Notifications.toast(message, "Error")
    end

    function Notifications.warning(message)
        return Notifications.toast(message, "Warning")
    end

    function Notifications.info(message)
        return Notifications.toast(message, "Info")
    end

    return Notifications


end


-- ============================================================================
-- Module: NexusUI/Visualizers/LineChart
-- ============================================================================
NexusUI_Modules["NexusUI/Visualizers/LineChart"] = function()
    local script = CreateMockScript("NexusUI/Visualizers/LineChart")
    
    --[[
        NexusUI Line Chart Component
        Renders line charts with multiple series support
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// LineChart Module
    local LineChart = {}
    LineChart.__index = LineChart
    LineChart.ClassName = "LineChart"

    --// Constructor
    function LineChart.new(config)
        local self = setmetatable({}, LineChart)

        config = config or {}

        self.Data = config.Data or {} -- Array of {Label, Value} or multiple series
        self.Series = config.Series or {} -- [{Name, Color, Data}]
        self.Width = config.Width or 300
        self.Height = config.Height or 200
        self.ShowGrid = config.ShowGrid ~= false
        self.ShowLabels = config.ShowLabels ~= false
        self.ShowPoints = config.ShowPoints ~= false
        self.ShowTooltip = config.ShowTooltip ~= false
        self.Animated = config.Animated ~= false
        self.LineWidth = config.LineWidth or 2
        self.PointRadius = config.PointRadius or 4
        self.GridLines = config.GridLines or 5
        self.Smooth = config.Smooth or false
        self.FillArea = config.FillArea or false

        -- Colors
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
        self.GridColor = config.GridColor or Color3.fromRGB(63, 63, 70)
        self.LabelColor = config.LabelColor or Color3.fromRGB(161, 161, 170)
        self.DefaultLineColor = config.LineColor or Color3.fromRGB(99, 102, 241)

        -- State
        self._connections = {}
        self._lines = {}
        self._points = {}

        return self
    end

    --// Calculate chart bounds
    function LineChart:_calculateBounds()
        local minY, maxY = math.huge, -math.huge
        local data = #self.Series > 0 and self.Series or {{Data = self.Data, Color = self.DefaultLineColor}}

        for _, series in ipairs(data) do
            for _, point in ipairs(series.Data or {}) do
                local value = type(point) == "table" and point.Value or point
                minY = math.min(minY, value)
                maxY = math.max(maxY, value)
            end
        end

        -- Add padding
        local padding = (maxY - minY) * 0.1
        if padding == 0 then padding = 1 end

        return minY - padding, maxY + padding
    end

    --// Create line between points
    function LineChart:_createLine(startPos, endPos, color, parent, thickness)
        local distance = (endPos - startPos).Magnitude
        local angle = math.atan2(endPos.Y - startPos.Y, endPos.X - startPos.X)

        local line = Instance.new("Frame")
        line.Name = "Line"
        line.BackgroundColor3 = color
        line.BorderSizePixel = 0
        line.Size = UDim2.new(0, distance, 0, thickness or self.LineWidth)
        line.Position = UDim2.new(0, startPos.X, 0, startPos.Y)
        line.AnchorPoint = Vector2.new(0, 0.5)
        line.Rotation = math.deg(angle)
        line.Parent = parent

        return line
    end

    --// Create point marker
    function LineChart:_createPoint(pos, color, parent)
        local point = Instance.new("Frame")
        point.Name = "Point"
        point.BackgroundColor3 = color
        point.BorderSizePixel = 0
        point.Size = UDim2.new(0, self.PointRadius * 2, 0, self.PointRadius * 2)
        point.Position = UDim2.new(0, pos.X - self.PointRadius, 0, pos.Y - self.PointRadius)
        point.Parent = parent

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(1, 0)
        corner.Parent = point

        return point
    end

    --// Create chart
    function LineChart:Create(parent)
        -- Main container
        local chart = Instance.new("Frame")
        chart.Name = "LineChart"
        chart.Size = UDim2.new(0, self.Width, 0, self.Height)
        chart.BackgroundColor3 = self.BackgroundColor
        chart.BorderSizePixel = 0

        if parent then
            chart.Parent = parent
        end

        self.Instance = chart

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = chart

        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, 30)
        padding.PaddingBottom = UDim.new(0, 30)
        padding.PaddingLeft = UDim.new(0, 40)
        padding.PaddingRight = UDim.new(0, 20)
        padding.Parent = chart

        -- Chart area
        local chartArea = Instance.new("Frame")
        chartArea.Name = "ChartArea"
        chartArea.Size = UDim2.new(1, 0, 1, 0)
        chartArea.BackgroundTransparency = 1
        chartArea.ClipsDescendants = true
        chartArea.Parent = chart
        self._chartArea = chartArea

        -- Grid container
        if self.ShowGrid then
            self:_createGrid()
        end

        -- Lines container
        local linesContainer = Instance.new("Frame")
        linesContainer.Name = "Lines"
        linesContainer.Size = UDim2.new(1, 0, 1, 0)
        linesContainer.BackgroundTransparency = 1
        linesContainer.Parent = chartArea
        self._linesContainer = linesContainer

        -- Draw initial data
        self:Update()

        return self
    end

    --// Create grid lines
    function LineChart:_createGrid()
        local minY, maxY = self:_calculateBounds()
        local chartArea = self._chartArea

        -- Horizontal grid lines
        for i = 0, self.GridLines do
            local y = i / self.GridLines

            local gridLine = Instance.new("Frame")
            gridLine.Name = "GridLine_H_" .. i
            gridLine.Size = UDim2.new(1, 0, 0, 1)
            gridLine.Position = UDim2.new(0, 0, y, 0)
            gridLine.BackgroundColor3 = self.GridColor
            gridLine.BackgroundTransparency = 0.7
            gridLine.BorderSizePixel = 0
            gridLine.Parent = chartArea

            -- Y-axis labels
            if self.ShowLabels then
                local value = maxY - (y * (maxY - minY))

                local label = Instance.new("TextLabel")
                label.Size = UDim2.new(0, 35, 0, 14)
                label.Position = UDim2.new(0, -40, y, -7)
                label.BackgroundTransparency = 1
                label.Font = Enum.Font.Gotham
                label.Text = tostring(math.floor(value * 10) / 10)
                label.TextColor3 = self.LabelColor
                label.TextSize = 10
                label.TextXAlignment = Enum.TextXAlignment.Right
                label.Parent = chartArea
            end
        end
    end

    --// Update chart with new data
    function LineChart:Update(newData)
        if newData then
            if newData.Data then
                self.Data = newData.Data
            end
            if newData.Series then
                self.Series = newData.Series
            end
        end

        -- Clear existing lines and points
        for _, line in ipairs(self._lines) do
            line:Destroy()
        end
        self._lines = {}

        for _, point in ipairs(self._points) do
            point:Destroy()
        end
        self._points = {}

        -- Get data to plot
        local data = #self.Series > 0 and self.Series or {{Data = self.Data, Color = self.DefaultLineColor, Name = "Series 1"}}

        if #data == 0 then return self end

        local minY, maxY = self:_calculateBounds()
        local chartWidth = self._chartArea.AbsoluteSize.X
        local chartHeight = self._chartArea.AbsoluteSize.Y

        -- Draw each series
        for _, series in ipairs(data) do
            local seriesData = series.Data or {}
            local color = series.Color or self.DefaultLineColor

            if #seriesData < 2 then continue end

            local points = {}

            -- Calculate point positions
            for i, point in ipairs(seriesData) do
                local value = type(point) == "table" and point.Value or point
                local x = ((i - 1) / (#seriesData - 1)) * chartWidth
                local y = chartHeight - ((value - minY) / (maxY - minY)) * chartHeight

                table.insert(points, Vector2.new(x, y))
            end

            -- Draw lines
            for i = 1, #points - 1 do
                local line = self:_createLine(points[i], points[i + 1], color, self._linesContainer)
                table.insert(self._lines, line)

                -- Animate
                if self.Animated then
                    line.BackgroundTransparency = 1
                    TweenService:Create(line, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, i * 0.05), {
                        BackgroundTransparency = 0,
                    }):Play()
                end
            end

            -- Draw points
            if self.ShowPoints then
                for i, pos in ipairs(points) do
                    local point = self:_createPoint(pos, color, self._linesContainer)
                    table.insert(self._points, point)

                    if self.Animated then
                        point.Size = UDim2.new(0, 0, 0, 0)
                        point.Position = UDim2.new(0, pos.X, 0, pos.Y)
                        TweenService:Create(point, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, i * 0.05), {
                            Size = UDim2.new(0, self.PointRadius * 2, 0, self.PointRadius * 2),
                            Position = UDim2.new(0, pos.X - self.PointRadius, 0, pos.Y - self.PointRadius),
                        }):Play()
                    end
                end
            end
        end

        return self
    end

    --// Add data point
    function LineChart:AddPoint(value, seriesIndex)
        seriesIndex = seriesIndex or 1

        if #self.Series > 0 then
            table.insert(self.Series[seriesIndex].Data, value)
        else
            table.insert(self.Data, value)
        end

        self:Update()
        return self
    end

    --// Set data
    function LineChart:SetData(data)
        self.Data = data
        self:Update()
        return self
    end

    --// Destroy
    function LineChart:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return LineChart


end


-- ============================================================================
-- Module: NexusUI/Visualizers/BarChart
-- ============================================================================
NexusUI_Modules["NexusUI/Visualizers/BarChart"] = function()
    local script = CreateMockScript("NexusUI/Visualizers/BarChart")
    
    --[[
        NexusUI Bar Chart Component
        Vertical and horizontal bar charts
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// BarChart Module
    local BarChart = {}
    BarChart.__index = BarChart
    BarChart.ClassName = "BarChart"

    --// Constructor
    function BarChart.new(config)
        local self = setmetatable({}, BarChart)

        config = config or {}

        self.Data = config.Data or {} -- [{Label, Value, Color?}]
        self.Width = config.Width or 300
        self.Height = config.Height or 200
        self.Horizontal = config.Horizontal or false
        self.ShowLabels = config.ShowLabels ~= false
        self.ShowValues = config.ShowValues ~= false
        self.ShowGrid = config.ShowGrid ~= false
        self.Animated = config.Animated ~= false
        self.BarSpacing = config.BarSpacing or 0.2 -- Percentage of bar width
        self.BarRadius = config.BarRadius or 4
        self.Stacked = config.Stacked or false
        self.Grouped = config.Grouped or false

        -- Colors
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
        self.GridColor = config.GridColor or Color3.fromRGB(63, 63, 70)
        self.LabelColor = config.LabelColor or Color3.fromRGB(161, 161, 170)
        self.DefaultColors = config.Colors or {
            Color3.fromRGB(99, 102, 241),
            Color3.fromRGB(236, 72, 153),
            Color3.fromRGB(34, 197, 94),
            Color3.fromRGB(245, 158, 11),
            Color3.fromRGB(239, 68, 68),
            Color3.fromRGB(59, 130, 246),
            Color3.fromRGB(168, 85, 247),
            Color3.fromRGB(20, 184, 166),
        }

        -- State
        self._connections = {}
        self._bars = {}

        return self
    end

    --// Create bar chart
    function BarChart:Create(parent)
        -- Main container
        local chart = Instance.new("Frame")
        chart.Name = "BarChart"
        chart.Size = UDim2.new(0, self.Width, 0, self.Height)
        chart.BackgroundColor3 = self.BackgroundColor
        chart.BorderSizePixel = 0

        if parent then
            chart.Parent = parent
        end

        self.Instance = chart

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = chart

        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, 20)
        padding.PaddingBottom = UDim.new(0, self.ShowLabels and 35 or 20)
        padding.PaddingLeft = UDim.new(0, self.ShowValues and 40 or 20)
        padding.PaddingRight = UDim.new(0, 20)
        padding.Parent = chart

        -- Chart area
        local chartArea = Instance.new("Frame")
        chartArea.Name = "ChartArea"
        chartArea.Size = UDim2.new(1, 0, 1, 0)
        chartArea.BackgroundTransparency = 1
        chartArea.ClipsDescendants = true
        chartArea.Parent = chart
        self._chartArea = chartArea

        -- Bars container
        local barsContainer = Instance.new("Frame")
        barsContainer.Name = "Bars"
        barsContainer.Size = UDim2.new(1, 0, 1, 0)
        barsContainer.BackgroundTransparency = 1
        barsContainer.Parent = chartArea
        self._barsContainer = barsContainer

        -- Draw initial data
        self:Update()

        return self
    end

    --// Update chart
    function BarChart:Update(newData)
        if newData then
            self.Data = newData
        end

        -- Clear existing bars
        for _, bar in ipairs(self._bars) do
            bar:Destroy()
        end
        self._bars = {}

        -- Clear existing labels
        for _, child in ipairs(self._chartArea:GetChildren()) do
            if child.Name:find("Label_") or child.Name:find("Value_") then
                child:Destroy()
            end
        end

        local data = self.Data
        if #data == 0 then return self end

        -- Find max value
        local maxValue = 0
        for _, item in ipairs(data) do
            local value = type(item) == "table" and item.Value or item
            maxValue = math.max(maxValue, value)
        end

        if maxValue == 0 then maxValue = 1 end

        local chartWidth = self._chartArea.AbsoluteSize.X
        local chartHeight = self._chartArea.AbsoluteSize.Y

        local barCount = #data
        local totalSpacing = self.BarSpacing * barCount
        local barWidthRatio = (1 - totalSpacing) / barCount

        -- Create bars
        for i, item in ipairs(data) do
            local value = type(item) == "table" and item.Value or item
            local label = type(item) == "table" and item.Label or tostring(i)
            local color = type(item) == "table" and item.Color or self.DefaultColors[((i - 1) % #self.DefaultColors) + 1]

            local heightRatio = value / maxValue
            local xPos = (i - 1) / barCount + self.BarSpacing / 2 / barCount

            -- Bar frame
            local bar = Instance.new("Frame")
            bar.Name = "Bar_" .. i
            bar.BackgroundColor3 = color
            bar.BorderSizePixel = 0

            if self.Horizontal then
                bar.Size = self.Animated and UDim2.new(0, 0, barWidthRatio, 0) or UDim2.new(heightRatio, 0, barWidthRatio, 0)
                bar.Position = UDim2.new(0, 0, xPos, 0)
            else
                bar.Size = self.Animated and UDim2.new(barWidthRatio, 0, 0, 0) or UDim2.new(barWidthRatio, 0, heightRatio, 0)
                bar.Position = UDim2.new(xPos, 0, 1 - heightRatio, 0)
                bar.AnchorPoint = Vector2.new(0, 0)
            end

            bar.Parent = self._barsContainer

            local barCorner = Instance.new("UICorner")
            barCorner.CornerRadius = UDim.new(0, self.BarRadius)
            barCorner.Parent = bar

            table.insert(self._bars, bar)

            -- Animate
            if self.Animated then
                if self.Horizontal then
                    TweenService:Create(bar, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, i * 0.05), {
                        Size = UDim2.new(heightRatio, 0, barWidthRatio, 0),
                    }):Play()
                else
                    TweenService:Create(bar, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, i * 0.05), {
                        Size = UDim2.new(barWidthRatio, 0, heightRatio, 0),
                        Position = UDim2.new(xPos, 0, 1 - heightRatio, 0),
                    }):Play()
                end
            end

            -- Label
            if self.ShowLabels then
                local labelText = Instance.new("TextLabel")
                labelText.Name = "Label_" .. i
                labelText.Size = UDim2.new(barWidthRatio, 0, 0, 16)
                labelText.Position = UDim2.new(xPos, 0, 1, 5)
                labelText.BackgroundTransparency = 1
                labelText.Font = Enum.Font.Gotham
                labelText.Text = label
                labelText.TextColor3 = self.LabelColor
                labelText.TextSize = 10
                labelText.TextTruncate = Enum.TextTruncate.AtEnd
                labelText.Parent = self._chartArea
            end

            -- Value label
            if self.ShowValues then
                local valueText = Instance.new("TextLabel")
                valueText.Name = "Value_" .. i
                valueText.Size = UDim2.new(barWidthRatio, 0, 0, 14)
                valueText.Position = UDim2.new(xPos, 0, 1 - heightRatio, -18)
                valueText.BackgroundTransparency = 1
                valueText.Font = Enum.Font.GothamMedium
                valueText.Text = tostring(math.floor(value * 100) / 100)
                valueText.TextColor3 = color
                valueText.TextSize = 10
                valueText.Parent = self._chartArea
            end

            -- Hover effect
            local button = Instance.new("TextButton")
            button.Size = UDim2.new(1, 0, 1, 0)
            button.BackgroundTransparency = 1
            button.Text = ""
            button.Parent = bar

            table.insert(self._connections, button.MouseEnter:Connect(function()
                TweenService:Create(bar, TweenInfo.new(0.15), {
                    BackgroundTransparency = 0.2,
                }):Play()
            end))

            table.insert(self._connections, button.MouseLeave:Connect(function()
                TweenService:Create(bar, TweenInfo.new(0.15), {
                    BackgroundTransparency = 0,
                }):Play()
            end))
        end

        return self
    end

    --// Set data
    function BarChart:SetData(data)
        self.Data = data
        self:Update()
        return self
    end

    --// Destroy
    function BarChart:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return BarChart


end


-- ============================================================================
-- Module: NexusUI/Visualizers/PieChart
-- ============================================================================
NexusUI_Modules["NexusUI/Visualizers/PieChart"] = function()
    local script = CreateMockScript("NexusUI/Visualizers/PieChart")
    
    --[[
        NexusUI Pie Chart Component
        Circular pie chart with segments
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// PieChart Module
    local PieChart = {}
    PieChart.__index = PieChart
    PieChart.ClassName = "PieChart"

    --// Constructor
    function PieChart.new(config)
        local self = setmetatable({}, PieChart)

        config = config or {}

        self.Data = config.Data or {} -- [{Label, Value, Color?}]
        self.Size = config.Size or 150
        self.ShowLabels = config.ShowLabels or false
        self.ShowLegend = config.ShowLegend ~= false
        self.ShowValues = config.ShowValues or false
        self.Animated = config.Animated ~= false
        self.InnerRadius = config.InnerRadius or 0 -- For donut chart
        self.StartAngle = config.StartAngle or -90

        -- Colors
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
        self.LabelColor = config.LabelColor or Color3.fromRGB(250, 250, 250)
        self.DefaultColors = config.Colors or {
            Color3.fromRGB(99, 102, 241),
            Color3.fromRGB(236, 72, 153),
            Color3.fromRGB(34, 197, 94),
            Color3.fromRGB(245, 158, 11),
            Color3.fromRGB(239, 68, 68),
            Color3.fromRGB(59, 130, 246),
            Color3.fromRGB(168, 85, 247),
            Color3.fromRGB(20, 184, 166),
        }

        -- State
        self._connections = {}
        self._segments = {}

        return self
    end

    --// Create a pie segment
    function PieChart:_createSegment(startAngle, endAngle, color, parent)
        -- Create segment using UI gradients and clipping
        local segment = Instance.new("Frame")
        segment.Name = "Segment"
        segment.Size = UDim2.new(1, 0, 1, 0)
        segment.Position = UDim2.new(0.5, 0, 0.5, 0)
        segment.AnchorPoint = Vector2.new(0.5, 0.5)
        segment.BackgroundTransparency = 1
        segment.Parent = parent

        -- Use ImageLabel for pie segment (would need custom asset in real implementation)
        -- For this implementation, we'll use a simplified approach
        local wedge = Instance.new("Frame")
        wedge.Size = UDim2.new(0.5, 0, 0.5, 0)
        wedge.Position = UDim2.new(0.5, 0, 0.5, 0)
        wedge.AnchorPoint = Vector2.new(0, 1)
        wedge.BackgroundColor3 = color
        wedge.BorderSizePixel = 0
        wedge.Rotation = startAngle
        wedge.ClipsDescendants = true
        wedge.Parent = segment

        local wedgeClip = Instance.new("Frame")
        wedgeClip.Size = UDim2.new(2, 0, 2, 0)
        wedgeClip.Position = UDim2.new(0, 0, 1, 0)
        wedgeClip.AnchorPoint = Vector2.new(0, 1)
        wedgeClip.BackgroundColor3 = color
        wedgeClip.BorderSizePixel = 0
        wedgeClip.Rotation = math.min(endAngle - startAngle, 90)
        wedgeClip.Parent = wedge

        return segment
    end

    --// Create pie chart
    function PieChart:Create(parent)
        -- Main container
        local chart = Instance.new("Frame")
        chart.Name = "PieChart"
        chart.Size = UDim2.new(0, self.Size + (self.ShowLegend and 150 or 0), 0, self.Size)
        chart.BackgroundColor3 = self.BackgroundColor
        chart.BorderSizePixel = 0

        if parent then
            chart.Parent = parent
        end

        self.Instance = chart

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = chart

        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, 15)
        padding.PaddingBottom = UDim.new(0, 15)
        padding.PaddingLeft = UDim.new(0, 15)
        padding.PaddingRight = UDim.new(0, 15)
        padding.Parent = chart

        -- Pie container
        local pieContainer = Instance.new("Frame")
        pieContainer.Name = "PieContainer"
        pieContainer.Size = UDim2.new(0, self.Size - 30, 0, self.Size - 30)
        pieContainer.BackgroundTransparency = 1
        pieContainer.ClipsDescendants = true
        pieContainer.Parent = chart
        self._pieContainer = pieContainer

        local pieCorner = Instance.new("UICorner")
        pieCorner.CornerRadius = UDim.new(1, 0)
        pieCorner.Parent = pieContainer

        -- Legend container
        if self.ShowLegend then
            local legendContainer = Instance.new("Frame")
            legendContainer.Name = "Legend"
            legendContainer.Size = UDim2.new(0, 120, 1, 0)
            legendContainer.Position = UDim2.new(0, self.Size - 20, 0, 0)
            legendContainer.BackgroundTransparency = 1
            legendContainer.Parent = chart
            self._legendContainer = legendContainer

            local legendLayout = Instance.new("UIListLayout")
            legendLayout.Padding = UDim.new(0, 8)
            legendLayout.Parent = legendContainer
        end

        -- Draw initial data
        self:Update()

        return self
    end

    --// Update chart
    function PieChart:Update(newData)
        if newData then
            self.Data = newData
        end

        -- Clear existing segments
        for _, segment in ipairs(self._segments) do
            segment:Destroy()
        end
        self._segments = {}

        -- Clear legend
        if self._legendContainer then
            for _, child in ipairs(self._legendContainer:GetChildren()) do
                if child:IsA("Frame") then
                    child:Destroy()
                end
            end
        end

        local data = self.Data
        if #data == 0 then return self end

        -- Calculate total
        local total = 0
        for _, item in ipairs(data) do
            local value = type(item) == "table" and item.Value or item
            total = total + value
        end

        if total == 0 then return self end

        -- Create segments
        local currentAngle = self.StartAngle

        for i, item in ipairs(data) do
            local value = type(item) == "table" and item.Value or item
            local label = type(item) == "table" and item.Label or tostring(i)
            local color = type(item) == "table" and item.Color or self.DefaultColors[((i - 1) % #self.DefaultColors) + 1]

            local percentage = value / total
            local angle = percentage * 360

            -- Create colored segment frame (simplified visualization)
            local segment = Instance.new("Frame")
            segment.Name = "Segment_" .. i
            segment.Size = UDim2.new(0.5, 0, 0.5, 0)
            segment.Position = UDim2.new(0.5, 0, 0.5, 0)
            segment.AnchorPoint = Vector2.new(0, 0)
            segment.BackgroundColor3 = color
            segment.BorderSizePixel = 0
            segment.Rotation = currentAngle
            segment.Parent = self._pieContainer

            table.insert(self._segments, segment)

            -- Legend item
            if self.ShowLegend and self._legendContainer then
                local legendItem = Instance.new("Frame")
                legendItem.Size = UDim2.new(1, 0, 0, 20)
                legendItem.BackgroundTransparency = 1
                legendItem.Parent = self._legendContainer

                local colorBox = Instance.new("Frame")
                colorBox.Size = UDim2.new(0, 12, 0, 12)
                colorBox.Position = UDim2.new(0, 0, 0.5, 0)
                colorBox.AnchorPoint = Vector2.new(0, 0.5)
                colorBox.BackgroundColor3 = color
                colorBox.BorderSizePixel = 0
                colorBox.Parent = legendItem

                local colorBoxCorner = Instance.new("UICorner")
                colorBoxCorner.CornerRadius = UDim.new(0, 3)
                colorBoxCorner.Parent = colorBox

                local legendLabel = Instance.new("TextLabel")
                legendLabel.Size = UDim2.new(1, -18, 1, 0)
                legendLabel.Position = UDim2.new(0, 18, 0, 0)
                legendLabel.BackgroundTransparency = 1
                legendLabel.Font = Enum.Font.Gotham
                legendLabel.Text = label .. " (" .. math.floor(percentage * 100) .. "%)"
                legendLabel.TextColor3 = self.LabelColor
                legendLabel.TextSize = 11
                legendLabel.TextXAlignment = Enum.TextXAlignment.Left
                legendLabel.TextTruncate = Enum.TextTruncate.AtEnd
                legendLabel.Parent = legendItem
            end

            currentAngle = currentAngle + angle
        end

        -- Add center circle for donut effect
        if self.InnerRadius > 0 then
            local center = Instance.new("Frame")
            center.Name = "Center"
            center.Size = UDim2.new(self.InnerRadius / 50, 0, self.InnerRadius / 50, 0)
            center.Position = UDim2.new(0.5, 0, 0.5, 0)
            center.AnchorPoint = Vector2.new(0.5, 0.5)
            center.BackgroundColor3 = self.BackgroundColor
            center.BorderSizePixel = 0
            center.ZIndex = 2
            center.Parent = self._pieContainer

            local centerCorner = Instance.new("UICorner")
            centerCorner.CornerRadius = UDim.new(1, 0)
            centerCorner.Parent = center

            table.insert(self._segments, center)
        end

        return self
    end

    --// Set data
    function PieChart:SetData(data)
        self.Data = data
        self:Update()
        return self
    end

    --// Destroy
    function PieChart:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return PieChart


end


-- ============================================================================
-- Module: NexusUI/Visualizers/AreaChart
-- ============================================================================
NexusUI_Modules["NexusUI/Visualizers/AreaChart"] = function()
    local script = CreateMockScript("NexusUI/Visualizers/AreaChart")
    
    --[[
        NexusUI Area Chart Component
        Line chart with filled area underneath
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// AreaChart Module
    local AreaChart = {}
    AreaChart.__index = AreaChart
    AreaChart.ClassName = "AreaChart"

    --// Constructor
    function AreaChart.new(config)
        local self = setmetatable({}, AreaChart)

        config = config or {}

        self.Data = config.Data or {}
        self.Series = config.Series or {}
        self.Width = config.Width or 300
        self.Height = config.Height or 200
        self.ShowGrid = config.ShowGrid ~= false
        self.ShowLabels = config.ShowLabels ~= false
        self.ShowPoints = config.ShowPoints or false
        self.Animated = config.Animated ~= false
        self.Stacked = config.Stacked or false
        self.FillOpacity = config.FillOpacity or 0.3

        -- Colors
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
        self.GridColor = config.GridColor or Color3.fromRGB(63, 63, 70)
        self.LabelColor = config.LabelColor or Color3.fromRGB(161, 161, 170)
        self.LineColor = config.LineColor or Color3.fromRGB(99, 102, 241)
        self.FillColor = config.FillColor or Color3.fromRGB(99, 102, 241)

        -- State
        self._connections = {}

        return self
    end

    --// Create chart
    function AreaChart:Create(parent)
        local chart = Instance.new("Frame")
        chart.Name = "AreaChart"
        chart.Size = UDim2.new(0, self.Width, 0, self.Height)
        chart.BackgroundColor3 = self.BackgroundColor
        chart.BorderSizePixel = 0

        if parent then
            chart.Parent = parent
        end

        self.Instance = chart

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = chart

        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, 20)
        padding.PaddingBottom = UDim.new(0, 30)
        padding.PaddingLeft = UDim.new(0, 40)
        padding.PaddingRight = UDim.new(0, 20)
        padding.Parent = chart

        local chartArea = Instance.new("Frame")
        chartArea.Name = "ChartArea"
        chartArea.Size = UDim2.new(1, 0, 1, 0)
        chartArea.BackgroundTransparency = 1
        chartArea.ClipsDescendants = true
        chartArea.Parent = chart
        self._chartArea = chartArea

        -- Fill area (background gradient)
        local fillArea = Instance.new("Frame")
        fillArea.Name = "FillArea"
        fillArea.Size = UDim2.new(1, 0, 1, 0)
        fillArea.Position = UDim2.new(0, 0, 1, 0)
        fillArea.AnchorPoint = Vector2.new(0, 1)
        fillArea.BackgroundColor3 = self.FillColor
        fillArea.BackgroundTransparency = 1 - self.FillOpacity
        fillArea.BorderSizePixel = 0
        fillArea.Parent = chartArea
        self._fillArea = fillArea

        local gradient = Instance.new("UIGradient")
        gradient.Rotation = 90
        gradient.Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 0),
            NumberSequenceKeypoint.new(1, 0.8),
        })
        gradient.Parent = fillArea

        self:Update()

        return self
    end

    --// Update chart
    function AreaChart:Update(newData)
        if newData then
            self.Data = newData.Data or self.Data
            self.Series = newData.Series or self.Series
        end

        local data = self.Data
        if #data == 0 then return self end

        -- Find min/max values
        local minY, maxY = math.huge, -math.huge
        for _, point in ipairs(data) do
            local value = type(point) == "table" and point.Value or point
            minY = math.min(minY, value)
            maxY = math.max(maxY, value)
        end

        local padding = (maxY - minY) * 0.1
        if padding == 0 then padding = 1 end
        minY = minY - padding
        maxY = maxY + padding

        -- Calculate fill height based on average value
        local avgValue = 0
        for _, point in ipairs(data) do
            local value = type(point) == "table" and point.Value or point
            avgValue = avgValue + value
        end
        avgValue = avgValue / #data

        local fillHeight = ((avgValue - minY) / (maxY - minY))

        if self.Animated then
            self._fillArea.Size = UDim2.new(1, 0, 0, 0)
            TweenService:Create(self._fillArea, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                Size = UDim2.new(1, 0, fillHeight, 0),
            }):Play()
        else
            self._fillArea.Size = UDim2.new(1, 0, fillHeight, 0)
        end

        return self
    end

    --// Set data
    function AreaChart:SetData(data)
        self.Data = data
        self:Update()
        return self
    end

    --// Destroy
    function AreaChart:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return AreaChart


end


-- ============================================================================
-- Module: NexusUI/Visualizers/RadarChart
-- ============================================================================
NexusUI_Modules["NexusUI/Visualizers/RadarChart"] = function()
    local script = CreateMockScript("NexusUI/Visualizers/RadarChart")
    
    --[[
        NexusUI Radar Chart Component
        Spider/radar chart for multi-dimensional data
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// RadarChart Module
    local RadarChart = {}
    RadarChart.__index = RadarChart
    RadarChart.ClassName = "RadarChart"

    --// Constructor
    function RadarChart.new(config)
        local self = setmetatable({}, RadarChart)

        config = config or {}

        self.Data = config.Data or {} -- [{Label, Value}]
        self.Size = config.Size or 200
        self.ShowLabels = config.ShowLabels ~= false
        self.ShowGrid = config.ShowGrid ~= false
        self.Animated = config.Animated ~= false
        self.GridLevels = config.GridLevels or 5
        self.MaxValue = config.MaxValue or 100

        -- Colors
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
        self.GridColor = config.GridColor or Color3.fromRGB(63, 63, 70)
        self.LabelColor = config.LabelColor or Color3.fromRGB(161, 161, 170)
        self.FillColor = config.FillColor or Color3.fromRGB(99, 102, 241)
        self.LineColor = config.LineColor or Color3.fromRGB(99, 102, 241)
        self.FillOpacity = config.FillOpacity or 0.3

        -- State
        self._connections = {}

        return self
    end

    --// Create chart
    function RadarChart:Create(parent)
        local chart = Instance.new("Frame")
        chart.Name = "RadarChart"
        chart.Size = UDim2.new(0, self.Size, 0, self.Size)
        chart.BackgroundColor3 = self.BackgroundColor
        chart.BorderSizePixel = 0

        if parent then
            chart.Parent = parent
        end

        self.Instance = chart

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = chart

        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, 30)
        padding.PaddingBottom = UDim.new(0, 30)
        padding.PaddingLeft = UDim.new(0, 30)
        padding.PaddingRight = UDim.new(0, 30)
        padding.Parent = chart

        local chartArea = Instance.new("Frame")
        chartArea.Name = "ChartArea"
        chartArea.Size = UDim2.new(1, 0, 1, 0)
        chartArea.BackgroundTransparency = 1
        chartArea.Parent = chart
        self._chartArea = chartArea

        self:Update()

        return self
    end

    --// Draw grid
    function RadarChart:_drawGrid()
        local data = self.Data
        if #data < 3 then return end

        local center = Vector2.new(
            self._chartArea.AbsoluteSize.X / 2,
            self._chartArea.AbsoluteSize.Y / 2
        )
        local radius = math.min(center.X, center.Y)
        local numAxes = #data

        -- Draw axis lines
        for i = 1, numAxes do
            local angle = ((i - 1) / numAxes) * math.pi * 2 - math.pi / 2
            local endX = center.X + math.cos(angle) * radius
            local endY = center.Y + math.sin(angle) * radius

            local axisLine = Instance.new("Frame")
            axisLine.Name = "Axis_" .. i
            axisLine.BackgroundColor3 = self.GridColor
            axisLine.BackgroundTransparency = 0.5
            axisLine.BorderSizePixel = 0

            local distance = math.sqrt((endX - center.X)^2 + (endY - center.Y)^2)
            local lineAngle = math.atan2(endY - center.Y, endX - center.X)

            axisLine.Size = UDim2.new(0, distance, 0, 1)
            axisLine.Position = UDim2.new(0, center.X, 0, center.Y)
            axisLine.AnchorPoint = Vector2.new(0, 0.5)
            axisLine.Rotation = math.deg(lineAngle)
            axisLine.Parent = self._chartArea

            -- Label
            if self.ShowLabels then
                local label = Instance.new("TextLabel")
                label.Size = UDim2.new(0, 60, 0, 16)
                label.Position = UDim2.new(0, endX, 0, endY)
                label.AnchorPoint = Vector2.new(0.5, 0.5)
                label.BackgroundTransparency = 1
                label.Font = Enum.Font.Gotham
                label.Text = data[i].Label or tostring(i)
                label.TextColor3 = self.LabelColor
                label.TextSize = 10
                label.Parent = self._chartArea
            end
        end
    end

    --// Update chart
    function RadarChart:Update(newData)
        if newData then
            self.Data = newData
        end

        -- Clear existing
        for _, child in ipairs(self._chartArea:GetChildren()) do
            child:Destroy()
        end

        if self.ShowGrid then
            self:_drawGrid()
        end

        -- Draw data polygon would go here
        -- Simplified for this implementation

        return self
    end

    --// Set data
    function RadarChart:SetData(data)
        self.Data = data
        self:Update()
        return self
    end

    --// Destroy
    function RadarChart:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return RadarChart


end


-- ============================================================================
-- Module: NexusUI/Visualizers/DonutChart
-- ============================================================================
NexusUI_Modules["NexusUI/Visualizers/DonutChart"] = function()
    local script = CreateMockScript("NexusUI/Visualizers/DonutChart")
    
    --[[
        NexusUI Donut Chart Component
        Pie chart with center cutout
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// DonutChart Module
    local DonutChart = {}
    DonutChart.__index = DonutChart
    DonutChart.ClassName = "DonutChart"

    --// Constructor
    function DonutChart.new(config)
        local self = setmetatable({}, DonutChart)

        config = config or {}

        self.Data = config.Data or {}
        self.Size = config.Size or 150
        self.InnerRadius = config.InnerRadius or 0.6 -- Percentage
        self.ShowLegend = config.ShowLegend ~= false
        self.ShowCenter = config.ShowCenter ~= false
        self.CenterText = config.CenterText or ""
        self.CenterValue = config.CenterValue or ""
        self.Animated = config.Animated ~= false

        -- Colors
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
        self.LabelColor = config.LabelColor or Color3.fromRGB(250, 250, 250)
        self.DefaultColors = config.Colors or {
            Color3.fromRGB(99, 102, 241),
            Color3.fromRGB(236, 72, 153),
            Color3.fromRGB(34, 197, 94),
            Color3.fromRGB(245, 158, 11),
            Color3.fromRGB(239, 68, 68),
        }

        -- State
        self._connections = {}

        return self
    end

    --// Create chart
    function DonutChart:Create(parent)
        local chart = Instance.new("Frame")
        chart.Name = "DonutChart"
        chart.Size = UDim2.new(0, self.Size + (self.ShowLegend and 120 or 0) + 30, 0, self.Size + 30)
        chart.BackgroundColor3 = self.BackgroundColor
        chart.BorderSizePixel = 0

        if parent then
            chart.Parent = parent
        end

        self.Instance = chart

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = chart

        -- Donut container
        local donutContainer = Instance.new("Frame")
        donutContainer.Name = "DonutContainer"
        donutContainer.Size = UDim2.new(0, self.Size, 0, self.Size)
        donutContainer.Position = UDim2.new(0, 15, 0, 15)
        donutContainer.BackgroundTransparency = 1
        donutContainer.Parent = chart
        self._donutContainer = donutContainer

        -- Ring segments container
        local ringContainer = Instance.new("Frame")
        ringContainer.Name = "Ring"
        ringContainer.Size = UDim2.new(1, 0, 1, 0)
        ringContainer.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
        ringContainer.BorderSizePixel = 0
        ringContainer.Parent = donutContainer
        self._ringContainer = ringContainer

        local ringCorner = Instance.new("UICorner")
        ringCorner.CornerRadius = UDim.new(1, 0)
        ringCorner.Parent = ringContainer

        -- Center circle
        local center = Instance.new("Frame")
        center.Name = "Center"
        center.Size = UDim2.new(self.InnerRadius, 0, self.InnerRadius, 0)
        center.Position = UDim2.new(0.5, 0, 0.5, 0)
        center.AnchorPoint = Vector2.new(0.5, 0.5)
        center.BackgroundColor3 = self.BackgroundColor
        center.BorderSizePixel = 0
        center.ZIndex = 2
        center.Parent = donutContainer
        self._center = center

        local centerCorner = Instance.new("UICorner")
        centerCorner.CornerRadius = UDim.new(1, 0)
        centerCorner.Parent = center

        -- Center text
        if self.ShowCenter then
            local centerLabel = Instance.new("TextLabel")
            centerLabel.Size = UDim2.new(0.8, 0, 0, 16)
            centerLabel.Position = UDim2.new(0.5, 0, 0.4, 0)
            centerLabel.AnchorPoint = Vector2.new(0.5, 0.5)
            centerLabel.BackgroundTransparency = 1
            centerLabel.Font = Enum.Font.Gotham
            centerLabel.Text = self.CenterText
            centerLabel.TextColor3 = Color3.fromRGB(161, 161, 170)
            centerLabel.TextSize = 11
            centerLabel.TextScaled = false
            centerLabel.Parent = center
            self._centerLabel = centerLabel

            local centerValue = Instance.new("TextLabel")
            centerValue.Size = UDim2.new(0.8, 0, 0, 20)
            centerValue.Position = UDim2.new(0.5, 0, 0.6, 0)
            centerValue.AnchorPoint = Vector2.new(0.5, 0.5)
            centerValue.BackgroundTransparency = 1
            centerValue.Font = Enum.Font.GothamBold
            centerValue.Text = self.CenterValue
            centerValue.TextColor3 = self.LabelColor
            centerValue.TextSize = 18
            centerValue.TextScaled = false
            centerValue.Parent = center
            self._centerValue = centerValue
        end

        -- Legend
        if self.ShowLegend then
            local legend = Instance.new("Frame")
            legend.Name = "Legend"
            legend.Size = UDim2.new(0, 110, 0, self.Size)
            legend.Position = UDim2.new(0, self.Size + 20, 0, 15)
            legend.BackgroundTransparency = 1
            legend.Parent = chart
            self._legend = legend

            local legendLayout = Instance.new("UIListLayout")
            legendLayout.Padding = UDim.new(0, 8)
            legendLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            legendLayout.Parent = legend
        end

        self:Update()

        return self
    end

    --// Update chart
    function DonutChart:Update(newData)
        if newData then
            self.Data = newData.Data or self.Data
            self.CenterText = newData.CenterText or self.CenterText
            self.CenterValue = newData.CenterValue or self.CenterValue
        end

        -- Update center text
        if self._centerLabel then
            self._centerLabel.Text = self.CenterText
        end
        if self._centerValue then
            self._centerValue.Text = self.CenterValue
        end

        -- Clear existing legend items
        if self._legend then
            for _, child in ipairs(self._legend:GetChildren()) do
                if child:IsA("Frame") then
                    child:Destroy()
                end
            end
        end

        -- Create legend items
        local total = 0
        for _, item in ipairs(self.Data) do
            total = total + (type(item) == "table" and item.Value or item)
        end

        if self._legend then
            for i, item in ipairs(self.Data) do
                local value = type(item) == "table" and item.Value or item
                local label = type(item) == "table" and item.Label or tostring(i)
                local color = type(item) == "table" and item.Color or self.DefaultColors[((i - 1) % #self.DefaultColors) + 1]
                local percentage = total > 0 and math.floor((value / total) * 100) or 0

                local legendItem = Instance.new("Frame")
                legendItem.Size = UDim2.new(1, 0, 0, 22)
                legendItem.BackgroundTransparency = 1
                legendItem.Parent = self._legend

                local colorDot = Instance.new("Frame")
                colorDot.Size = UDim2.new(0, 10, 0, 10)
                colorDot.Position = UDim2.new(0, 0, 0.5, 0)
                colorDot.AnchorPoint = Vector2.new(0, 0.5)
                colorDot.BackgroundColor3 = color
                colorDot.BorderSizePixel = 0
                colorDot.Parent = legendItem

                local dotCorner = Instance.new("UICorner")
                dotCorner.CornerRadius = UDim.new(1, 0)
                dotCorner.Parent = colorDot

                local itemLabel = Instance.new("TextLabel")
                itemLabel.Size = UDim2.new(1, -16, 1, 0)
                itemLabel.Position = UDim2.new(0, 16, 0, 0)
                itemLabel.BackgroundTransparency = 1
                itemLabel.Font = Enum.Font.Gotham
                itemLabel.Text = label .. " " .. percentage .. "%"
                itemLabel.TextColor3 = self.LabelColor
                itemLabel.TextSize = 11
                itemLabel.TextXAlignment = Enum.TextXAlignment.Left
                itemLabel.TextTruncate = Enum.TextTruncate.AtEnd
                itemLabel.Parent = legendItem
            end
        end

        return self
    end

    --// Set center text
    function DonutChart:SetCenterText(text, value)
        self.CenterText = text or self.CenterText
        self.CenterValue = value or self.CenterValue

        if self._centerLabel then
            self._centerLabel.Text = self.CenterText
        end
        if self._centerValue then
            self._centerValue.Text = self.CenterValue
        end

        return self
    end

    --// Set data
    function DonutChart:SetData(data)
        self.Data = data
        self:Update()
        return self
    end

    --// Destroy
    function DonutChart:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return DonutChart


end


-- ============================================================================
-- Module: NexusUI/Visualizers/Sparkline
-- ============================================================================
NexusUI_Modules["NexusUI/Visualizers/Sparkline"] = function()
    local script = CreateMockScript("NexusUI/Visualizers/Sparkline")
    
    --[[
        NexusUI Sparkline Component
        Compact inline chart for trends
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Sparkline Module
    local Sparkline = {}
    Sparkline.__index = Sparkline
    Sparkline.ClassName = "Sparkline"

    --// Constructor
    function Sparkline.new(config)
        local self = setmetatable({}, Sparkline)

        config = config or {}

        self.Data = config.Data or {}
        self.Width = config.Width or 100
        self.Height = config.Height or 30
        self.LineWidth = config.LineWidth or 1.5
        self.ShowArea = config.ShowArea or false
        self.ShowMinMax = config.ShowMinMax or false
        self.ShowLastPoint = config.ShowLastPoint ~= false
        self.Animated = config.Animated ~= false

        -- Colors
        self.LineColor = config.LineColor or Color3.fromRGB(99, 102, 241)
        self.AreaColor = config.AreaColor or Color3.fromRGB(99, 102, 241)
        self.AreaOpacity = config.AreaOpacity or 0.2
        self.PositiveColor = config.PositiveColor or Color3.fromRGB(34, 197, 94)
        self.NegativeColor = config.NegativeColor or Color3.fromRGB(239, 68, 68)

        -- State
        self._connections = {}
        self._lines = {}

        return self
    end

    --// Create sparkline
    function Sparkline:Create(parent)
        local sparkline = Instance.new("Frame")
        sparkline.Name = "Sparkline"
        sparkline.Size = UDim2.new(0, self.Width, 0, self.Height)
        sparkline.BackgroundTransparency = 1
        sparkline.ClipsDescendants = true

        if parent then
            sparkline.Parent = parent
        end

        self.Instance = sparkline

        -- Area fill
        if self.ShowArea then
            local area = Instance.new("Frame")
            area.Name = "Area"
            area.Size = UDim2.new(1, 0, 1, 0)
            area.Position = UDim2.new(0, 0, 1, 0)
            area.AnchorPoint = Vector2.new(0, 1)
            area.BackgroundColor3 = self.AreaColor
            area.BackgroundTransparency = 1 - self.AreaOpacity
            area.BorderSizePixel = 0
            area.Parent = sparkline
            self._area = area

            local gradient = Instance.new("UIGradient")
            gradient.Rotation = 90
            gradient.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 0),
                NumberSequenceKeypoint.new(1, 0.9),
            })
            gradient.Parent = area
        end

        -- Lines container
        local linesContainer = Instance.new("Frame")
        linesContainer.Name = "Lines"
        linesContainer.Size = UDim2.new(1, 0, 1, 0)
        linesContainer.BackgroundTransparency = 1
        linesContainer.Parent = sparkline
        self._linesContainer = linesContainer

        -- Last point indicator
        if self.ShowLastPoint then
            local lastPoint = Instance.new("Frame")
            lastPoint.Name = "LastPoint"
            lastPoint.Size = UDim2.new(0, 6, 0, 6)
            lastPoint.BackgroundColor3 = self.LineColor
            lastPoint.BorderSizePixel = 0
            lastPoint.Visible = false
            lastPoint.Parent = sparkline
            self._lastPoint = lastPoint

            local pointCorner = Instance.new("UICorner")
            pointCorner.CornerRadius = UDim.new(1, 0)
            pointCorner.Parent = lastPoint
        end

        self:Update()

        return self
    end

    --// Create line segment
    function Sparkline:_createLine(startPos, endPos, color)
        local distance = (endPos - startPos).Magnitude
        local angle = math.atan2(endPos.Y - startPos.Y, endPos.X - startPos.X)

        local line = Instance.new("Frame")
        line.BackgroundColor3 = color or self.LineColor
        line.BorderSizePixel = 0
        line.Size = UDim2.new(0, distance, 0, self.LineWidth)
        line.Position = UDim2.new(0, startPos.X, 0, startPos.Y)
        line.AnchorPoint = Vector2.new(0, 0.5)
        line.Rotation = math.deg(angle)
        line.Parent = self._linesContainer

        return line
    end

    --// Update sparkline
    function Sparkline:Update(newData)
        if newData then
            self.Data = newData
        end

        -- Clear existing lines
        for _, line in ipairs(self._lines) do
            line:Destroy()
        end
        self._lines = {}

        local data = self.Data
        if #data < 2 then return self end

        -- Find min/max
        local minVal, maxVal = math.huge, -math.huge
        for _, val in ipairs(data) do
            minVal = math.min(minVal, val)
            maxVal = math.max(maxVal, val)
        end

        local range = maxVal - minVal
        if range == 0 then range = 1 end

        local width = self.Width
        local height = self.Height

        -- Calculate points
        local points = {}
        for i, val in ipairs(data) do
            local x = ((i - 1) / (#data - 1)) * width
            local y = height - ((val - minVal) / range) * height
            table.insert(points, Vector2.new(x, y))
        end

        -- Determine trend color
        local trendColor = self.LineColor
        if #data >= 2 then
            if data[#data] > data[1] then
                trendColor = self.PositiveColor
            elseif data[#data] < data[1] then
                trendColor = self.NegativeColor
            end
        end

        -- Draw lines
        for i = 1, #points - 1 do
            local line = self:_createLine(points[i], points[i + 1], trendColor)
            table.insert(self._lines, line)
        end

        -- Update area
        if self._area then
            local avgHeight = 0
            for _, val in ipairs(data) do
                avgHeight = avgHeight + ((val - minVal) / range)
            end
            avgHeight = avgHeight / #data

            self._area.BackgroundColor3 = trendColor
            self._area.Size = UDim2.new(1, 0, avgHeight, 0)
        end

        -- Update last point
        if self._lastPoint and #points > 0 then
            local lastPos = points[#points]
            self._lastPoint.Position = UDim2.new(0, lastPos.X - 3, 0, lastPos.Y - 3)
            self._lastPoint.BackgroundColor3 = trendColor
            self._lastPoint.Visible = true
        end

        return self
    end

    --// Add data point
    function Sparkline:AddPoint(value, maxPoints)
        table.insert(self.Data, value)

        if maxPoints and #self.Data > maxPoints then
            table.remove(self.Data, 1)
        end

        self:Update()
        return self
    end

    --// Set data
    function Sparkline:SetData(data)
        self.Data = data
        self:Update()
        return self
    end

    --// Destroy
    function Sparkline:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return Sparkline


end


-- ============================================================================
-- Module: NexusUI/Visualizers/Gauge
-- ============================================================================
NexusUI_Modules["NexusUI/Visualizers/Gauge"] = function()
    local script = CreateMockScript("NexusUI/Visualizers/Gauge")
    
    --[[
        NexusUI Gauge Component
        Circular gauge/meter for displaying values
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Gauge Module
    local Gauge = {}
    Gauge.__index = Gauge
    Gauge.ClassName = "Gauge"

    --// Constructor
    function Gauge.new(config)
        local self = setmetatable({}, Gauge)

        config = config or {}

        self.Value = config.Value or 0
        self.MinValue = config.MinValue or 0
        self.MaxValue = config.MaxValue or 100
        self.Size = config.Size or 120
        self.Thickness = config.Thickness or 10
        self.StartAngle = config.StartAngle or 135
        self.EndAngle = config.EndAngle or 405
        self.ShowValue = config.ShowValue ~= false
        self.ShowLabel = config.ShowLabel or false
        self.Label = config.Label or ""
        self.Unit = config.Unit or ""
        self.Animated = config.Animated ~= false
        self.Segments = config.Segments or 0 -- 0 = continuous

        -- Colors
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
        self.TrackColor = config.TrackColor or Color3.fromRGB(63, 63, 70)
        self.FillColor = config.FillColor or Color3.fromRGB(99, 102, 241)
        self.LabelColor = config.LabelColor or Color3.fromRGB(161, 161, 170)
        self.ValueColor = config.ValueColor or Color3.fromRGB(250, 250, 250)

        -- Color thresholds
        self.Thresholds = config.Thresholds or nil -- [{Value, Color}]

        -- State
        self._connections = {}

        return self
    end

    --// Get color for current value
    function Gauge:_getColorForValue(value)
        if not self.Thresholds then
            return self.FillColor
        end

        local color = self.FillColor
        for _, threshold in ipairs(self.Thresholds) do
            if value >= threshold.Value then
                color = threshold.Color
            end
        end

        return color
    end

    --// Create gauge
    function Gauge:Create(parent)
        local gauge = Instance.new("Frame")
        gauge.Name = "Gauge"
        gauge.Size = UDim2.new(0, self.Size, 0, self.Size)
        gauge.BackgroundColor3 = self.BackgroundColor
        gauge.BorderSizePixel = 0

        if parent then
            gauge.Parent = parent
        end

        self.Instance = gauge

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = gauge

        -- Track ring (background)
        local track = Instance.new("Frame")
        track.Name = "Track"
        track.Size = UDim2.new(1, -20, 1, -20)
        track.Position = UDim2.new(0.5, 0, 0.5, 0)
        track.AnchorPoint = Vector2.new(0.5, 0.5)
        track.BackgroundColor3 = self.TrackColor
        track.BorderSizePixel = 0
        track.Parent = gauge
        self._track = track

        local trackCorner = Instance.new("UICorner")
        trackCorner.CornerRadius = UDim.new(1, 0)
        trackCorner.Parent = track

        -- Inner circle (cutout)
        local inner = Instance.new("Frame")
        inner.Name = "Inner"
        inner.Size = UDim2.new(1, -self.Thickness * 2, 1, -self.Thickness * 2)
        inner.Position = UDim2.new(0.5, 0, 0.5, 0)
        inner.AnchorPoint = Vector2.new(0.5, 0.5)
        inner.BackgroundColor3 = self.BackgroundColor
        inner.BorderSizePixel = 0
        inner.ZIndex = 3
        inner.Parent = gauge
        self._inner = inner

        local innerCorner = Instance.new("UICorner")
        innerCorner.CornerRadius = UDim.new(1, 0)
        innerCorner.Parent = inner

        -- Fill ring (would need proper arc implementation)
        local fill = Instance.new("Frame")
        fill.Name = "Fill"
        fill.Size = UDim2.new(1, -20, 1, -20)
        fill.Position = UDim2.new(0.5, 0, 0.5, 0)
        fill.AnchorPoint = Vector2.new(0.5, 0.5)
        fill.BackgroundColor3 = self.FillColor
        fill.BorderSizePixel = 0
        fill.ZIndex = 2
        fill.Parent = gauge
        self._fill = fill

        local fillCorner = Instance.new("UICorner")
        fillCorner.CornerRadius = UDim.new(1, 0)
        fillCorner.Parent = fill

        -- Use UIGradient to simulate arc (simplified)
        local gradient = Instance.new("UIGradient")
        gradient.Rotation = 0
        gradient.Parent = fill
        self._gradient = gradient

        -- Value display
        if self.ShowValue then
            local valueLabel = Instance.new("TextLabel")
            valueLabel.Size = UDim2.new(0.7, 0, 0, 28)
            valueLabel.Position = UDim2.new(0.5, 0, 0.5, self.ShowLabel and -8 or 0)
            valueLabel.AnchorPoint = Vector2.new(0.5, 0.5)
            valueLabel.BackgroundTransparency = 1
            valueLabel.Font = Enum.Font.GothamBold
            valueLabel.Text = tostring(math.floor(self.Value))
            valueLabel.TextColor3 = self.ValueColor
            valueLabel.TextSize = 24
            valueLabel.ZIndex = 4
            valueLabel.Parent = gauge
            self._valueLabel = valueLabel

            if self.Unit ~= "" then
                local unitLabel = Instance.new("TextLabel")
                unitLabel.Size = UDim2.new(0.5, 0, 0, 14)
                unitLabel.Position = UDim2.new(0.5, 0, 0.5, 14)
                unitLabel.AnchorPoint = Vector2.new(0.5, 0.5)
                unitLabel.BackgroundTransparency = 1
                unitLabel.Font = Enum.Font.Gotham
                unitLabel.Text = self.Unit
                unitLabel.TextColor3 = self.LabelColor
                unitLabel.TextSize = 11
                unitLabel.ZIndex = 4
                unitLabel.Parent = gauge
                self._unitLabel = unitLabel
            end
        end

        -- Label
        if self.ShowLabel and self.Label ~= "" then
            local labelText = Instance.new("TextLabel")
            labelText.Size = UDim2.new(0.8, 0, 0, 14)
            labelText.Position = UDim2.new(0.5, 0, 0.5, 16)
            labelText.AnchorPoint = Vector2.new(0.5, 0.5)
            labelText.BackgroundTransparency = 1
            labelText.Font = Enum.Font.Gotham
            labelText.Text = self.Label
            labelText.TextColor3 = self.LabelColor
            labelText.TextSize = 10
            labelText.ZIndex = 4
            labelText.Parent = gauge
            self._labelText = labelText
        end

        self:Update()

        return self
    end

    --// Update gauge
    function Gauge:Update(newValue)
        if newValue ~= nil then
            self.Value = newValue
        end

        -- Calculate percentage
        local range = self.MaxValue - self.MinValue
        local percentage = (self.Value - self.MinValue) / range
        percentage = math.clamp(percentage, 0, 1)

        -- Update value text
        if self._valueLabel then
            self._valueLabel.Text = tostring(math.floor(self.Value))
        end

        -- Update fill color based on thresholds
        local color = self:_getColorForValue(self.Value)
        self._fill.BackgroundColor3 = color

        -- Update gradient to simulate arc (simplified visualization)
        local rotation = percentage * 360

        if self.Animated then
            -- Animate gradient rotation
            local currentRotation = self._gradient.Rotation
            local tween = TweenService:Create(self._gradient, TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {
                Rotation = rotation,
            })
            tween:Play()
        else
            self._gradient.Rotation = rotation
        end

        -- Update fill visibility based on percentage
        self._gradient.Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 0),
            NumberSequenceKeypoint.new(math.max(0.01, percentage), 0),
            NumberSequenceKeypoint.new(math.min(0.99, percentage + 0.01), 1),
            NumberSequenceKeypoint.new(1, 1),
        })

        return self
    end

    --// Set value
    function Gauge:SetValue(value)
        self:Update(value)
        return self
    end

    --// Set label
    function Gauge:SetLabel(label)
        self.Label = label
        if self._labelText then
            self._labelText.Text = label
        end
        return self
    end

    --// Destroy
    function Gauge:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return Gauge


end


-- ============================================================================
-- Module: NexusUI/Visualizers/Heatmap
-- ============================================================================
NexusUI_Modules["NexusUI/Visualizers/Heatmap"] = function()
    local script = CreateMockScript("NexusUI/Visualizers/Heatmap")
    
    --[[
        NexusUI Heatmap Component
        Grid-based color intensity visualization
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Heatmap Module
    local Heatmap = {}
    Heatmap.__index = Heatmap
    Heatmap.ClassName = "Heatmap"

    --// Constructor
    function Heatmap.new(config)
        local self = setmetatable({}, Heatmap)

        config = config or {}

        self.Data = config.Data or {} -- 2D array
        self.Rows = config.Rows or 7
        self.Columns = config.Columns or 12
        self.CellSize = config.CellSize or 20
        self.CellGap = config.CellGap or 2
        self.ShowLabels = config.ShowLabels or false
        self.ShowTooltip = config.ShowTooltip ~= false
        self.Animated = config.Animated ~= false
        self.RowLabels = config.RowLabels or nil
        self.ColumnLabels = config.ColumnLabels or nil

        -- Colors
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
        self.LabelColor = config.LabelColor or Color3.fromRGB(161, 161, 170)
        self.MinColor = config.MinColor or Color3.fromRGB(39, 39, 42)
        self.MaxColor = config.MaxColor or Color3.fromRGB(99, 102, 241)
        self.ColorScale = config.ColorScale or nil -- Array of colors for gradient

        -- State
        self._connections = {}
        self._cells = {}

        return self
    end

    --// Interpolate color based on value
    function Heatmap:_getColorForValue(value, min, max)
        local t = (value - min) / (max - min)
        t = math.clamp(t, 0, 1)

        if self.ColorScale and #self.ColorScale >= 2 then
            -- Multi-color scale
            local scaledT = t * (#self.ColorScale - 1)
            local index = math.floor(scaledT)
            local fraction = scaledT - index

            index = math.clamp(index, 0, #self.ColorScale - 2)

            local c1 = self.ColorScale[index + 1]
            local c2 = self.ColorScale[index + 2]

            return Color3.new(
                c1.R + (c2.R - c1.R) * fraction,
                c1.G + (c2.G - c1.G) * fraction,
                c1.B + (c2.B - c1.B) * fraction
            )
        else
            -- Two-color interpolation
            return Color3.new(
                self.MinColor.R + (self.MaxColor.R - self.MinColor.R) * t,
                self.MinColor.G + (self.MaxColor.G - self.MinColor.G) * t,
                self.MinColor.B + (self.MaxColor.B - self.MinColor.B) * t
            )
        end
    end

    --// Create heatmap
    function Heatmap:Create(parent)
        local labelOffset = self.ShowLabels and 30 or 0
        local width = self.Columns * (self.CellSize + self.CellGap) - self.CellGap + labelOffset + 20
        local height = self.Rows * (self.CellSize + self.CellGap) - self.CellGap + labelOffset + 20

        local heatmap = Instance.new("Frame")
        heatmap.Name = "Heatmap"
        heatmap.Size = UDim2.new(0, width, 0, height)
        heatmap.BackgroundColor3 = self.BackgroundColor
        heatmap.BorderSizePixel = 0

        if parent then
            heatmap.Parent = parent
        end

        self.Instance = heatmap

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = heatmap

        -- Grid container
        local grid = Instance.new("Frame")
        grid.Name = "Grid"
        grid.Size = UDim2.new(1, -20 - labelOffset, 1, -20 - labelOffset)
        grid.Position = UDim2.new(0, 10 + labelOffset, 0, 10 + labelOffset)
        grid.BackgroundTransparency = 1
        grid.Parent = heatmap
        self._grid = grid

        -- Row labels
        if self.ShowLabels and self.RowLabels then
            for i, label in ipairs(self.RowLabels) do
                local labelText = Instance.new("TextLabel")
                labelText.Size = UDim2.new(0, labelOffset - 5, 0, self.CellSize)
                labelText.Position = UDim2.new(0, 5, 0, 10 + labelOffset + (i - 1) * (self.CellSize + self.CellGap))
                labelText.BackgroundTransparency = 1
                labelText.Font = Enum.Font.Gotham
                labelText.Text = label
                labelText.TextColor3 = self.LabelColor
                labelText.TextSize = 10
                labelText.TextXAlignment = Enum.TextXAlignment.Right
                labelText.Parent = heatmap
            end
        end

        -- Column labels
        if self.ShowLabels and self.ColumnLabels then
            for i, label in ipairs(self.ColumnLabels) do
                local labelText = Instance.new("TextLabel")
                labelText.Size = UDim2.new(0, self.CellSize, 0, labelOffset - 5)
                labelText.Position = UDim2.new(0, 10 + labelOffset + (i - 1) * (self.CellSize + self.CellGap), 0, 5)
                labelText.BackgroundTransparency = 1
                labelText.Font = Enum.Font.Gotham
                labelText.Text = label
                labelText.TextColor3 = self.LabelColor
                labelText.TextSize = 10
                labelText.Rotation = -45
                labelText.Parent = heatmap
            end
        end

        self:Update()

        return self
    end

    --// Update heatmap
    function Heatmap:Update(newData)
        if newData then
            self.Data = newData
        end

        -- Clear existing cells
        for _, cell in ipairs(self._cells) do
            cell:Destroy()
        end
        self._cells = {}

        -- Find min/max values
        local minVal, maxVal = math.huge, -math.huge
        for _, row in ipairs(self.Data) do
            for _, val in ipairs(row) do
                minVal = math.min(minVal, val)
                maxVal = math.max(maxVal, val)
            end
        end

        if minVal == maxVal then
            maxVal = minVal + 1
        end

        -- Create cells
        for rowIndex, row in ipairs(self.Data) do
            for colIndex, value in ipairs(row) do
                local cell = Instance.new("Frame")
                cell.Name = string.format("Cell_%d_%d", rowIndex, colIndex)
                cell.Size = UDim2.new(0, self.CellSize, 0, self.CellSize)
                cell.Position = UDim2.new(
                    0, (colIndex - 1) * (self.CellSize + self.CellGap),
                    0, (rowIndex - 1) * (self.CellSize + self.CellGap)
                )
                cell.BackgroundColor3 = self:_getColorForValue(value, minVal, maxVal)
                cell.BorderSizePixel = 0
                cell.Parent = self._grid

                local cellCorner = Instance.new("UICorner")
                cellCorner.CornerRadius = UDim.new(0, 3)
                cellCorner.Parent = cell

                table.insert(self._cells, cell)

                -- Animation
                if self.Animated then
                    cell.BackgroundTransparency = 1
                    TweenService:Create(cell, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, (rowIndex + colIndex) * 0.02), {
                        BackgroundTransparency = 0,
                    }):Play()
                end

                -- Tooltip on hover
                if self.ShowTooltip then
                    local button = Instance.new("TextButton")
                    button.Size = UDim2.new(1, 0, 1, 0)
                    button.BackgroundTransparency = 1
                    button.Text = ""
                    button.Parent = cell

                    table.insert(self._connections, button.MouseEnter:Connect(function()
                        -- Show tooltip (simplified)
                        TweenService:Create(cell, TweenInfo.new(0.1), {
                            Size = UDim2.new(0, self.CellSize + 4, 0, self.CellSize + 4),
                            Position = UDim2.new(
                                0, (colIndex - 1) * (self.CellSize + self.CellGap) - 2,
                                0, (rowIndex - 1) * (self.CellSize + self.CellGap) - 2
                            ),
                        }):Play()
                    end))

                    table.insert(self._connections, button.MouseLeave:Connect(function()
                        TweenService:Create(cell, TweenInfo.new(0.1), {
                            Size = UDim2.new(0, self.CellSize, 0, self.CellSize),
                            Position = UDim2.new(
                                0, (colIndex - 1) * (self.CellSize + self.CellGap),
                                0, (rowIndex - 1) * (self.CellSize + self.CellGap)
                            ),
                        }):Play()
                    end))
                end
            end
        end

        return self
    end

    --// Set data
    function Heatmap:SetData(data)
        self.Data = data
        self:Update()
        return self
    end

    --// Destroy
    function Heatmap:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return Heatmap


end


-- ============================================================================
-- Module: NexusUI/Visualizers/FPSGraph
-- ============================================================================
NexusUI_Modules["NexusUI/Visualizers/FPSGraph"] = function()
    local script = CreateMockScript("NexusUI/Visualizers/FPSGraph")
    
    --[[
        NexusUI FPS Graph Component
        Real-time FPS visualization
    ]]

    --// Services
    local RunService = game:GetService("RunService")
    local TweenService = game:GetService("TweenService")

    --// FPSGraph Module
    local FPSGraph = {}
    FPSGraph.__index = FPSGraph
    FPSGraph.ClassName = "FPSGraph"

    --// Constructor
    function FPSGraph.new(config)
        local self = setmetatable({}, FPSGraph)

        config = config or {}

        self.Width = config.Width or 200
        self.Height = config.Height or 80
        self.MaxDataPoints = config.MaxDataPoints or 60
        self.UpdateRate = config.UpdateRate or 1/30 -- 30 updates per second
        self.ShowValue = config.ShowValue ~= false
        self.ShowMin = config.ShowMin or false
        self.ShowMax = config.ShowMax or false
        self.ShowAverage = config.ShowAverage or false

        -- Colors
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
        self.GridColor = config.GridColor or Color3.fromRGB(39, 39, 42)
        self.LineColor = config.LineColor or Color3.fromRGB(34, 197, 94)
        self.LowFPSColor = config.LowFPSColor or Color3.fromRGB(239, 68, 68)
        self.MediumFPSColor = config.MediumFPSColor or Color3.fromRGB(245, 158, 11)
        self.TextColor = config.TextColor or Color3.fromRGB(250, 250, 250)

        -- Thresholds
        self.LowFPSThreshold = config.LowFPSThreshold or 30
        self.MediumFPSThreshold = config.MediumFPSThreshold or 45

        -- State
        self._fpsData = {}
        self._currentFPS = 60
        self._frameCount = 0
        self._lastTime = os.clock()
        self._connections = {}
        self._running = false

        return self
    end

    --// Get color for FPS value
    function FPSGraph:_getColorForFPS(fps)
        if fps < self.LowFPSThreshold then
            return self.LowFPSColor
        elseif fps < self.MediumFPSThreshold then
            return self.MediumFPSColor
        else
            return self.LineColor
        end
    end

    --// Create graph
    function FPSGraph:Create(parent)
        local graph = Instance.new("Frame")
        graph.Name = "FPSGraph"
        graph.Size = UDim2.new(0, self.Width, 0, self.Height)
        graph.BackgroundColor3 = self.BackgroundColor
        graph.BorderSizePixel = 0

        if parent then
            graph.Parent = parent
        end

        self.Instance = graph

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = graph

        -- Header
        local header = Instance.new("Frame")
        header.Size = UDim2.new(1, 0, 0, 24)
        header.BackgroundTransparency = 1
        header.Parent = graph

        local title = Instance.new("TextLabel")
        title.Size = UDim2.new(0, 60, 1, 0)
        title.Position = UDim2.new(0, 10, 0, 0)
        title.BackgroundTransparency = 1
        title.Font = Enum.Font.GothamMedium
        title.Text = "FPS"
        title.TextColor3 = Color3.fromRGB(161, 161, 170)
        title.TextSize = 11
        title.TextXAlignment = Enum.TextXAlignment.Left
        title.Parent = header

        local fpsValue = Instance.new("TextLabel")
        fpsValue.Name = "FPSValue"
        fpsValue.Size = UDim2.new(0, 60, 1, 0)
        fpsValue.Position = UDim2.new(1, -70, 0, 0)
        fpsValue.BackgroundTransparency = 1
        fpsValue.Font = Enum.Font.GothamBold
        fpsValue.Text = "60"
        fpsValue.TextColor3 = self.LineColor
        fpsValue.TextSize = 14
        fpsValue.TextXAlignment = Enum.TextXAlignment.Right
        fpsValue.Parent = header
        self._fpsLabel = fpsValue

        -- Graph area
        local graphArea = Instance.new("Frame")
        graphArea.Name = "GraphArea"
        graphArea.Size = UDim2.new(1, -20, 1, -34)
        graphArea.Position = UDim2.new(0, 10, 0, 28)
        graphArea.BackgroundColor3 = self.GridColor
        graphArea.BackgroundTransparency = 0.5
        graphArea.BorderSizePixel = 0
        graphArea.ClipsDescendants = true
        graphArea.Parent = graph
        self._graphArea = graphArea

        local graphCorner = Instance.new("UICorner")
        graphCorner.CornerRadius = UDim.new(0, 4)
        graphCorner.Parent = graphArea

        -- Lines container
        local linesContainer = Instance.new("Frame")
        linesContainer.Name = "Lines"
        linesContainer.Size = UDim2.new(1, 0, 1, 0)
        linesContainer.BackgroundTransparency = 1
        linesContainer.Parent = graphArea
        self._linesContainer = linesContainer

        -- Grid lines
        for i = 1, 3 do
            local gridLine = Instance.new("Frame")
            gridLine.Size = UDim2.new(1, 0, 0, 1)
            gridLine.Position = UDim2.new(0, 0, i * 0.25, 0)
            gridLine.BackgroundColor3 = self.GridColor
            gridLine.BackgroundTransparency = 0.5
            gridLine.BorderSizePixel = 0
            gridLine.Parent = graphArea
        end

        -- Stats display
        if self.ShowMin or self.ShowMax or self.ShowAverage then
            local stats = Instance.new("Frame")
            stats.Size = UDim2.new(1, 0, 0, 14)
            stats.Position = UDim2.new(0, 0, 1, -14)
            stats.BackgroundTransparency = 1
            stats.Parent = graph

            local statsLayout = Instance.new("UIListLayout")
            statsLayout.FillDirection = Enum.FillDirection.Horizontal
            statsLayout.Padding = UDim.new(0, 15)
            statsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            statsLayout.Parent = stats

            if self.ShowMin then
                local minLabel = Instance.new("TextLabel")
                minLabel.Name = "Min"
                minLabel.Size = UDim2.new(0, 50, 1, 0)
                minLabel.BackgroundTransparency = 1
                minLabel.Font = Enum.Font.Gotham
                minLabel.Text = "Min: --"
                minLabel.TextColor3 = self.LowFPSColor
                minLabel.TextSize = 9
                minLabel.Parent = stats
                self._minLabel = minLabel
            end

            if self.ShowAverage then
                local avgLabel = Instance.new("TextLabel")
                avgLabel.Name = "Avg"
                avgLabel.Size = UDim2.new(0, 50, 1, 0)
                avgLabel.BackgroundTransparency = 1
                avgLabel.Font = Enum.Font.Gotham
                avgLabel.Text = "Avg: --"
                avgLabel.TextColor3 = self.MediumFPSColor
                avgLabel.TextSize = 9
                avgLabel.Parent = stats
                self._avgLabel = avgLabel
            end

            if self.ShowMax then
                local maxLabel = Instance.new("TextLabel")
                maxLabel.Name = "Max"
                maxLabel.Size = UDim2.new(0, 50, 1, 0)
                maxLabel.BackgroundTransparency = 1
                maxLabel.Font = Enum.Font.Gotham
                maxLabel.Text = "Max: --"
                maxLabel.TextColor3 = self.LineColor
                maxLabel.TextSize = 9
                maxLabel.Parent = stats
                self._maxLabel = maxLabel
            end
        end

        return self
    end

    --// Start monitoring
    function FPSGraph:Start()
        if self._running then return self end
        self._running = true

        -- FPS counter
        local fpsConnection = RunService.Heartbeat:Connect(function()
            self._frameCount = self._frameCount + 1
        end)
        table.insert(self._connections, fpsConnection)

        -- Update loop
        local lastUpdate = os.clock()
        local updateConnection = RunService.Heartbeat:Connect(function()
            local now = os.clock()
            local elapsed = now - self._lastTime

            if elapsed >= 1 then
                self._currentFPS = self._frameCount / elapsed
                self._frameCount = 0
                self._lastTime = now

                -- Store data point
                table.insert(self._fpsData, self._currentFPS)
                if #self._fpsData > self.MaxDataPoints then
                    table.remove(self._fpsData, 1)
                end
            end

            -- Update display at update rate
            if now - lastUpdate >= self.UpdateRate then
                lastUpdate = now
                self:_updateDisplay()
            end
        end)
        table.insert(self._connections, updateConnection)

        return self
    end

    --// Stop monitoring
    function FPSGraph:Stop()
        self._running = false

        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        return self
    end

    --// Update display
    function FPSGraph:_updateDisplay()
        local fps = math.floor(self._currentFPS + 0.5)
        local color = self:_getColorForFPS(fps)

        -- Update FPS label
        if self._fpsLabel then
            self._fpsLabel.Text = tostring(fps)
            self._fpsLabel.TextColor3 = color
        end

        -- Update graph
        self:_drawGraph()

        -- Update stats
        if #self._fpsData > 0 then
            local min, max, sum = math.huge, -math.huge, 0
            for _, val in ipairs(self._fpsData) do
                min = math.min(min, val)
                max = math.max(max, val)
                sum = sum + val
            end
            local avg = sum / #self._fpsData

            if self._minLabel then
                self._minLabel.Text = "Min: " .. math.floor(min)
            end
            if self._maxLabel then
                self._maxLabel.Text = "Max: " .. math.floor(max)
            end
            if self._avgLabel then
                self._avgLabel.Text = "Avg: " .. math.floor(avg)
            end
        end
    end

    --// Draw graph
    function FPSGraph:_drawGraph()
        -- Clear existing lines
        for _, child in ipairs(self._linesContainer:GetChildren()) do
            child:Destroy()
        end

        local data = self._fpsData
        if #data < 2 then return end

        local graphWidth = self._graphArea.AbsoluteSize.X
        local graphHeight = self._graphArea.AbsoluteSize.Y

        -- Normalize to 0-120 FPS range
        local maxFPS = 120

        local points = {}
        for i, fps in ipairs(data) do
            local x = ((i - 1) / (self.MaxDataPoints - 1)) * graphWidth
            local y = graphHeight - (math.min(fps, maxFPS) / maxFPS) * graphHeight
            table.insert(points, Vector2.new(x, y))
        end

        -- Draw lines
        for i = 1, #points - 1 do
            local startPos = points[i]
            local endPos = points[i + 1]

            local distance = (endPos - startPos).Magnitude
            local angle = math.atan2(endPos.Y - startPos.Y, endPos.X - startPos.X)

            local fps = data[i]
            local color = self:_getColorForFPS(fps)

            local line = Instance.new("Frame")
            line.BackgroundColor3 = color
            line.BorderSizePixel = 0
            line.Size = UDim2.new(0, distance + 1, 0, 2)
            line.Position = UDim2.new(0, startPos.X, 0, startPos.Y)
            line.AnchorPoint = Vector2.new(0, 0.5)
            line.Rotation = math.deg(angle)
            line.Parent = self._linesContainer
        end
    end

    --// Get current FPS
    function FPSGraph:GetFPS()
        return math.floor(self._currentFPS + 0.5)
    end

    --// Destroy
    function FPSGraph:Destroy()
        self:Stop()

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return FPSGraph


end


-- ============================================================================
-- Module: NexusUI/Visualizers/MemoryGraph
-- ============================================================================
NexusUI_Modules["NexusUI/Visualizers/MemoryGraph"] = function()
    local script = CreateMockScript("NexusUI/Visualizers/MemoryGraph")
    
    --[[
        NexusUI Memory Graph Component
        Real-time memory usage visualization
    ]]

    --// Services
    local RunService = game:GetService("RunService")

    --// MemoryGraph Module
    local MemoryGraph = {}
    MemoryGraph.__index = MemoryGraph
    MemoryGraph.ClassName = "MemoryGraph"

    --// Constructor
    function MemoryGraph.new(config)
        local self = setmetatable({}, MemoryGraph)

        config = config or {}

        self.Width = config.Width or 200
        self.Height = config.Height or 80
        self.MaxDataPoints = config.MaxDataPoints or 60
        self.UpdateRate = config.UpdateRate or 1 -- Update every second
        self.ShowValue = config.ShowValue ~= false

        -- Colors
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
        self.GridColor = config.GridColor or Color3.fromRGB(39, 39, 42)
        self.LineColor = config.LineColor or Color3.fromRGB(139, 92, 246)
        self.HighMemColor = config.HighMemColor or Color3.fromRGB(239, 68, 68)
        self.TextColor = config.TextColor or Color3.fromRGB(250, 250, 250)

        -- Thresholds (in MB)
        self.HighMemThreshold = config.HighMemThreshold or 500

        -- State
        self._memoryData = {}
        self._currentMemory = 0
        self._connections = {}
        self._running = false

        return self
    end

    --// Create graph
    function MemoryGraph:Create(parent)
        local graph = Instance.new("Frame")
        graph.Name = "MemoryGraph"
        graph.Size = UDim2.new(0, self.Width, 0, self.Height)
        graph.BackgroundColor3 = self.BackgroundColor
        graph.BorderSizePixel = 0

        if parent then
            graph.Parent = parent
        end

        self.Instance = graph

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = graph

        -- Header
        local header = Instance.new("Frame")
        header.Size = UDim2.new(1, 0, 0, 24)
        header.BackgroundTransparency = 1
        header.Parent = graph

        local title = Instance.new("TextLabel")
        title.Size = UDim2.new(0, 80, 1, 0)
        title.Position = UDim2.new(0, 10, 0, 0)
        title.BackgroundTransparency = 1
        title.Font = Enum.Font.GothamMedium
        title.Text = "Memory"
        title.TextColor3 = Color3.fromRGB(161, 161, 170)
        title.TextSize = 11
        title.TextXAlignment = Enum.TextXAlignment.Left
        title.Parent = header

        local memValue = Instance.new("TextLabel")
        memValue.Name = "MemValue"
        memValue.Size = UDim2.new(0, 80, 1, 0)
        memValue.Position = UDim2.new(1, -90, 0, 0)
        memValue.BackgroundTransparency = 1
        memValue.Font = Enum.Font.GothamBold
        memValue.Text = "0 MB"
        memValue.TextColor3 = self.LineColor
        memValue.TextSize = 14
        memValue.TextXAlignment = Enum.TextXAlignment.Right
        memValue.Parent = header
        self._memLabel = memValue

        -- Graph area
        local graphArea = Instance.new("Frame")
        graphArea.Name = "GraphArea"
        graphArea.Size = UDim2.new(1, -20, 1, -34)
        graphArea.Position = UDim2.new(0, 10, 0, 28)
        graphArea.BackgroundColor3 = self.GridColor
        graphArea.BackgroundTransparency = 0.5
        graphArea.BorderSizePixel = 0
        graphArea.ClipsDescendants = true
        graphArea.Parent = graph
        self._graphArea = graphArea

        local graphCorner = Instance.new("UICorner")
        graphCorner.CornerRadius = UDim.new(0, 4)
        graphCorner.Parent = graphArea

        -- Fill area
        local fillArea = Instance.new("Frame")
        fillArea.Name = "Fill"
        fillArea.Size = UDim2.new(1, 0, 0, 0)
        fillArea.Position = UDim2.new(0, 0, 1, 0)
        fillArea.AnchorPoint = Vector2.new(0, 1)
        fillArea.BackgroundColor3 = self.LineColor
        fillArea.BackgroundTransparency = 0.7
        fillArea.BorderSizePixel = 0
        fillArea.Parent = graphArea
        self._fillArea = fillArea

        local gradient = Instance.new("UIGradient")
        gradient.Rotation = 90
        gradient.Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 0),
            NumberSequenceKeypoint.new(1, 0.8),
        })
        gradient.Parent = fillArea

        -- Lines container
        local linesContainer = Instance.new("Frame")
        linesContainer.Name = "Lines"
        linesContainer.Size = UDim2.new(1, 0, 1, 0)
        linesContainer.BackgroundTransparency = 1
        linesContainer.Parent = graphArea
        self._linesContainer = linesContainer

        return self
    end

    --// Start monitoring
    function MemoryGraph:Start()
        if self._running then return self end
        self._running = true

        local lastUpdate = os.clock()

        local connection = RunService.Heartbeat:Connect(function()
            local now = os.clock()

            if now - lastUpdate >= self.UpdateRate then
                lastUpdate = now

                -- Get memory usage
                self._currentMemory = collectgarbage("count") / 1024 -- KB to MB

                -- Store data point
                table.insert(self._memoryData, self._currentMemory)
                if #self._memoryData > self.MaxDataPoints then
                    table.remove(self._memoryData, 1)
                end

                self:_updateDisplay()
            end
        end)

        table.insert(self._connections, connection)

        return self
    end

    --// Stop monitoring
    function MemoryGraph:Stop()
        self._running = false

        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        return self
    end

    --// Update display
    function MemoryGraph:_updateDisplay()
        local mem = self._currentMemory
        local color = mem > self.HighMemThreshold and self.HighMemColor or self.LineColor

        -- Update label
        if self._memLabel then
            self._memLabel.Text = string.format("%.1f MB", mem)
            self._memLabel.TextColor3 = color
        end

        -- Update fill area
        if self._fillArea then
            local maxMem = 1000 -- Assume 1GB max for display
            local fillHeight = math.min(mem / maxMem, 1)
            self._fillArea.Size = UDim2.new(1, 0, fillHeight, 0)
            self._fillArea.BackgroundColor3 = color
        end

        -- Draw graph
        self:_drawGraph()
    end

    --// Draw graph
    function MemoryGraph:_drawGraph()
        for _, child in ipairs(self._linesContainer:GetChildren()) do
            child:Destroy()
        end

        local data = self._memoryData
        if #data < 2 then return end

        local graphWidth = self._graphArea.AbsoluteSize.X
        local graphHeight = self._graphArea.AbsoluteSize.Y

        local maxMem = 0
        for _, mem in ipairs(data) do
            maxMem = math.max(maxMem, mem)
        end
        maxMem = math.max(maxMem, 100) -- At least 100MB scale

        local points = {}
        for i, mem in ipairs(data) do
            local x = ((i - 1) / (self.MaxDataPoints - 1)) * graphWidth
            local y = graphHeight - (mem / maxMem) * graphHeight
            table.insert(points, Vector2.new(x, y))
        end

        for i = 1, #points - 1 do
            local startPos = points[i]
            local endPos = points[i + 1]

            local distance = (endPos - startPos).Magnitude
            local angle = math.atan2(endPos.Y - startPos.Y, endPos.X - startPos.X)

            local line = Instance.new("Frame")
            line.BackgroundColor3 = self.LineColor
            line.BorderSizePixel = 0
            line.Size = UDim2.new(0, distance + 1, 0, 2)
            line.Position = UDim2.new(0, startPos.X, 0, startPos.Y)
            line.AnchorPoint = Vector2.new(0, 0.5)
            line.Rotation = math.deg(angle)
            line.Parent = self._linesContainer
        end
    end

    --// Get current memory
    function MemoryGraph:GetMemory()
        return self._currentMemory
    end

    --// Destroy
    function MemoryGraph:Destroy()
        self:Stop()

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return MemoryGraph


end


-- ============================================================================
-- Module: NexusUI/Visualizers/NetworkGraph
-- ============================================================================
NexusUI_Modules["NexusUI/Visualizers/NetworkGraph"] = function()
    local script = CreateMockScript("NexusUI/Visualizers/NetworkGraph")
    
    --[[
        NexusUI Network Graph Component
        Real-time network latency/ping visualization
    ]]

    --// Services
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")

    --// NetworkGraph Module
    local NetworkGraph = {}
    NetworkGraph.__index = NetworkGraph
    NetworkGraph.ClassName = "NetworkGraph"

    --// Constructor
    function NetworkGraph.new(config)
        local self = setmetatable({}, NetworkGraph)

        config = config or {}

        self.Width = config.Width or 200
        self.Height = config.Height or 80
        self.MaxDataPoints = config.MaxDataPoints or 60
        self.UpdateRate = config.UpdateRate or 0.5
        self.ShowValue = config.ShowValue ~= false

        -- Colors
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
        self.GridColor = config.GridColor or Color3.fromRGB(39, 39, 42)
        self.LineColor = config.LineColor or Color3.fromRGB(59, 130, 246)
        self.HighPingColor = config.HighPingColor or Color3.fromRGB(239, 68, 68)
        self.MediumPingColor = config.MediumPingColor or Color3.fromRGB(245, 158, 11)
        self.TextColor = config.TextColor or Color3.fromRGB(250, 250, 250)

        -- Thresholds (in ms)
        self.HighPingThreshold = config.HighPingThreshold or 150
        self.MediumPingThreshold = config.MediumPingThreshold or 80

        -- State
        self._pingData = {}
        self._currentPing = 0
        self._connections = {}
        self._running = false

        return self
    end

    --// Get color for ping value
    function NetworkGraph:_getColorForPing(ping)
        if ping > self.HighPingThreshold then
            return self.HighPingColor
        elseif ping > self.MediumPingThreshold then
            return self.MediumPingColor
        else
            return self.LineColor
        end
    end

    --// Create graph
    function NetworkGraph:Create(parent)
        local graph = Instance.new("Frame")
        graph.Name = "NetworkGraph"
        graph.Size = UDim2.new(0, self.Width, 0, self.Height)
        graph.BackgroundColor3 = self.BackgroundColor
        graph.BorderSizePixel = 0

        if parent then
            graph.Parent = parent
        end

        self.Instance = graph

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = graph

        -- Header
        local header = Instance.new("Frame")
        header.Size = UDim2.new(1, 0, 0, 24)
        header.BackgroundTransparency = 1
        header.Parent = graph

        local title = Instance.new("TextLabel")
        title.Size = UDim2.new(0, 60, 1, 0)
        title.Position = UDim2.new(0, 10, 0, 0)
        title.BackgroundTransparency = 1
        title.Font = Enum.Font.GothamMedium
        title.Text = "Ping"
        title.TextColor3 = Color3.fromRGB(161, 161, 170)
        title.TextSize = 11
        title.TextXAlignment = Enum.TextXAlignment.Left
        title.Parent = header

        local pingValue = Instance.new("TextLabel")
        pingValue.Name = "PingValue"
        pingValue.Size = UDim2.new(0, 70, 1, 0)
        pingValue.Position = UDim2.new(1, -80, 0, 0)
        pingValue.BackgroundTransparency = 1
        pingValue.Font = Enum.Font.GothamBold
        pingValue.Text = "0 ms"
        pingValue.TextColor3 = self.LineColor
        pingValue.TextSize = 14
        pingValue.TextXAlignment = Enum.TextXAlignment.Right
        pingValue.Parent = header
        self._pingLabel = pingValue

        -- Graph area
        local graphArea = Instance.new("Frame")
        graphArea.Name = "GraphArea"
        graphArea.Size = UDim2.new(1, -20, 1, -34)
        graphArea.Position = UDim2.new(0, 10, 0, 28)
        graphArea.BackgroundColor3 = self.GridColor
        graphArea.BackgroundTransparency = 0.5
        graphArea.BorderSizePixel = 0
        graphArea.ClipsDescendants = true
        graphArea.Parent = graph
        self._graphArea = graphArea

        local graphCorner = Instance.new("UICorner")
        graphCorner.CornerRadius = UDim.new(0, 4)
        graphCorner.Parent = graphArea

        -- Lines container
        local linesContainer = Instance.new("Frame")
        linesContainer.Name = "Lines"
        linesContainer.Size = UDim2.new(1, 0, 1, 0)
        linesContainer.BackgroundTransparency = 1
        linesContainer.Parent = graphArea
        self._linesContainer = linesContainer

        -- Status indicator
        local status = Instance.new("Frame")
        status.Name = "Status"
        status.Size = UDim2.new(0, 8, 0, 8)
        status.Position = UDim2.new(0, 10, 0, 8)
        status.BackgroundColor3 = self.LineColor
        status.BorderSizePixel = 0
        status.Parent = graph
        self._statusIndicator = status

        local statusCorner = Instance.new("UICorner")
        statusCorner.CornerRadius = UDim.new(1, 0)
        statusCorner.Parent = status

        return self
    end

    --// Start monitoring
    function NetworkGraph:Start()
        if self._running then return self end
        self._running = true

        local lastUpdate = os.clock()

        local connection = RunService.Heartbeat:Connect(function()
            local now = os.clock()

            if now - lastUpdate >= self.UpdateRate then
                lastUpdate = now

                -- Get ping
                local player = Players.LocalPlayer
                if player then
                    local success, ping = pcall(function()
                        return player:GetNetworkPing()
                    end)

                    if success then
                        self._currentPing = ping * 1000 -- Convert to ms
                    end
                end

                -- Store data point
                table.insert(self._pingData, self._currentPing)
                if #self._pingData > self.MaxDataPoints then
                    table.remove(self._pingData, 1)
                end

                self:_updateDisplay()
            end
        end)

        table.insert(self._connections, connection)

        return self
    end

    --// Stop monitoring
    function NetworkGraph:Stop()
        self._running = false

        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        return self
    end

    --// Update display
    function NetworkGraph:_updateDisplay()
        local ping = math.floor(self._currentPing + 0.5)
        local color = self:_getColorForPing(ping)

        -- Update label
        if self._pingLabel then
            self._pingLabel.Text = ping .. " ms"
            self._pingLabel.TextColor3 = color
        end

        -- Update status indicator
        if self._statusIndicator then
            self._statusIndicator.BackgroundColor3 = color
        end

        -- Draw graph
        self:_drawGraph()
    end

    --// Draw graph
    function NetworkGraph:_drawGraph()
        for _, child in ipairs(self._linesContainer:GetChildren()) do
            child:Destroy()
        end

        local data = self._pingData
        if #data < 2 then return end

        local graphWidth = self._graphArea.AbsoluteSize.X
        local graphHeight = self._graphArea.AbsoluteSize.Y

        -- Auto-scale with minimum 200ms
        local maxPing = 200
        for _, p in ipairs(data) do
            maxPing = math.max(maxPing, p)
        end

        local points = {}
        for i, p in ipairs(data) do
            local x = ((i - 1) / (self.MaxDataPoints - 1)) * graphWidth
            local y = graphHeight - (math.min(p, maxPing) / maxPing) * graphHeight
            table.insert(points, Vector2.new(x, y))
        end

        for i = 1, #points - 1 do
            local startPos = points[i]
            local endPos = points[i + 1]

            local distance = (endPos - startPos).Magnitude
            local angle = math.atan2(endPos.Y - startPos.Y, endPos.X - startPos.X)

            local pingVal = data[i]
            local lineColor = self:_getColorForPing(pingVal)

            local line = Instance.new("Frame")
            line.BackgroundColor3 = lineColor
            line.BorderSizePixel = 0
            line.Size = UDim2.new(0, distance + 1, 0, 2)
            line.Position = UDim2.new(0, startPos.X, 0, startPos.Y)
            line.AnchorPoint = Vector2.new(0, 0.5)
            line.Rotation = math.deg(angle)
            line.Parent = self._linesContainer
        end
    end

    --// Get current ping
    function NetworkGraph:GetPing()
        return math.floor(self._currentPing + 0.5)
    end

    --// Destroy
    function NetworkGraph:Destroy()
        self:Stop()

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return NetworkGraph


end


-- ============================================================================
-- Module: NexusUI/Visualizers/PerformancePanel
-- ============================================================================
NexusUI_Modules["NexusUI/Visualizers/PerformancePanel"] = function()
    local script = CreateMockScript("NexusUI/Visualizers/PerformancePanel")
    
    --[[
        NexusUI Performance Panel Component
        Comprehensive performance monitoring panel with FPS, memory, and network
    ]]

    --// Services
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local TweenService = game:GetService("TweenService")

    --// PerformancePanel Module
    local PerformancePanel = {}
    PerformancePanel.__index = PerformancePanel
    PerformancePanel.ClassName = "PerformancePanel"

    --// Constructor
    function PerformancePanel.new(config)
        local self = setmetatable({}, PerformancePanel)

        config = config or {}

        self.Width = config.Width or 220
        self.Height = config.Height or 120
        self.Compact = config.Compact or false
        self.ShowFPS = config.ShowFPS ~= false
        self.ShowMemory = config.ShowMemory ~= false
        self.ShowPing = config.ShowPing ~= false
        self.ShowUptime = config.ShowUptime or false
        self.Draggable = config.Draggable ~= false
        self.Position = config.Position or UDim2.new(1, -230, 0, 10)

        -- Colors
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(18, 18, 21)
        self.TextColor = config.TextColor or Color3.fromRGB(250, 250, 250)
        self.LabelColor = config.LabelColor or Color3.fromRGB(113, 113, 122)
        self.AccentColor = config.AccentColor or Color3.fromRGB(99, 102, 241)

        -- FPS Colors
        self.HighFPSColor = config.HighFPSColor or Color3.fromRGB(34, 197, 94)
        self.MediumFPSColor = config.MediumFPSColor or Color3.fromRGB(245, 158, 11)
        self.LowFPSColor = config.LowFPSColor or Color3.fromRGB(239, 68, 68)

        -- Thresholds
        self.LowFPSThreshold = config.LowFPSThreshold or 30
        self.MediumFPSThreshold = config.MediumFPSThreshold or 45
        self.HighPingThreshold = config.HighPingThreshold or 150

        -- State
        self._connections = {}
        self._running = false
        self._frameCount = 0
        self._lastFPSTime = os.clock()
        self._currentFPS = 60
        self._currentMemory = 0
        self._currentPing = 0
        self._startTime = os.clock()
        self._fpsHistory = {}

        return self
    end

    --// Get FPS color
    function PerformancePanel:_getFPSColor(fps)
        if fps < self.LowFPSThreshold then
            return self.LowFPSColor
        elseif fps < self.MediumFPSThreshold then
            return self.MediumFPSColor
        else
            return self.HighFPSColor
        end
    end

    --// Create panel
    function PerformancePanel:Create(parent)
        local panel = Instance.new("Frame")
        panel.Name = "PerformancePanel"
        panel.Size = UDim2.new(0, self.Width, 0, self.Height)
        panel.Position = self.Position
        panel.BackgroundColor3 = self.BackgroundColor
        panel.BorderSizePixel = 0

        if parent then
            panel.Parent = parent
        end

        self.Instance = panel

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 10)
        corner.Parent = panel

        local stroke = Instance.new("UIStroke")
        stroke.Color = Color3.fromRGB(39, 39, 42)
        stroke.Thickness = 1
        stroke.Parent = panel

        -- Padding
        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, 12)
        padding.PaddingBottom = UDim.new(0, 12)
        padding.PaddingLeft = UDim.new(0, 14)
        padding.PaddingRight = UDim.new(0, 14)
        padding.Parent = panel

        -- Header
        local header = Instance.new("Frame")
        header.Size = UDim2.new(1, 0, 0, 20)
        header.BackgroundTransparency = 1
        header.Parent = panel

        local title = Instance.new("TextLabel")
        title.Size = UDim2.new(1, 0, 1, 0)
        title.BackgroundTransparency = 1
        title.Font = Enum.Font.GothamBold
        title.Text = "Performance"
        title.TextColor3 = self.TextColor
        title.TextSize = 12
        title.TextXAlignment = Enum.TextXAlignment.Left
        title.Parent = header

        -- Status indicator
        local statusDot = Instance.new("Frame")
        statusDot.Size = UDim2.new(0, 8, 0, 8)
        statusDot.Position = UDim2.new(1, -8, 0.5, 0)
        statusDot.AnchorPoint = Vector2.new(0, 0.5)
        statusDot.BackgroundColor3 = self.HighFPSColor
        statusDot.BorderSizePixel = 0
        statusDot.Parent = header
        self._statusDot = statusDot

        local statusCorner = Instance.new("UICorner")
        statusCorner.CornerRadius = UDim.new(1, 0)
        statusCorner.Parent = statusDot

        -- Stats container
        local stats = Instance.new("Frame")
        stats.Size = UDim2.new(1, 0, 1, -28)
        stats.Position = UDim2.new(0, 0, 0, 28)
        stats.BackgroundTransparency = 1
        stats.Parent = panel

        local statsLayout = Instance.new("UIListLayout")
        statsLayout.Padding = UDim.new(0, 8)
        statsLayout.Parent = stats

        -- FPS row
        if self.ShowFPS then
            local fpsRow = self:_createStatRow("FPS", "60", self.HighFPSColor, stats)
            self._fpsValueLabel = fpsRow:FindFirstChild("Value")
            self._fpsBar = fpsRow:FindFirstChild("Bar")
        end

        -- Memory row
        if self.ShowMemory then
            local memRow = self:_createStatRow("Memory", "0 MB", self.AccentColor, stats)
            self._memValueLabel = memRow:FindFirstChild("Value")
            self._memBar = memRow:FindFirstChild("Bar")
        end

        -- Ping row
        if self.ShowPing then
            local pingRow = self:_createStatRow("Ping", "0 ms", Color3.fromRGB(59, 130, 246), stats)
            self._pingValueLabel = pingRow:FindFirstChild("Value")
            self._pingBar = pingRow:FindFirstChild("Bar")
        end

        -- Uptime row
        if self.ShowUptime then
            local uptimeRow = self:_createStatRow("Uptime", "00:00", Color3.fromRGB(168, 85, 247), stats)
            self._uptimeValueLabel = uptimeRow:FindFirstChild("Value")
        end

        -- Draggable
        if self.Draggable then
            self:_setupDragging()
        end

        return self
    end

    --// Create stat row
    function PerformancePanel:_createStatRow(label, value, color, parent)
        local row = Instance.new("Frame")
        row.Name = label .. "Row"
        row.Size = UDim2.new(1, 0, 0, 18)
        row.BackgroundTransparency = 1
        row.Parent = parent

        local labelText = Instance.new("TextLabel")
        labelText.Name = "Label"
        labelText.Size = UDim2.new(0, 60, 1, 0)
        labelText.BackgroundTransparency = 1
        labelText.Font = Enum.Font.Gotham
        labelText.Text = label
        labelText.TextColor3 = self.LabelColor
        labelText.TextSize = 11
        labelText.TextXAlignment = Enum.TextXAlignment.Left
        labelText.Parent = row

        local valueText = Instance.new("TextLabel")
        valueText.Name = "Value"
        valueText.Size = UDim2.new(0, 60, 1, 0)
        valueText.Position = UDim2.new(1, -60, 0, 0)
        valueText.BackgroundTransparency = 1
        valueText.Font = Enum.Font.GothamMedium
        valueText.Text = value
        valueText.TextColor3 = color
        valueText.TextSize = 11
        valueText.TextXAlignment = Enum.TextXAlignment.Right
        valueText.Parent = row

        -- Progress bar
        local barTrack = Instance.new("Frame")
        barTrack.Name = "BarTrack"
        barTrack.Size = UDim2.new(1, -130, 0, 4)
        barTrack.Position = UDim2.new(0, 65, 0.5, 0)
        barTrack.AnchorPoint = Vector2.new(0, 0.5)
        barTrack.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
        barTrack.BorderSizePixel = 0
        barTrack.Parent = row

        local barCorner = Instance.new("UICorner")
        barCorner.CornerRadius = UDim.new(1, 0)
        barCorner.Parent = barTrack

        local bar = Instance.new("Frame")
        bar.Name = "Bar"
        bar.Size = UDim2.new(0.5, 0, 1, 0)
        bar.BackgroundColor3 = color
        bar.BorderSizePixel = 0
        bar.Parent = barTrack

        local barFillCorner = Instance.new("UICorner")
        barFillCorner.CornerRadius = UDim.new(1, 0)
        barFillCorner.Parent = bar

        return row
    end

    --// Setup dragging
    function PerformancePanel:_setupDragging()
        local dragging = false
        local dragStart = nil
        local startPos = nil

        local dragInput = Instance.new("TextButton")
        dragInput.Size = UDim2.new(1, 0, 0, 28)
        dragInput.BackgroundTransparency = 1
        dragInput.Text = ""
        dragInput.ZIndex = 2
        dragInput.Parent = self.Instance

        table.insert(self._connections, dragInput.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
                dragStart = input.Position
                startPos = self.Instance.Position
            end
        end))

        table.insert(self._connections, dragInput.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = false
            end
        end))

        table.insert(self._connections, game:GetService("UserInputService").InputChanged:Connect(function(input)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local delta = input.Position - dragStart
                self.Instance.Position = UDim2.new(
                    startPos.X.Scale,
                    startPos.X.Offset + delta.X,
                    startPos.Y.Scale,
                    startPos.Y.Offset + delta.Y
                )
            end
        end))
    end

    --// Start monitoring
    function PerformancePanel:Start()
        if self._running then return self end
        self._running = true

        -- FPS counter
        local fpsConnection = RunService.Heartbeat:Connect(function()
            self._frameCount = self._frameCount + 1

            local now = os.clock()
            local elapsed = now - self._lastFPSTime

            if elapsed >= 0.5 then
                self._currentFPS = self._frameCount / elapsed
                self._frameCount = 0
                self._lastFPSTime = now

                -- Store history
                table.insert(self._fpsHistory, self._currentFPS)
                if #self._fpsHistory > 60 then
                    table.remove(self._fpsHistory, 1)
                end
            end
        end)
        table.insert(self._connections, fpsConnection)

        -- Update display
        local updateConnection = RunService.Heartbeat:Connect(function()
            self:_updateDisplay()
        end)
        table.insert(self._connections, updateConnection)

        -- Memory and ping (less frequent)
        local statsConnection
        statsConnection = task.spawn(function()
            while self._running do
                -- Memory
                self._currentMemory = collectgarbage("count") / 1024

                -- Ping
                local player = Players.LocalPlayer
                if player then
                    local success, ping = pcall(function()
                        return player:GetNetworkPing()
                    end)
                    if success then
                        self._currentPing = ping * 1000
                    end
                end

                task.wait(1)
            end
        end)

        return self
    end

    --// Stop monitoring
    function PerformancePanel:Stop()
        self._running = false

        for _, connection in ipairs(self._connections) do
            if typeof(connection) == "RBXScriptConnection" then
                connection:Disconnect()
            end
        end
        self._connections = {}

        return self
    end

    --// Update display
    function PerformancePanel:_updateDisplay()
        local fps = math.floor(self._currentFPS + 0.5)
        local fpsColor = self:_getFPSColor(fps)

        -- Update FPS
        if self._fpsValueLabel then
            self._fpsValueLabel.Text = tostring(fps)
            self._fpsValueLabel.TextColor3 = fpsColor
        end
        if self._fpsBar then
            self._fpsBar.Size = UDim2.new(math.min(fps / 60, 1), 0, 1, 0)
            self._fpsBar.BackgroundColor3 = fpsColor
        end

        -- Update status dot
        if self._statusDot then
            self._statusDot.BackgroundColor3 = fpsColor
        end

        -- Update memory
        if self._memValueLabel then
            self._memValueLabel.Text = string.format("%.0f MB", self._currentMemory)
        end
        if self._memBar then
            self._memBar.Size = UDim2.new(math.min(self._currentMemory / 500, 1), 0, 1, 0)
        end

        -- Update ping
        local ping = math.floor(self._currentPing + 0.5)
        local pingColor = ping > self.HighPingThreshold and self.LowFPSColor or 
                          ping > 80 and self.MediumFPSColor or Color3.fromRGB(59, 130, 246)

        if self._pingValueLabel then
            self._pingValueLabel.Text = ping .. " ms"
            self._pingValueLabel.TextColor3 = pingColor
        end
        if self._pingBar then
            self._pingBar.Size = UDim2.new(math.min(ping / 200, 1), 0, 1, 0)
            self._pingBar.BackgroundColor3 = pingColor
        end

        -- Update uptime
        if self._uptimeValueLabel then
            local uptime = os.clock() - self._startTime
            local mins = math.floor(uptime / 60)
            local secs = math.floor(uptime % 60)
            self._uptimeValueLabel.Text = string.format("%02d:%02d", mins, secs)
        end
    end

    --// Get stats
    function PerformancePanel:GetStats()
        return {
            FPS = math.floor(self._currentFPS + 0.5),
            Memory = self._currentMemory,
            Ping = math.floor(self._currentPing + 0.5),
            Uptime = os.clock() - self._startTime,
        }
    end

    --// Toggle visibility
    function PerformancePanel:Toggle()
        self.Instance.Visible = not self.Instance.Visible
        return self
    end

    --// Destroy
    function PerformancePanel:Destroy()
        self:Stop()

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return PerformancePanel


end


-- ============================================================================
-- Module: NexusUI/Visualizers/init
-- ============================================================================
NexusUI_Modules["NexusUI/Visualizers/init"] = function()
    local script = CreateMockScript("NexusUI/Visualizers/init")
    
    --[[
        NexusUI Visualizers Module
        Charts, graphs, and data visualization components
    ]]

    --// Visualizers Module
    local Visualizers = {}

    Visualizers.LineChart = NexusRequire("NexusUI/Visualizers/LineChart")
    Visualizers.BarChart = NexusRequire("NexusUI/Visualizers/BarChart")
    Visualizers.PieChart = NexusRequire("NexusUI/Visualizers/PieChart")
    Visualizers.AreaChart = NexusRequire("NexusUI/Visualizers/AreaChart")
    Visualizers.RadarChart = NexusRequire("NexusUI/Visualizers/RadarChart")
    Visualizers.DonutChart = NexusRequire("NexusUI/Visualizers/DonutChart")
    Visualizers.Sparkline = NexusRequire("NexusUI/Visualizers/Sparkline")
    Visualizers.Gauge = NexusRequire("NexusUI/Visualizers/Gauge")
    Visualizers.Heatmap = NexusRequire("NexusUI/Visualizers/Heatmap")
    Visualizers.FPSGraph = NexusRequire("NexusUI/Visualizers/FPSGraph")
    Visualizers.MemoryGraph = NexusRequire("NexusUI/Visualizers/MemoryGraph")
    Visualizers.NetworkGraph = NexusRequire("NexusUI/Visualizers/NetworkGraph")
    Visualizers.PerformancePanel = NexusRequire("NexusUI/Visualizers/PerformancePanel")

    return Visualizers


end


-- ============================================================================
-- Module: NexusUI/Special/Console
-- ============================================================================
NexusUI_Modules["NexusUI/Special/Console"] = function()
    local script = CreateMockScript("NexusUI/Special/Console")
    
    --[[
        NexusUI Console Component
        Developer console with command execution
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")
    local HttpService = game:GetService("HttpService")

    --// Console Module
    local Console = {}
    Console.__index = Console
    Console.ClassName = "Console"

    --// Log levels
    Console.Level = {
        Debug = 1,
        Info = 2,
        Warn = 3,
        Error = 4,
        Success = 5,
    }

    --// Level colors
    local LEVEL_COLORS = {
        [1] = Color3.fromRGB(113, 113, 122), -- Debug
        [2] = Color3.fromRGB(250, 250, 250), -- Info
        [3] = Color3.fromRGB(245, 158, 11), -- Warn
        [4] = Color3.fromRGB(239, 68, 68), -- Error
        [5] = Color3.fromRGB(34, 197, 94), -- Success
    }

    local LEVEL_PREFIXES = {
        [1] = "[DEBUG]",
        [2] = "[INFO]",
        [3] = "[WARN]",
        [4] = "[ERROR]",
        [5] = "[SUCCESS]",
    }

    --// Constructor
    function Console.new(config)
        local self = setmetatable({}, Console)

        config = config or {}

        self.Width = config.Width or 500
        self.Height = config.Height or 300
        self.MaxLines = config.MaxLines or 500
        self.ShowTimestamp = config.ShowTimestamp ~= false
        self.ShowLevel = config.ShowLevel ~= false
        self.AutoScroll = config.AutoScroll ~= false
        self.EnableInput = config.EnableInput ~= false
        self.FilterLevel = config.FilterLevel or Console.Level.Debug

        -- Colors
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(13, 13, 15)
        self.TextColor = config.TextColor or Color3.fromRGB(250, 250, 250)
        self.InputColor = config.InputColor or Color3.fromRGB(24, 24, 27)
        self.BorderColor = config.BorderColor or Color3.fromRGB(39, 39, 42)

        -- Callbacks
        self.OnCommand = config.OnCommand

        -- State
        self._logs = {}
        self._commandHistory = {}
        self._historyIndex = 0
        self._connections = {}

        return self
    end

    --// Create console
    function Console:Create(parent)
        local console = Instance.new("Frame")
        console.Name = "Console"
        console.Size = UDim2.new(0, self.Width, 0, self.Height)
        console.BackgroundColor3 = self.BackgroundColor
        console.BorderSizePixel = 0

        if parent then
            console.Parent = parent
        end

        self.Instance = console

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = console

        local stroke = Instance.new("UIStroke")
        stroke.Color = self.BorderColor
        stroke.Thickness = 1
        stroke.Parent = console

        -- Header
        local header = Instance.new("Frame")
        header.Size = UDim2.new(1, 0, 0, 32)
        header.BackgroundColor3 = Color3.fromRGB(18, 18, 21)
        header.BorderSizePixel = 0
        header.Parent = console

        local headerCorner = Instance.new("UICorner")
        headerCorner.CornerRadius = UDim.new(0, 8)
        headerCorner.Parent = header

        -- Fix bottom corners of header
        local headerFix = Instance.new("Frame")
        headerFix.Size = UDim2.new(1, 0, 0, 8)
        headerFix.Position = UDim2.new(0, 0, 1, -8)
        headerFix.BackgroundColor3 = Color3.fromRGB(18, 18, 21)
        headerFix.BorderSizePixel = 0
        headerFix.Parent = header

        local title = Instance.new("TextLabel")
        title.Size = UDim2.new(1, -80, 1, 0)
        title.Position = UDim2.new(0, 12, 0, 0)
        title.BackgroundTransparency = 1
        title.Font = Enum.Font.GothamMedium
        title.Text = "Console"
        title.TextColor3 = Color3.fromRGB(161, 161, 170)
        title.TextSize = 12
        title.TextXAlignment = Enum.TextXAlignment.Left
        title.Parent = header

        -- Clear button
        local clearBtn = Instance.new("TextButton")
        clearBtn.Size = UDim2.new(0, 50, 0, 22)
        clearBtn.Position = UDim2.new(1, -60, 0.5, 0)
        clearBtn.AnchorPoint = Vector2.new(0, 0.5)
        clearBtn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
        clearBtn.BorderSizePixel = 0
        clearBtn.Font = Enum.Font.GothamMedium
        clearBtn.Text = "Clear"
        clearBtn.TextColor3 = Color3.fromRGB(161, 161, 170)
        clearBtn.TextSize = 11
        clearBtn.AutoButtonColor = false
        clearBtn.Parent = header

        local clearBtnCorner = Instance.new("UICorner")
        clearBtnCorner.CornerRadius = UDim.new(0, 4)
        clearBtnCorner.Parent = clearBtn

        table.insert(self._connections, clearBtn.MouseButton1Click:Connect(function()
            self:Clear()
        end))

        -- Log area
        local logArea = Instance.new("ScrollingFrame")
        logArea.Name = "LogArea"
        logArea.Size = UDim2.new(1, -16, 1, self.EnableInput and -80 or -48)
        logArea.Position = UDim2.new(0, 8, 0, 40)
        logArea.BackgroundTransparency = 1
        logArea.BorderSizePixel = 0
        logArea.ScrollBarThickness = 4
        logArea.ScrollBarImageColor3 = Color3.fromRGB(63, 63, 70)
        logArea.CanvasSize = UDim2.new(0, 0, 0, 0)
        logArea.AutomaticCanvasSize = Enum.AutomaticSize.Y
        logArea.Parent = console
        self._logArea = logArea

        local logLayout = Instance.new("UIListLayout")
        logLayout.Padding = UDim.new(0, 2)
        logLayout.Parent = logArea

        -- Input area
        if self.EnableInput then
            local inputContainer = Instance.new("Frame")
            inputContainer.Size = UDim2.new(1, -16, 0, 32)
            inputContainer.Position = UDim2.new(0, 8, 1, -40)
            inputContainer.BackgroundColor3 = self.InputColor
            inputContainer.BorderSizePixel = 0
            inputContainer.Parent = console

            local inputCorner = Instance.new("UICorner")
            inputCorner.CornerRadius = UDim.new(0, 6)
            inputCorner.Parent = inputContainer

            local prefix = Instance.new("TextLabel")
            prefix.Size = UDim2.new(0, 20, 1, 0)
            prefix.Position = UDim2.new(0, 8, 0, 0)
            prefix.BackgroundTransparency = 1
            prefix.Font = Enum.Font.Code
            prefix.Text = ">"
            prefix.TextColor3 = Color3.fromRGB(99, 102, 241)
            prefix.TextSize = 14
            prefix.Parent = inputContainer

            local input = Instance.new("TextBox")
            input.Size = UDim2.new(1, -35, 1, 0)
            input.Position = UDim2.new(0, 28, 0, 0)
            input.BackgroundTransparency = 1
            input.Font = Enum.Font.Code
            input.PlaceholderText = "Enter command..."
            input.PlaceholderColor3 = Color3.fromRGB(82, 82, 91)
            input.Text = ""
            input.TextColor3 = self.TextColor
            input.TextSize = 13
            input.TextXAlignment = Enum.TextXAlignment.Left
            input.ClearTextOnFocus = false
            input.Parent = inputContainer
            self._input = input

            -- Input handling
            table.insert(self._connections, input.FocusLost:Connect(function(enterPressed)
                if enterPressed and input.Text ~= "" then
                    self:ExecuteCommand(input.Text)
                    table.insert(self._commandHistory, input.Text)
                    self._historyIndex = #self._commandHistory + 1
                    input.Text = ""
                end
            end))

            -- Command history navigation
            table.insert(self._connections, game:GetService("UserInputService").InputBegan:Connect(function(inputObj)
                if not input:IsFocused() then return end

                if inputObj.KeyCode == Enum.KeyCode.Up then
                    if self._historyIndex > 1 then
                        self._historyIndex = self._historyIndex - 1
                        input.Text = self._commandHistory[self._historyIndex] or ""
                    end
                elseif inputObj.KeyCode == Enum.KeyCode.Down then
                    if self._historyIndex < #self._commandHistory then
                        self._historyIndex = self._historyIndex + 1
                        input.Text = self._commandHistory[self._historyIndex] or ""
                    elseif self._historyIndex == #self._commandHistory then
                        self._historyIndex = self._historyIndex + 1
                        input.Text = ""
                    end
                end
            end))
        end

        return self
    end

    --// Log message
    function Console:Log(message, level)
        level = level or Console.Level.Info

        if level < self.FilterLevel then return self end

        local logEntry = {
            Message = message,
            Level = level,
            Timestamp = os.date("%H:%M:%S"),
            Time = os.clock(),
        }

        table.insert(self._logs, logEntry)

        -- Trim old logs
        while #self._logs > self.MaxLines do
            table.remove(self._logs, 1)
            -- Remove from display
            local firstChild = self._logArea:FindFirstChildOfClass("TextLabel")
            if firstChild then
                firstChild:Destroy()
            end
        end

        -- Create log line
        local text = ""

        if self.ShowTimestamp then
            text = text .. "[" .. logEntry.Timestamp .. "] "
        end

        if self.ShowLevel then
            text = text .. LEVEL_PREFIXES[level] .. " "
        end

        text = text .. message

        local logLine = Instance.new("TextLabel")
        logLine.Size = UDim2.new(1, 0, 0, 0)
        logLine.AutomaticSize = Enum.AutomaticSize.Y
        logLine.BackgroundTransparency = 1
        logLine.Font = Enum.Font.Code
        logLine.Text = text
        logLine.TextColor3 = LEVEL_COLORS[level] or self.TextColor
        logLine.TextSize = 12
        logLine.TextXAlignment = Enum.TextXAlignment.Left
        logLine.TextWrapped = true
        logLine.RichText = true
        logLine.Parent = self._logArea

        -- Auto scroll
        if self.AutoScroll then
            self._logArea.CanvasPosition = Vector2.new(0, self._logArea.AbsoluteCanvasSize.Y)
        end

        return self
    end

    --// Convenience methods
    function Console:Debug(message)
        return self:Log(message, Console.Level.Debug)
    end

    function Console:Info(message)
        return self:Log(message, Console.Level.Info)
    end

    function Console:Warn(message)
        return self:Log(message, Console.Level.Warn)
    end

    function Console:Error(message)
        return self:Log(message, Console.Level.Error)
    end

    function Console:Success(message)
        return self:Log(message, Console.Level.Success)
    end

    --// Execute command
    function Console:ExecuteCommand(command)
        self:Log("> " .. command, Console.Level.Debug)

        if self.OnCommand then
            local success, result = pcall(self.OnCommand, command)
            if success then
                if result then
                    self:Log(tostring(result), Console.Level.Info)
                end
            else
                self:Error("Command error: " .. tostring(result))
            end
        else
            -- Default: try to execute as Lua
            local func, err = loadstring(command)
            if func then
                local success, result = pcall(func)
                if success then
                    if result ~= nil then
                        self:Success(tostring(result))
                    else
                        self:Success("Executed successfully")
                    end
                else
                    self:Error(tostring(result))
                end
            else
                self:Error("Syntax error: " .. tostring(err))
            end
        end

        return self
    end

    --// Clear console
    function Console:Clear()
        self._logs = {}

        for _, child in ipairs(self._logArea:GetChildren()) do
            if child:IsA("TextLabel") then
                child:Destroy()
            end
        end

        return self
    end

    --// Set filter level
    function Console:SetFilterLevel(level)
        self.FilterLevel = level
        return self
    end

    --// Get logs
    function Console:GetLogs()
        return self._logs
    end

    --// Export logs
    function Console:Export()
        local text = ""
        for _, log in ipairs(self._logs) do
            text = text .. "[" .. log.Timestamp .. "] " .. LEVEL_PREFIXES[log.Level] .. " " .. log.Message .. "\n"
        end
        return text
    end

    --// Destroy
    function Console:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return Console


end


-- ============================================================================
-- Module: NexusUI/Special/CodeEditor
-- ============================================================================
NexusUI_Modules["NexusUI/Special/CodeEditor"] = function()
    local script = CreateMockScript("NexusUI/Special/CodeEditor")
    
    --[[
        NexusUI Code Editor Component
        Syntax-highlighted code editor for scripts
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")
    local UserInputService = game:GetService("UserInputService")

    --// CodeEditor Module
    local CodeEditor = {}
    CodeEditor.__index = CodeEditor
    CodeEditor.ClassName = "CodeEditor"

    --// Syntax highlighting patterns (Lua/Luau)
    local KEYWORDS = {
        "and", "break", "do", "else", "elseif", "end", "false", "for", "function",
        "if", "in", "local", "nil", "not", "or", "repeat", "return", "then",
        "true", "until", "while", "continue", "export", "type", "typeof"
    }

    local BUILTINS = {
        "print", "warn", "error", "assert", "type", "typeof", "tostring", "tonumber",
        "pairs", "ipairs", "next", "select", "unpack", "pcall", "xpcall", "coroutine",
        "table", "string", "math", "os", "debug", "game", "workspace", "script",
        "wait", "delay", "spawn", "tick", "time", "Instance", "Vector2", "Vector3",
        "CFrame", "Color3", "BrickColor", "UDim", "UDim2", "Enum", "task", "require"
    }

    --// Syntax colors
    local SYNTAX_COLORS = {
        Keyword = Color3.fromRGB(198, 120, 221),
        Builtin = Color3.fromRGB(97, 175, 239),
        String = Color3.fromRGB(152, 195, 121),
        Number = Color3.fromRGB(209, 154, 102),
        Comment = Color3.fromRGB(92, 99, 112),
        Operator = Color3.fromRGB(86, 182, 194),
        Normal = Color3.fromRGB(171, 178, 191),
    }

    --// Constructor
    function CodeEditor.new(config)
        local self = setmetatable({}, CodeEditor)

        config = config or {}

        self.Width = config.Width or 500
        self.Height = config.Height or 350
        self.ShowLineNumbers = config.ShowLineNumbers ~= false
        self.TabSize = config.TabSize or 4
        self.FontSize = config.FontSize or 13
        self.SyntaxHighlight = config.SyntaxHighlight ~= false
        self.ReadOnly = config.ReadOnly or false

        -- Colors
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(30, 30, 35)
        self.GutterColor = config.GutterColor or Color3.fromRGB(24, 24, 27)
        self.TextColor = config.TextColor or SYNTAX_COLORS.Normal
        self.LineNumberColor = config.LineNumberColor or Color3.fromRGB(82, 82, 91)
        self.SelectionColor = config.SelectionColor or Color3.fromRGB(99, 102, 241)
        self.CursorColor = config.CursorColor or Color3.fromRGB(250, 250, 250)

        -- Callbacks
        self.OnChange = config.OnChange
        self.OnExecute = config.OnExecute -- Ctrl+Enter

        -- State
        self._text = config.Text or ""
        self._cursorPos = 0
        self._selectionStart = nil
        self._lines = {}
        self._connections = {}

        return self
    end

    --// Create editor
    function CodeEditor:Create(parent)
        local editor = Instance.new("Frame")
        editor.Name = "CodeEditor"
        editor.Size = UDim2.new(0, self.Width, 0, self.Height)
        editor.BackgroundColor3 = self.BackgroundColor
        editor.BorderSizePixel = 0

        if parent then
            editor.Parent = parent
        end

        self.Instance = editor

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = editor

        -- Header
        local header = Instance.new("Frame")
        header.Size = UDim2.new(1, 0, 0, 36)
        header.BackgroundColor3 = self.GutterColor
        header.BorderSizePixel = 0
        header.Parent = editor

        local headerCorner = Instance.new("UICorner")
        headerCorner.CornerRadius = UDim.new(0, 8)
        headerCorner.Parent = header

        local headerFix = Instance.new("Frame")
        headerFix.Size = UDim2.new(1, 0, 0, 8)
        headerFix.Position = UDim2.new(0, 0, 1, -8)
        headerFix.BackgroundColor3 = self.GutterColor
        headerFix.BorderSizePixel = 0
        headerFix.Parent = header

        -- Title
        local title = Instance.new("TextLabel")
        title.Size = UDim2.new(0, 150, 1, 0)
        title.Position = UDim2.new(0, 12, 0, 0)
        title.BackgroundTransparency = 1
        title.Font = Enum.Font.GothamMedium
        title.Text = "Script Editor"
        title.TextColor3 = Color3.fromRGB(161, 161, 170)
        title.TextSize = 12
        title.TextXAlignment = Enum.TextXAlignment.Left
        title.Parent = header

        -- Action buttons
        local actionsContainer = Instance.new("Frame")
        actionsContainer.Size = UDim2.new(0, 160, 0, 24)
        actionsContainer.Position = UDim2.new(1, -170, 0.5, 0)
        actionsContainer.AnchorPoint = Vector2.new(0, 0.5)
        actionsContainer.BackgroundTransparency = 1
        actionsContainer.Parent = header

        local actionsLayout = Instance.new("UIListLayout")
        actionsLayout.FillDirection = Enum.FillDirection.Horizontal
        actionsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
        actionsLayout.Padding = UDim.new(0, 8)
        actionsLayout.Parent = actionsContainer

        -- Clear button
        local clearBtn = self:_createButton("Clear", actionsContainer, function()
            self:SetText("")
        end)

        -- Execute button
        local executeBtn = self:_createButton("Execute", actionsContainer, function()
            self:Execute()
        end, Color3.fromRGB(34, 197, 94))

        -- Editor area
        local editorArea = Instance.new("Frame")
        editorArea.Size = UDim2.new(1, 0, 1, -36)
        editorArea.Position = UDim2.new(0, 0, 0, 36)
        editorArea.BackgroundTransparency = 1
        editorArea.ClipsDescendants = true
        editorArea.Parent = editor

        -- Line numbers gutter
        if self.ShowLineNumbers then
            local gutter = Instance.new("Frame")
            gutter.Name = "Gutter"
            gutter.Size = UDim2.new(0, 45, 1, 0)
            gutter.BackgroundColor3 = self.GutterColor
            gutter.BorderSizePixel = 0
            gutter.Parent = editorArea
            self._gutter = gutter

            local gutterScroll = Instance.new("ScrollingFrame")
            gutterScroll.Size = UDim2.new(1, 0, 1, 0)
            gutterScroll.BackgroundTransparency = 1
            gutterScroll.BorderSizePixel = 0
            gutterScroll.ScrollBarThickness = 0
            gutterScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
            gutterScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
            gutterScroll.ScrollingEnabled = false
            gutterScroll.Parent = gutter
            self._gutterScroll = gutterScroll

            local gutterLayout = Instance.new("UIListLayout")
            gutterLayout.Parent = gutterScroll

            local gutterPadding = Instance.new("UIPadding")
            gutterPadding.PaddingTop = UDim.new(0, 8)
            gutterPadding.Parent = gutterScroll
        end

        -- Code scroll area
        local codeScroll = Instance.new("ScrollingFrame")
        codeScroll.Name = "CodeArea"
        codeScroll.Size = UDim2.new(1, self.ShowLineNumbers and -45 or 0, 1, 0)
        codeScroll.Position = UDim2.new(0, self.ShowLineNumbers and 45 or 0, 0, 0)
        codeScroll.BackgroundTransparency = 1
        codeScroll.BorderSizePixel = 0
        codeScroll.ScrollBarThickness = 6
        codeScroll.ScrollBarImageColor3 = Color3.fromRGB(63, 63, 70)
        codeScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
        codeScroll.AutomaticCanvasSize = Enum.AutomaticSize.XY
        codeScroll.Parent = editorArea
        self._codeScroll = codeScroll

        local codePadding = Instance.new("UIPadding")
        codePadding.PaddingTop = UDim.new(0, 8)
        codePadding.PaddingLeft = UDim.new(0, 8)
        codePadding.PaddingRight = UDim.new(0, 8)
        codePadding.PaddingBottom = UDim.new(0, 8)
        codePadding.Parent = codeScroll

        -- Text input
        local codeInput = Instance.new("TextBox")
        codeInput.Name = "CodeInput"
        codeInput.Size = UDim2.new(1, 0, 0, 0)
        codeInput.AutomaticSize = Enum.AutomaticSize.Y
        codeInput.BackgroundTransparency = 1
        codeInput.Font = Enum.Font.Code
        codeInput.Text = self._text
        codeInput.TextColor3 = self.TextColor
        codeInput.TextSize = self.FontSize
        codeInput.TextXAlignment = Enum.TextXAlignment.Left
        codeInput.TextYAlignment = Enum.TextYAlignment.Top
        codeInput.MultiLine = true
        codeInput.ClearTextOnFocus = false
        codeInput.TextEditable = not self.ReadOnly
        codeInput.TextWrapped = false
        codeInput.Parent = codeScroll
        self._codeInput = codeInput

        -- Sync scrolling with gutter
        if self._gutterScroll then
            table.insert(self._connections, codeScroll:GetPropertyChangedSignal("CanvasPosition"):Connect(function()
                self._gutterScroll.CanvasPosition = Vector2.new(0, codeScroll.CanvasPosition.Y)
            end))
        end

        -- Text change handling
        table.insert(self._connections, codeInput:GetPropertyChangedSignal("Text"):Connect(function()
            self._text = codeInput.Text
            self:_updateLineNumbers()

            if self.OnChange then
                self.OnChange(self._text)
            end
        end))

        -- Keyboard shortcuts
        table.insert(self._connections, UserInputService.InputBegan:Connect(function(input, processed)
            if not codeInput:IsFocused() then return end

            if input.KeyCode == Enum.KeyCode.Return and UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
                self:Execute()
            elseif input.KeyCode == Enum.KeyCode.Tab then
                -- Insert tab
                local cursorPos = codeInput.CursorPosition
                local text = codeInput.Text
                local tab = string.rep(" ", self.TabSize)
                codeInput.Text = text:sub(1, cursorPos - 1) .. tab .. text:sub(cursorPos)
                codeInput.CursorPosition = cursorPos + self.TabSize
            end
        end))

        -- Initial line numbers
        self:_updateLineNumbers()

        return self
    end

    --// Create button helper
    function CodeEditor:_createButton(text, parent, callback, color)
        local btn = Instance.new("TextButton")
        btn.Size = UDim2.new(0, 60, 1, 0)
        btn.BackgroundColor3 = color or Color3.fromRGB(39, 39, 42)
        btn.BorderSizePixel = 0
        btn.Font = Enum.Font.GothamMedium
        btn.Text = text
        btn.TextColor3 = Color3.fromRGB(250, 250, 250)
        btn.TextSize = 11
        btn.AutoButtonColor = false
        btn.Parent = parent

        local btnCorner = Instance.new("UICorner")
        btnCorner.CornerRadius = UDim.new(0, 4)
        btnCorner.Parent = btn

        table.insert(self._connections, btn.MouseButton1Click:Connect(callback))

        table.insert(self._connections, btn.MouseEnter:Connect(function()
            TweenService:Create(btn, TweenInfo.new(0.1), {
                BackgroundTransparency = 0.2,
            }):Play()
        end))

        table.insert(self._connections, btn.MouseLeave:Connect(function()
            TweenService:Create(btn, TweenInfo.new(0.1), {
                BackgroundTransparency = 0,
            }):Play()
        end))

        return btn
    end

    --// Update line numbers
    function CodeEditor:_updateLineNumbers()
        if not self._gutterScroll then return end

        -- Clear existing
        for _, child in ipairs(self._gutterScroll:GetChildren()) do
            if child:IsA("TextLabel") then
                child:Destroy()
            end
        end

        -- Count lines
        local lineCount = 1
        for _ in self._text:gmatch("\n") do
            lineCount = lineCount + 1
        end

        -- Create line numbers
        for i = 1, lineCount do
            local lineNum = Instance.new("TextLabel")
            lineNum.Size = UDim2.new(1, -8, 0, self.FontSize + 4)
            lineNum.BackgroundTransparency = 1
            lineNum.Font = Enum.Font.Code
            lineNum.Text = tostring(i)
            lineNum.TextColor3 = self.LineNumberColor
            lineNum.TextSize = self.FontSize
            lineNum.TextXAlignment = Enum.TextXAlignment.Right
            lineNum.Parent = self._gutterScroll
        end
    end

    --// Set text
    function CodeEditor:SetText(text)
        self._text = text
        if self._codeInput then
            self._codeInput.Text = text
        end
        self:_updateLineNumbers()
        return self
    end

    --// Get text
    function CodeEditor:GetText()
        return self._text
    end

    --// Execute code
    function CodeEditor:Execute()
        if self.OnExecute then
            self.OnExecute(self._text)
        else
            -- Default execution
            local func, err = loadstring(self._text)
            if func then
                local success, result = pcall(func)
                if not success then
                    warn("[CodeEditor] Runtime error:", result)
                end
            else
                warn("[CodeEditor] Syntax error:", err)
            end
        end
        return self
    end

    --// Destroy
    function CodeEditor:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return CodeEditor


end


-- ============================================================================
-- Module: NexusUI/Special/Terminal
-- ============================================================================
NexusUI_Modules["NexusUI/Special/Terminal"] = function()
    local script = CreateMockScript("NexusUI/Special/Terminal")
    
    --[[
        NexusUI Terminal Component
        Command-line style terminal interface
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Terminal Module
    local Terminal = {}
    Terminal.__index = Terminal
    Terminal.ClassName = "Terminal"

    --// Constructor
    function Terminal.new(config)
        local self = setmetatable({}, Terminal)

        config = config or {}

        self.Width = config.Width or 500
        self.Height = config.Height or 300
        self.MaxLines = config.MaxLines or 1000
        self.Prompt = config.Prompt or ">"
        self.Title = config.Title or "Terminal"

        -- Colors
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(0, 0, 0)
        self.TextColor = config.TextColor or Color3.fromRGB(0, 255, 0)
        self.PromptColor = config.PromptColor or Color3.fromRGB(0, 200, 255)
        self.ErrorColor = config.ErrorColor or Color3.fromRGB(255, 80, 80)

        -- Commands
        self.Commands = config.Commands or {}

        -- Callbacks
        self.OnCommand = config.OnCommand

        -- State
        self._history = {}
        self._historyIndex = 0
        self._output = {}
        self._connections = {}

        return self
    end

    --// Create terminal
    function Terminal:Create(parent)
        local terminal = Instance.new("Frame")
        terminal.Name = "Terminal"
        terminal.Size = UDim2.new(0, self.Width, 0, self.Height)
        terminal.BackgroundColor3 = self.BackgroundColor
        terminal.BorderSizePixel = 0

        if parent then
            terminal.Parent = parent
        end

        self.Instance = terminal

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = terminal

        -- Title bar
        local titleBar = Instance.new("Frame")
        titleBar.Size = UDim2.new(1, 0, 0, 28)
        titleBar.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        titleBar.BorderSizePixel = 0
        titleBar.Parent = terminal

        local titleCorner = Instance.new("UICorner")
        titleCorner.CornerRadius = UDim.new(0, 8)
        titleCorner.Parent = titleBar

        local titleFix = Instance.new("Frame")
        titleFix.Size = UDim2.new(1, 0, 0, 8)
        titleFix.Position = UDim2.new(0, 0, 1, -8)
        titleFix.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        titleFix.BorderSizePixel = 0
        titleFix.Parent = titleBar

        -- Window controls (decorative)
        local controls = Instance.new("Frame")
        controls.Size = UDim2.new(0, 60, 0, 12)
        controls.Position = UDim2.new(0, 10, 0.5, 0)
        controls.AnchorPoint = Vector2.new(0, 0.5)
        controls.BackgroundTransparency = 1
        controls.Parent = titleBar

        local controlsLayout = Instance.new("UIListLayout")
        controlsLayout.FillDirection = Enum.FillDirection.Horizontal
        controlsLayout.Padding = UDim.new(0, 6)
        controlsLayout.Parent = controls

        for _, color in ipairs({Color3.fromRGB(255, 96, 92), Color3.fromRGB(255, 189, 68), Color3.fromRGB(39, 201, 63)}) do
            local dot = Instance.new("Frame")
            dot.Size = UDim2.new(0, 12, 0, 12)
            dot.BackgroundColor3 = color
            dot.BorderSizePixel = 0
            dot.Parent = controls

            local dotCorner = Instance.new("UICorner")
            dotCorner.CornerRadius = UDim.new(1, 0)
            dotCorner.Parent = dot
        end

        -- Title text
        local title = Instance.new("TextLabel")
        title.Size = UDim2.new(1, 0, 1, 0)
        title.BackgroundTransparency = 1
        title.Font = Enum.Font.GothamMedium
        title.Text = self.Title
        title.TextColor3 = Color3.fromRGB(150, 150, 150)
        title.TextSize = 12
        title.Parent = titleBar

        -- Output area
        local outputArea = Instance.new("ScrollingFrame")
        outputArea.Name = "Output"
        outputArea.Size = UDim2.new(1, -20, 1, -68)
        outputArea.Position = UDim2.new(0, 10, 0, 32)
        outputArea.BackgroundTransparency = 1
        outputArea.BorderSizePixel = 0
        outputArea.ScrollBarThickness = 4
        outputArea.ScrollBarImageColor3 = Color3.fromRGB(60, 60, 60)
        outputArea.CanvasSize = UDim2.new(0, 0, 0, 0)
        outputArea.AutomaticCanvasSize = Enum.AutomaticSize.Y
        outputArea.Parent = terminal
        self._outputArea = outputArea

        local outputLayout = Instance.new("UIListLayout")
        outputLayout.Padding = UDim.new(0, 2)
        outputLayout.Parent = outputArea

        -- Input area
        local inputContainer = Instance.new("Frame")
        inputContainer.Size = UDim2.new(1, -20, 0, 24)
        inputContainer.Position = UDim2.new(0, 10, 1, -32)
        inputContainer.BackgroundTransparency = 1
        inputContainer.Parent = terminal

        local promptLabel = Instance.new("TextLabel")
        promptLabel.Size = UDim2.new(0, 15, 1, 0)
        promptLabel.BackgroundTransparency = 1
        promptLabel.Font = Enum.Font.Code
        promptLabel.Text = self.Prompt
        promptLabel.TextColor3 = self.PromptColor
        promptLabel.TextSize = 14
        promptLabel.TextXAlignment = Enum.TextXAlignment.Left
        promptLabel.Parent = inputContainer

        local input = Instance.new("TextBox")
        input.Size = UDim2.new(1, -20, 1, 0)
        input.Position = UDim2.new(0, 20, 0, 0)
        input.BackgroundTransparency = 1
        input.Font = Enum.Font.Code
        input.PlaceholderText = ""
        input.Text = ""
        input.TextColor3 = self.TextColor
        input.TextSize = 14
        input.TextXAlignment = Enum.TextXAlignment.Left
        input.ClearTextOnFocus = false
        input.Parent = inputContainer
        self._input = input

        -- Blinking cursor effect
        local cursor = Instance.new("Frame")
        cursor.Size = UDim2.new(0, 8, 0, 14)
        cursor.Position = UDim2.new(0, 20, 0.5, 0)
        cursor.AnchorPoint = Vector2.new(0, 0.5)
        cursor.BackgroundColor3 = self.TextColor
        cursor.BorderSizePixel = 0
        cursor.Parent = inputContainer
        self._cursor = cursor

        task.spawn(function()
            while self._cursor and self._cursor.Parent do
                self._cursor.Visible = not self._cursor.Visible
                task.wait(0.5)
            end
        end)

        -- Input handling
        table.insert(self._connections, input.FocusLost:Connect(function(enterPressed)
            if enterPressed and input.Text ~= "" then
                local cmd = input.Text
                self:WriteLine(self.Prompt .. " " .. cmd, self.TextColor)
                self:ExecuteCommand(cmd)
                table.insert(self._history, cmd)
                self._historyIndex = #self._history + 1
                input.Text = ""
            end
        end))

        -- History navigation
        table.insert(self._connections, game:GetService("UserInputService").InputBegan:Connect(function(inputObj)
            if not input:IsFocused() then return end

            if inputObj.KeyCode == Enum.KeyCode.Up then
                if self._historyIndex > 1 then
                    self._historyIndex = self._historyIndex - 1
                    input.Text = self._history[self._historyIndex] or ""
                end
            elseif inputObj.KeyCode == Enum.KeyCode.Down then
                if self._historyIndex < #self._history then
                    self._historyIndex = self._historyIndex + 1
                    input.Text = self._history[self._historyIndex] or ""
                elseif self._historyIndex == #self._history then
                    self._historyIndex = self._historyIndex + 1
                    input.Text = ""
                end
            end
        end))

        -- Welcome message
        self:WriteLine("NexusUI Terminal v1.0", Color3.fromRGB(100, 200, 255))
        self:WriteLine("Type 'help' for available commands", Color3.fromRGB(150, 150, 150))
        self:WriteLine("")

        return self
    end

    --// Write line to output
    function Terminal:WriteLine(text, color)
        color = color or self.TextColor

        local line = Instance.new("TextLabel")
        line.Size = UDim2.new(1, 0, 0, 0)
        line.AutomaticSize = Enum.AutomaticSize.Y
        line.BackgroundTransparency = 1
        line.Font = Enum.Font.Code
        line.Text = text
        line.TextColor3 = color
        line.TextSize = 13
        line.TextXAlignment = Enum.TextXAlignment.Left
        line.TextWrapped = true
        line.RichText = true
        line.Parent = self._outputArea

        table.insert(self._output, line)

        -- Trim old lines
        while #self._output > self.MaxLines do
            local oldLine = table.remove(self._output, 1)
            oldLine:Destroy()
        end

        -- Auto scroll
        self._outputArea.CanvasPosition = Vector2.new(0, self._outputArea.AbsoluteCanvasSize.Y)

        return self
    end

    --// Write error
    function Terminal:WriteError(text)
        return self:WriteLine("Error: " .. text, self.ErrorColor)
    end

    --// Execute command
    function Terminal:ExecuteCommand(command)
        local parts = {}
        for part in command:gmatch("%S+") do
            table.insert(parts, part)
        end

        local cmd = parts[1]
        local args = {unpack(parts, 2)}

        -- Check custom commands
        if self.Commands[cmd] then
            local success, err = pcall(self.Commands[cmd], self, unpack(args))
            if not success then
                self:WriteError(tostring(err))
            end
            return self
        end

        -- Built-in commands
        if cmd == "help" then
            self:WriteLine("Available commands:", Color3.fromRGB(150, 150, 150))
            self:WriteLine("  help     - Show this message")
            self:WriteLine("  clear    - Clear terminal")
            self:WriteLine("  echo     - Print message")
            self:WriteLine("  run      - Execute Lua code")
            for name, _ in pairs(self.Commands) do
                self:WriteLine("  " .. name)
            end
        elseif cmd == "clear" then
            self:Clear()
        elseif cmd == "echo" then
            self:WriteLine(table.concat(args, " "))
        elseif cmd == "run" then
            local code = table.concat(args, " ")
            local func, err = loadstring(code)
            if func then
                local success, result = pcall(func)
                if success then
                    if result ~= nil then
                        self:WriteLine(tostring(result))
                    end
                else
                    self:WriteError(tostring(result))
                end
            else
                self:WriteError(tostring(err))
            end
        else
            -- Custom callback
            if self.OnCommand then
                local success, result = pcall(self.OnCommand, cmd, args)
                if success and result then
                    self:WriteLine(tostring(result))
                elseif not success then
                    self:WriteError(tostring(result))
                else
                    self:WriteError("Unknown command: " .. cmd)
                end
            else
                self:WriteError("Unknown command: " .. cmd)
            end
        end

        return self
    end

    --// Clear terminal
    function Terminal:Clear()
        for _, line in ipairs(self._output) do
            line:Destroy()
        end
        self._output = {}
        return self
    end

    --// Register command
    function Terminal:RegisterCommand(name, callback)
        self.Commands[name] = callback
        return self
    end

    --// Destroy
    function Terminal:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return Terminal


end


-- ============================================================================
-- Module: NexusUI/Special/ESP
-- ============================================================================
NexusUI_Modules["NexusUI/Special/ESP"] = function()
    local script = CreateMockScript("NexusUI/Special/ESP")
    
    --[[
        NexusUI ESP Component
        Player/entity ESP (Extra Sensory Perception) overlay
    ]]

    --// Services
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local Workspace = game:GetService("Workspace")

    --// ESP Module
    local ESP = {}
    ESP.__index = ESP
    ESP.ClassName = "ESP"

    --// Constructor
    function ESP.new(config)
        local self = setmetatable({}, ESP)

        config = config or {}

        self.Enabled = config.Enabled or false
        self.ShowBox = config.ShowBox ~= false
        self.ShowName = config.ShowName ~= false
        self.ShowHealth = config.ShowHealth or false
        self.ShowDistance = config.ShowDistance or false
        self.ShowTracers = config.ShowTracers or false
        self.ShowSkeleton = config.ShowSkeleton or false
        self.TeamCheck = config.TeamCheck or false
        self.MaxDistance = config.MaxDistance or 1000

        -- Colors
        self.BoxColor = config.BoxColor or Color3.fromRGB(255, 255, 255)
        self.NameColor = config.NameColor or Color3.fromRGB(255, 255, 255)
        self.HealthColor = config.HealthColor or Color3.fromRGB(0, 255, 0)
        self.DistanceColor = config.DistanceColor or Color3.fromRGB(200, 200, 200)
        self.TracerColor = config.TracerColor or Color3.fromRGB(255, 255, 255)
        self.TeamColor = config.TeamColor or nil -- Use team color if available
        self.EnemyColor = config.EnemyColor or Color3.fromRGB(255, 50, 50)
        self.FriendlyColor = config.FriendlyColor or Color3.fromRGB(50, 255, 50)

        -- State
        self._drawings = {}
        self._connections = {}
        self._running = false

        return self
    end

    --// Create ESP instance
    function ESP:Create(parent)
        -- ESP uses Drawing library for Roblox executors
        -- This is a fallback using frames for non-executor environments

        local container = Instance.new("Frame")
        container.Name = "ESPContainer"
        container.Size = UDim2.new(1, 0, 1, 0)
        container.BackgroundTransparency = 1
        container.Parent = parent

        self.Instance = container

        return self
    end

    --// Check if player is on same team
    function ESP:_isFriendly(player)
        local localPlayer = Players.LocalPlayer
        if not localPlayer or not self.TeamCheck then return false end

        return player.Team and localPlayer.Team and player.Team == localPlayer.Team
    end

    --// Get screen position from world position
    function ESP:_worldToScreen(position)
        local camera = Workspace.CurrentCamera
        if not camera then return nil, false end

        local screenPos, onScreen = camera:WorldToViewportPoint(position)
        return Vector2.new(screenPos.X, screenPos.Y), onScreen
    end

    --// Create or update player ESP
    function ESP:_updatePlayerESP(player)
        local character = player.Character
        if not character then return end

        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        local head = character:FindFirstChild("Head")

        if not humanoid or not rootPart or not head then return end
        if humanoid.Health <= 0 then return end

        local localPlayer = Players.LocalPlayer
        if player == localPlayer then return end

        -- Distance check
        local localCharacter = localPlayer and localPlayer.Character
        local localRoot = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")

        local distance = 0
        if localRoot then
            distance = (rootPart.Position - localRoot.Position).Magnitude
            if distance > self.MaxDistance then
                self:_hidePlayerESP(player)
                return
            end
        end

        -- Team check
        local isFriendly = self:_isFriendly(player)
        if self.TeamCheck and isFriendly then
            self:_hidePlayerESP(player)
            return
        end

        -- Get ESP color
        local espColor = self.BoxColor
        if self.TeamColor and player.Team then
            espColor = player.TeamColor.Color
        elseif isFriendly then
            espColor = self.FriendlyColor
        else
            espColor = self.EnemyColor
        end

        -- Get screen positions
        local rootScreen, rootOnScreen = self:_worldToScreen(rootPart.Position)
        local headScreen, headOnScreen = self:_worldToScreen(head.Position + Vector3.new(0, 1, 0))

        if not rootOnScreen and not headOnScreen then
            self:_hidePlayerESP(player)
            return
        end

        -- Create/update drawings
        local drawings = self._drawings[player.UserId]
        if not drawings then
            drawings = self:_createPlayerDrawings(player)
            self._drawings[player.UserId] = drawings
        end

        -- Update box
        if self.ShowBox and drawings.box then
            local boxHeight = math.abs(headScreen.Y - rootScreen.Y) + 20
            local boxWidth = boxHeight * 0.6

            drawings.box.Visible = true
            drawings.box.Position = UDim2.new(0, rootScreen.X - boxWidth/2, 0, headScreen.Y - 10)
            drawings.box.Size = UDim2.new(0, boxWidth, 0, boxHeight)

            if drawings.boxStroke then
                drawings.boxStroke.Color = espColor
            end
        end

        -- Update name
        if self.ShowName and drawings.name then
            drawings.name.Visible = true
            drawings.name.Position = UDim2.new(0, rootScreen.X, 0, headScreen.Y - 25)
            drawings.name.Text = player.DisplayName
            drawings.name.TextColor3 = self.NameColor
        end

        -- Update health
        if self.ShowHealth and drawings.health then
            local healthPercent = humanoid.Health / humanoid.MaxHealth

            drawings.health.Visible = true
            drawings.healthBar.Visible = true

            local boxHeight = math.abs(headScreen.Y - rootScreen.Y) + 20
            local boxWidth = boxHeight * 0.6

            drawings.health.Position = UDim2.new(0, rootScreen.X - boxWidth/2 - 6, 0, headScreen.Y - 10)
            drawings.health.Size = UDim2.new(0, 4, 0, boxHeight)

            drawings.healthBar.Size = UDim2.new(1, 0, healthPercent, 0)
            drawings.healthBar.Position = UDim2.new(0, 0, 1 - healthPercent, 0)
            drawings.healthBar.BackgroundColor3 = Color3.fromRGB(
                255 * (1 - healthPercent),
                255 * healthPercent,
                0
            )
        end

        -- Update distance
        if self.ShowDistance and drawings.distance then
            drawings.distance.Visible = true
            drawings.distance.Position = UDim2.new(0, rootScreen.X, 0, rootScreen.Y + 5)
            drawings.distance.Text = string.format("[%dm]", math.floor(distance))
            drawings.distance.TextColor3 = self.DistanceColor
        end

        -- Update tracer
        if self.ShowTracers and drawings.tracer then
            local camera = Workspace.CurrentCamera
            local viewportSize = camera.ViewportSize

            drawings.tracer.Visible = true
            drawings.tracer.Position = UDim2.new(0, viewportSize.X / 2, 0, viewportSize.Y)
            -- Tracer line would connect to player position
        end
    end

    --// Create player drawings
    function ESP:_createPlayerDrawings(player)
        local drawings = {}

        -- Box
        if self.ShowBox then
            local box = Instance.new("Frame")
            box.Name = "Box"
            box.BackgroundTransparency = 1
            box.BorderSizePixel = 0
            box.Visible = false
            box.Parent = self.Instance

            local stroke = Instance.new("UIStroke")
            stroke.Color = self.BoxColor
            stroke.Thickness = 1
            stroke.Parent = box

            drawings.box = box
            drawings.boxStroke = stroke
        end

        -- Name
        if self.ShowName then
            local name = Instance.new("TextLabel")
            name.Name = "Name"
            name.BackgroundTransparency = 1
            name.Font = Enum.Font.GothamMedium
            name.TextSize = 13
            name.TextStrokeTransparency = 0.5
            name.AnchorPoint = Vector2.new(0.5, 1)
            name.Visible = false
            name.Parent = self.Instance

            drawings.name = name
        end

        -- Health bar
        if self.ShowHealth then
            local health = Instance.new("Frame")
            health.Name = "HealthBg"
            health.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            health.BorderSizePixel = 0
            health.Visible = false
            health.Parent = self.Instance

            local healthCorner = Instance.new("UICorner")
            healthCorner.CornerRadius = UDim.new(0, 2)
            healthCorner.Parent = health

            local healthBar = Instance.new("Frame")
            healthBar.Name = "HealthBar"
            healthBar.BackgroundColor3 = self.HealthColor
            healthBar.BorderSizePixel = 0
            healthBar.AnchorPoint = Vector2.new(0, 1)
            healthBar.Parent = health

            local healthBarCorner = Instance.new("UICorner")
            healthBarCorner.CornerRadius = UDim.new(0, 2)
            healthBarCorner.Parent = healthBar

            drawings.health = health
            drawings.healthBar = healthBar
        end

        -- Distance
        if self.ShowDistance then
            local distance = Instance.new("TextLabel")
            distance.Name = "Distance"
            distance.BackgroundTransparency = 1
            distance.Font = Enum.Font.Gotham
            distance.TextSize = 11
            distance.TextStrokeTransparency = 0.5
            distance.AnchorPoint = Vector2.new(0.5, 0)
            distance.Visible = false
            distance.Parent = self.Instance

            drawings.distance = distance
        end

        return drawings
    end

    --// Hide player ESP
    function ESP:_hidePlayerESP(player)
        local drawings = self._drawings[player.UserId]
        if not drawings then return end

        for _, drawing in pairs(drawings) do
            if typeof(drawing) == "Instance" then
                drawing.Visible = false
            end
        end
    end

    --// Remove player ESP
    function ESP:_removePlayerESP(player)
        local drawings = self._drawings[player.UserId]
        if not drawings then return end

        for _, drawing in pairs(drawings) do
            if typeof(drawing) == "Instance" then
                drawing:Destroy()
            end
        end

        self._drawings[player.UserId] = nil
    end

    --// Start ESP
    function ESP:Start()
        if self._running then return self end
        self._running = true
        self.Enabled = true

        -- Update loop
        local updateConnection = RunService.RenderStepped:Connect(function()
            if not self.Enabled then return end

            for _, player in ipairs(Players:GetPlayers()) do
                self:_updatePlayerESP(player)
            end
        end)
        table.insert(self._connections, updateConnection)

        -- Player added/removed
        table.insert(self._connections, Players.PlayerAdded:Connect(function(player)
            -- Will be handled by update loop
        end))

        table.insert(self._connections, Players.PlayerRemoving:Connect(function(player)
            self:_removePlayerESP(player)
        end))

        return self
    end

    --// Stop ESP
    function ESP:Stop()
        self._running = false
        self.Enabled = false

        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        -- Hide all drawings
        for _, player in ipairs(Players:GetPlayers()) do
            self:_hidePlayerESP(player)
        end

        return self
    end

    --// Toggle
    function ESP:Toggle()
        if self.Enabled then
            self:Stop()
        else
            self:Start()
        end
        return self
    end

    --// Set option
    function ESP:SetOption(option, value)
        self[option] = value
        return self
    end

    --// Destroy
    function ESP:Destroy()
        self:Stop()

        for userId, drawings in pairs(self._drawings) do
            for _, drawing in pairs(drawings) do
                if typeof(drawing) == "Instance" then
                    drawing:Destroy()
                end
            end
        end
        self._drawings = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return ESP


end


-- ============================================================================
-- Module: NexusUI/Special/Watermark
-- ============================================================================
NexusUI_Modules["NexusUI/Special/Watermark"] = function()
    local script = CreateMockScript("NexusUI/Special/Watermark")
    
    --[[
        NexusUI Watermark Component
        Customizable watermark/branding display
    ]]

    --// Services
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local TweenService = game:GetService("TweenService")

    --// Watermark Module
    local Watermark = {}
    Watermark.__index = Watermark
    Watermark.ClassName = "Watermark"

    --// Constructor
    function Watermark.new(config)
        local self = setmetatable({}, Watermark)

        config = config or {}

        self.Title = config.Title or "NexusUI"
        self.Subtitle = config.Subtitle or nil
        self.ShowFPS = config.ShowFPS or false
        self.ShowPing = config.ShowPing or false
        self.ShowTime = config.ShowTime or false
        self.ShowUsername = config.ShowUsername or false
        self.Position = config.Position or "TopRight" -- TopRight, TopLeft, BottomRight, BottomLeft
        self.Draggable = config.Draggable or false

        -- Colors
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(18, 18, 21)
        self.TextColor = config.TextColor or Color3.fromRGB(250, 250, 250)
        self.AccentColor = config.AccentColor or Color3.fromRGB(99, 102, 241)

        -- State
        self._fps = 60
        self._ping = 0
        self._frameCount = 0
        self._lastTime = os.clock()
        self._connections = {}

        return self
    end

    --// Get position UDim2
    function Watermark:_getPositionConfig()
        local positions = {
            TopRight = {
                Position = UDim2.new(1, -10, 0, 10),
                AnchorPoint = Vector2.new(1, 0),
            },
            TopLeft = {
                Position = UDim2.new(0, 10, 0, 10),
                AnchorPoint = Vector2.new(0, 0),
            },
            BottomRight = {
                Position = UDim2.new(1, -10, 1, -10),
                AnchorPoint = Vector2.new(1, 1),
            },
            BottomLeft = {
                Position = UDim2.new(0, 10, 1, -10),
                AnchorPoint = Vector2.new(0, 1),
            },
        }

        return positions[self.Position] or positions.TopRight
    end

    --// Create watermark
    function Watermark:Create(parent)
        local posConfig = self:_getPositionConfig()

        local watermark = Instance.new("Frame")
        watermark.Name = "Watermark"
        watermark.Size = UDim2.new(0, 0, 0, 26)
        watermark.AutomaticSize = Enum.AutomaticSize.X
        watermark.Position = posConfig.Position
        watermark.AnchorPoint = posConfig.AnchorPoint
        watermark.BackgroundColor3 = self.BackgroundColor
        watermark.BorderSizePixel = 0

        if parent then
            watermark.Parent = parent
        end

        self.Instance = watermark

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 6)
        corner.Parent = watermark

        local stroke = Instance.new("UIStroke")
        stroke.Color = Color3.fromRGB(39, 39, 42)
        stroke.Thickness = 1
        stroke.Parent = watermark

        local padding = Instance.new("UIPadding")
        padding.PaddingLeft = UDim.new(0, 10)
        padding.PaddingRight = UDim.new(0, 10)
        padding.Parent = watermark

        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.Padding = UDim.new(0, 8)
        layout.Parent = watermark

        -- Accent bar
        local accent = Instance.new("Frame")
        accent.Size = UDim2.new(0, 3, 0.6, 0)
        accent.BackgroundColor3 = self.AccentColor
        accent.BorderSizePixel = 0
        accent.LayoutOrder = 1
        accent.Parent = watermark

        local accentCorner = Instance.new("UICorner")
        accentCorner.CornerRadius = UDim.new(1, 0)
        accentCorner.Parent = accent

        -- Title
        local title = Instance.new("TextLabel")
        title.Size = UDim2.new(0, 0, 1, 0)
        title.AutomaticSize = Enum.AutomaticSize.X
        title.BackgroundTransparency = 1
        title.Font = Enum.Font.GothamBold
        title.Text = self.Title
        title.TextColor3 = self.TextColor
        title.TextSize = 12
        title.LayoutOrder = 2
        title.Parent = watermark
        self._titleLabel = title

        -- Subtitle
        if self.Subtitle then
            local subtitle = Instance.new("TextLabel")
            subtitle.Size = UDim2.new(0, 0, 1, 0)
            subtitle.AutomaticSize = Enum.AutomaticSize.X
            subtitle.BackgroundTransparency = 1
            subtitle.Font = Enum.Font.Gotham
            subtitle.Text = self.Subtitle
            subtitle.TextColor3 = Color3.fromRGB(113, 113, 122)
            subtitle.TextSize = 11
            subtitle.LayoutOrder = 3
            subtitle.Parent = watermark
            self._subtitleLabel = subtitle
        end

        -- Separator
        local addSeparator = function(order)
            local sep = Instance.new("Frame")
            sep.Size = UDim2.new(0, 1, 0.5, 0)
            sep.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
            sep.BorderSizePixel = 0
            sep.LayoutOrder = order
            sep.Parent = watermark
            return sep
        end

        -- Info items
        local currentOrder = 10

        if self.ShowUsername then
            addSeparator(currentOrder)
            currentOrder = currentOrder + 1

            local username = Instance.new("TextLabel")
            username.Size = UDim2.new(0, 0, 1, 0)
            username.AutomaticSize = Enum.AutomaticSize.X
            username.BackgroundTransparency = 1
            username.Font = Enum.Font.Gotham
            username.Text = Players.LocalPlayer.Name
            username.TextColor3 = Color3.fromRGB(161, 161, 170)
            username.TextSize = 11
            username.LayoutOrder = currentOrder
            username.Parent = watermark
            currentOrder = currentOrder + 1
        end

        if self.ShowFPS then
            addSeparator(currentOrder)
            currentOrder = currentOrder + 1

            local fps = Instance.new("TextLabel")
            fps.Name = "FPS"
            fps.Size = UDim2.new(0, 40, 1, 0)
            fps.BackgroundTransparency = 1
            fps.Font = Enum.Font.GothamMedium
            fps.Text = "60 FPS"
            fps.TextColor3 = Color3.fromRGB(34, 197, 94)
            fps.TextSize = 11
            fps.LayoutOrder = currentOrder
            fps.Parent = watermark
            self._fpsLabel = fps
            currentOrder = currentOrder + 1
        end

        if self.ShowPing then
            addSeparator(currentOrder)
            currentOrder = currentOrder + 1

            local ping = Instance.new("TextLabel")
            ping.Name = "Ping"
            ping.Size = UDim2.new(0, 45, 1, 0)
            ping.BackgroundTransparency = 1
            ping.Font = Enum.Font.GothamMedium
            ping.Text = "0 ms"
            ping.TextColor3 = Color3.fromRGB(59, 130, 246)
            ping.TextSize = 11
            ping.LayoutOrder = currentOrder
            ping.Parent = watermark
            self._pingLabel = ping
            currentOrder = currentOrder + 1
        end

        if self.ShowTime then
            addSeparator(currentOrder)
            currentOrder = currentOrder + 1

            local time = Instance.new("TextLabel")
            time.Name = "Time"
            time.Size = UDim2.new(0, 50, 1, 0)
            time.BackgroundTransparency = 1
            time.Font = Enum.Font.Gotham
            time.Text = os.date("%H:%M")
            time.TextColor3 = Color3.fromRGB(161, 161, 170)
            time.TextSize = 11
            time.LayoutOrder = currentOrder
            time.Parent = watermark
            self._timeLabel = time
        end

        -- Draggable
        if self.Draggable then
            self:_setupDragging()
        end

        -- Start update loop
        self:_startUpdating()

        return self
    end

    --// Setup dragging
    function Watermark:_setupDragging()
        local dragging = false
        local dragStart = nil
        local startPos = nil

        local dragInput = Instance.new("TextButton")
        dragInput.Size = UDim2.new(1, 0, 1, 0)
        dragInput.BackgroundTransparency = 1
        dragInput.Text = ""
        dragInput.ZIndex = 2
        dragInput.Parent = self.Instance

        table.insert(self._connections, dragInput.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
                dragStart = input.Position
                startPos = self.Instance.Position
            end
        end))

        table.insert(self._connections, dragInput.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = false
            end
        end))

        table.insert(self._connections, game:GetService("UserInputService").InputChanged:Connect(function(input)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local delta = input.Position - dragStart
                self.Instance.Position = UDim2.new(
                    startPos.X.Scale,
                    startPos.X.Offset + delta.X,
                    startPos.Y.Scale,
                    startPos.Y.Offset + delta.Y
                )
            end
        end))
    end

    --// Start update loop
    function Watermark:_startUpdating()
        -- FPS counter
        if self.ShowFPS then
            table.insert(self._connections, RunService.Heartbeat:Connect(function()
                self._frameCount = self._frameCount + 1

                local now = os.clock()
                local elapsed = now - self._lastTime

                if elapsed >= 0.5 then
                    self._fps = self._frameCount / elapsed
                    self._frameCount = 0
                    self._lastTime = now

                    local fps = math.floor(self._fps + 0.5)
                    self._fpsLabel.Text = fps .. " FPS"

                    -- Color based on FPS
                    if fps >= 50 then
                        self._fpsLabel.TextColor3 = Color3.fromRGB(34, 197, 94)
                    elseif fps >= 30 then
                        self._fpsLabel.TextColor3 = Color3.fromRGB(245, 158, 11)
                    else
                        self._fpsLabel.TextColor3 = Color3.fromRGB(239, 68, 68)
                    end
                end
            end))
        end

        -- Ping updater
        if self.ShowPing then
            task.spawn(function()
                while self.Instance and self.Instance.Parent do
                    local success, ping = pcall(function()
                        return Players.LocalPlayer:GetNetworkPing()
                    end)

                    if success then
                        self._ping = math.floor(ping * 1000 + 0.5)
                        self._pingLabel.Text = self._ping .. " ms"

                        if self._ping < 80 then
                            self._pingLabel.TextColor3 = Color3.fromRGB(59, 130, 246)
                        elseif self._ping < 150 then
                            self._pingLabel.TextColor3 = Color3.fromRGB(245, 158, 11)
                        else
                            self._pingLabel.TextColor3 = Color3.fromRGB(239, 68, 68)
                        end
                    end

                    task.wait(1)
                end
            end)
        end

        -- Time updater
        if self.ShowTime then
            task.spawn(function()
                while self.Instance and self.Instance.Parent do
                    self._timeLabel.Text = os.date("%H:%M")
                    task.wait(1)
                end
            end)
        end
    end

    --// Set title
    function Watermark:SetTitle(title)
        self.Title = title
        if self._titleLabel then
            self._titleLabel.Text = title
        end
        return self
    end

    --// Set subtitle
    function Watermark:SetSubtitle(subtitle)
        self.Subtitle = subtitle
        if self._subtitleLabel then
            self._subtitleLabel.Text = subtitle
        end
        return self
    end

    --// Toggle visibility
    function Watermark:Toggle()
        self.Instance.Visible = not self.Instance.Visible
        return self
    end

    --// Destroy
    function Watermark:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return Watermark


end


-- ============================================================================
-- Module: NexusUI/Special/Crosshair
-- ============================================================================
NexusUI_Modules["NexusUI/Special/Crosshair"] = function()
    local script = CreateMockScript("NexusUI/Special/Crosshair")
    
    --[[
        NexusUI Crosshair Component
        Customizable crosshair overlay
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Crosshair Module
    local Crosshair = {}
    Crosshair.__index = Crosshair
    Crosshair.ClassName = "Crosshair"

    --// Crosshair types
    Crosshair.Type = {
        Cross = "Cross",
        Dot = "Dot",
        Circle = "Circle",
        Square = "Square",
        Custom = "Custom",
    }

    --// Constructor
    function Crosshair.new(config)
        local self = setmetatable({}, Crosshair)

        config = config or {}

        self.CrosshairType = config.Type or Crosshair.Type.Cross
        self.Size = config.Size or 10
        self.Gap = config.Gap or 4
        self.Thickness = config.Thickness or 2
        self.Outline = config.Outline ~= false
        self.OutlineThickness = config.OutlineThickness or 1
        self.Dynamic = config.Dynamic or false -- Expand when moving

        -- Colors
        self.Color = config.Color or Color3.fromRGB(0, 255, 0)
        self.OutlineColor = config.OutlineColor or Color3.fromRGB(0, 0, 0)

        -- State
        self._lines = {}
        self._connections = {}

        return self
    end

    --// Create crosshair
    function Crosshair:Create(parent)
        local crosshair = Instance.new("Frame")
        crosshair.Name = "Crosshair"
        crosshair.Size = UDim2.new(0, self.Size * 2 + self.Gap * 2, 0, self.Size * 2 + self.Gap * 2)
        crosshair.Position = UDim2.new(0.5, 0, 0.5, 0)
        crosshair.AnchorPoint = Vector2.new(0.5, 0.5)
        crosshair.BackgroundTransparency = 1

        if parent then
            crosshair.Parent = parent
        end

        self.Instance = crosshair

        -- Create crosshair based on type
        if self.CrosshairType == Crosshair.Type.Cross then
            self:_createCross()
        elseif self.CrosshairType == Crosshair.Type.Dot then
            self:_createDot()
        elseif self.CrosshairType == Crosshair.Type.Circle then
            self:_createCircle()
        elseif self.CrosshairType == Crosshair.Type.Square then
            self:_createSquare()
        end

        return self
    end

    --// Create cross crosshair
    function Crosshair:_createCross()
        local centerX = self.Size + self.Gap
        local centerY = self.Size + self.Gap

        -- Top line
        local top = self:_createLine(
            UDim2.new(0.5, 0, 0, 0),
            UDim2.new(0, self.Thickness, 0, self.Size),
            Vector2.new(0.5, 0)
        )
        table.insert(self._lines, top)

        -- Bottom line
        local bottom = self:_createLine(
            UDim2.new(0.5, 0, 1, 0),
            UDim2.new(0, self.Thickness, 0, self.Size),
            Vector2.new(0.5, 1)
        )
        table.insert(self._lines, bottom)

        -- Left line
        local left = self:_createLine(
            UDim2.new(0, 0, 0.5, 0),
            UDim2.new(0, self.Size, 0, self.Thickness),
            Vector2.new(0, 0.5)
        )
        table.insert(self._lines, left)

        -- Right line
        local right = self:_createLine(
            UDim2.new(1, 0, 0.5, 0),
            UDim2.new(0, self.Size, 0, self.Thickness),
            Vector2.new(1, 0.5)
        )
        table.insert(self._lines, right)

        -- Center dot (optional)
        local dot = Instance.new("Frame")
        dot.Size = UDim2.new(0, self.Thickness, 0, self.Thickness)
        dot.Position = UDim2.new(0.5, 0, 0.5, 0)
        dot.AnchorPoint = Vector2.new(0.5, 0.5)
        dot.BackgroundColor3 = self.Color
        dot.BorderSizePixel = 0
        dot.Parent = self.Instance

        if self.Outline then
            local dotStroke = Instance.new("UIStroke")
            dotStroke.Color = self.OutlineColor
            dotStroke.Thickness = self.OutlineThickness
            dotStroke.Parent = dot
        end
    end

    --// Create line helper
    function Crosshair:_createLine(position, size, anchorPoint)
        local line = Instance.new("Frame")
        line.Size = size
        line.Position = position
        line.AnchorPoint = anchorPoint
        line.BackgroundColor3 = self.Color
        line.BorderSizePixel = 0
        line.Parent = self.Instance

        if self.Outline then
            local stroke = Instance.new("UIStroke")
            stroke.Color = self.OutlineColor
            stroke.Thickness = self.OutlineThickness
            stroke.Parent = line
        end

        return line
    end

    --// Create dot crosshair
    function Crosshair:_createDot()
        local dot = Instance.new("Frame")
        dot.Size = UDim2.new(0, self.Size, 0, self.Size)
        dot.Position = UDim2.new(0.5, 0, 0.5, 0)
        dot.AnchorPoint = Vector2.new(0.5, 0.5)
        dot.BackgroundColor3 = self.Color
        dot.BorderSizePixel = 0
        dot.Parent = self.Instance

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(1, 0)
        corner.Parent = dot

        if self.Outline then
            local stroke = Instance.new("UIStroke")
            stroke.Color = self.OutlineColor
            stroke.Thickness = self.OutlineThickness
            stroke.Parent = dot
        end

        table.insert(self._lines, dot)
    end

    --// Create circle crosshair
    function Crosshair:_createCircle()
        local circle = Instance.new("Frame")
        circle.Size = UDim2.new(0, self.Size * 2, 0, self.Size * 2)
        circle.Position = UDim2.new(0.5, 0, 0.5, 0)
        circle.AnchorPoint = Vector2.new(0.5, 0.5)
        circle.BackgroundTransparency = 1
        circle.BorderSizePixel = 0
        circle.Parent = self.Instance

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(1, 0)
        corner.Parent = circle

        local stroke = Instance.new("UIStroke")
        stroke.Color = self.Color
        stroke.Thickness = self.Thickness
        stroke.Parent = circle

        if self.Outline then
            -- Inner outline would need separate element
        end

        table.insert(self._lines, circle)

        -- Center dot
        local dot = Instance.new("Frame")
        dot.Size = UDim2.new(0, self.Thickness, 0, self.Thickness)
        dot.Position = UDim2.new(0.5, 0, 0.5, 0)
        dot.AnchorPoint = Vector2.new(0.5, 0.5)
        dot.BackgroundColor3 = self.Color
        dot.BorderSizePixel = 0
        dot.Parent = self.Instance

        local dotCorner = Instance.new("UICorner")
        dotCorner.CornerRadius = UDim.new(1, 0)
        dotCorner.Parent = dot
    end

    --// Create square crosshair
    function Crosshair:_createSquare()
        local square = Instance.new("Frame")
        square.Size = UDim2.new(0, self.Size * 2, 0, self.Size * 2)
        square.Position = UDim2.new(0.5, 0, 0.5, 0)
        square.AnchorPoint = Vector2.new(0.5, 0.5)
        square.BackgroundTransparency = 1
        square.BorderSizePixel = 0
        square.Parent = self.Instance

        local stroke = Instance.new("UIStroke")
        stroke.Color = self.Color
        stroke.Thickness = self.Thickness
        stroke.Parent = square

        table.insert(self._lines, square)
    end

    --// Set color
    function Crosshair:SetColor(color)
        self.Color = color

        for _, line in ipairs(self._lines) do
            if line:IsA("Frame") then
                if line.BackgroundTransparency < 1 then
                    line.BackgroundColor3 = color
                end

                local stroke = line:FindFirstChildOfClass("UIStroke")
                if stroke and stroke.Color ~= self.OutlineColor then
                    stroke.Color = color
                end
            end
        end

        return self
    end

    --// Set size
    function Crosshair:SetSize(size)
        self.Size = size
        -- Would need to rebuild
        return self
    end

    --// Toggle visibility
    function Crosshair:Toggle()
        self.Instance.Visible = not self.Instance.Visible
        return self
    end

    --// Destroy
    function Crosshair:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return Crosshair


end


-- ============================================================================
-- Module: NexusUI/Special/Aimbot
-- ============================================================================
NexusUI_Modules["NexusUI/Special/Aimbot"] = function()
    local script = CreateMockScript("NexusUI/Special/Aimbot")
    
    --[[
        NexusUI Aimbot Component
        Aimbot/aim assist configuration panel
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Aimbot Module (UI only - settings panel)
    local Aimbot = {}
    Aimbot.__index = Aimbot
    Aimbot.ClassName = "AimbotSettings"

    --// Constructor
    function Aimbot.new(config)
        local self = setmetatable({}, Aimbot)

        config = config or {}

        -- Settings
        self.Enabled = config.Enabled or false
        self.FOV = config.FOV or 100
        self.Smoothness = config.Smoothness or 10
        self.TargetPart = config.TargetPart or "Head"
        self.TeamCheck = config.TeamCheck ~= false
        self.WallCheck = config.WallCheck ~= false
        self.ShowFOV = config.ShowFOV or false
        self.AimKey = config.AimKey or Enum.UserInputType.MouseButton2
        self.Prediction = config.Prediction or false
        self.PredictionAmount = config.PredictionAmount or 0.1

        -- Callbacks
        self.OnSettingsChanged = config.OnSettingsChanged

        -- State
        self._connections = {}

        return self
    end

    --// Create settings panel
    function Aimbot:Create(parent)
        local panel = Instance.new("Frame")
        panel.Name = "AimbotSettings"
        panel.Size = UDim2.new(0, 280, 0, 0)
        panel.AutomaticSize = Enum.AutomaticSize.Y
        panel.BackgroundColor3 = Color3.fromRGB(24, 24, 27)
        panel.BorderSizePixel = 0

        if parent then
            panel.Parent = parent
        end

        self.Instance = panel

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = panel

        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, 12)
        padding.PaddingBottom = UDim.new(0, 12)
        padding.PaddingLeft = UDim.new(0, 12)
        padding.PaddingRight = UDim.new(0, 12)
        padding.Parent = panel

        local layout = Instance.new("UIListLayout")
        layout.Padding = UDim.new(0, 8)
        layout.Parent = panel

        -- Header
        local header = Instance.new("TextLabel")
        header.Size = UDim2.new(1, 0, 0, 20)
        header.BackgroundTransparency = 1
        header.Font = Enum.Font.GothamBold
        header.Text = "Aimbot Settings"
        header.TextColor3 = Color3.fromRGB(250, 250, 250)
        header.TextSize = 14
        header.TextXAlignment = Enum.TextXAlignment.Left
        header.LayoutOrder = 1
        header.Parent = panel

        -- Enabled toggle
        self:_createToggle("Enabled", self.Enabled, function(value)
            self.Enabled = value
            self:_notifyChange()
        end, 2)

        -- FOV slider
        self:_createSlider("FOV", self.FOV, 10, 500, function(value)
            self.FOV = value
            self:_notifyChange()
        end, 3)

        -- Smoothness slider
        self:_createSlider("Smoothness", self.Smoothness, 1, 50, function(value)
            self.Smoothness = value
            self:_notifyChange()
        end, 4)

        -- Target part dropdown
        self:_createDropdown("Target Part", {"Head", "Torso", "Random"}, self.TargetPart, function(value)
            self.TargetPart = value
            self:_notifyChange()
        end, 5)

        -- Team check toggle
        self:_createToggle("Team Check", self.TeamCheck, function(value)
            self.TeamCheck = value
            self:_notifyChange()
        end, 6)

        -- Wall check toggle
        self:_createToggle("Wall Check", self.WallCheck, function(value)
            self.WallCheck = value
            self:_notifyChange()
        end, 7)

        -- Show FOV toggle
        self:_createToggle("Show FOV Circle", self.ShowFOV, function(value)
            self.ShowFOV = value
            self:_notifyChange()
        end, 8)

        -- Prediction toggle
        self:_createToggle("Prediction", self.Prediction, function(value)
            self.Prediction = value
            self:_notifyChange()
        end, 9)

        return self
    end

    --// Create toggle helper
    function Aimbot:_createToggle(name, defaultValue, callback, order)
        local row = Instance.new("Frame")
        row.Size = UDim2.new(1, 0, 0, 28)
        row.BackgroundTransparency = 1
        row.LayoutOrder = order
        row.Parent = self.Instance

        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, -50, 1, 0)
        label.BackgroundTransparency = 1
        label.Font = Enum.Font.Gotham
        label.Text = name
        label.TextColor3 = Color3.fromRGB(161, 161, 170)
        label.TextSize = 12
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = row

        local toggle = Instance.new("Frame")
        toggle.Size = UDim2.new(0, 40, 0, 20)
        toggle.Position = UDim2.new(1, 0, 0.5, 0)
        toggle.AnchorPoint = Vector2.new(1, 0.5)
        toggle.BackgroundColor3 = defaultValue and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(63, 63, 70)
        toggle.BorderSizePixel = 0
        toggle.Parent = row

        local toggleCorner = Instance.new("UICorner")
        toggleCorner.CornerRadius = UDim.new(1, 0)
        toggleCorner.Parent = toggle

        local knob = Instance.new("Frame")
        knob.Size = UDim2.new(0, 16, 0, 16)
        knob.Position = defaultValue and UDim2.new(1, -18, 0.5, 0) or UDim2.new(0, 2, 0.5, 0)
        knob.AnchorPoint = Vector2.new(0, 0.5)
        knob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        knob.BorderSizePixel = 0
        knob.Parent = toggle

        local knobCorner = Instance.new("UICorner")
        knobCorner.CornerRadius = UDim.new(1, 0)
        knobCorner.Parent = knob

        local button = Instance.new("TextButton")
        button.Size = UDim2.new(1, 0, 1, 0)
        button.BackgroundTransparency = 1
        button.Text = ""
        button.Parent = toggle

        local enabled = defaultValue

        table.insert(self._connections, button.MouseButton1Click:Connect(function()
            enabled = not enabled

            TweenService:Create(toggle, TweenInfo.new(0.2), {
                BackgroundColor3 = enabled and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(63, 63, 70),
            }):Play()

            TweenService:Create(knob, TweenInfo.new(0.2), {
                Position = enabled and UDim2.new(1, -18, 0.5, 0) or UDim2.new(0, 2, 0.5, 0),
            }):Play()

            callback(enabled)
        end))
    end

    --// Create slider helper
    function Aimbot:_createSlider(name, defaultValue, min, max, callback, order)
        local row = Instance.new("Frame")
        row.Size = UDim2.new(1, 0, 0, 40)
        row.BackgroundTransparency = 1
        row.LayoutOrder = order
        row.Parent = self.Instance

        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, -40, 0, 16)
        label.BackgroundTransparency = 1
        label.Font = Enum.Font.Gotham
        label.Text = name
        label.TextColor3 = Color3.fromRGB(161, 161, 170)
        label.TextSize = 12
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = row

        local valueLabel = Instance.new("TextLabel")
        valueLabel.Size = UDim2.new(0, 40, 0, 16)
        valueLabel.Position = UDim2.new(1, 0, 0, 0)
        valueLabel.AnchorPoint = Vector2.new(1, 0)
        valueLabel.BackgroundTransparency = 1
        valueLabel.Font = Enum.Font.GothamMedium
        valueLabel.Text = tostring(math.floor(defaultValue))
        valueLabel.TextColor3 = Color3.fromRGB(99, 102, 241)
        valueLabel.TextSize = 12
        valueLabel.TextXAlignment = Enum.TextXAlignment.Right
        valueLabel.Parent = row

        local track = Instance.new("Frame")
        track.Size = UDim2.new(1, 0, 0, 6)
        track.Position = UDim2.new(0, 0, 0, 24)
        track.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
        track.BorderSizePixel = 0
        track.Parent = row

        local trackCorner = Instance.new("UICorner")
        trackCorner.CornerRadius = UDim.new(1, 0)
        trackCorner.Parent = track

        local fill = Instance.new("Frame")
        fill.Size = UDim2.new((defaultValue - min) / (max - min), 0, 1, 0)
        fill.BackgroundColor3 = Color3.fromRGB(99, 102, 241)
        fill.BorderSizePixel = 0
        fill.Parent = track

        local fillCorner = Instance.new("UICorner")
        fillCorner.CornerRadius = UDim.new(1, 0)
        fillCorner.Parent = fill

        local input = Instance.new("TextButton")
        input.Size = UDim2.new(1, 0, 1, 10)
        input.Position = UDim2.new(0, 0, 0, -5)
        input.BackgroundTransparency = 1
        input.Text = ""
        input.Parent = track

        local dragging = false

        local function update(inputX)
            local relativeX = math.clamp((inputX - track.AbsolutePosition.X) / track.AbsoluteSize.X, 0, 1)
            local value = min + (max - min) * relativeX

            fill.Size = UDim2.new(relativeX, 0, 1, 0)
            valueLabel.Text = tostring(math.floor(value))

            callback(value)
        end

        table.insert(self._connections, input.InputBegan:Connect(function(inputObj)
            if inputObj.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
                update(inputObj.Position.X)
            end
        end))

        table.insert(self._connections, input.InputEnded:Connect(function(inputObj)
            if inputObj.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = false
            end
        end))

        table.insert(self._connections, game:GetService("UserInputService").InputChanged:Connect(function(inputObj)
            if dragging and inputObj.UserInputType == Enum.UserInputType.MouseMovement then
                update(inputObj.Position.X)
            end
        end))
    end

    --// Create dropdown helper (simplified)
    function Aimbot:_createDropdown(name, options, defaultValue, callback, order)
        local row = Instance.new("Frame")
        row.Size = UDim2.new(1, 0, 0, 28)
        row.BackgroundTransparency = 1
        row.LayoutOrder = order
        row.Parent = self.Instance

        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(0.5, 0, 1, 0)
        label.BackgroundTransparency = 1
        label.Font = Enum.Font.Gotham
        label.Text = name
        label.TextColor3 = Color3.fromRGB(161, 161, 170)
        label.TextSize = 12
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = row

        local dropdown = Instance.new("TextButton")
        dropdown.Size = UDim2.new(0.5, -4, 1, 0)
        dropdown.Position = UDim2.new(0.5, 4, 0, 0)
        dropdown.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
        dropdown.BorderSizePixel = 0
        dropdown.Font = Enum.Font.Gotham
        dropdown.Text = defaultValue
        dropdown.TextColor3 = Color3.fromRGB(250, 250, 250)
        dropdown.TextSize = 11
        dropdown.AutoButtonColor = false
        dropdown.Parent = row

        local dropdownCorner = Instance.new("UICorner")
        dropdownCorner.CornerRadius = UDim.new(0, 4)
        dropdownCorner.Parent = dropdown

        local currentIndex = 1
        for i, opt in ipairs(options) do
            if opt == defaultValue then
                currentIndex = i
                break
            end
        end

        table.insert(self._connections, dropdown.MouseButton1Click:Connect(function()
            currentIndex = currentIndex % #options + 1
            dropdown.Text = options[currentIndex]
            callback(options[currentIndex])
        end))
    end

    --// Notify settings changed
    function Aimbot:_notifyChange()
        if self.OnSettingsChanged then
            self.OnSettingsChanged(self:GetSettings())
        end
    end

    --// Get settings
    function Aimbot:GetSettings()
        return {
            Enabled = self.Enabled,
            FOV = self.FOV,
            Smoothness = self.Smoothness,
            TargetPart = self.TargetPart,
            TeamCheck = self.TeamCheck,
            WallCheck = self.WallCheck,
            ShowFOV = self.ShowFOV,
            AimKey = self.AimKey,
            Prediction = self.Prediction,
            PredictionAmount = self.PredictionAmount,
        }
    end

    --// Set settings
    function Aimbot:SetSettings(settings)
        for key, value in pairs(settings) do
            self[key] = value
        end
        return self
    end

    --// Destroy
    function Aimbot:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return Aimbot


end


-- ============================================================================
-- Module: NexusUI/Special/Playerlist
-- ============================================================================
NexusUI_Modules["NexusUI/Special/Playerlist"] = function()
    local script = CreateMockScript("NexusUI/Special/Playerlist")
    
    --[[
        NexusUI Playerlist Component
        Enhanced player list with additional info
    ]]

    --// Services
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local TweenService = game:GetService("TweenService")

    --// Playerlist Module
    local Playerlist = {}
    Playerlist.__index = Playerlist
    Playerlist.ClassName = "Playerlist"

    --// Constructor
    function Playerlist.new(config)
        local self = setmetatable({}, Playerlist)

        config = config or {}

        self.Width = config.Width or 280
        self.Height = config.Height or 400
        self.ShowHealth = config.ShowHealth or false
        self.ShowTeam = config.ShowTeam ~= false
        self.ShowDistance = config.ShowDistance or false
        self.ShowAvatar = config.ShowAvatar ~= false
        self.ShowActions = config.ShowActions or false
        self.UpdateRate = config.UpdateRate or 1

        -- Colors
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
        self.HeaderColor = config.HeaderColor or Color3.fromRGB(18, 18, 21)
        self.TextColor = config.TextColor or Color3.fromRGB(250, 250, 250)
        self.SubTextColor = config.SubTextColor or Color3.fromRGB(113, 113, 122)

        -- Callbacks
        self.OnPlayerClick = config.OnPlayerClick

        -- State
        self._playerItems = {}
        self._connections = {}

        return self
    end

    --// Create playerlist
    function Playerlist:Create(parent)
        local playerlist = Instance.new("Frame")
        playerlist.Name = "Playerlist"
        playerlist.Size = UDim2.new(0, self.Width, 0, self.Height)
        playerlist.BackgroundColor3 = self.BackgroundColor
        playerlist.BorderSizePixel = 0

        if parent then
            playerlist.Parent = parent
        end

        self.Instance = playerlist

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 10)
        corner.Parent = playerlist

        local stroke = Instance.new("UIStroke")
        stroke.Color = Color3.fromRGB(39, 39, 42)
        stroke.Thickness = 1
        stroke.Parent = playerlist

        -- Header
        local header = Instance.new("Frame")
        header.Size = UDim2.new(1, 0, 0, 36)
        header.BackgroundColor3 = self.HeaderColor
        header.BorderSizePixel = 0
        header.Parent = playerlist

        local headerCorner = Instance.new("UICorner")
        headerCorner.CornerRadius = UDim.new(0, 10)
        headerCorner.Parent = header

        local headerFix = Instance.new("Frame")
        headerFix.Size = UDim2.new(1, 0, 0, 10)
        headerFix.Position = UDim2.new(0, 0, 1, -10)
        headerFix.BackgroundColor3 = self.HeaderColor
        headerFix.BorderSizePixel = 0
        headerFix.Parent = header

        local title = Instance.new("TextLabel")
        title.Size = UDim2.new(0.6, 0, 1, 0)
        title.Position = UDim2.new(0, 14, 0, 0)
        title.BackgroundTransparency = 1
        title.Font = Enum.Font.GothamBold
        title.Text = "Players"
        title.TextColor3 = self.TextColor
        title.TextSize = 13
        title.TextXAlignment = Enum.TextXAlignment.Left
        title.Parent = header

        local countLabel = Instance.new("TextLabel")
        countLabel.Name = "Count"
        countLabel.Size = UDim2.new(0, 50, 1, 0)
        countLabel.Position = UDim2.new(1, -60, 0, 0)
        countLabel.BackgroundTransparency = 1
        countLabel.Font = Enum.Font.GothamMedium
        countLabel.Text = #Players:GetPlayers() .. "/" .. Players.MaxPlayers
        countLabel.TextColor3 = self.SubTextColor
        countLabel.TextSize = 12
        countLabel.TextXAlignment = Enum.TextXAlignment.Right
        countLabel.Parent = header
        self._countLabel = countLabel

        -- Player list scroll
        local scroll = Instance.new("ScrollingFrame")
        scroll.Size = UDim2.new(1, -16, 1, -48)
        scroll.Position = UDim2.new(0, 8, 0, 42)
        scroll.BackgroundTransparency = 1
        scroll.BorderSizePixel = 0
        scroll.ScrollBarThickness = 4
        scroll.ScrollBarImageColor3 = Color3.fromRGB(63, 63, 70)
        scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
        scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
        scroll.Parent = playerlist
        self._scroll = scroll

        local scrollLayout = Instance.new("UIListLayout")
        scrollLayout.Padding = UDim.new(0, 4)
        scrollLayout.Parent = scroll

        -- Initialize player list
        self:_populatePlayers()

        -- Player events
        table.insert(self._connections, Players.PlayerAdded:Connect(function(player)
            self:_addPlayer(player)
            self:_updateCount()
        end))

        table.insert(self._connections, Players.PlayerRemoving:Connect(function(player)
            self:_removePlayer(player)
            self:_updateCount()
        end))

        -- Update loop
        task.spawn(function()
            while self.Instance and self.Instance.Parent do
                self:_updatePlayers()
                task.wait(self.UpdateRate)
            end
        end)

        return self
    end

    --// Populate initial players
    function Playerlist:_populatePlayers()
        for _, player in ipairs(Players:GetPlayers()) do
            self:_addPlayer(player)
        end
    end

    --// Add player item
    function Playerlist:_addPlayer(player)
        if self._playerItems[player.UserId] then return end

        local localPlayer = Players.LocalPlayer
        local isLocal = player == localPlayer

        local item = Instance.new("Frame")
        item.Name = "Player_" .. player.UserId
        item.Size = UDim2.new(1, 0, 0, self.ShowAvatar and 40 or 30)
        item.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        item.BackgroundTransparency = 0.5
        item.BorderSizePixel = 0
        item.Parent = self._scroll

        local itemCorner = Instance.new("UICorner")
        itemCorner.CornerRadius = UDim.new(0, 6)
        itemCorner.Parent = item

        -- Avatar
        if self.ShowAvatar then
            local avatar = Instance.new("ImageLabel")
            avatar.Size = UDim2.new(0, 28, 0, 28)
            avatar.Position = UDim2.new(0, 6, 0.5, 0)
            avatar.AnchorPoint = Vector2.new(0, 0.5)
            avatar.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
            avatar.BorderSizePixel = 0
            avatar.Parent = item

            local avatarCorner = Instance.new("UICorner")
            avatarCorner.CornerRadius = UDim.new(0, 6)
            avatarCorner.Parent = avatar

            -- Load avatar thumbnail
            task.spawn(function()
                local success, content = pcall(function()
                    return Players:GetUserThumbnailAsync(
                        player.UserId,
                        Enum.ThumbnailType.HeadShot,
                        Enum.ThumbnailSize.Size48x48
                    )
                end)
                if success and avatar.Parent then
                    avatar.Image = content
                end
            end)
        end

        -- Name
        local nameOffset = self.ShowAvatar and 42 or 10
        local name = Instance.new("TextLabel")
        name.Name = "Name"
        name.Size = UDim2.new(1, -nameOffset - 60, 0, 16)
        name.Position = UDim2.new(0, nameOffset, 0, self.ShowTeam and 4 or 7)
        name.BackgroundTransparency = 1
        name.Font = Enum.Font.GothamMedium
        name.Text = player.DisplayName
        name.TextColor3 = isLocal and Color3.fromRGB(99, 102, 241) or self.TextColor
        name.TextSize = 12
        name.TextXAlignment = Enum.TextXAlignment.Left
        name.TextTruncate = Enum.TextTruncate.AtEnd
        name.Parent = item

        -- Team/status
        if self.ShowTeam then
            local team = Instance.new("TextLabel")
            team.Name = "Team"
            team.Size = UDim2.new(1, -nameOffset - 60, 0, 12)
            team.Position = UDim2.new(0, nameOffset, 0, 20)
            team.BackgroundTransparency = 1
            team.Font = Enum.Font.Gotham
            team.Text = player.Team and player.Team.Name or "No Team"
            team.TextColor3 = player.Team and player.TeamColor.Color or self.SubTextColor
            team.TextSize = 10
            team.TextXAlignment = Enum.TextXAlignment.Left
            team.Parent = item
        end

        -- Health bar
        if self.ShowHealth then
            local healthBg = Instance.new("Frame")
            healthBg.Name = "HealthBg"
            healthBg.Size = UDim2.new(0, 40, 0, 4)
            healthBg.Position = UDim2.new(1, -50, 0.5, 0)
            healthBg.AnchorPoint = Vector2.new(0, 0.5)
            healthBg.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
            healthBg.BorderSizePixel = 0
            healthBg.Parent = item

            local healthCorner = Instance.new("UICorner")
            healthCorner.CornerRadius = UDim.new(1, 0)
            healthCorner.Parent = healthBg

            local healthFill = Instance.new("Frame")
            healthFill.Name = "Fill"
            healthFill.Size = UDim2.new(1, 0, 1, 0)
            healthFill.BackgroundColor3 = Color3.fromRGB(34, 197, 94)
            healthFill.BorderSizePixel = 0
            healthFill.Parent = healthBg

            local healthFillCorner = Instance.new("UICorner")
            healthFillCorner.CornerRadius = UDim.new(1, 0)
            healthFillCorner.Parent = healthFill
        end

        -- Distance
        if self.ShowDistance then
            local distance = Instance.new("TextLabel")
            distance.Name = "Distance"
            distance.Size = UDim2.new(0, 50, 1, 0)
            distance.Position = UDim2.new(1, -55, 0, 0)
            distance.BackgroundTransparency = 1
            distance.Font = Enum.Font.Gotham
            distance.Text = "--"
            distance.TextColor3 = self.SubTextColor
            distance.TextSize = 10
            distance.TextXAlignment = Enum.TextXAlignment.Right
            distance.Parent = item
        end

        -- Click interaction
        local button = Instance.new("TextButton")
        button.Size = UDim2.new(1, 0, 1, 0)
        button.BackgroundTransparency = 1
        button.Text = ""
        button.Parent = item

        table.insert(self._connections, button.MouseButton1Click:Connect(function()
            if self.OnPlayerClick then
                self.OnPlayerClick(player)
            end
        end))

        table.insert(self._connections, button.MouseEnter:Connect(function()
            TweenService:Create(item, TweenInfo.new(0.1), {
                BackgroundTransparency = 0,
            }):Play()
        end))

        table.insert(self._connections, button.MouseLeave:Connect(function()
            TweenService:Create(item, TweenInfo.new(0.1), {
                BackgroundTransparency = 0.5,
            }):Play()
        end))

        self._playerItems[player.UserId] = item
    end

    --// Remove player item
    function Playerlist:_removePlayer(player)
        local item = self._playerItems[player.UserId]
        if item then
            item:Destroy()
            self._playerItems[player.UserId] = nil
        end
    end

    --// Update players
    function Playerlist:_updatePlayers()
        local localPlayer = Players.LocalPlayer
        local localCharacter = localPlayer and localPlayer.Character
        local localRoot = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")

        for userId, item in pairs(self._playerItems) do
            local player = Players:GetPlayerByUserId(userId)
            if not player then continue end

            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            local rootPart = character and character:FindFirstChild("HumanoidRootPart")

            -- Update health
            if self.ShowHealth then
                local healthBg = item:FindFirstChild("HealthBg")
                if healthBg and humanoid then
                    local fill = healthBg:FindFirstChild("Fill")
                    if fill then
                        local healthPercent = humanoid.Health / humanoid.MaxHealth
                        fill.Size = UDim2.new(healthPercent, 0, 1, 0)

                        -- Color based on health
                        if healthPercent > 0.6 then
                            fill.BackgroundColor3 = Color3.fromRGB(34, 197, 94)
                        elseif healthPercent > 0.3 then
                            fill.BackgroundColor3 = Color3.fromRGB(245, 158, 11)
                        else
                            fill.BackgroundColor3 = Color3.fromRGB(239, 68, 68)
                        end
                    end
                end
            end

            -- Update distance
            if self.ShowDistance then
                local distLabel = item:FindFirstChild("Distance")
                if distLabel and localRoot and rootPart then
                    local distance = (rootPart.Position - localRoot.Position).Magnitude
                    distLabel.Text = math.floor(distance) .. "m"
                end
            end

            -- Update team
            if self.ShowTeam then
                local teamLabel = item:FindFirstChild("Team")
                if teamLabel then
                    teamLabel.Text = player.Team and player.Team.Name or "No Team"
                    teamLabel.TextColor3 = player.Team and player.TeamColor.Color or self.SubTextColor
                end
            end
        end
    end

    --// Update count
    function Playerlist:_updateCount()
        if self._countLabel then
            self._countLabel.Text = #Players:GetPlayers() .. "/" .. Players.MaxPlayers
        end
    end

    --// Refresh list
    function Playerlist:Refresh()
        -- Clear existing
        for _, item in pairs(self._playerItems) do
            item:Destroy()
        end
        self._playerItems = {}

        -- Repopulate
        self:_populatePlayers()
        self:_updateCount()

        return self
    end

    --// Toggle visibility
    function Playerlist:Toggle()
        self.Instance.Visible = not self.Instance.Visible
        return self
    end

    --// Destroy
    function Playerlist:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return Playerlist


end


-- ============================================================================
-- Module: NexusUI/Special/Killfeed
-- ============================================================================
NexusUI_Modules["NexusUI/Special/Killfeed"] = function()
    local script = CreateMockScript("NexusUI/Special/Killfeed")
    
    --[[
        NexusUI Killfeed Component
        Kill notification feed display
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Killfeed Module
    local Killfeed = {}
    Killfeed.__index = Killfeed
    Killfeed.ClassName = "Killfeed"

    --// Constructor
    function Killfeed.new(config)
        local self = setmetatable({}, Killfeed)

        config = config or {}

        self.MaxEntries = config.MaxEntries or 5
        self.EntryDuration = config.EntryDuration or 5
        self.Position = config.Position or "TopRight"
        self.ShowWeapon = config.ShowWeapon ~= false
        self.ShowHeadshot = config.ShowHeadshot or false
        self.Animated = config.Animated ~= false

        -- Colors
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(18, 18, 21)
        self.KillerColor = config.KillerColor or Color3.fromRGB(239, 68, 68)
        self.VictimColor = config.VictimColor or Color3.fromRGB(161, 161, 170)
        self.SelfColor = config.SelfColor or Color3.fromRGB(99, 102, 241)

        -- State
        self._entries = {}
        self._connections = {}

        return self
    end

    --// Get position config
    function Killfeed:_getPositionConfig()
        local positions = {
            TopRight = {
                Position = UDim2.new(1, -10, 0, 100),
                AnchorPoint = Vector2.new(1, 0),
            },
            TopLeft = {
                Position = UDim2.new(0, 10, 0, 100),
                AnchorPoint = Vector2.new(0, 0),
            },
            BottomRight = {
                Position = UDim2.new(1, -10, 1, -100),
                AnchorPoint = Vector2.new(1, 1),
            },
            BottomLeft = {
                Position = UDim2.new(0, 10, 1, -100),
                AnchorPoint = Vector2.new(0, 1),
            },
        }

        return positions[self.Position] or positions.TopRight
    end

    --// Create killfeed
    function Killfeed:Create(parent)
        local posConfig = self:_getPositionConfig()

        local killfeed = Instance.new("Frame")
        killfeed.Name = "Killfeed"
        killfeed.Size = UDim2.new(0, 250, 0, 0)
        killfeed.AutomaticSize = Enum.AutomaticSize.Y
        killfeed.Position = posConfig.Position
        killfeed.AnchorPoint = posConfig.AnchorPoint
        killfeed.BackgroundTransparency = 1

        if parent then
            killfeed.Parent = parent
        end

        self.Instance = killfeed

        local layout = Instance.new("UIListLayout")
        layout.Padding = UDim.new(0, 4)
        layout.VerticalAlignment = string.find(self.Position, "Bottom") and Enum.VerticalAlignment.Bottom or Enum.VerticalAlignment.Top
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Parent = killfeed

        return self
    end

    --// Add kill entry
    function Killfeed:AddKill(killer, victim, weapon, isHeadshot)
        local localPlayer = game:GetService("Players").LocalPlayer

        local entry = Instance.new("Frame")
        entry.Name = "KillEntry"
        entry.Size = UDim2.new(1, 0, 0, 26)
        entry.BackgroundColor3 = self.BackgroundColor
        entry.BackgroundTransparency = 0.2
        entry.BorderSizePixel = 0
        entry.LayoutOrder = #self._entries + 1
        entry.Parent = self.Instance

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 6)
        corner.Parent = entry

        local padding = Instance.new("UIPadding")
        padding.PaddingLeft = UDim.new(0, 10)
        padding.PaddingRight = UDim.new(0, 10)
        padding.Parent = entry

        -- Content container
        local content = Instance.new("Frame")
        content.Size = UDim2.new(1, 0, 1, 0)
        content.BackgroundTransparency = 1
        content.Parent = entry

        local contentLayout = Instance.new("UIListLayout")
        contentLayout.FillDirection = Enum.FillDirection.Horizontal
        contentLayout.VerticalAlignment = Enum.VerticalAlignment.Center
        contentLayout.Padding = UDim.new(0, 6)
        contentLayout.Parent = content

        -- Killer name
        local killerColor = killer == localPlayer.Name and self.SelfColor or self.KillerColor
        local killerLabel = Instance.new("TextLabel")
        killerLabel.Size = UDim2.new(0, 0, 1, 0)
        killerLabel.AutomaticSize = Enum.AutomaticSize.X
        killerLabel.BackgroundTransparency = 1
        killerLabel.Font = Enum.Font.GothamMedium
        killerLabel.Text = killer
        killerLabel.TextColor3 = killerColor
        killerLabel.TextSize = 12
        killerLabel.LayoutOrder = 1
        killerLabel.Parent = content

        -- Weapon/kill icon
        if self.ShowWeapon and weapon then
            local weaponLabel = Instance.new("TextLabel")
            weaponLabel.Size = UDim2.new(0, 0, 1, 0)
            weaponLabel.AutomaticSize = Enum.AutomaticSize.X
            weaponLabel.BackgroundTransparency = 1
            weaponLabel.Font = Enum.Font.Gotham
            weaponLabel.Text = "[" .. weapon .. "]"
            weaponLabel.TextColor3 = Color3.fromRGB(113, 113, 122)
            weaponLabel.TextSize = 10
            weaponLabel.LayoutOrder = 2
            weaponLabel.Parent = content
        else
            local arrow = Instance.new("TextLabel")
            arrow.Size = UDim2.new(0, 20, 1, 0)
            arrow.BackgroundTransparency = 1
            arrow.Font = Enum.Font.GothamBold
            arrow.Text = "→"
            arrow.TextColor3 = Color3.fromRGB(113, 113, 122)
            arrow.TextSize = 12
            arrow.LayoutOrder = 2
            arrow.Parent = content
        end

        -- Headshot indicator
        if self.ShowHeadshot and isHeadshot then
            local headshotIcon = Instance.new("TextLabel")
            headshotIcon.Size = UDim2.new(0, 16, 1, 0)
            headshotIcon.BackgroundTransparency = 1
            headshotIcon.Font = Enum.Font.GothamBold
            headshotIcon.Text = "◉"
            headshotIcon.TextColor3 = Color3.fromRGB(245, 158, 11)
            headshotIcon.TextSize = 10
            headshotIcon.LayoutOrder = 3
            headshotIcon.Parent = content
        end

        -- Victim name
        local victimColor = victim == localPlayer.Name and self.SelfColor or self.VictimColor
        local victimLabel = Instance.new("TextLabel")
        victimLabel.Size = UDim2.new(0, 0, 1, 0)
        victimLabel.AutomaticSize = Enum.AutomaticSize.X
        victimLabel.BackgroundTransparency = 1
        victimLabel.Font = Enum.Font.GothamMedium
        victimLabel.Text = victim
        victimLabel.TextColor3 = victimColor
        victimLabel.TextSize = 12
        victimLabel.LayoutOrder = 4
        victimLabel.Parent = content

        -- Animate in
        if self.Animated then
            entry.BackgroundTransparency = 1
            content.Position = UDim2.new(0.2, 0, 0, 0)

            TweenService:Create(entry, TweenInfo.new(0.2), {
                BackgroundTransparency = 0.2,
            }):Play()

            TweenService:Create(content, TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {
                Position = UDim2.new(0, 0, 0, 0),
            }):Play()
        end

        -- Store entry
        table.insert(self._entries, entry)

        -- Remove oldest if over limit
        while #self._entries > self.MaxEntries do
            local oldest = table.remove(self._entries, 1)
            self:_removeEntry(oldest)
        end

        -- Auto remove after duration
        task.delay(self.EntryDuration, function()
            for i, e in ipairs(self._entries) do
                if e == entry then
                    table.remove(self._entries, i)
                    self:_removeEntry(entry)
                    break
                end
            end
        end)

        return self
    end

    --// Remove entry with animation
    function Killfeed:_removeEntry(entry)
        if not entry or not entry.Parent then return end

        if self.Animated then
            TweenService:Create(entry, TweenInfo.new(0.15), {
                BackgroundTransparency = 1,
            }):Play()

            task.delay(0.15, function()
                if entry and entry.Parent then
                    entry:Destroy()
                end
            end)
        else
            entry:Destroy()
        end
    end

    --// Clear all entries
    function Killfeed:Clear()
        for _, entry in ipairs(self._entries) do
            entry:Destroy()
        end
        self._entries = {}
        return self
    end

    --// Toggle visibility
    function Killfeed:Toggle()
        self.Instance.Visible = not self.Instance.Visible
        return self
    end

    --// Destroy
    function Killfeed:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return Killfeed


end


-- ============================================================================
-- Module: NexusUI/Special/Minimap
-- ============================================================================
NexusUI_Modules["NexusUI/Special/Minimap"] = function()
    local script = CreateMockScript("NexusUI/Special/Minimap")
    
    --[[
        NexusUI Minimap Component
        Simple top-down minimap display
    ]]

    --// Services
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local Workspace = game:GetService("Workspace")

    --// Minimap Module
    local Minimap = {}
    Minimap.__index = Minimap
    Minimap.ClassName = "Minimap"

    --// Constructor
    function Minimap.new(config)
        local self = setmetatable({}, Minimap)

        config = config or {}

        self.Size = config.Size or 150
        self.Scale = config.Scale or 10 -- Studs per pixel
        self.ShowPlayers = config.ShowPlayers ~= false
        self.ShowTeam = config.ShowTeam ~= false
        self.ShowNames = config.ShowNames or false
        self.Rotation = config.Rotation ~= false -- Rotate with player
        self.Position = config.Position or "BottomLeft"

        -- Colors
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(18, 18, 21)
        self.BorderColor = config.BorderColor or Color3.fromRGB(39, 39, 42)
        self.SelfColor = config.SelfColor or Color3.fromRGB(99, 102, 241)
        self.EnemyColor = config.EnemyColor or Color3.fromRGB(239, 68, 68)
        self.TeamColor = config.TeamColor or Color3.fromRGB(34, 197, 94)

        -- State
        self._markers = {}
        self._connections = {}

        return self
    end

    --// Get position config
    function Minimap:_getPositionConfig()
        local positions = {
            TopRight = {
                Position = UDim2.new(1, -10, 0, 10),
                AnchorPoint = Vector2.new(1, 0),
            },
            TopLeft = {
                Position = UDim2.new(0, 10, 0, 10),
                AnchorPoint = Vector2.new(0, 0),
            },
            BottomRight = {
                Position = UDim2.new(1, -10, 1, -10),
                AnchorPoint = Vector2.new(1, 1),
            },
            BottomLeft = {
                Position = UDim2.new(0, 10, 1, -10),
                AnchorPoint = Vector2.new(0, 1),
            },
        }

        return positions[self.Position] or positions.BottomLeft
    end

    --// Create minimap
    function Minimap:Create(parent)
        local posConfig = self:_getPositionConfig()

        local minimap = Instance.new("Frame")
        minimap.Name = "Minimap"
        minimap.Size = UDim2.new(0, self.Size, 0, self.Size)
        minimap.Position = posConfig.Position
        minimap.AnchorPoint = posConfig.AnchorPoint
        minimap.BackgroundColor3 = self.BackgroundColor
        minimap.BorderSizePixel = 0

        if parent then
            minimap.Parent = parent
        end

        self.Instance = minimap

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = minimap

        local stroke = Instance.new("UIStroke")
        stroke.Color = self.BorderColor
        stroke.Thickness = 2
        stroke.Parent = minimap

        -- Map container (clips markers)
        local mapContainer = Instance.new("Frame")
        mapContainer.Name = "MapContainer"
        mapContainer.Size = UDim2.new(1, -8, 1, -8)
        mapContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
        mapContainer.AnchorPoint = Vector2.new(0.5, 0.5)
        mapContainer.BackgroundTransparency = 1
        mapContainer.ClipsDescendants = true
        mapContainer.Parent = minimap
        self._mapContainer = mapContainer

        local mapCorner = Instance.new("UICorner")
        mapCorner.CornerRadius = UDim.new(0, 6)
        mapCorner.Parent = mapContainer

        -- Self marker (center)
        local selfMarker = Instance.new("Frame")
        selfMarker.Name = "SelfMarker"
        selfMarker.Size = UDim2.new(0, 10, 0, 10)
        selfMarker.Position = UDim2.new(0.5, 0, 0.5, 0)
        selfMarker.AnchorPoint = Vector2.new(0.5, 0.5)
        selfMarker.BackgroundColor3 = self.SelfColor
        selfMarker.BorderSizePixel = 0
        selfMarker.ZIndex = 10
        selfMarker.Parent = mapContainer
        self._selfMarker = selfMarker

        local selfCorner = Instance.new("UICorner")
        selfCorner.CornerRadius = UDim.new(1, 0)
        selfCorner.Parent = selfMarker

        -- Direction indicator
        local directionIndicator = Instance.new("Frame")
        directionIndicator.Size = UDim2.new(0, 0, 0, 0)
        directionIndicator.Position = UDim2.new(0.5, 0, 0, -2)
        directionIndicator.AnchorPoint = Vector2.new(0.5, 1)
        directionIndicator.BackgroundTransparency = 1
        directionIndicator.BorderSizePixel = 0
        directionIndicator.Parent = selfMarker

        local arrow = Instance.new("ImageLabel")
        arrow.Size = UDim2.new(0, 8, 0, 8)
        arrow.BackgroundTransparency = 1
        arrow.Image = "rbxassetid://7072723678" -- Triangle/arrow
        arrow.ImageColor3 = self.SelfColor
        arrow.Rotation = 0
        arrow.Parent = directionIndicator
        self._directionArrow = arrow

        -- Compass
        local compassLabels = {"N", "E", "S", "W"}
        local compassPositions = {
            {0.5, 0.05}, {0.95, 0.5}, {0.5, 0.95}, {0.05, 0.5}
        }

        for i, label in ipairs(compassLabels) do
            local compassLabel = Instance.new("TextLabel")
            compassLabel.Size = UDim2.new(0, 16, 0, 16)
            compassLabel.Position = UDim2.new(compassPositions[i][1], 0, compassPositions[i][2], 0)
            compassLabel.AnchorPoint = Vector2.new(0.5, 0.5)
            compassLabel.BackgroundTransparency = 1
            compassLabel.Font = Enum.Font.GothamBold
            compassLabel.Text = label
            compassLabel.TextColor3 = Color3.fromRGB(82, 82, 91)
            compassLabel.TextSize = 10
            compassLabel.ZIndex = 5
            compassLabel.Parent = mapContainer
        end

        -- Start update loop
        self:Start()

        return self
    end

    --// Start updating
    function Minimap:Start()
        -- Update loop
        local connection = RunService.Heartbeat:Connect(function()
            self:_update()
        end)
        table.insert(self._connections, connection)

        -- Player events
        table.insert(self._connections, Players.PlayerAdded:Connect(function(player)
            -- Will be handled by update
        end))

        table.insert(self._connections, Players.PlayerRemoving:Connect(function(player)
            self:_removeMarker(player)
        end))

        return self
    end

    --// Stop updating
    function Minimap:Stop()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}
        return self
    end

    --// Update minimap
    function Minimap:_update()
        local localPlayer = Players.LocalPlayer
        local localCharacter = localPlayer and localPlayer.Character
        local localRoot = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")

        if not localRoot then return end

        local localPos = localRoot.Position
        local localRotation = localRoot.CFrame:ToEulerAnglesYXZ()

        -- Update self rotation
        if self.Rotation then
            -- Map rotates with player
            -- (Implementation would rotate the container)
        end

        -- Update player markers
        if self.ShowPlayers then
            for _, player in ipairs(Players:GetPlayers()) do
                if player == localPlayer then continue end

                local character = player.Character
                local rootPart = character and character:FindFirstChild("HumanoidRootPart")
                local humanoid = character and character:FindFirstChild("Humanoid")

                if not rootPart or not humanoid or humanoid.Health <= 0 then
                    self:_removeMarker(player)
                    continue
                end

                -- Calculate relative position
                local relativePos = rootPart.Position - localPos
                local mapX = relativePos.X / self.Scale
                local mapZ = relativePos.Z / self.Scale

                -- Check if within map bounds
                local maxDist = self.Size / 2 - 10
                local dist = math.sqrt(mapX^2 + mapZ^2)

                if dist > maxDist then
                    -- Clamp to edge
                    local ratio = maxDist / dist
                    mapX = mapX * ratio
                    mapZ = mapZ * ratio
                end

                -- Get or create marker
                local marker = self._markers[player.UserId]
                if not marker then
                    marker = self:_createMarker(player)
                    self._markers[player.UserId] = marker
                end

                -- Update marker position
                marker.Position = UDim2.new(0.5, mapX, 0.5, mapZ)
                marker.Visible = true

                -- Update color based on team
                if self.ShowTeam and player.Team then
                    local isFriendly = localPlayer.Team and player.Team == localPlayer.Team
                    marker.BackgroundColor3 = isFriendly and self.TeamColor or self.EnemyColor
                else
                    marker.BackgroundColor3 = self.EnemyColor
                end
            end
        end
    end

    --// Create player marker
    function Minimap:_createMarker(player)
        local marker = Instance.new("Frame")
        marker.Name = "Marker_" .. player.UserId
        marker.Size = UDim2.new(0, 6, 0, 6)
        marker.AnchorPoint = Vector2.new(0.5, 0.5)
        marker.BackgroundColor3 = self.EnemyColor
        marker.BorderSizePixel = 0
        marker.ZIndex = 5
        marker.Parent = self._mapContainer

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(1, 0)
        corner.Parent = marker

        return marker
    end

    --// Remove player marker
    function Minimap:_removeMarker(player)
        local marker = self._markers[player.UserId]
        if marker then
            marker:Destroy()
            self._markers[player.UserId] = nil
        end
    end

    --// Set scale
    function Minimap:SetScale(scale)
        self.Scale = scale
        return self
    end

    --// Toggle visibility
    function Minimap:Toggle()
        self.Instance.Visible = not self.Instance.Visible
        return self
    end

    --// Destroy
    function Minimap:Destroy()
        self:Stop()

        for _, marker in pairs(self._markers) do
            marker:Destroy()
        end
        self._markers = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return Minimap


end


-- ============================================================================
-- Module: NexusUI/Special/Spectate
-- ============================================================================
NexusUI_Modules["NexusUI/Special/Spectate"] = function()
    local script = CreateMockScript("NexusUI/Special/Spectate")
    
    --[[
        NexusUI Spectate Component
        Player spectating system
    ]]

    --// Services
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local Workspace = game:GetService("Workspace")
    local UserInputService = game:GetService("UserInputService")
    local TweenService = game:GetService("TweenService")

    --// Spectate Module
    local Spectate = {}
    Spectate.__index = Spectate
    Spectate.ClassName = "Spectate"

    --// Constructor
    function Spectate.new(config)
        local self = setmetatable({}, Spectate)

        config = config or {}

        self.ShowUI = config.ShowUI ~= false
        self.ShowHealth = config.ShowHealth ~= false
        self.ShowControls = config.ShowControls ~= false
        self.AutoCycle = config.AutoCycle or false
        self.CycleDelay = config.CycleDelay or 10

        -- Colors
        self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(18, 18, 21)
        self.TextColor = config.TextColor or Color3.fromRGB(250, 250, 250)
        self.AccentColor = config.AccentColor or Color3.fromRGB(99, 102, 241)

        -- Callbacks
        self.OnSpectate = config.OnSpectate
        self.OnStopSpectate = config.OnStopSpectate

        -- State
        self._spectating = nil
        self._originalCamera = nil
        self._connections = {}

        return self
    end

    --// Create UI
    function Spectate:Create(parent)
        if not self.ShowUI then
            return self
        end

        local spectateUI = Instance.new("Frame")
        spectateUI.Name = "SpectateUI"
        spectateUI.Size = UDim2.new(0, 300, 0, 50)
        spectateUI.Position = UDim2.new(0.5, 0, 0, 60)
        spectateUI.AnchorPoint = Vector2.new(0.5, 0)
        spectateUI.BackgroundColor3 = self.BackgroundColor
        spectateUI.BackgroundTransparency = 0.2
        spectateUI.BorderSizePixel = 0
        spectateUI.Visible = false

        if parent then
            spectateUI.Parent = parent
        end

        self.Instance = spectateUI

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 10)
        corner.Parent = spectateUI

        local padding = Instance.new("UIPadding")
        padding.PaddingLeft = UDim.new(0, 15)
        padding.PaddingRight = UDim.new(0, 15)
        padding.Parent = spectateUI

        -- Spectating label
        local label = Instance.new("TextLabel")
        label.Name = "Label"
        label.Size = UDim2.new(1, 0, 0, 18)
        label.Position = UDim2.new(0, 0, 0, 8)
        label.BackgroundTransparency = 1
        label.Font = Enum.Font.Gotham
        label.Text = "SPECTATING"
        label.TextColor3 = self.AccentColor
        label.TextSize = 10
        label.TextXAlignment = Enum.TextXAlignment.Center
        label.Parent = spectateUI

        -- Player name
        local playerName = Instance.new("TextLabel")
        playerName.Name = "PlayerName"
        playerName.Size = UDim2.new(1, 0, 0, 22)
        playerName.Position = UDim2.new(0, 0, 0, 24)
        playerName.BackgroundTransparency = 1
        playerName.Font = Enum.Font.GothamBold
        playerName.Text = "Player Name"
        playerName.TextColor3 = self.TextColor
        playerName.TextSize = 16
        playerName.TextXAlignment = Enum.TextXAlignment.Center
        playerName.Parent = spectateUI
        self._nameLabel = playerName

        -- Controls
        if self.ShowControls then
            local controls = Instance.new("Frame")
            controls.Size = UDim2.new(0, 120, 0, 28)
            controls.Position = UDim2.new(0.5, 0, 1, 10)
            controls.AnchorPoint = Vector2.new(0.5, 0)
            controls.BackgroundTransparency = 1
            controls.Parent = spectateUI

            local controlsLayout = Instance.new("UIListLayout")
            controlsLayout.FillDirection = Enum.FillDirection.Horizontal
            controlsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            controlsLayout.Padding = UDim.new(0, 10)
            controlsLayout.Parent = controls

            -- Previous button
            local prevBtn = self:_createControlButton("<", controls, function()
                self:Previous()
            end)

            -- Stop button
            local stopBtn = self:_createControlButton("×", controls, function()
                self:StopSpectating()
            end)

            -- Next button
            local nextBtn = self:_createControlButton(">", controls, function()
                self:Next()
            end)
        end

        return self
    end

    --// Create control button
    function Spectate:_createControlButton(text, parent, callback)
        local btn = Instance.new("TextButton")
        btn.Size = UDim2.new(0, 28, 0, 28)
        btn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
        btn.BorderSizePixel = 0
        btn.Font = Enum.Font.GothamBold
        btn.Text = text
        btn.TextColor3 = self.TextColor
        btn.TextSize = 16
        btn.AutoButtonColor = false
        btn.Parent = parent

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 6)
        corner.Parent = btn

        table.insert(self._connections, btn.MouseButton1Click:Connect(callback))

        table.insert(self._connections, btn.MouseEnter:Connect(function()
            TweenService:Create(btn, TweenInfo.new(0.1), {
                BackgroundColor3 = self.AccentColor,
            }):Play()
        end))

        table.insert(self._connections, btn.MouseLeave:Connect(function()
            TweenService:Create(btn, TweenInfo.new(0.1), {
                BackgroundColor3 = Color3.fromRGB(39, 39, 42),
            }):Play()
        end))

        return btn
    end

    --// Get spectatable players
    function Spectate:_getSpectatablePlayers()
        local players = {}
        local localPlayer = Players.LocalPlayer

        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= localPlayer then
                local character = player.Character
                local humanoid = character and character:FindFirstChild("Humanoid")

                if humanoid and humanoid.Health > 0 then
                    table.insert(players, player)
                end
            end
        end

        return players
    end

    --// Start spectating a player
    function Spectate:SpectatePlayer(player)
        if not player or player == Players.LocalPlayer then return self end

        local character = player.Character
        local humanoid = character and character:FindFirstChild("Humanoid")

        if not character or not humanoid or humanoid.Health <= 0 then
            return self
        end

        -- Store original camera settings
        if not self._spectating then
            self._originalCamera = {
                CameraType = Workspace.CurrentCamera.CameraType,
                CameraSubject = Workspace.CurrentCamera.CameraSubject,
            }
        end

        -- Set camera to spectate
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
        Workspace.CurrentCamera.CameraSubject = humanoid

        self._spectating = player

        -- Update UI
        if self.Instance then
            self.Instance.Visible = true
            if self._nameLabel then
                self._nameLabel.Text = player.DisplayName
            end
        end

        -- Callback
        if self.OnSpectate then
            self.OnSpectate(player)
        end

        -- Watch for death
        local connection
        connection = humanoid.Died:Connect(function()
            connection:Disconnect()
            if self._spectating == player then
                self:Next()
            end
        end)
        table.insert(self._connections, connection)

        return self
    end

    --// Stop spectating
    function Spectate:StopSpectating()
        if not self._spectating then return self end

        -- Restore camera
        if self._originalCamera then
            local localPlayer = Players.LocalPlayer
            local character = localPlayer and localPlayer.Character
            local humanoid = character and character:FindFirstChild("Humanoid")

            Workspace.CurrentCamera.CameraType = self._originalCamera.CameraType
            Workspace.CurrentCamera.CameraSubject = humanoid or self._originalCamera.CameraSubject
        end

        local previousTarget = self._spectating
        self._spectating = nil
        self._originalCamera = nil

        -- Update UI
        if self.Instance then
            self.Instance.Visible = false
        end

        -- Callback
        if self.OnStopSpectate then
            self.OnStopSpectate(previousTarget)
        end

        return self
    end

    --// Next player
    function Spectate:Next()
        local players = self:_getSpectatablePlayers()
        if #players == 0 then
            self:StopSpectating()
            return self
        end

        local currentIndex = 1
        if self._spectating then
            for i, player in ipairs(players) do
                if player == self._spectating then
                    currentIndex = i
                    break
                end
            end
        end

        local nextIndex = currentIndex % #players + 1
        self:SpectatePlayer(players[nextIndex])

        return self
    end

    --// Previous player
    function Spectate:Previous()
        local players = self:_getSpectatablePlayers()
        if #players == 0 then
            self:StopSpectating()
            return self
        end

        local currentIndex = 1
        if self._spectating then
            for i, player in ipairs(players) do
                if player == self._spectating then
                    currentIndex = i
                    break
                end
            end
        end

        local prevIndex = (currentIndex - 2) % #players + 1
        self:SpectatePlayer(players[prevIndex])

        return self
    end

    --// Get current spectate target
    function Spectate:GetTarget()
        return self._spectating
    end

    --// Is spectating
    function Spectate:IsSpectating()
        return self._spectating ~= nil
    end

    --// Toggle (spectate first available or stop)
    function Spectate:Toggle()
        if self._spectating then
            self:StopSpectating()
        else
            local players = self:_getSpectatablePlayers()
            if #players > 0 then
                self:SpectatePlayer(players[1])
            end
        end
        return self
    end

    --// Destroy
    function Spectate:Destroy()
        self:StopSpectating()

        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    return Spectate


end


-- ============================================================================
-- Module: NexusUI/Special/init
-- ============================================================================
NexusUI_Modules["NexusUI/Special/init"] = function()
    local script = CreateMockScript("NexusUI/Special/init")
    
    --[[
        NexusUI Special Components Module
        Advanced executor-specific components
    ]]

    --// Special Components Module
    local Special = {}

    Special.Console = NexusRequire("NexusUI/Special/Console")
    Special.CodeEditor = NexusRequire("NexusUI/Special/CodeEditor")
    Special.Terminal = NexusRequire("NexusUI/Special/Terminal")
    Special.ESP = NexusRequire("NexusUI/Special/ESP")
    Special.Watermark = NexusRequire("NexusUI/Special/Watermark")
    Special.Crosshair = NexusRequire("NexusUI/Special/Crosshair")
    Special.Aimbot = NexusRequire("NexusUI/Special/Aimbot")
    Special.Playerlist = NexusRequire("NexusUI/Special/Playerlist")
    Special.Killfeed = NexusRequire("NexusUI/Special/Killfeed")
    Special.Minimap = NexusRequire("NexusUI/Special/Minimap")
    Special.Spectate = NexusRequire("NexusUI/Special/Spectate")

    return Special


end


-- ============================================================================
-- Module: NexusUI/Features/Sound
-- ============================================================================
NexusUI_Modules["NexusUI/Features/Sound"] = function()
    local script = CreateMockScript("NexusUI/Features/Sound")
    
    --[[
        NexusUI Sound System
        UI sound effects management
    ]]

    --// Services
    local SoundService = game:GetService("SoundService")
    local TweenService = game:GetService("TweenService")

    --// Sound Module
    local Sound = {}
    Sound.__index = Sound
    Sound.ClassName = "SoundSystem"

    --// Sound packs
    local SoundPacks = {
        Default = {
            Click = "rbxassetid://6895079853",
            Hover = "rbxassetid://6895079949",
            Toggle = "rbxassetid://6895079707",
            Success = "rbxassetid://6026984224",
            Error = "rbxassetid://5356081124",
            Warning = "rbxassetid://4590657391",
            Notification = "rbxassetid://4590657391",
            Open = "rbxassetid://6895079586",
            Close = "rbxassetid://6895079453",
            Slide = "rbxassetid://6895079628",
            Type = "rbxassetid://6895079776",
        },
        Minimal = {
            Click = "rbxassetid://6895079853",
            Hover = "",
            Toggle = "rbxassetid://6895079707",
            Success = "",
            Error = "",
            Warning = "",
            Notification = "rbxassetid://4590657391",
            Open = "",
            Close = "",
            Slide = "",
            Type = "",
        },
        Gaming = {
            Click = "rbxassetid://6895079853",
            Hover = "rbxassetid://6895079949",
            Toggle = "rbxassetid://6895079707",
            Success = "rbxassetid://6026984224",
            Error = "rbxassetid://5356081124",
            Warning = "rbxassetid://4590657391",
            Notification = "rbxassetid://4590657391",
            Open = "rbxassetid://6895079586",
            Close = "rbxassetid://6895079453",
            Slide = "rbxassetid://6895079628",
            Type = "rbxassetid://6895079776",
        },
        Retro = {
            Click = "rbxassetid://6895079853",
            Hover = "rbxassetid://6895079949",
            Toggle = "rbxassetid://6895079707",
            Success = "rbxassetid://6026984224",
            Error = "rbxassetid://5356081124",
            Warning = "rbxassetid://4590657391",
            Notification = "rbxassetid://4590657391",
            Open = "rbxassetid://6895079586",
            Close = "rbxassetid://6895079453",
            Slide = "rbxassetid://6895079628",
            Type = "rbxassetid://6895079776",
        },
        Silent = {
            Click = "",
            Hover = "",
            Toggle = "",
            Success = "",
            Error = "",
            Warning = "",
            Notification = "",
            Open = "",
            Close = "",
            Slide = "",
            Type = "",
        },
    }

    --// Default volumes
    local DefaultVolumes = {
        Click = 0.3,
        Hover = 0.15,
        Toggle = 0.25,
        Success = 0.4,
        Error = 0.4,
        Warning = 0.35,
        Notification = 0.4,
        Open = 0.25,
        Close = 0.2,
        Slide = 0.2,
        Type = 0.1,
    }

    --// Singleton instance
    local _instance = nil

    --// Constructor
    function Sound.new(config)
        if _instance then
            return _instance
        end

        local self = setmetatable({}, Sound)

        config = config or {}

        self.Enabled = config.Enabled ~= false
        self.MasterVolume = config.MasterVolume or 0.5
        self.CurrentPack = config.SoundPack or "Default"
        self.Volumes = config.Volumes or {}

        -- State
        self._sounds = {}
        self._soundGroup = nil

        -- Initialize
        self:_initialize()

        _instance = self

        return self
    end

    --// Get singleton instance
    function Sound.getInstance()
        if not _instance then
            _instance = Sound.new()
        end
        return _instance
    end

    --// Initialize sound system
    function Sound:_initialize()
        -- Create sound group
        self._soundGroup = Instance.new("SoundGroup")
        self._soundGroup.Name = "NexusUI_Sounds"
        self._soundGroup.Volume = self.MasterVolume
        self._soundGroup.Parent = SoundService

        -- Pre-create sound instances for quick playback
        for soundName, soundId in pairs(SoundPacks[self.CurrentPack] or SoundPacks.Default) do
            if soundId and soundId ~= "" then
                local sound = Instance.new("Sound")
                sound.Name = soundName
                sound.SoundId = soundId
                sound.Volume = DefaultVolumes[soundName] or 0.3
                sound.SoundGroup = self._soundGroup
                sound.Parent = self._soundGroup
                self._sounds[soundName] = sound
            end
        end
    end

    --// Play sound
    function Sound:Play(soundName, volume, pitch)
        if not self.Enabled then return end

        local sound = self._sounds[soundName]
        if not sound then
            -- Check if sound exists in current pack
            local pack = SoundPacks[self.CurrentPack] or SoundPacks.Default
            local soundId = pack[soundName]

            if not soundId or soundId == "" then return end

            -- Create new sound instance
            sound = Instance.new("Sound")
            sound.Name = soundName
            sound.SoundId = soundId
            sound.Volume = DefaultVolumes[soundName] or 0.3
            sound.SoundGroup = self._soundGroup
            sound.Parent = self._soundGroup
            self._sounds[soundName] = sound
        end

        -- Apply overrides
        local originalVolume = sound.Volume
        local originalPitch = sound.PlaybackSpeed

        if volume then
            sound.Volume = volume * self.MasterVolume
        else
            sound.Volume = (self.Volumes[soundName] or DefaultVolumes[soundName] or 0.3) * self.MasterVolume
        end

        if pitch then
            sound.PlaybackSpeed = pitch
        end

        -- Clone and play for overlapping sounds
        local clone = sound:Clone()
        clone.Parent = self._soundGroup
        clone:Play()

        -- Cleanup after play
        clone.Ended:Connect(function()
            clone:Destroy()
        end)

        -- Restore original values
        sound.Volume = originalVolume
        sound.PlaybackSpeed = originalPitch
    end

    --// Play click sound
    function Sound:Click()
        self:Play("Click")
    end

    --// Play hover sound
    function Sound:Hover()
        self:Play("Hover")
    end

    --// Play toggle sound
    function Sound:Toggle()
        self:Play("Toggle")
    end

    --// Play success sound
    function Sound:Success()
        self:Play("Success")
    end

    --// Play error sound
    function Sound:Error()
        self:Play("Error")
    end

    --// Play warning sound
    function Sound:Warning()
        self:Play("Warning")
    end

    --// Play notification sound
    function Sound:Notification()
        self:Play("Notification")
    end

    --// Play open sound
    function Sound:Open()
        self:Play("Open")
    end

    --// Play close sound
    function Sound:Close()
        self:Play("Close")
    end

    --// Play slide sound
    function Sound:Slide()
        self:Play("Slide")
    end

    --// Play type sound
    function Sound:Type()
        self:Play("Type")
    end

    --// Set sound pack
    function Sound:SetSoundPack(packName)
        if not SoundPacks[packName] then
            warn("[NexusUI Sound] Unknown sound pack:", packName)
            return self
        end

        self.CurrentPack = packName

        -- Clear existing sounds
        for _, sound in pairs(self._sounds) do
            sound:Destroy()
        end
        self._sounds = {}

        -- Re-initialize with new pack
        for soundName, soundId in pairs(SoundPacks[packName]) do
            if soundId and soundId ~= "" then
                local sound = Instance.new("Sound")
                sound.Name = soundName
                sound.SoundId = soundId
                sound.Volume = DefaultVolumes[soundName] or 0.3
                sound.SoundGroup = self._soundGroup
                sound.Parent = self._soundGroup
                self._sounds[soundName] = sound
            end
        end

        return self
    end

    --// Get available sound packs
    function Sound:GetSoundPacks()
        local packs = {}
        for name in pairs(SoundPacks) do
            table.insert(packs, name)
        end
        return packs
    end

    --// Set master volume
    function Sound:SetMasterVolume(volume)
        self.MasterVolume = math.clamp(volume, 0, 1)
        if self._soundGroup then
            self._soundGroup.Volume = self.MasterVolume
        end
        return self
    end

    --// Set individual sound volume
    function Sound:SetSoundVolume(soundName, volume)
        self.Volumes[soundName] = math.clamp(volume, 0, 1)
        return self
    end

    --// Enable/disable sounds
    function Sound:SetEnabled(enabled)
        self.Enabled = enabled
        return self
    end

    --// Toggle sounds
    function Sound:Toggle()
        self.Enabled = not self.Enabled
        return self
    end

    --// Add custom sound pack
    function Sound:AddSoundPack(name, sounds)
        SoundPacks[name] = sounds
        return self
    end

    --// Destroy
    function Sound:Destroy()
        if self._soundGroup then
            self._soundGroup:Destroy()
            self._soundGroup = nil
        end

        self._sounds = {}
        _instance = nil
    end

    return Sound


end


-- ============================================================================
-- Module: NexusUI/Features/Config
-- ============================================================================
NexusUI_Modules["NexusUI/Features/Config"] = function()
    local script = CreateMockScript("NexusUI/Features/Config")
    
    --[[
        NexusUI Config System
        Save and load configuration files
    ]]

    --// Services
    local HttpService = game:GetService("HttpService")
    local Players = game:GetService("Players")

    --// Config Module
    local Config = {}
    Config.__index = Config
    Config.ClassName = "ConfigSystem"

    --// Singleton instance
    local _instance = nil

    --// Constructor
    function Config.new(config)
        if _instance then
            return _instance
        end

        local self = setmetatable({}, Config)

        config = config or {}

        self.FolderName = config.FolderName or "NexusUI"
        self.ConfigFolder = config.ConfigFolder or "Configs"
        self.AutoSave = config.AutoSave or false
        self.AutoSaveInterval = config.AutoSaveInterval or 60
        self.CloudSync = config.CloudSync or false

        -- State
        self._configs = {}
        self._currentConfig = "Default"
        self._autoSaveConnection = nil
        self._callbacks = {}

        -- Initialize
        self:_initialize()

        _instance = self

        return self
    end

    --// Get singleton instance
    function Config.getInstance()
        if not _instance then
            _instance = Config.new()
        end
        return _instance
    end

    --// Initialize config system
    function Config:_initialize()
        -- Create folders if they don't exist
        pcall(function()
            if makefolder and not isfolder then
                makefolder(self.FolderName)
                makefolder(self.FolderName .. "/" .. self.ConfigFolder)
            elseif isfolder and not isfolder(self.FolderName) then
                makefolder(self.FolderName)
            end

            if isfolder and not isfolder(self.FolderName .. "/" .. self.ConfigFolder) then
                makefolder(self.FolderName .. "/" .. self.ConfigFolder)
            end
        end)

        -- Start auto-save if enabled
        if self.AutoSave then
            self:StartAutoSave()
        end
    end

    --// Get config file path
    function Config:_getPath(configName)
        return self.FolderName .. "/" .. self.ConfigFolder .. "/" .. configName .. ".json"
    end

    --// Save config
    function Config:Save(configName, data)
        configName = configName or self._currentConfig
        data = data or self._configs[configName] or {}

        local path = self:_getPath(configName)

        -- Add metadata
        local configData = {
            _metadata = {
                name = configName,
                savedAt = os.time(),
                version = "1.0.0",
                player = Players.LocalPlayer and Players.LocalPlayer.Name or "Unknown",
            },
            data = data,
        }

        local success, err = pcall(function()
            if writefile then
                local json = HttpService:JSONEncode(configData)
                writefile(path, json)
            else
                warn("[NexusUI Config] writefile not available")
            end
        end)

        if success then
            self._configs[configName] = data
            self:_fireCallbacks("save", configName, data)
        else
            warn("[NexusUI Config] Failed to save config:", err)
        end

        return success
    end

    --// Load config
    function Config:Load(configName)
        configName = configName or self._currentConfig

        local path = self:_getPath(configName)

        local success, result = pcall(function()
            if readfile and isfile then
                if isfile(path) then
                    local json = readfile(path)
                    return HttpService:JSONDecode(json)
                end
            else
                warn("[NexusUI Config] readfile/isfile not available")
            end
            return nil
        end)

        if success and result then
            local data = result.data or result
            self._configs[configName] = data
            self._currentConfig = configName
            self:_fireCallbacks("load", configName, data)
            return data
        else
            if not success then
                warn("[NexusUI Config] Failed to load config:", result)
            end
        end

        return nil
    end

    --// Delete config
    function Config:Delete(configName)
        configName = configName or self._currentConfig

        local path = self:_getPath(configName)

        local success = pcall(function()
            if delfile and isfile then
                if isfile(path) then
                    delfile(path)
                end
            end
        end)

        if success then
            self._configs[configName] = nil
            self:_fireCallbacks("delete", configName)
        end

        return success
    end

    --// Get all configs
    function Config:GetConfigs()
        local configs = {}

        pcall(function()
            if listfiles and isfolder then
                local folderPath = self.FolderName .. "/" .. self.ConfigFolder
                if isfolder(folderPath) then
                    for _, file in ipairs(listfiles(folderPath)) do
                        local name = file:match("([^/\\]+)%.json$")
                        if name then
                            table.insert(configs, name)
                        end
                    end
                end
            end
        end)

        return configs
    end

    --// Check if config exists
    function Config:Exists(configName)
        configName = configName or self._currentConfig
        local path = self:_getPath(configName)

        local exists = false
        pcall(function()
            if isfile then
                exists = isfile(path)
            end
        end)

        return exists
    end

    --// Set value in current config
    function Config:Set(key, value)
        if not self._configs[self._currentConfig] then
            self._configs[self._currentConfig] = {}
        end

        -- Support nested keys (e.g., "settings.theme")
        local keys = {}
        for k in key:gmatch("[^%.]+") do
            table.insert(keys, k)
        end

        local current = self._configs[self._currentConfig]
        for i = 1, #keys - 1 do
            local k = keys[i]
            if type(current[k]) ~= "table" then
                current[k] = {}
            end
            current = current[k]
        end

        current[keys[#keys]] = value
        self:_fireCallbacks("change", key, value)

        return self
    end

    --// Get value from current config
    function Config:Get(key, default)
        local data = self._configs[self._currentConfig]
        if not data then return default end

        -- Support nested keys
        local keys = {}
        for k in key:gmatch("[^%.]+") do
            table.insert(keys, k)
        end

        local current = data
        for _, k in ipairs(keys) do
            if type(current) ~= "table" then
                return default
            end
            current = current[k]
        end

        return current ~= nil and current or default
    end

    --// Get all values in current config
    function Config:GetAll()
        return self._configs[self._currentConfig] or {}
    end

    --// Set current config
    function Config:SetCurrent(configName)
        self._currentConfig = configName
        return self
    end

    --// Get current config name
    function Config:GetCurrent()
        return self._currentConfig
    end

    --// Start auto-save
    function Config:StartAutoSave()
        if self._autoSaveConnection then return self end

        self._autoSaveConnection = task.spawn(function()
            while true do
                task.wait(self.AutoSaveInterval)
                if self._configs[self._currentConfig] then
                    self:Save()
                end
            end
        end)

        return self
    end

    --// Stop auto-save
    function Config:StopAutoSave()
        if self._autoSaveConnection then
            task.cancel(self._autoSaveConnection)
            self._autoSaveConnection = nil
        end
        return self
    end

    --// Add callback
    function Config:OnChange(callback)
        table.insert(self._callbacks, callback)
        return #self._callbacks
    end

    --// Remove callback
    function Config:RemoveCallback(id)
        self._callbacks[id] = nil
    end

    --// Fire callbacks
    function Config:_fireCallbacks(event, ...)
        for _, callback in pairs(self._callbacks) do
            if callback then
                pcall(callback, event, ...)
            end
        end
    end

    --// Export config to string
    function Config:Export(configName)
        configName = configName or self._currentConfig
        local data = self._configs[configName]

        if data then
            local success, json = pcall(function()
                return HttpService:JSONEncode(data)
            end)

            if success then
                return json
            end
        end

        return nil
    end

    --// Import config from string
    function Config:Import(configName, jsonString)
        local success, data = pcall(function()
            return HttpService:JSONDecode(jsonString)
        end)

        if success and data then
            self._configs[configName] = data
            self:Save(configName, data)
            return true
        end

        return false
    end

    --// Destroy
    function Config:Destroy()
        self:StopAutoSave()
        self._configs = {}
        self._callbacks = {}
        _instance = nil
    end

    return Config


end


-- ============================================================================
-- Module: NexusUI/Features/Hotkey
-- ============================================================================
NexusUI_Modules["NexusUI/Features/Hotkey"] = function()
    local script = CreateMockScript("NexusUI/Features/Hotkey")
    
    --[[
        NexusUI Hotkey System
        Global hotkey/keybind management
    ]]

    --// Services
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")

    --// Hotkey Module
    local Hotkey = {}
    Hotkey.__index = Hotkey
    Hotkey.ClassName = "HotkeySystem"

    --// Key name mappings
    local KeyNames = {
        [Enum.KeyCode.LeftControl] = "LCtrl",
        [Enum.KeyCode.RightControl] = "RCtrl",
        [Enum.KeyCode.LeftShift] = "LShift",
        [Enum.KeyCode.RightShift] = "RShift",
        [Enum.KeyCode.LeftAlt] = "LAlt",
        [Enum.KeyCode.RightAlt] = "RAlt",
        [Enum.KeyCode.Tab] = "Tab",
        [Enum.KeyCode.Space] = "Space",
        [Enum.KeyCode.Return] = "Enter",
        [Enum.KeyCode.Backspace] = "Back",
        [Enum.KeyCode.Delete] = "Del",
        [Enum.KeyCode.Insert] = "Ins",
        [Enum.KeyCode.Home] = "Home",
        [Enum.KeyCode.End] = "End",
        [Enum.KeyCode.PageUp] = "PgUp",
        [Enum.KeyCode.PageDown] = "PgDn",
        [Enum.KeyCode.Up] = "↑",
        [Enum.KeyCode.Down] = "↓",
        [Enum.KeyCode.Left] = "←",
        [Enum.KeyCode.Right] = "→",
        [Enum.KeyCode.Escape] = "Esc",
        [Enum.KeyCode.CapsLock] = "Caps",
        [Enum.KeyCode.Tilde] = "~",
    }

    --// Singleton instance
    local _instance = nil

    --// Constructor
    function Hotkey.new(config)
        if _instance then
            return _instance
        end

        local self = setmetatable({}, Hotkey)

        config = config or {}

        self.Enabled = config.Enabled ~= false
        self.AllowInTextbox = config.AllowInTextbox or false

        -- State
        self._bindings = {}
        self._holdBindings = {}
        self._combos = {}
        self._heldKeys = {}
        self._connections = {}

        -- Initialize
        self:_initialize()

        _instance = self

        return self
    end

    --// Get singleton instance
    function Hotkey.getInstance()
        if not _instance then
            _instance = Hotkey.new()
        end
        return _instance
    end

    --// Initialize hotkey system
    function Hotkey:_initialize()
        -- Input began
        local inputBeganConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if not self.Enabled then return end

            -- Check if in textbox
            if gameProcessed and not self.AllowInTextbox then
                local focused = UserInputService:GetFocusedTextBox()
                if focused then return end
            end

            -- Handle keyboard
            if input.UserInputType == Enum.UserInputType.Keyboard then
                self._heldKeys[input.KeyCode] = true
                self:_checkBindings(input.KeyCode, true)
                self:_checkCombos()
            end

            -- Handle mouse
            if input.UserInputType == Enum.UserInputType.MouseButton1 or
               input.UserInputType == Enum.UserInputType.MouseButton2 or
               input.UserInputType == Enum.UserInputType.MouseButton3 then
                self:_checkMouseBindings(input.UserInputType, true)
            end
        end)
        table.insert(self._connections, inputBeganConnection)

        -- Input ended
        local inputEndedConnection = UserInputService.InputEnded:Connect(function(input, gameProcessed)
            if not self.Enabled then return end

            if input.UserInputType == Enum.UserInputType.Keyboard then
                self._heldKeys[input.KeyCode] = nil
                self:_checkBindings(input.KeyCode, false)
            end

            if input.UserInputType == Enum.UserInputType.MouseButton1 or
               input.UserInputType == Enum.UserInputType.MouseButton2 or
               input.UserInputType == Enum.UserInputType.MouseButton3 then
                self:_checkMouseBindings(input.UserInputType, false)
            end
        end)
        table.insert(self._connections, inputEndedConnection)
    end

    --// Check bindings
    function Hotkey:_checkBindings(keyCode, pressed)
        local binding = self._bindings[keyCode]
        if binding then
            if pressed then
                if binding.callback then
                    pcall(binding.callback)
                end
            end
        end

        -- Check hold bindings
        local holdBinding = self._holdBindings[keyCode]
        if holdBinding then
            if pressed then
                if holdBinding.onPress then
                    pcall(holdBinding.onPress)
                end
            else
                if holdBinding.onRelease then
                    pcall(holdBinding.onRelease)
                end
            end
        end
    end

    --// Check mouse bindings
    function Hotkey:_checkMouseBindings(inputType, pressed)
        local binding = self._bindings[inputType]
        if binding then
            if pressed then
                if binding.callback then
                    pcall(binding.callback)
                end
            end
        end
    end

    --// Check combo bindings
    function Hotkey:_checkCombos()
        for _, combo in pairs(self._combos) do
            local allPressed = true
            for _, key in ipairs(combo.keys) do
                if not self._heldKeys[key] then
                    allPressed = false
                    break
                end
            end

            if allPressed then
                if combo.callback then
                    pcall(combo.callback)
                end
            end
        end
    end

    --// Bind key
    function Hotkey:Bind(key, callback, id)
        if type(key) == "string" then
            key = Enum.KeyCode[key]
        end

        id = id or tostring(key)

        self._bindings[key] = {
            id = id,
            key = key,
            callback = callback,
        }

        return id
    end

    --// Bind hold key (separate press/release)
    function Hotkey:BindHold(key, onPress, onRelease, id)
        if type(key) == "string" then
            key = Enum.KeyCode[key]
        end

        id = id or tostring(key) .. "_hold"

        self._holdBindings[key] = {
            id = id,
            key = key,
            onPress = onPress,
            onRelease = onRelease,
        }

        return id
    end

    --// Bind key combo (e.g., Ctrl+Shift+K)
    function Hotkey:BindCombo(keys, callback, id)
        local keyList = {}
        for _, key in ipairs(keys) do
            if type(key) == "string" then
                key = Enum.KeyCode[key]
            end
            table.insert(keyList, key)
        end

        id = id or table.concat(keys, "+")

        self._combos[id] = {
            id = id,
            keys = keyList,
            callback = callback,
        }

        return id
    end

    --// Unbind key
    function Hotkey:Unbind(key)
        if type(key) == "string" then
            -- Check if it's a combo ID
            if self._combos[key] then
                self._combos[key] = nil
                return true
            end

            key = Enum.KeyCode[key]
        end

        self._bindings[key] = nil
        self._holdBindings[key] = nil

        return true
    end

    --// Unbind combo
    function Hotkey:UnbindCombo(id)
        self._combos[id] = nil
        return true
    end

    --// Clear all bindings
    function Hotkey:ClearAll()
        self._bindings = {}
        self._holdBindings = {}
        self._combos = {}
        return self
    end

    --// Check if key is held
    function Hotkey:IsKeyHeld(key)
        if type(key) == "string" then
            key = Enum.KeyCode[key]
        end
        return self._heldKeys[key] == true
    end

    --// Check if modifier is held
    function Hotkey:IsCtrlHeld()
        return self._heldKeys[Enum.KeyCode.LeftControl] or self._heldKeys[Enum.KeyCode.RightControl]
    end

    function Hotkey:IsShiftHeld()
        return self._heldKeys[Enum.KeyCode.LeftShift] or self._heldKeys[Enum.KeyCode.RightShift]
    end

    function Hotkey:IsAltHeld()
        return self._heldKeys[Enum.KeyCode.LeftAlt] or self._heldKeys[Enum.KeyCode.RightAlt]
    end

    --// Get key name
    function Hotkey:GetKeyName(key)
        if type(key) == "string" then
            return key
        end

        return KeyNames[key] or key.Name
    end

    --// Get all bindings
    function Hotkey:GetBindings()
        local bindings = {}

        for key, binding in pairs(self._bindings) do
            table.insert(bindings, {
                key = key,
                id = binding.id,
                type = "press",
            })
        end

        for key, binding in pairs(self._holdBindings) do
            table.insert(bindings, {
                key = key,
                id = binding.id,
                type = "hold",
            })
        end

        for id, combo in pairs(self._combos) do
            table.insert(bindings, {
                keys = combo.keys,
                id = id,
                type = "combo",
            })
        end

        return bindings
    end

    --// Set enabled
    function Hotkey:SetEnabled(enabled)
        self.Enabled = enabled
        return self
    end

    --// Toggle
    function Hotkey:Toggle()
        self.Enabled = not self.Enabled
        return self
    end

    --// Destroy
    function Hotkey:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        self._bindings = {}
        self._holdBindings = {}
        self._combos = {}
        self._heldKeys = {}

        _instance = nil
    end

    return Hotkey


end


-- ============================================================================
-- Module: NexusUI/Features/DragDrop
-- ============================================================================
NexusUI_Modules["NexusUI/Features/DragDrop"] = function()
    local script = CreateMockScript("NexusUI/Features/DragDrop")
    
    --[[
        NexusUI Drag and Drop System
        Dragging and dropping UI elements
    ]]

    --// Services
    local UserInputService = game:GetService("UserInputService")
    local TweenService = game:GetService("TweenService")

    --// DragDrop Module
    local DragDrop = {}
    DragDrop.__index = DragDrop
    DragDrop.ClassName = "DragDropSystem"

    --// Singleton instance
    local _instance = nil

    --// Constructor
    function DragDrop.new(config)
        if _instance then
            return _instance
        end

        local self = setmetatable({}, DragDrop)

        config = config or {}

        self.Enabled = config.Enabled ~= false
        self.SnapToGrid = config.SnapToGrid or false
        self.GridSize = config.GridSize or 10
        self.ShowPreview = config.ShowPreview ~= false
        self.AnimateDrop = config.AnimateDrop ~= false

        -- State
        self._draggables = {}
        self._dropZones = {}
        self._currentDrag = nil
        self._connections = {}

        -- Initialize
        self:_initialize()

        _instance = self

        return self
    end

    --// Get singleton instance
    function DragDrop.getInstance()
        if not _instance then
            _instance = DragDrop.new()
        end
        return _instance
    end

    --// Initialize drag drop system
    function DragDrop:_initialize()
        -- Global mouse move handler
        local moveConnection = UserInputService.InputChanged:Connect(function(input)
            if not self.Enabled or not self._currentDrag then return end

            if input.UserInputType == Enum.UserInputType.MouseMovement then
                self:_updateDrag(input.Position)
            end
        end)
        table.insert(self._connections, moveConnection)

        -- Global mouse release handler
        local releaseConnection = UserInputService.InputEnded:Connect(function(input)
            if not self.Enabled or not self._currentDrag then return end

            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                self:_endDrag()
            end
        end)
        table.insert(self._connections, releaseConnection)
    end

    --// Make element draggable
    function DragDrop:MakeDraggable(element, config)
        config = config or {}

        local id = config.Id or element.Name .. "_" .. tostring(os.clock())

        local draggable = {
            id = id,
            element = element,
            handle = config.Handle or element,
            bounds = config.Bounds, -- Parent or ScreenGui
            constrainX = config.ConstrainX or false,
            constrainY = config.ConstrainY or false,
            onDragStart = config.OnDragStart,
            onDrag = config.OnDrag,
            onDragEnd = config.OnDragEnd,
            data = config.Data,
            canDrop = config.CanDrop,
            connections = {},
        }

        -- Setup drag start
        local inputBeganConnection = draggable.handle.InputBegan:Connect(function(input)
            if not self.Enabled then return end

            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                self:_startDrag(draggable, input.Position)
            end
        end)
        table.insert(draggable.connections, inputBeganConnection)

        self._draggables[id] = draggable

        return id
    end

    --// Remove draggable
    function DragDrop:RemoveDraggable(id)
        local draggable = self._draggables[id]
        if draggable then
            for _, connection in ipairs(draggable.connections) do
                connection:Disconnect()
            end
            self._draggables[id] = nil
        end
        return self
    end

    --// Register drop zone
    function DragDrop:RegisterDropZone(element, config)
        config = config or {}

        local id = config.Id or element.Name .. "_dropzone_" .. tostring(os.clock())

        local dropZone = {
            id = id,
            element = element,
            accepts = config.Accepts, -- Function or table of draggable IDs
            onDragEnter = config.OnDragEnter,
            onDragLeave = config.OnDragLeave,
            onDrop = config.OnDrop,
            highlight = config.Highlight ~= false,
            highlightColor = config.HighlightColor or Color3.fromRGB(99, 102, 241),
        }

        self._dropZones[id] = dropZone

        return id
    end

    --// Remove drop zone
    function DragDrop:RemoveDropZone(id)
        self._dropZones[id] = nil
        return self
    end

    --// Start drag
    function DragDrop:_startDrag(draggable, mousePos)
        if self._currentDrag then return end

        local element = draggable.element

        self._currentDrag = {
            draggable = draggable,
            startPos = element.Position,
            offset = Vector2.new(
                mousePos.X - element.AbsolutePosition.X,
                mousePos.Y - element.AbsolutePosition.Y
            ),
            currentDropZone = nil,
        }

        -- Bring to front
        element.ZIndex = element.ZIndex + 100

        -- Create preview if needed
        if self.ShowPreview then
            -- Create semi-transparent clone as preview
        end

        -- Callback
        if draggable.onDragStart then
            draggable.onDragStart(draggable.element, draggable.data)
        end
    end

    --// Update drag position
    function DragDrop:_updateDrag(mousePos)
        local drag = self._currentDrag
        if not drag then return end

        local draggable = drag.draggable
        local element = draggable.element

        local newX = mousePos.X - drag.offset.X
        local newY = mousePos.Y - drag.offset.Y

        -- Apply constraints
        if draggable.constrainX then
            newX = drag.startPos.X.Offset
        end
        if draggable.constrainY then
            newY = drag.startPos.Y.Offset
        end

        -- Snap to grid
        if self.SnapToGrid then
            newX = math.floor(newX / self.GridSize + 0.5) * self.GridSize
            newY = math.floor(newY / self.GridSize + 0.5) * self.GridSize
        end

        -- Apply bounds
        if draggable.bounds then
            local bounds = draggable.bounds
            local boundsPos = bounds.AbsolutePosition
            local boundsSize = bounds.AbsoluteSize
            local elemSize = element.AbsoluteSize

            newX = math.clamp(newX, boundsPos.X, boundsPos.X + boundsSize.X - elemSize.X)
            newY = math.clamp(newY, boundsPos.Y, boundsPos.Y + boundsSize.Y - elemSize.Y)
        end

        -- Update position
        element.Position = UDim2.new(0, newX, 0, newY)

        -- Check drop zones
        self:_checkDropZones(Vector2.new(mousePos.X, mousePos.Y))

        -- Callback
        if draggable.onDrag then
            draggable.onDrag(element, Vector2.new(newX, newY), draggable.data)
        end
    end

    --// Check drop zones
    function DragDrop:_checkDropZones(mousePos)
        local drag = self._currentDrag
        if not drag then return end

        local currentZone = nil

        for _, zone in pairs(self._dropZones) do
            local zoneElem = zone.element
            local zonePos = zoneElem.AbsolutePosition
            local zoneSize = zoneElem.AbsoluteSize

            if mousePos.X >= zonePos.X and mousePos.X <= zonePos.X + zoneSize.X and
               mousePos.Y >= zonePos.Y and mousePos.Y <= zonePos.Y + zoneSize.Y then

                -- Check if zone accepts this draggable
                local accepts = true
                if zone.accepts then
                    if type(zone.accepts) == "function" then
                        accepts = zone.accepts(drag.draggable.id, drag.draggable.data)
                    elseif type(zone.accepts) == "table" then
                        accepts = table.find(zone.accepts, drag.draggable.id) ~= nil
                    end
                end

                if accepts then
                    currentZone = zone
                    break
                end
            end
        end

        -- Handle zone changes
        if currentZone ~= drag.currentDropZone then
            -- Leave old zone
            if drag.currentDropZone then
                if drag.currentDropZone.onDragLeave then
                    drag.currentDropZone.onDragLeave(drag.draggable.element, drag.draggable.data)
                end
                if drag.currentDropZone.highlight then
                    -- Remove highlight
                end
            end

            -- Enter new zone
            if currentZone then
                if currentZone.onDragEnter then
                    currentZone.onDragEnter(drag.draggable.element, drag.draggable.data)
                end
                if currentZone.highlight then
                    -- Add highlight
                end
            end

            drag.currentDropZone = currentZone
        end
    end

    --// End drag
    function DragDrop:_endDrag()
        local drag = self._currentDrag
        if not drag then return end

        local draggable = drag.draggable
        local element = draggable.element

        -- Restore ZIndex
        element.ZIndex = element.ZIndex - 100

        -- Handle drop
        local dropped = false
        if drag.currentDropZone then
            if drag.currentDropZone.onDrop then
                dropped = drag.currentDropZone.onDrop(element, draggable.data)
            else
                dropped = true
            end

            -- Remove highlight
            if drag.currentDropZone.highlight then
                -- Remove highlight
            end
        end

        -- Animate back if not dropped
        if not dropped and self.AnimateDrop then
            TweenService:Create(element, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                Position = drag.startPos,
            }):Play()
        end

        -- Callback
        if draggable.onDragEnd then
            draggable.onDragEnd(element, dropped, drag.currentDropZone, draggable.data)
        end

        -- Clear preview
        if self.ShowPreview then
            -- Remove preview
        end

        self._currentDrag = nil
    end

    --// Cancel current drag
    function DragDrop:Cancel()
        if self._currentDrag then
            local drag = self._currentDrag
            local element = drag.draggable.element

            element.ZIndex = element.ZIndex - 100
            element.Position = drag.startPos

            self._currentDrag = nil
        end
        return self
    end

    --// Check if dragging
    function DragDrop:IsDragging()
        return self._currentDrag ~= nil
    end

    --// Get current drag info
    function DragDrop:GetCurrentDrag()
        if self._currentDrag then
            return {
                id = self._currentDrag.draggable.id,
                element = self._currentDrag.draggable.element,
                data = self._currentDrag.draggable.data,
            }
        end
        return nil
    end

    --// Set enabled
    function DragDrop:SetEnabled(enabled)
        self.Enabled = enabled
        if not enabled and self._currentDrag then
            self:Cancel()
        end
        return self
    end

    --// Destroy
    function DragDrop:Destroy()
        self:Cancel()

        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        for _, draggable in pairs(self._draggables) do
            for _, conn in ipairs(draggable.connections) do
                conn:Disconnect()
            end
        end

        self._draggables = {}
        self._dropZones = {}

        _instance = nil
    end

    return DragDrop


end


-- ============================================================================
-- Module: NexusUI/Features/init
-- ============================================================================
NexusUI_Modules["NexusUI/Features/init"] = function()
    local script = CreateMockScript("NexusUI/Features/init")
    
    --[[
        NexusUI Features Module
        Core features and systems
    ]]

    --// Features Module
    local Features = {}

    Features.Sound = NexusRequire("NexusUI/Features/Sound")
    Features.Config = NexusRequire("NexusUI/Features/Config")
    Features.Hotkey = NexusRequire("NexusUI/Features/Hotkey")
    Features.DragDrop = NexusRequire("NexusUI/Features/DragDrop")

    return Features


end


-- ============================================================================
-- Module: NexusUI/Layout/Flex
-- ============================================================================
NexusUI_Modules["NexusUI/Layout/Flex"] = function()
    local script = CreateMockScript("NexusUI/Layout/Flex")
    
    --[[
        NexusUI Flex Layout
        Flexbox-style layout system
    ]]

    --// Flex Module
    local Flex = {}
    Flex.__index = Flex
    Flex.ClassName = "FlexLayout"

    --// Directions
    Flex.Direction = {
        Row = "Row",
        RowReverse = "RowReverse",
        Column = "Column",
        ColumnReverse = "ColumnReverse",
    }

    --// Justify content
    Flex.Justify = {
        Start = "Start",
        End = "End",
        Center = "Center",
        SpaceBetween = "SpaceBetween",
        SpaceAround = "SpaceAround",
        SpaceEvenly = "SpaceEvenly",
    }

    --// Align items
    Flex.Align = {
        Start = "Start",
        End = "End",
        Center = "Center",
        Stretch = "Stretch",
        Baseline = "Baseline",
    }

    --// Constructor
    function Flex.new(config)
        local self = setmetatable({}, Flex)

        config = config or {}

        self.Direction = config.Direction or Flex.Direction.Row
        self.Justify = config.Justify or Flex.Justify.Start
        self.Align = config.Align or Flex.Align.Start
        self.Wrap = config.Wrap or false
        self.Gap = config.Gap or 0
        self.Padding = config.Padding or 0

        return self
    end

    --// Create flex container
    function Flex:Create(parent)
        local container = Instance.new("Frame")
        container.Name = "FlexContainer"
        container.Size = UDim2.new(1, 0, 1, 0)
        container.BackgroundTransparency = 1

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Apply layout
        self:_applyLayout()

        return self
    end

    --// Apply layout using UIListLayout
    function Flex:_applyLayout()
        local container = self.Instance
        if not container then return end

        -- Remove existing layout
        local existingLayout = container:FindFirstChildOfClass("UIListLayout")
        if existingLayout then
            existingLayout:Destroy()
        end

        local layout = Instance.new("UIListLayout")

        -- Direction
        if self.Direction == Flex.Direction.Row or self.Direction == Flex.Direction.RowReverse then
            layout.FillDirection = Enum.FillDirection.Horizontal
        else
            layout.FillDirection = Enum.FillDirection.Vertical
        end

        -- Justify (horizontal alignment for row, vertical for column)
        if self.Direction == Flex.Direction.Row or self.Direction == Flex.Direction.RowReverse then
            if self.Justify == Flex.Justify.Start then
                layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
            elseif self.Justify == Flex.Justify.End then
                layout.HorizontalAlignment = Enum.HorizontalAlignment.Right
            elseif self.Justify == Flex.Justify.Center then
                layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            end
        else
            if self.Justify == Flex.Justify.Start then
                layout.VerticalAlignment = Enum.VerticalAlignment.Top
            elseif self.Justify == Flex.Justify.End then
                layout.VerticalAlignment = Enum.VerticalAlignment.Bottom
            elseif self.Justify == Flex.Justify.Center then
                layout.VerticalAlignment = Enum.VerticalAlignment.Center
            end
        end

        -- Align (cross-axis alignment)
        if self.Direction == Flex.Direction.Row or self.Direction == Flex.Direction.RowReverse then
            if self.Align == Flex.Align.Start then
                layout.VerticalAlignment = Enum.VerticalAlignment.Top
            elseif self.Align == Flex.Align.End then
                layout.VerticalAlignment = Enum.VerticalAlignment.Bottom
            elseif self.Align == Flex.Align.Center then
                layout.VerticalAlignment = Enum.VerticalAlignment.Center
            end
        else
            if self.Align == Flex.Align.Start then
                layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
            elseif self.Align == Flex.Align.End then
                layout.HorizontalAlignment = Enum.HorizontalAlignment.Right
            elseif self.Align == Flex.Align.Center then
                layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            end
        end

        -- Gap
        layout.Padding = UDim.new(0, self.Gap)

        -- Wrapping
        layout.Wraps = self.Wrap

        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Parent = container

        -- Padding
        if self.Padding > 0 then
            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, self.Padding)
            padding.PaddingBottom = UDim.new(0, self.Padding)
            padding.PaddingLeft = UDim.new(0, self.Padding)
            padding.PaddingRight = UDim.new(0, self.Padding)
            padding.Parent = container
        end
    end

    --// Set direction
    function Flex:SetDirection(direction)
        self.Direction = direction
        self:_applyLayout()
        return self
    end

    --// Set justify
    function Flex:SetJustify(justify)
        self.Justify = justify
        self:_applyLayout()
        return self
    end

    --// Set align
    function Flex:SetAlign(align)
        self.Align = align
        self:_applyLayout()
        return self
    end

    --// Set gap
    function Flex:SetGap(gap)
        self.Gap = gap
        self:_applyLayout()
        return self
    end

    --// Set wrap
    function Flex:SetWrap(wrap)
        self.Wrap = wrap
        self:_applyLayout()
        return self
    end

    --// Add child
    function Flex:AddChild(child, order)
        if order then
            child.LayoutOrder = order
        end
        child.Parent = self.Instance
        return self
    end

    --// Remove child
    function Flex:RemoveChild(child)
        if child.Parent == self.Instance then
            child.Parent = nil
        end
        return self
    end

    --// Clear children
    function Flex:Clear()
        for _, child in ipairs(self.Instance:GetChildren()) do
            if not child:IsA("UIListLayout") and not child:IsA("UIPadding") then
                child:Destroy()
            end
        end
        return self
    end

    --// Destroy
    function Flex:Destroy()
        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    --// Static helper to create flex layout on existing frame
    function Flex.apply(frame, config)
        config = config or {}

        local flex = Flex.new(config)
        flex.Instance = frame
        flex:_applyLayout()

        return flex
    end

    return Flex


end


-- ============================================================================
-- Module: NexusUI/Layout/Grid
-- ============================================================================
NexusUI_Modules["NexusUI/Layout/Grid"] = function()
    local script = CreateMockScript("NexusUI/Layout/Grid")
    
    --[[
        NexusUI Grid Layout
        CSS Grid-style layout system
    ]]

    --// Grid Module
    local Grid = {}
    Grid.__index = Grid
    Grid.ClassName = "GridLayout"

    --// Constructor
    function Grid.new(config)
        local self = setmetatable({}, Grid)

        config = config or {}

        self.Columns = config.Columns or 3
        self.Rows = config.Rows or 0 -- 0 = auto
        self.CellSize = config.CellSize or UDim2.new(0, 100, 0, 100)
        self.CellPadding = config.CellPadding or UDim2.new(0, 10, 0, 10)
        self.StartCorner = config.StartCorner or "TopLeft"
        self.FillDirection = config.FillDirection or "Horizontal"
        self.HorizontalAlignment = config.HorizontalAlignment or "Left"
        self.VerticalAlignment = config.VerticalAlignment or "Top"
        self.SortOrder = config.SortOrder or "LayoutOrder"

        return self
    end

    --// Create grid container
    function Grid:Create(parent)
        local container = Instance.new("Frame")
        container.Name = "GridContainer"
        container.Size = UDim2.new(1, 0, 1, 0)
        container.BackgroundTransparency = 1

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Apply layout
        self:_applyLayout()

        return self
    end

    --// Apply layout using UIGridLayout
    function Grid:_applyLayout()
        local container = self.Instance
        if not container then return end

        -- Remove existing layout
        local existingLayout = container:FindFirstChildOfClass("UIGridLayout")
        if existingLayout then
            existingLayout:Destroy()
        end

        local layout = Instance.new("UIGridLayout")

        layout.CellSize = self.CellSize
        layout.CellPadding = self.CellPadding

        -- Start corner
        if self.StartCorner == "TopLeft" then
            layout.StartCorner = Enum.StartCorner.TopLeft
        elseif self.StartCorner == "TopRight" then
            layout.StartCorner = Enum.StartCorner.TopRight
        elseif self.StartCorner == "BottomLeft" then
            layout.StartCorner = Enum.StartCorner.BottomLeft
        elseif self.StartCorner == "BottomRight" then
            layout.StartCorner = Enum.StartCorner.BottomRight
        end

        -- Fill direction
        if self.FillDirection == "Horizontal" then
            layout.FillDirection = Enum.FillDirection.Horizontal
        else
            layout.FillDirection = Enum.FillDirection.Vertical
        end

        -- Alignment
        if self.HorizontalAlignment == "Left" then
            layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
        elseif self.HorizontalAlignment == "Center" then
            layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        elseif self.HorizontalAlignment == "Right" then
            layout.HorizontalAlignment = Enum.HorizontalAlignment.Right
        end

        if self.VerticalAlignment == "Top" then
            layout.VerticalAlignment = Enum.VerticalAlignment.Top
        elseif self.VerticalAlignment == "Center" then
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
        elseif self.VerticalAlignment == "Bottom" then
            layout.VerticalAlignment = Enum.VerticalAlignment.Bottom
        end

        -- Sort order
        if self.SortOrder == "LayoutOrder" then
            layout.SortOrder = Enum.SortOrder.LayoutOrder
        else
            layout.SortOrder = Enum.SortOrder.Name
        end

        -- Columns constraint (if specified)
        if self.Columns > 0 then
            -- Note: UIGridLayout doesn't have column constraint
            -- We can approximate by adjusting CellSize
        end

        layout.Parent = container
        self._layout = layout
    end

    --// Set columns
    function Grid:SetColumns(columns)
        self.Columns = columns
        self:_applyLayout()
        return self
    end

    --// Set cell size
    function Grid:SetCellSize(size)
        self.CellSize = size
        self:_applyLayout()
        return self
    end

    --// Set cell padding
    function Grid:SetCellPadding(padding)
        self.CellPadding = padding
        self:_applyLayout()
        return self
    end

    --// Add child
    function Grid:AddChild(child, order)
        if order then
            child.LayoutOrder = order
        end
        child.Parent = self.Instance
        return self
    end

    --// Remove child
    function Grid:RemoveChild(child)
        if child.Parent == self.Instance then
            child.Parent = nil
        end
        return self
    end

    --// Clear children
    function Grid:Clear()
        for _, child in ipairs(self.Instance:GetChildren()) do
            if not child:IsA("UIGridLayout") then
                child:Destroy()
            end
        end
        return self
    end

    --// Get content size
    function Grid:GetContentSize()
        if self._layout then
            return self._layout.AbsoluteContentSize
        end
        return Vector2.new(0, 0)
    end

    --// Destroy
    function Grid:Destroy()
        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    --// Static helper
    function Grid.apply(frame, config)
        config = config or {}

        local grid = Grid.new(config)
        grid.Instance = frame
        grid:_applyLayout()

        return grid
    end

    return Grid


end


-- ============================================================================
-- Module: NexusUI/Layout/Stack
-- ============================================================================
NexusUI_Modules["NexusUI/Layout/Stack"] = function()
    local script = CreateMockScript("NexusUI/Layout/Stack")
    
    --[[
        NexusUI Stack Layout
        Vertical or horizontal stack layout
    ]]

    --// Stack Module
    local Stack = {}
    Stack.__index = Stack
    Stack.ClassName = "StackLayout"

    --// Constructor
    function Stack.new(config)
        local self = setmetatable({}, Stack)

        config = config or {}

        self.Direction = config.Direction or "Vertical" -- Vertical or Horizontal
        self.Spacing = config.Spacing or 8
        self.Padding = config.Padding or {0, 0, 0, 0} -- Top, Right, Bottom, Left
        self.HorizontalAlignment = config.HorizontalAlignment or "Left"
        self.VerticalAlignment = config.VerticalAlignment or "Top"

        return self
    end

    --// Create stack container
    function Stack:Create(parent)
        local container = Instance.new("Frame")
        container.Name = "StackContainer"
        container.Size = UDim2.new(1, 0, 0, 0)
        container.AutomaticSize = self.Direction == "Vertical" and Enum.AutomaticSize.Y or Enum.AutomaticSize.X
        container.BackgroundTransparency = 1

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Apply layout
        self:_applyLayout()

        return self
    end

    --// Apply layout
    function Stack:_applyLayout()
        local container = self.Instance
        if not container then return end

        -- Remove existing layout
        local existingLayout = container:FindFirstChildOfClass("UIListLayout")
        if existingLayout then
            existingLayout:Destroy()
        end

        local existingPadding = container:FindFirstChildOfClass("UIPadding")
        if existingPadding then
            existingPadding:Destroy()
        end

        local layout = Instance.new("UIListLayout")

        -- Direction
        if self.Direction == "Vertical" then
            layout.FillDirection = Enum.FillDirection.Vertical
        else
            layout.FillDirection = Enum.FillDirection.Horizontal
        end

        -- Spacing
        layout.Padding = UDim.new(0, self.Spacing)

        -- Alignment
        if self.HorizontalAlignment == "Left" then
            layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
        elseif self.HorizontalAlignment == "Center" then
            layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        elseif self.HorizontalAlignment == "Right" then
            layout.HorizontalAlignment = Enum.HorizontalAlignment.Right
        end

        if self.VerticalAlignment == "Top" then
            layout.VerticalAlignment = Enum.VerticalAlignment.Top
        elseif self.VerticalAlignment == "Center" then
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
        elseif self.VerticalAlignment == "Bottom" then
            layout.VerticalAlignment = Enum.VerticalAlignment.Bottom
        end

        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Parent = container

        -- Padding
        local padding = self.Padding
        if type(padding) == "number" then
            padding = {padding, padding, padding, padding}
        end

        local uiPadding = Instance.new("UIPadding")
        uiPadding.PaddingTop = UDim.new(0, padding[1])
        uiPadding.PaddingRight = UDim.new(0, padding[2])
        uiPadding.PaddingBottom = UDim.new(0, padding[3])
        uiPadding.PaddingLeft = UDim.new(0, padding[4])
        uiPadding.Parent = container
    end

    --// Set direction
    function Stack:SetDirection(direction)
        self.Direction = direction

        if self.Instance then
            self.Instance.AutomaticSize = direction == "Vertical" and Enum.AutomaticSize.Y or Enum.AutomaticSize.X
        end

        self:_applyLayout()
        return self
    end

    --// Set spacing
    function Stack:SetSpacing(spacing)
        self.Spacing = spacing
        self:_applyLayout()
        return self
    end

    --// Set padding
    function Stack:SetPadding(padding)
        self.Padding = padding
        self:_applyLayout()
        return self
    end

    --// Add child
    function Stack:AddChild(child, order)
        if order then
            child.LayoutOrder = order
        else
            -- Auto-increment order
            local maxOrder = 0
            for _, c in ipairs(self.Instance:GetChildren()) do
                if c:IsA("GuiObject") and c.LayoutOrder > maxOrder then
                    maxOrder = c.LayoutOrder
                end
            end
            child.LayoutOrder = maxOrder + 1
        end
        child.Parent = self.Instance
        return self
    end

    --// Add spacer
    function Stack:AddSpacer(size)
        local spacer = Instance.new("Frame")
        spacer.Name = "Spacer"
        spacer.BackgroundTransparency = 1

        if self.Direction == "Vertical" then
            spacer.Size = UDim2.new(1, 0, 0, size or 0)
            if not size then
                spacer.AutomaticSize = Enum.AutomaticSize.Y
            end
        else
            spacer.Size = UDim2.new(0, size or 0, 1, 0)
            if not size then
                spacer.AutomaticSize = Enum.AutomaticSize.X
            end
        end

        self:AddChild(spacer)
        return spacer
    end

    --// Remove child
    function Stack:RemoveChild(child)
        if child.Parent == self.Instance then
            child.Parent = nil
        end
        return self
    end

    --// Clear
    function Stack:Clear()
        for _, child in ipairs(self.Instance:GetChildren()) do
            if not child:IsA("UIListLayout") and not child:IsA("UIPadding") then
                child:Destroy()
            end
        end
        return self
    end

    --// Destroy
    function Stack:Destroy()
        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    --// Static helpers
    function Stack.Vertical(config)
        config = config or {}
        config.Direction = "Vertical"
        return Stack.new(config)
    end

    function Stack.Horizontal(config)
        config = config or {}
        config.Direction = "Horizontal"
        return Stack.new(config)
    end

    function Stack.apply(frame, config)
        config = config or {}

        local stack = Stack.new(config)
        stack.Instance = frame
        stack:_applyLayout()

        return stack
    end

    return Stack


end


-- ============================================================================
-- Module: NexusUI/Layout/Center
-- ============================================================================
NexusUI_Modules["NexusUI/Layout/Center"] = function()
    local script = CreateMockScript("NexusUI/Layout/Center")
    
    --[[
        NexusUI Center Layout
        Centers content within container
    ]]

    --// Center Module
    local Center = {}
    Center.__index = Center
    Center.ClassName = "CenterLayout"

    --// Constructor
    function Center.new(config)
        local self = setmetatable({}, Center)

        config = config or {}

        self.Horizontal = config.Horizontal ~= false
        self.Vertical = config.Vertical ~= false

        return self
    end

    --// Create centered container
    function Center:Create(parent)
        local container = Instance.new("Frame")
        container.Name = "CenterContainer"
        container.Size = UDim2.new(1, 0, 1, 0)
        container.BackgroundTransparency = 1

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Inner container for content
        local inner = Instance.new("Frame")
        inner.Name = "Content"
        inner.BackgroundTransparency = 1
        inner.AutomaticSize = Enum.AutomaticSize.XY
        inner.Parent = container

        -- Position based on centering options
        if self.Horizontal and self.Vertical then
            inner.Position = UDim2.new(0.5, 0, 0.5, 0)
            inner.AnchorPoint = Vector2.new(0.5, 0.5)
        elseif self.Horizontal then
            inner.Position = UDim2.new(0.5, 0, 0, 0)
            inner.AnchorPoint = Vector2.new(0.5, 0)
        elseif self.Vertical then
            inner.Position = UDim2.new(0, 0, 0.5, 0)
            inner.AnchorPoint = Vector2.new(0, 0.5)
        end

        self._content = inner

        return self
    end

    --// Get content container
    function Center:GetContent()
        return self._content
    end

    --// Add child to content
    function Center:AddChild(child)
        child.Parent = self._content
        return self
    end

    --// Destroy
    function Center:Destroy()
        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    --// Static helper
    function Center.apply(element)
        element.Position = UDim2.new(0.5, 0, 0.5, 0)
        element.AnchorPoint = Vector2.new(0.5, 0.5)
        return element
    end

    function Center.horizontal(element)
        element.Position = UDim2.new(0.5, 0, element.Position.Y.Scale, element.Position.Y.Offset)
        element.AnchorPoint = Vector2.new(0.5, element.AnchorPoint.Y)
        return element
    end

    function Center.vertical(element)
        element.Position = UDim2.new(element.Position.X.Scale, element.Position.X.Offset, 0.5, 0)
        element.AnchorPoint = Vector2.new(element.AnchorPoint.X, 0.5)
        return element
    end

    return Center


end


-- ============================================================================
-- Module: NexusUI/Layout/Spacer
-- ============================================================================
NexusUI_Modules["NexusUI/Layout/Spacer"] = function()
    local script = CreateMockScript("NexusUI/Layout/Spacer")
    
    --[[
        NexusUI Spacer Component
        Flexible spacer for layouts
    ]]

    --// Spacer Module
    local Spacer = {}
    Spacer.__index = Spacer
    Spacer.ClassName = "Spacer"

    --// Constructor
    function Spacer.new(config)
        local self = setmetatable({}, Spacer)

        config = config or {}

        self.Size = config.Size -- nil for flexible, number for fixed
        self.Direction = config.Direction or "Both" -- Horizontal, Vertical, Both

        return self
    end

    --// Create spacer
    function Spacer:Create(parent)
        local spacer = Instance.new("Frame")
        spacer.Name = "Spacer"
        spacer.BackgroundTransparency = 1
        spacer.BorderSizePixel = 0

        if self.Size then
            -- Fixed size
            if self.Direction == "Horizontal" then
                spacer.Size = UDim2.new(0, self.Size, 1, 0)
            elseif self.Direction == "Vertical" then
                spacer.Size = UDim2.new(1, 0, 0, self.Size)
            else
                spacer.Size = UDim2.new(0, self.Size, 0, self.Size)
            end
        else
            -- Flexible (fills available space)
            if self.Direction == "Horizontal" then
                spacer.Size = UDim2.new(1, 0, 0, 0)
                spacer.AutomaticSize = Enum.AutomaticSize.None
            elseif self.Direction == "Vertical" then
                spacer.Size = UDim2.new(0, 0, 1, 0)
                spacer.AutomaticSize = Enum.AutomaticSize.None
            else
                spacer.Size = UDim2.new(1, 0, 1, 0)
            end
        end

        if parent then
            spacer.Parent = parent
        end

        self.Instance = spacer

        return self
    end

    --// Set size
    function Spacer:SetSize(size)
        self.Size = size

        if self.Instance then
            if size then
                if self.Direction == "Horizontal" then
                    self.Instance.Size = UDim2.new(0, size, 1, 0)
                elseif self.Direction == "Vertical" then
                    self.Instance.Size = UDim2.new(1, 0, 0, size)
                else
                    self.Instance.Size = UDim2.new(0, size, 0, size)
                end
            end
        end

        return self
    end

    --// Destroy
    function Spacer:Destroy()
        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    --// Static helpers
    function Spacer.horizontal(size, parent)
        local spacer = Spacer.new({
            Size = size,
            Direction = "Horizontal"
        })
        return spacer:Create(parent)
    end

    function Spacer.vertical(size, parent)
        local spacer = Spacer.new({
            Size = size,
            Direction = "Vertical"
        })
        return spacer:Create(parent)
    end

    function Spacer.flex(parent)
        local spacer = Spacer.new({
            Direction = "Both"
        })
        return spacer:Create(parent)
    end

    return Spacer


end


-- ============================================================================
-- Module: NexusUI/Layout/Responsive
-- ============================================================================
NexusUI_Modules["NexusUI/Layout/Responsive"] = function()
    local script = CreateMockScript("NexusUI/Layout/Responsive")
    
    --[[
        NexusUI Responsive Layout
        Responsive breakpoint system
    ]]

    --// Services
    local Workspace = game:GetService("Workspace")

    --// Responsive Module
    local Responsive = {}
    Responsive.__index = Responsive
    Responsive.ClassName = "ResponsiveLayout"

    --// Breakpoints
    Responsive.Breakpoints = {
        xs = 0,    -- Extra small (mobile)
        sm = 576,  -- Small
        md = 768,  -- Medium
        lg = 992,  -- Large
        xl = 1200, -- Extra large
        xxl = 1400, -- Extra extra large
    }

    --// Constructor
    function Responsive.new(config)
        local self = setmetatable({}, Responsive)

        config = config or {}

        self.Breakpoints = config.Breakpoints or Responsive.Breakpoints
        self.Styles = config.Styles or {} -- {breakpoint: {property: value}}

        -- State
        self._currentBreakpoint = nil
        self._connections = {}

        return self
    end

    --// Get current breakpoint
    function Responsive:_getBreakpoint()
        local camera = Workspace.CurrentCamera
        if not camera then return "md" end

        local width = camera.ViewportSize.X

        local current = "xs"
        for name, minWidth in pairs(self.Breakpoints) do
            if width >= minWidth then
                -- Find the highest matching breakpoint
                if minWidth >= (self.Breakpoints[current] or 0) then
                    current = name
                end
            end
        end

        return current
    end

    --// Apply responsive styles
    function Responsive:Apply(element)
        self._element = element

        -- Initial application
        self:_updateStyles()

        -- Watch for viewport changes
        local camera = Workspace.CurrentCamera
        if camera then
            local connection = camera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
                self:_updateStyles()
            end)
            table.insert(self._connections, connection)
        end

        return self
    end

    --// Update styles based on breakpoint
    function Responsive:_updateStyles()
        local breakpoint = self:_getBreakpoint()

        if breakpoint == self._currentBreakpoint then return end
        self._currentBreakpoint = breakpoint

        local element = self._element
        if not element then return end

        -- Get breakpoint order
        local order = {"xs", "sm", "md", "lg", "xl", "xxl"}
        local breakpointIndex = table.find(order, breakpoint) or 1

        -- Apply styles from smallest to current breakpoint (cascading)
        local appliedStyles = {}
        for i = 1, breakpointIndex do
            local bp = order[i]
            local styles = self.Styles[bp]

            if styles then
                for property, value in pairs(styles) do
                    appliedStyles[property] = value
                end
            end
        end

        -- Apply to element
        for property, value in pairs(appliedStyles) do
            pcall(function()
                element[property] = value
            end)
        end
    end

    --// Add style for breakpoint
    function Responsive:AddStyle(breakpoint, property, value)
        if not self.Styles[breakpoint] then
            self.Styles[breakpoint] = {}
        end
        self.Styles[breakpoint][property] = value

        self:_updateStyles()
        return self
    end

    --// Set styles for breakpoint
    function Responsive:SetStyles(breakpoint, styles)
        self.Styles[breakpoint] = styles
        self:_updateStyles()
        return self
    end

    --// Get current breakpoint
    function Responsive:GetCurrentBreakpoint()
        return self._currentBreakpoint or self:_getBreakpoint()
    end

    --// Check breakpoint
    function Responsive:IsBreakpoint(breakpoint)
        return self:GetCurrentBreakpoint() == breakpoint
    end

    --// Check if at least breakpoint
    function Responsive:IsAtLeast(breakpoint)
        local order = {"xs", "sm", "md", "lg", "xl", "xxl"}
        local currentIndex = table.find(order, self:GetCurrentBreakpoint()) or 1
        local targetIndex = table.find(order, breakpoint) or 1

        return currentIndex >= targetIndex
    end

    --// Destroy
    function Responsive:Destroy()
        for _, connection in ipairs(self._connections) do
            connection:Disconnect()
        end
        self._connections = {}

        self._element = nil
    end

    --// Static helpers
    function Responsive.getBreakpoint()
        local camera = Workspace.CurrentCamera
        if not camera then return "md" end

        local width = camera.ViewportSize.X

        if width < 576 then return "xs"
        elseif width < 768 then return "sm"
        elseif width < 992 then return "md"
        elseif width < 1200 then return "lg"
        elseif width < 1400 then return "xl"
        else return "xxl" end
    end

    function Responsive.isMobile()
        return Responsive.getBreakpoint() == "xs" or Responsive.getBreakpoint() == "sm"
    end

    function Responsive.isDesktop()
        local bp = Responsive.getBreakpoint()
        return bp == "lg" or bp == "xl" or bp == "xxl"
    end

    return Responsive


end


-- ============================================================================
-- Module: NexusUI/Layout/Container
-- ============================================================================
NexusUI_Modules["NexusUI/Layout/Container"] = function()
    local script = CreateMockScript("NexusUI/Layout/Container")
    
    --[[
        NexusUI Container Layout
        General-purpose container with common styling
    ]]

    --// Container Module
    local Container = {}
    Container.__index = Container
    Container.ClassName = "Container"

    --// Constructor
    function Container.new(config)
        local self = setmetatable({}, Container)

        config = config or {}

        self.Width = config.Width -- nil for full width
        self.MaxWidth = config.MaxWidth
        self.Padding = config.Padding or 0
        self.Centered = config.Centered ~= false
        self.Background = config.Background -- Color3 or nil
        self.BackgroundTransparency = config.BackgroundTransparency or (config.Background and 0 or 1)
        self.CornerRadius = config.CornerRadius or 0

        return self
    end

    --// Create container
    function Container:Create(parent)
        local container = Instance.new("Frame")
        container.Name = "Container"
        container.BackgroundTransparency = self.BackgroundTransparency
        container.BorderSizePixel = 0

        -- Size
        if self.Width then
            container.Size = UDim2.new(0, self.Width, 1, 0)
        else
            container.Size = UDim2.new(1, 0, 1, 0)
        end

        -- Centering
        if self.Centered then
            container.Position = UDim2.new(0.5, 0, 0, 0)
            container.AnchorPoint = Vector2.new(0.5, 0)
        end

        -- Background
        if self.Background then
            container.BackgroundColor3 = self.Background
        end

        -- Corner radius
        if self.CornerRadius > 0 then
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, self.CornerRadius)
            corner.Parent = container
        end

        -- Padding
        if self.Padding > 0 then
            local padding
            if type(self.Padding) == "number" then
                padding = Instance.new("UIPadding")
                padding.PaddingTop = UDim.new(0, self.Padding)
                padding.PaddingBottom = UDim.new(0, self.Padding)
                padding.PaddingLeft = UDim.new(0, self.Padding)
                padding.PaddingRight = UDim.new(0, self.Padding)
            elseif type(self.Padding) == "table" then
                padding = Instance.new("UIPadding")
                padding.PaddingTop = UDim.new(0, self.Padding[1] or 0)
                padding.PaddingRight = UDim.new(0, self.Padding[2] or 0)
                padding.PaddingBottom = UDim.new(0, self.Padding[3] or 0)
                padding.PaddingLeft = UDim.new(0, self.Padding[4] or 0)
            end

            if padding then
                padding.Parent = container
            end
        end

        -- Max width constraint
        if self.MaxWidth then
            local constraint = Instance.new("UISizeConstraint")
            constraint.MaxSize = Vector2.new(self.MaxWidth, math.huge)
            constraint.Parent = container
        end

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        return self
    end

    --// Add child
    function Container:AddChild(child)
        child.Parent = self.Instance
        return self
    end

    --// Set background
    function Container:SetBackground(color, transparency)
        if self.Instance then
            if color then
                self.Instance.BackgroundColor3 = color
                self.Instance.BackgroundTransparency = transparency or 0
            else
                self.Instance.BackgroundTransparency = 1
            end
        end
        return self
    end

    --// Destroy
    function Container:Destroy()
        if self.Instance then
            self.Instance:Destroy()
            self.Instance = nil
        end
    end

    --// Static helpers
    function Container.fluid(config)
        config = config or {}
        config.Width = nil
        return Container.new(config)
    end

    function Container.fixed(width, config)
        config = config or {}
        config.Width = width
        return Container.new(config)
    end

    function Container.responsive(config)
        -- Returns container that adjusts based on viewport
        config = config or {}

        local container = Container.new(config)

        -- Would integrate with Responsive module

        return container
    end

    return Container


end


-- ============================================================================
-- Module: NexusUI/Layout/Utils
-- ============================================================================
NexusUI_Modules["NexusUI/Layout/Utils"] = function()
    local script = CreateMockScript("NexusUI/Layout/Utils")
    
    --[[
        NexusUI Layout Utilities
        Helper functions for layout calculations
    ]]

    --// Utils Module
    local Utils = {}

    --// Calculate aspect ratio
    function Utils.aspectRatio(width, height)
        return width / height
    end

    --// Fit element to container while maintaining aspect ratio
    function Utils.fitAspectRatio(containerWidth, containerHeight, contentWidth, contentHeight, mode)
        mode = mode or "contain" -- contain or cover

        local containerRatio = containerWidth / containerHeight
        local contentRatio = contentWidth / contentHeight

        local finalWidth, finalHeight

        if mode == "contain" then
            if contentRatio > containerRatio then
                finalWidth = containerWidth
                finalHeight = containerWidth / contentRatio
            else
                finalHeight = containerHeight
                finalWidth = containerHeight * contentRatio
            end
        else -- cover
            if contentRatio > containerRatio then
                finalHeight = containerHeight
                finalWidth = containerHeight * contentRatio
            else
                finalWidth = containerWidth
                finalHeight = containerWidth / contentRatio
            end
        end

        return finalWidth, finalHeight
    end

    --// Calculate position to center element
    function Utils.centerPosition(containerWidth, containerHeight, elementWidth, elementHeight)
        return (containerWidth - elementWidth) / 2, (containerHeight - elementHeight) / 2
    end

    --// Calculate grid cell size
    function Utils.gridCellSize(containerWidth, containerHeight, columns, rows, gapX, gapY)
        gapX = gapX or 0
        gapY = gapY or 0

        local totalGapX = gapX * (columns - 1)
        local totalGapY = gapY * (rows - 1)

        local cellWidth = (containerWidth - totalGapX) / columns
        local cellHeight = (containerHeight - totalGapY) / rows

        return cellWidth, cellHeight
    end

    --// Calculate percentage
    function Utils.percentage(value, total)
        return (value / total) * 100
    end

    --// Calculate value from percentage
    function Utils.fromPercentage(percentage, total)
        return (percentage / 100) * total
    end

    --// Clamp value
    function Utils.clamp(value, min, max)
        return math.max(min, math.min(max, value))
    end

    --// Linear interpolation
    function Utils.lerp(a, b, t)
        return a + (b - a) * t
    end

    --// Inverse lerp
    function Utils.inverseLerp(a, b, value)
        if a == b then return 0 end
        return (value - a) / (b - a)
    end

    --// Map value from one range to another
    function Utils.map(value, inMin, inMax, outMin, outMax)
        return outMin + (value - inMin) * (outMax - outMin) / (inMax - inMin)
    end

    --// Round to nearest multiple
    function Utils.roundToMultiple(value, multiple)
        return math.floor(value / multiple + 0.5) * multiple
    end

    --// Calculate absolute position from relative
    function Utils.absolutePosition(relativeX, relativeY, containerWidth, containerHeight)
        return relativeX * containerWidth, relativeY * containerHeight
    end

    --// Calculate relative position from absolute
    function Utils.relativePosition(absoluteX, absoluteY, containerWidth, containerHeight)
        return absoluteX / containerWidth, absoluteY / containerHeight
    end

    --// Calculate distance between two points
    function Utils.distance(x1, y1, x2, y2)
        return math.sqrt((x2 - x1)^2 + (y2 - y1)^2)
    end

    --// Check if point is inside rectangle
    function Utils.isInsideRect(pointX, pointY, rectX, rectY, rectWidth, rectHeight)
        return pointX >= rectX and pointX <= rectX + rectWidth and
               pointY >= rectY and pointY <= rectY + rectHeight
    end

    --// Calculate overlap between two rectangles
    function Utils.rectangleOverlap(r1x, r1y, r1w, r1h, r2x, r2y, r2w, r2h)
        local overlapX = math.max(0, math.min(r1x + r1w, r2x + r2w) - math.max(r1x, r2x))
        local overlapY = math.max(0, math.min(r1y + r1h, r2y + r2h) - math.max(r1y, r2y))
        return overlapX * overlapY
    end

    --// Distribute items evenly
    function Utils.distributeEvenly(count, totalSpace, itemSize, includeEnds)
        if count <= 0 then return {} end

        local positions = {}
        local totalItemSpace = count * itemSize
        local remainingSpace = totalSpace - totalItemSpace

        local gaps
        if includeEnds then
            gaps = count + 1
        else
            gaps = math.max(1, count - 1)
        end

        local gapSize = remainingSpace / gaps

        for i = 1, count do
            local position
            if includeEnds then
                position = gapSize + (i - 1) * (itemSize + gapSize)
            else
                position = (i - 1) * (itemSize + gapSize)
            end
            table.insert(positions, position)
        end

        return positions
    end

    --// Calculate safe area (accounting for notches, etc.)
    function Utils.getSafeArea()
        -- Returns top, right, bottom, left insets
        -- In Roblox, we can use GuiService:GetGuiInset()
        local GuiService = game:GetService("GuiService")
        local inset = GuiService:GetGuiInset()

        return {
            top = inset.Y,
            right = 0,
            bottom = 0,
            left = 0,
        }
    end

    return Utils


end


-- ============================================================================
-- Module: NexusUI/Layout/init
-- ============================================================================
NexusUI_Modules["NexusUI/Layout/init"] = function()
    local script = CreateMockScript("NexusUI/Layout/init")
    
    --[[
        NexusUI Layout Module
        Layout utilities and helpers
    ]]

    --// Layout Module
    local Layout = {}

    Layout.Flex = NexusRequire("NexusUI/Layout/Flex")
    Layout.Grid = NexusRequire("NexusUI/Layout/Grid")
    Layout.Stack = NexusRequire("NexusUI/Layout/Stack")
    Layout.Center = NexusRequire("NexusUI/Layout/Center")
    Layout.Spacer = NexusRequire("NexusUI/Layout/Spacer")
    Layout.Responsive = NexusRequire("NexusUI/Layout/Responsive")
    Layout.Container = NexusRequire("NexusUI/Layout/Container")
    Layout.Utils = NexusRequire("NexusUI/Layout/Utils")

    return Layout


end


-- ============================================================================
-- Module: NexusUI/Assets/Icons
-- ============================================================================
NexusUI_Modules["NexusUI/Assets/Icons"] = function()
    local script = CreateMockScript("NexusUI/Assets/Icons")
    
    --[[
        NexusUI Icons
        Icon library and management
    ]]

    --// Icons Module
    local Icons = {}

    --// Icon asset IDs (using free Roblox asset IDs)
    Icons.List = {
        -- Navigation
        Home = "rbxassetid://7072719587",
        Menu = "rbxassetid://7072720871",
        MenuClose = "rbxassetid://7072725342",
        ArrowLeft = "rbxassetid://7072703107",
        ArrowRight = "rbxassetid://7072703296",
        ArrowUp = "rbxassetid://7072703444",
        ArrowDown = "rbxassetid://7072703000",
        ChevronLeft = "rbxassetid://7072706663",
        ChevronRight = "rbxassetid://7072706820",
        ChevronUp = "rbxassetid://7072706973",
        ChevronDown = "rbxassetid://7072706544",
        Expand = "rbxassetid://7072710755",
        Collapse = "rbxassetid://7072707660",

        -- Actions
        Check = "rbxassetid://7072706016",
        Close = "rbxassetid://7072725342",
        Plus = "rbxassetid://7072723422",
        Minus = "rbxassetid://7072721098",
        Edit = "rbxassetid://7072710028",
        Delete = "rbxassetid://7072709279",
        Copy = "rbxassetid://7072707989",
        Paste = "rbxassetid://7072722817",
        Cut = "rbxassetid://7072708890",
        Save = "rbxassetid://7072723844",
        Download = "rbxassetid://7072709629",
        Upload = "rbxassetid://7072725180",
        Refresh = "rbxassetid://7072723608",
        Undo = "rbxassetid://7072725042",
        Redo = "rbxassetid://7072723542",

        -- Status
        Info = "rbxassetid://7072718185",
        Warning = "rbxassetid://7072725760",
        Error = "rbxassetid://7072706350",
        Success = "rbxassetid://7072706016",
        Question = "rbxassetid://7072723351",

        -- UI Elements
        Settings = "rbxassetid://7072724058",
        Gear = "rbxassetid://7072717028",
        User = "rbxassetid://7072725527",
        Users = "rbxassetid://7072725596",
        Search = "rbxassetid://7072723946",
        Filter = "rbxassetid://7072717163",
        Sort = "rbxassetid://7072724249",
        Lock = "rbxassetid://7072720420",
        Unlock = "rbxassetid://7072725113",
        Eye = "rbxassetid://7072710906",
        EyeOff = "rbxassetid://7072711032",
        Heart = "rbxassetid://7072717700",
        HeartFilled = "rbxassetid://7072717561",
        Star = "rbxassetid://7072724388",
        StarFilled = "rbxassetid://7072724510",

        -- Media
        Play = "rbxassetid://7072723127",
        Pause = "rbxassetid://7072722602",
        Stop = "rbxassetid://7072724637",
        SkipForward = "rbxassetid://7072724138",
        SkipBack = "rbxassetid://7072724179",
        Volume = "rbxassetid://7072725667",
        VolumeOff = "rbxassetid://7072725706",
        Microphone = "rbxassetid://7072720953",
        MicrophoneOff = "rbxassetid://7072721026",
        Camera = "rbxassetid://7072706222",
        Image = "rbxassetid://7072717922",
        Video = "rbxassetid://7072725419",
        Music = "rbxassetid://7072721435",

        -- File
        File = "rbxassetid://7072711258",
        FileText = "rbxassetid://7072711384",
        Folder = "rbxassetid://7072716795",
        FolderOpen = "rbxassetid://7072716892",
        Archive = "rbxassetid://7072702841",

        -- Communication
        Mail = "rbxassetid://7072720659",
        Message = "rbxassetid://7072720800",
        Chat = "rbxassetid://7072706432",
        Bell = "rbxassetid://7072704113",
        BellOff = "rbxassetid://7072704273",

        -- Misc
        Clock = "rbxassetid://7072707510",
        Calendar = "rbxassetid://7072705891",
        Map = "rbxassetid://7072720734",
        Pin = "rbxassetid://7072723001",
        Link = "rbxassetid://7072720149",
        ExternalLink = "rbxassetid://7072710647",
        Code = "rbxassetid://7072707783",
        Terminal = "rbxassetid://7072724853",
        Database = "rbxassetid://7072709037",
        Cloud = "rbxassetid://7072707374",
        Sun = "rbxassetid://7072724735",
        Moon = "rbxassetid://7072721235",

        -- Gaming
        Gamepad = "rbxassetid://7072716958",
        Trophy = "rbxassetid://7072724969",
        Target = "rbxassetid://7072724783",
        Crosshair = "rbxassetid://7072708702",
        Shield = "rbxassetid://7072724165",
        Sword = "rbxassetid://7072724692",
    }

    --// Get icon by name
    function Icons.Get(name)
        return Icons.List[name]
    end

    --// Get all icon names
    function Icons.GetNames()
        local names = {}
        for name in pairs(Icons.List) do
            table.insert(names, name)
        end
        table.sort(names)
        return names
    end

    --// Check if icon exists
    function Icons.Exists(name)
        return Icons.List[name] ~= nil
    end

    --// Create icon image label
    function Icons.Create(name, size, color, parent)
        local iconId = Icons.List[name]
        if not iconId then
            warn("[NexusUI Icons] Unknown icon:", name)
            return nil
        end

        local icon = Instance.new("ImageLabel")
        icon.Name = "Icon_" .. name
        icon.Size = UDim2.new(0, size or 16, 0, size or 16)
        icon.BackgroundTransparency = 1
        icon.Image = iconId
        icon.ImageColor3 = color or Color3.fromRGB(255, 255, 255)
        icon.ScaleType = Enum.ScaleType.Fit

        if parent then
            icon.Parent = parent
        end

        return icon
    end

    --// Create icon button
    function Icons.CreateButton(name, size, color, parent)
        local iconId = Icons.List[name]
        if not iconId then
            warn("[NexusUI Icons] Unknown icon:", name)
            return nil
        end

        local button = Instance.new("ImageButton")
        button.Name = "IconBtn_" .. name
        button.Size = UDim2.new(0, size or 24, 0, size or 24)
        button.BackgroundTransparency = 1
        button.Image = iconId
        button.ImageColor3 = color or Color3.fromRGB(255, 255, 255)
        button.ScaleType = Enum.ScaleType.Fit
        button.AutoButtonColor = false

        if parent then
            button.Parent = parent
        end

        return button
    end

    --// Register custom icon
    function Icons.Register(name, assetId)
        Icons.List[name] = assetId
    end

    --// Register multiple icons
    function Icons.RegisterBatch(icons)
        for name, assetId in pairs(icons) do
            Icons.List[name] = assetId
        end
    end

    return Icons


end


-- ============================================================================
-- Module: NexusUI/Assets/Images
-- ============================================================================
NexusUI_Modules["NexusUI/Assets/Images"] = function()
    local script = CreateMockScript("NexusUI/Assets/Images")
    
    --[[
        NexusUI Images
        Image asset management
    ]]

    --// Images Module
    local Images = {}

    --// Common images
    Images.List = {
        -- Shadows
        Shadow = "rbxassetid://6015897843",
        ShadowSmall = "rbxassetid://6015897843",

        -- Gradients
        GradientHorizontal = "rbxassetid://2968001672",
        GradientVertical = "rbxassetid://2968001672",
        GradientRadial = "rbxassetid://2968001672",

        -- Patterns
        Noise = "rbxassetid://8553713741",
        Dots = "rbxassetid://2508702972",
        Grid = "rbxassetid://2508702972",
        Lines = "rbxassetid://2508702972",

        -- Shapes
        Circle = "rbxassetid://3570695787",
        RoundedSquare = "rbxassetid://3570695787",
        Triangle = "rbxassetid://7072723678",

        -- UI Elements
        LoadingSpinner = "rbxassetid://6034818372",
        CheckMark = "rbxassetid://7072706016",

        -- Backgrounds
        AbstractBg1 = "rbxassetid://2508702972",
        AbstractBg2 = "rbxassetid://2508702972",
    }

    --// Get image by name
    function Images.Get(name)
        return Images.List[name]
    end

    --// Create image label
    function Images.Create(name, size, color, parent)
        local imageId = Images.List[name]
        if not imageId then
            warn("[NexusUI Images] Unknown image:", name)
            return nil
        end

        local image = Instance.new("ImageLabel")
        image.Name = "Image_" .. name
        image.Size = size or UDim2.new(1, 0, 1, 0)
        image.BackgroundTransparency = 1
        image.Image = imageId

        if color then
            image.ImageColor3 = color
        end

        if parent then
            image.Parent = parent
        end

        return image
    end

    --// Create shadow
    function Images.CreateShadow(parent, size, transparency)
        local shadow = Instance.new("ImageLabel")
        shadow.Name = "Shadow"
        shadow.Size = size or UDim2.new(1, 20, 1, 20)
        shadow.Position = UDim2.new(0.5, 0, 0.5, 4)
        shadow.AnchorPoint = Vector2.new(0.5, 0.5)
        shadow.BackgroundTransparency = 1
        shadow.Image = Images.List.Shadow
        shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
        shadow.ImageTransparency = transparency or 0.5
        shadow.ScaleType = Enum.ScaleType.Slice
        shadow.SliceCenter = Rect.new(49, 49, 450, 450)
        shadow.ZIndex = -1

        if parent then
            shadow.Parent = parent
        end

        return shadow
    end

    --// Register custom image
    function Images.Register(name, assetId)
        Images.List[name] = assetId
    end

    return Images


end


-- ============================================================================
-- Module: NexusUI/Assets/Fonts
-- ============================================================================
NexusUI_Modules["NexusUI/Assets/Fonts"] = function()
    local script = CreateMockScript("NexusUI/Assets/Fonts")
    
    --[[
        NexusUI Fonts
        Font management and presets
    ]]

    --// Fonts Module
    local Fonts = {}

    --// Font presets
    Fonts.Presets = {
        -- Default fonts
        Default = Enum.Font.Gotham,
        DefaultMedium = Enum.Font.GothamMedium,
        DefaultBold = Enum.Font.GothamBold,

        -- System fonts
        System = Enum.Font.GothamMedium,
        SystemLight = Enum.Font.Gotham,
        SystemBold = Enum.Font.GothamBold,

        -- Display fonts
        Display = Enum.Font.GothamBlack,
        DisplayBold = Enum.Font.GothamBold,

        -- Code fonts
        Code = Enum.Font.Code,
        Monospace = Enum.Font.RobotoMono,

        -- Legacy fonts
        Legacy = Enum.Font.SourceSans,
        LegacyBold = Enum.Font.SourceSansBold,
        LegacyItalic = Enum.Font.SourceSansItalic,

        -- Special fonts
        Fantasy = Enum.Font.Fantasy,
        Cartoon = Enum.Font.Cartoon,
        SciFi = Enum.Font.SciFi,

        -- Modern fonts
        Ubuntu = Enum.Font.Ubuntu,
        Nunito = Enum.Font.Nunito,
        Michroma = Enum.Font.Michroma,
        Oswald = Enum.Font.Oswald,
        Bangers = Enum.Font.Bangers,
    }

    --// Font sizes
    Fonts.Sizes = {
        XSmall = 10,
        Small = 12,
        Normal = 14,
        Medium = 16,
        Large = 18,
        XLarge = 20,
        XXLarge = 24,
        Heading = 28,
        Title = 32,
        Display = 40,
    }

    --// Font weights (for TextLabel/TextButton RichText)
    Fonts.Weights = {
        Light = 300,
        Regular = 400,
        Medium = 500,
        SemiBold = 600,
        Bold = 700,
        ExtraBold = 800,
        Black = 900,
    }

    --// Get font by name
    function Fonts.Get(name)
        return Fonts.Presets[name] or Fonts.Presets.Default
    end

    --// Get size by name
    function Fonts.GetSize(name)
        return Fonts.Sizes[name] or Fonts.Sizes.Normal
    end

    --// Apply font to element
    function Fonts.Apply(element, fontName, sizeName)
        if element:IsA("TextLabel") or element:IsA("TextButton") or element:IsA("TextBox") then
            element.Font = Fonts.Get(fontName or "Default")
            element.TextSize = Fonts.GetSize(sizeName or "Normal")
        end
        return element
    end

    --// Create styled text (returns formatted string for RichText)
    function Fonts.StyledText(text, options)
        options = options or {}

        local result = text

        if options.Bold then
            result = "<b>" .. result .. "</b>"
        end

        if options.Italic then
            result = "<i>" .. result .. "</i>"
        end

        if options.Underline then
            result = "<u>" .. result .. "</u>"
        end

        if options.Strike then
            result = "<s>" .. result .. "</s>"
        end

        if options.Size then
            result = string.format('<font size="%d">%s</font>', options.Size, result)
        end

        if options.Color then
            local hex = string.format("#%02X%02X%02X", 
                math.floor(options.Color.R * 255),
                math.floor(options.Color.G * 255),
                math.floor(options.Color.B * 255)
            )
            result = string.format('<font color="%s">%s</font>', hex, result)
        end

        return result
    end

    --// Register custom font preset
    function Fonts.Register(name, font)
        Fonts.Presets[name] = font
    end

    return Fonts


end


-- ============================================================================
-- Module: NexusUI/Assets/Sounds
-- ============================================================================
NexusUI_Modules["NexusUI/Assets/Sounds"] = function()
    local script = CreateMockScript("NexusUI/Assets/Sounds")
    
    --[[
        NexusUI Sound Assets
        Sound asset definitions
    ]]

    --// Sounds Module
    local Sounds = {}

    --// Sound asset IDs
    Sounds.List = {
        -- UI Sounds
        Click = "rbxassetid://6895079853",
        Hover = "rbxassetid://6895079949",
        Toggle = "rbxassetid://6895079707",
        Open = "rbxassetid://6895079586",
        Close = "rbxassetid://6895079453",
        Slide = "rbxassetid://6895079628",
        Type = "rbxassetid://6895079776",

        -- Notification sounds
        Notification = "rbxassetid://4590657391",
        Success = "rbxassetid://6026984224",
        Error = "rbxassetid://5356081124",
        Warning = "rbxassetid://4590657391",

        -- Game sounds
        Coin = "rbxassetid://4612373660",
        LevelUp = "rbxassetid://5153893389",
        Achievement = "rbxassetid://4612373660",

        -- Menu sounds
        MenuOpen = "rbxassetid://6895079586",
        MenuClose = "rbxassetid://6895079453",
        MenuSelect = "rbxassetid://6895079853",

        -- Misc
        Pop = "rbxassetid://6895079853",
        Swoosh = "rbxassetid://6895079628",
        Ding = "rbxassetid://4590657391",
    }

    --// Get sound by name
    function Sounds.Get(name)
        return Sounds.List[name]
    end

    --// Get all sound names
    function Sounds.GetNames()
        local names = {}
        for name in pairs(Sounds.List) do
            table.insert(names, name)
        end
        table.sort(names)
        return names
    end

    --// Register custom sound
    function Sounds.Register(name, assetId)
        Sounds.List[name] = assetId
    end

    --// Create sound instance
    function Sounds.Create(name, volume, parent)
        local soundId = Sounds.List[name]
        if not soundId then
            warn("[NexusUI Sounds] Unknown sound:", name)
            return nil
        end

        local sound = Instance.new("Sound")
        sound.Name = "Sound_" .. name
        sound.SoundId = soundId
        sound.Volume = volume or 0.5

        if parent then
            sound.Parent = parent
        end

        return sound
    end

    --// Play sound once
    function Sounds.PlayOnce(name, volume, parent)
        local sound = Sounds.Create(name, volume, parent or game:GetService("SoundService"))
        if sound then
            sound:Play()
            sound.Ended:Connect(function()
                sound:Destroy()
            end)
        end
        return sound
    end

    return Sounds


end


-- ============================================================================
-- Module: NexusUI/Assets/Sprites
-- ============================================================================
NexusUI_Modules["NexusUI/Assets/Sprites"] = function()
    local script = CreateMockScript("NexusUI/Assets/Sprites")
    
    --[[
        NexusUI Sprites
        Sprite sheet and atlas management
    ]]

    --// Sprites Module
    local Sprites = {}

    --// Sprite sheets
    Sprites.Sheets = {
        UI = {
            Image = "rbxassetid://2508702972",
            Size = Vector2.new(512, 512),
            Sprites = {
                Button = { Position = Vector2.new(0, 0), Size = Vector2.new(64, 32) },
                ButtonHover = { Position = Vector2.new(64, 0), Size = Vector2.new(64, 32) },
                Input = { Position = Vector2.new(0, 32), Size = Vector2.new(64, 32) },
                Checkbox = { Position = Vector2.new(0, 64), Size = Vector2.new(24, 24) },
                CheckboxChecked = { Position = Vector2.new(24, 64), Size = Vector2.new(24, 24) },
                Radio = { Position = Vector2.new(48, 64), Size = Vector2.new(24, 24) },
                RadioSelected = { Position = Vector2.new(72, 64), Size = Vector2.new(24, 24) },
                Toggle = { Position = Vector2.new(0, 88), Size = Vector2.new(48, 24) },
                ToggleOn = { Position = Vector2.new(48, 88), Size = Vector2.new(48, 24) },
            }
        },
        Icons = {
            Image = "rbxassetid://2508702972",
            Size = Vector2.new(512, 512),
            Sprites = {
                Home = { Position = Vector2.new(0, 0), Size = Vector2.new(24, 24) },
                Settings = { Position = Vector2.new(24, 0), Size = Vector2.new(24, 24) },
                User = { Position = Vector2.new(48, 0), Size = Vector2.new(24, 24) },
                Search = { Position = Vector2.new(72, 0), Size = Vector2.new(24, 24) },
            }
        }
    }

    --// Get sprite from sheet
    function Sprites.Get(sheetName, spriteName)
        local sheet = Sprites.Sheets[sheetName]
        if not sheet then
            warn("[NexusUI Sprites] Unknown sheet:", sheetName)
            return nil
        end

        local sprite = sheet.Sprites[spriteName]
        if not sprite then
            warn("[NexusUI Sprites] Unknown sprite:", spriteName, "in sheet:", sheetName)
            return nil
        end

        return {
            Image = sheet.Image,
            ImageRectOffset = sprite.Position,
            ImageRectSize = sprite.Size
        }
    end

    --// Create sprite image
    function Sprites.Create(sheetName, spriteName, size, color, parent)
        local spriteData = Sprites.Get(sheetName, spriteName)
        if not spriteData then return nil end

        local image = Instance.new("ImageLabel")
        image.Name = "Sprite_" .. spriteName
        image.Size = size or UDim2.new(0, spriteData.ImageRectSize.X, 0, spriteData.ImageRectSize.Y)
        image.BackgroundTransparency = 1
        image.Image = spriteData.Image
        image.ImageRectOffset = spriteData.ImageRectOffset
        image.ImageRectSize = spriteData.ImageRectSize

        if color then
            image.ImageColor3 = color
        end

        if parent then
            image.Parent = parent
        end

        return image
    end

    --// Register custom sprite sheet
    function Sprites.RegisterSheet(name, imageId, size, sprites)
        Sprites.Sheets[name] = {
            Image = imageId,
            Size = size,
            Sprites = sprites
        }
    end

    --// Add sprite to existing sheet
    function Sprites.AddSprite(sheetName, spriteName, position, size)
        local sheet = Sprites.Sheets[sheetName]
        if not sheet then
            warn("[NexusUI Sprites] Cannot add sprite, unknown sheet:", sheetName)
            return false
        end

        sheet.Sprites[spriteName] = {
            Position = position,
            Size = size
        }
        return true
    end

    return Sprites


end


-- ============================================================================
-- Module: NexusUI/Assets/Loader
-- ============================================================================
NexusUI_Modules["NexusUI/Assets/Loader"] = function()
    local script = CreateMockScript("NexusUI/Assets/Loader")
    
    --[[
        NexusUI Asset Loader
        Preload and cache assets
    ]]

    --// Services
    local ContentProvider = game:GetService("ContentProvider")

    --// Loader Module
    local Loader = {}
    Loader.__index = Loader
    Loader.ClassName = "AssetLoader"

    --// Singleton
    local _instance = nil

    --// Constructor
    function Loader.new()
        if _instance then
            return _instance
        end

        local self = setmetatable({}, Loader)

        self._cache = {}
        self._loading = {}
        self._loadedCount = 0
        self._totalCount = 0

        _instance = self

        return self
    end

    --// Get instance
    function Loader.getInstance()
        if not _instance then
            _instance = Loader.new()
        end
        return _instance
    end

    --// Preload single asset
    function Loader:PreloadAsync(assetId, callback)
        if self._cache[assetId] then
            if callback then callback(true) end
            return true
        end

        if self._loading[assetId] then
            -- Already loading
            return false
        end

        self._loading[assetId] = true
        self._totalCount = self._totalCount + 1

        local success = pcall(function()
            ContentProvider:PreloadAsync({assetId})
        end)

        self._cache[assetId] = success
        self._loading[assetId] = nil
        self._loadedCount = self._loadedCount + 1

        if callback then callback(success) end

        return success
    end

    --// Preload multiple assets
    function Loader:PreloadBatchAsync(assetIds, progressCallback, completeCallback)
        local total = #assetIds
        local loaded = 0
        local results = {}

        for _, assetId in ipairs(assetIds) do
            task.spawn(function()
                local success = self:PreloadAsync(assetId)
                results[assetId] = success
                loaded = loaded + 1

                if progressCallback then
                    progressCallback(loaded, total, assetId, success)
                end

                if loaded >= total and completeCallback then
                    completeCallback(results)
                end
            end)
        end
    end

    --// Preload all library assets
    function Loader:PreloadLibrary(progressCallback, completeCallback)
        local assets = {}

        -- Collect all asset IDs from library
        local Icons = NexusRequire("NexusUI/Icons")
        for _, assetId in pairs(Icons.List) do
            table.insert(assets, assetId)
        end

        local Images = NexusRequire("NexusUI/Images")
        for _, assetId in pairs(Images.List) do
            table.insert(assets, assetId)
        end

        local Sounds = NexusRequire("NexusUI/Sounds")
        for _, assetId in pairs(Sounds.List) do
            table.insert(assets, assetId)
        end

        self:PreloadBatchAsync(assets, progressCallback, completeCallback)
    end

    --// Check if asset is cached
    function Loader:IsCached(assetId)
        return self._cache[assetId] == true
    end

    --// Check if asset is loading
    function Loader:IsLoading(assetId)
        return self._loading[assetId] == true
    end

    --// Get loading progress
    function Loader:GetProgress()
        if self._totalCount == 0 then return 1 end
        return self._loadedCount / self._totalCount
    end

    --// Clear cache
    function Loader:ClearCache()
        self._cache = {}
        self._loadedCount = 0
        self._totalCount = 0
    end

    return Loader


end


-- ============================================================================
-- Module: NexusUI/Assets/Cache
-- ============================================================================
NexusUI_Modules["NexusUI/Assets/Cache"] = function()
    local script = CreateMockScript("NexusUI/Assets/Cache")
    
    --[[
        NexusUI Asset Cache
        In-memory caching for loaded assets
    ]]

    --// Cache Module
    local Cache = {}
    Cache.__index = Cache
    Cache.ClassName = "AssetCache"

    --// Singleton
    local _instance = nil

    --// Constructor
    function Cache.new()
        if _instance then
            return _instance
        end

        local self = setmetatable({}, Cache)

        self._cache = {}
        self._metadata = {}
        self._maxSize = 100 -- Maximum cached items
        self._accessOrder = {} -- LRU tracking

        _instance = self

        return self
    end

    --// Get instance
    function Cache.getInstance()
        if not _instance then
            _instance = Cache.new()
        end
        return _instance
    end

    --// Set max cache size
    function Cache:SetMaxSize(size)
        self._maxSize = size
        self:_Cleanup()
    end

    --// Get cached item
    function Cache:Get(key)
        local item = self._cache[key]
        if item then
            self:_UpdateAccess(key)
            return item
        end
        return nil
    end

    --// Set cached item
    function Cache:Set(key, value, metadata)
        if self:GetSize() >= self._maxSize then
            self:_EvictOldest()
        end

        self._cache[key] = value
        self._metadata[key] = metadata or {}
        self:_UpdateAccess(key)
    end

    --// Check if item exists
    function Cache:Has(key)
        return self._cache[key] ~= nil
    end

    --// Remove item
    function Cache:Remove(key)
        self._cache[key] = nil
        self._metadata[key] = nil

        for i, k in ipairs(self._accessOrder) do
            if k == key then
                table.remove(self._accessOrder, i)
                break
            end
        end
    end

    --// Get cache size
    function Cache:GetSize()
        local count = 0
        for _ in pairs(self._cache) do
            count = count + 1
        end
        return count
    end

    --// Clear cache
    function Cache:Clear()
        self._cache = {}
        self._metadata = {}
        self._accessOrder = {}
    end

    --// Get all keys
    function Cache:GetKeys()
        local keys = {}
        for key in pairs(self._cache) do
            table.insert(keys, key)
        end
        return keys
    end

    --// Get metadata for item
    function Cache:GetMetadata(key)
        return self._metadata[key]
    end

    --// Update access order (LRU)
    function Cache:_UpdateAccess(key)
        -- Remove existing entry
        for i, k in ipairs(self._accessOrder) do
            if k == key then
                table.remove(self._accessOrder, i)
                break
            end
        end

        -- Add to end (most recently used)
        table.insert(self._accessOrder, key)
    end

    --// Evict oldest item (LRU)
    function Cache:_EvictOldest()
        if #self._accessOrder > 0 then
            local oldestKey = table.remove(self._accessOrder, 1)
            self._cache[oldestKey] = nil
            self._metadata[oldestKey] = nil
        end
    end

    --// Cleanup excess items
    function Cache:_Cleanup()
        while self:GetSize() > self._maxSize do
            self:_EvictOldest()
        end
    end

    --// Get or create cached item
    function Cache:GetOrCreate(key, createFunc)
        local item = self:Get(key)
        if item then
            return item
        end

        local newItem = createFunc()
        self:Set(key, newItem)
        return newItem
    end

    return Cache


end


-- ============================================================================
-- Module: NexusUI/Assets/init
-- ============================================================================
NexusUI_Modules["NexusUI/Assets/init"] = function()
    local script = CreateMockScript("NexusUI/Assets/init")
    
    --[[
        NexusUI Assets Module
        Icons and asset management
    ]]

    --// Assets Module
    local Assets = {}

    Assets.Icons = NexusRequire("NexusUI/Assets/Icons")
    Assets.Images = NexusRequire("NexusUI/Assets/Images")
    Assets.Fonts = NexusRequire("NexusUI/Assets/Fonts")
    Assets.Sounds = NexusRequire("NexusUI/Assets/Sounds")
    Assets.Sprites = NexusRequire("NexusUI/Assets/Sprites")
    Assets.Loader = NexusRequire("NexusUI/Assets/Loader")
    Assets.Cache = NexusRequire("NexusUI/Assets/Cache")

    return Assets


end


-- ============================================================================
-- Module: NexusUI/Builders/UI
-- ============================================================================
NexusUI_Modules["NexusUI/Builders/UI"] = function()
    local script = CreateMockScript("NexusUI/Builders/UI")
    
    --[[
        NexusUI UI Builder
        Fluent interface for building UI elements
    ]]

    --// UI Builder
    local UIBuilder = {}
    UIBuilder.__index = UIBuilder
    UIBuilder.ClassName = "UIBuilder"

    --// Constructor
    function UIBuilder.new(className)
        local self = setmetatable({}, UIBuilder)

        self._className = className or "Frame"
        self._properties = {}
        self._children = {}
        self._events = {}
        self._constraints = {}
        self._modifiers = {}

        return self
    end

    --// Static create methods
    function UIBuilder.Frame()
        return UIBuilder.new("Frame")
    end

    function UIBuilder.TextLabel()
        return UIBuilder.new("TextLabel")
    end

    function UIBuilder.TextButton()
        return UIBuilder.new("TextButton")
    end

    function UIBuilder.TextBox()
        return UIBuilder.new("TextBox")
    end

    function UIBuilder.ImageLabel()
        return UIBuilder.new("ImageLabel")
    end

    function UIBuilder.ImageButton()
        return UIBuilder.new("ImageButton")
    end

    function UIBuilder.ScrollingFrame()
        return UIBuilder.new("ScrollingFrame")
    end

    function UIBuilder.ViewportFrame()
        return UIBuilder.new("ViewportFrame")
    end

    function UIBuilder.CanvasGroup()
        return UIBuilder.new("CanvasGroup")
    end

    --// Set property
    function UIBuilder:Set(property, value)
        self._properties[property] = value
        return self
    end

    --// Common property setters
    function UIBuilder:Name(name)
        return self:Set("Name", name)
    end

    function UIBuilder:Size(width, height, widthScale, heightScale)
        if typeof(width) == "UDim2" then
            return self:Set("Size", width)
        end
        widthScale = widthScale or 0
        heightScale = heightScale or 0
        return self:Set("Size", UDim2.new(widthScale, width, heightScale, height))
    end

    function UIBuilder:Position(x, y, xScale, yScale)
        if typeof(x) == "UDim2" then
            return self:Set("Position", x)
        end
        xScale = xScale or 0
        yScale = yScale or 0
        return self:Set("Position", UDim2.new(xScale, x, yScale, y))
    end

    function UIBuilder:AnchorPoint(x, y)
        if typeof(x) == "Vector2" then
            return self:Set("AnchorPoint", x)
        end
        return self:Set("AnchorPoint", Vector2.new(x, y or 0))
    end

    function UIBuilder:BackgroundColor(color)
        return self:Set("BackgroundColor3", color)
    end

    function UIBuilder:BackgroundTransparency(value)
        return self:Set("BackgroundTransparency", value)
    end

    function UIBuilder:BorderSizePixel(size)
        return self:Set("BorderSizePixel", size)
    end

    function UIBuilder:ClipsDescendants(value)
        return self:Set("ClipsDescendants", value)
    end

    function UIBuilder:ZIndex(index)
        return self:Set("ZIndex", index)
    end

    function UIBuilder:Visible(value)
        return self:Set("Visible", value)
    end

    --// Text properties
    function UIBuilder:Text(text)
        return self:Set("Text", text)
    end

    function UIBuilder:TextColor(color)
        return self:Set("TextColor3", color)
    end

    function UIBuilder:TextSize(size)
        return self:Set("TextSize", size)
    end

    function UIBuilder:Font(font)
        return self:Set("Font", font)
    end

    function UIBuilder:TextXAlignment(alignment)
        return self:Set("TextXAlignment", alignment)
    end

    function UIBuilder:TextYAlignment(alignment)
        return self:Set("TextYAlignment", alignment)
    end

    function UIBuilder:TextWrapped(value)
        return self:Set("TextWrapped", value)
    end

    function UIBuilder:RichText(value)
        return self:Set("RichText", value)
    end

    --// Image properties
    function UIBuilder:Image(assetId)
        return self:Set("Image", assetId)
    end

    function UIBuilder:ImageColor(color)
        return self:Set("ImageColor3", color)
    end

    function UIBuilder:ImageTransparency(value)
        return self:Set("ImageTransparency", value)
    end

    function UIBuilder:ScaleType(scaleType)
        return self:Set("ScaleType", scaleType)
    end

    --// Add corner radius
    function UIBuilder:CornerRadius(radius)
        if typeof(radius) == "number" then
            radius = UDim.new(0, radius)
        end
        table.insert(self._constraints, {
            Type = "UICorner",
            Properties = { CornerRadius = radius }
        })
        return self
    end

    --// Add padding
    function UIBuilder:Padding(top, right, bottom, left)
        if typeof(top) == "number" then
            top = UDim.new(0, top)
        end
        if typeof(right) == "number" then
            right = UDim.new(0, right or top.Offset)
        elseif not right then
            right = top
        end
        if typeof(bottom) == "number" then
            bottom = UDim.new(0, bottom or top.Offset)
        elseif not bottom then
            bottom = top
        end
        if typeof(left) == "number" then
            left = UDim.new(0, left or right.Offset)
        elseif not left then
            left = right
        end

        table.insert(self._constraints, {
            Type = "UIPadding",
            Properties = {
                PaddingTop = top,
                PaddingRight = right,
                PaddingBottom = bottom,
                PaddingLeft = left
            }
        })
        return self
    end

    --// Add stroke
    function UIBuilder:Stroke(color, thickness, transparency)
        table.insert(self._constraints, {
            Type = "UIStroke",
            Properties = {
                Color = color or Color3.fromRGB(255, 255, 255),
                Thickness = thickness or 1,
                Transparency = transparency or 0
            }
        })
        return self
    end

    --// Add gradient
    function UIBuilder:Gradient(colorSequence, rotation)
        table.insert(self._constraints, {
            Type = "UIGradient",
            Properties = {
                Color = colorSequence,
                Rotation = rotation or 0
            }
        })
        return self
    end

    --// Add list layout
    function UIBuilder:ListLayout(direction, padding, alignment)
        table.insert(self._constraints, {
            Type = "UIListLayout",
            Properties = {
                FillDirection = direction or Enum.FillDirection.Vertical,
                Padding = typeof(padding) == "number" and UDim.new(0, padding) or padding,
                HorizontalAlignment = alignment or Enum.HorizontalAlignment.Left,
                VerticalAlignment = alignment or Enum.VerticalAlignment.Top,
                SortOrder = Enum.SortOrder.LayoutOrder
            }
        })
        return self
    end

    --// Add grid layout
    function UIBuilder:GridLayout(cellSize, padding)
        table.insert(self._constraints, {
            Type = "UIGridLayout",
            Properties = {
                CellSize = cellSize or UDim2.new(0, 100, 0, 100),
                CellPadding = typeof(padding) == "number" and UDim2.new(0, padding, 0, padding) or padding,
                SortOrder = Enum.SortOrder.LayoutOrder
            }
        })
        return self
    end

    --// Add aspect ratio
    function UIBuilder:AspectRatio(ratio, type)
        table.insert(self._constraints, {
            Type = "UIAspectRatioConstraint",
            Properties = {
                AspectRatio = ratio or 1,
                AspectType = type or Enum.AspectType.FitWithinMaxSize
            }
        })
        return self
    end

    --// Add size constraint
    function UIBuilder:SizeConstraint(minSize, maxSize)
        table.insert(self._constraints, {
            Type = "UISizeConstraint",
            Properties = {
                MinSize = minSize or Vector2.new(0, 0),
                MaxSize = maxSize or Vector2.new(math.huge, math.huge)
            }
        })
        return self
    end

    --// Add child
    function UIBuilder:Child(child)
        table.insert(self._children, child)
        return self
    end

    --// Add multiple children
    function UIBuilder:Children(...)
        for _, child in ipairs({...}) do
            table.insert(self._children, child)
        end
        return self
    end

    --// Add event handler
    function UIBuilder:On(event, callback)
        self._events[event] = callback
        return self
    end

    --// Common events
    function UIBuilder:OnClick(callback)
        return self:On("MouseButton1Click", callback)
    end

    function UIBuilder:OnHover(enterCallback, leaveCallback)
        self:On("MouseEnter", enterCallback)
        if leaveCallback then
            self:On("MouseLeave", leaveCallback)
        end
        return self
    end

    function UIBuilder:OnFocusLost(callback)
        return self:On("FocusLost", callback)
    end

    --// Build the instance
    function UIBuilder:Build(parent)
        local instance = Instance.new(self._className)

        -- Apply properties
        for property, value in pairs(self._properties) do
            instance[property] = value
        end

        -- Apply constraints
        for _, constraint in ipairs(self._constraints) do
            local constraintInstance = Instance.new(constraint.Type)
            for property, value in pairs(constraint.Properties) do
                constraintInstance[property] = value
            end
            constraintInstance.Parent = instance
        end

        -- Add children
        for _, child in ipairs(self._children) do
            if typeof(child) == "table" and child.Build then
                child:Build(instance)
            elseif typeof(child) == "Instance" then
                child.Parent = instance
            end
        end

        -- Connect events
        for event, callback in pairs(self._events) do
            if instance[event] then
                instance[event]:Connect(callback)
            end
        end

        -- Set parent
        if parent then
            instance.Parent = parent
        end

        return instance
    end

    return UIBuilder


end


-- ============================================================================
-- Module: NexusUI/Builders/Window
-- ============================================================================
NexusUI_Modules["NexusUI/Builders/Window"] = function()
    local script = CreateMockScript("NexusUI/Builders/Window")
    
    --[[
        NexusUI Window Builder
        Builder pattern for creating windows
    ]]

    --// Window Builder
    local WindowBuilder = {}
    WindowBuilder.__index = WindowBuilder
    WindowBuilder.ClassName = "WindowBuilder"

    --// Constructor
    function WindowBuilder.new()
        local self = setmetatable({}, WindowBuilder)

        self._config = {
            Title = "Window",
            Size = UDim2.new(0, 500, 0, 400),
            Position = UDim2.new(0.5, 0, 0.5, 0),
            AnchorPoint = Vector2.new(0.5, 0.5),
            Theme = nil,
            Draggable = true,
            Resizable = true,
            MinSize = Vector2.new(200, 150),
            MaxSize = Vector2.new(1920, 1080),
            Closeable = true,
            Minimizable = true,
            Maximizable = true,
            ShowTitleBar = true,
            ShowStatusBar = false,
            StatusText = "",
            Icon = nil,
            Tabs = {},
            OnClose = nil,
            OnMinimize = nil,
            OnMaximize = nil,
            OnResize = nil,
            OnDrag = nil,
        }

        return self
    end

    --// Static create
    function WindowBuilder.Create()
        return WindowBuilder.new()
    end

    --// Title
    function WindowBuilder:Title(title)
        self._config.Title = title
        return self
    end

    --// Size
    function WindowBuilder:Size(width, height)
        if typeof(width) == "UDim2" then
            self._config.Size = width
        else
            self._config.Size = UDim2.new(0, width, 0, height)
        end
        return self
    end

    --// Position
    function WindowBuilder:Position(x, y)
        if typeof(x) == "UDim2" then
            self._config.Position = x
        else
            self._config.Position = UDim2.new(0.5, x - self._config.Size.X.Offset / 2, 0.5, y - self._config.Size.Y.Offset / 2)
        end
        return self
    end

    --// Center
    function WindowBuilder:Center()
        self._config.Position = UDim2.new(0.5, 0, 0.5, 0)
        self._config.AnchorPoint = Vector2.new(0.5, 0.5)
        return self
    end

    --// Theme
    function WindowBuilder:Theme(theme)
        self._config.Theme = theme
        return self
    end

    --// Draggable
    function WindowBuilder:Draggable(value)
        self._config.Draggable = value
        return self
    end

    --// Resizable
    function WindowBuilder:Resizable(value)
        self._config.Resizable = value
        return self
    end

    --// Min/Max size
    function WindowBuilder:MinSize(width, height)
        self._config.MinSize = Vector2.new(width, height)
        return self
    end

    function WindowBuilder:MaxSize(width, height)
        self._config.MaxSize = Vector2.new(width, height)
        return self
    end

    --// Window controls
    function WindowBuilder:Closeable(value)
        self._config.Closeable = value
        return self
    end

    function WindowBuilder:Minimizable(value)
        self._config.Minimizable = value
        return self
    end

    function WindowBuilder:Maximizable(value)
        self._config.Maximizable = value
        return self
    end

    --// Title bar
    function WindowBuilder:ShowTitleBar(value)
        self._config.ShowTitleBar = value
        return self
    end

    --// Status bar
    function WindowBuilder:ShowStatusBar(value, text)
        self._config.ShowStatusBar = value
        if text then
            self._config.StatusText = text
        end
        return self
    end

    --// Icon
    function WindowBuilder:Icon(icon)
        self._config.Icon = icon
        return self
    end

    --// Add tab
    function WindowBuilder:AddTab(name, config)
        table.insert(self._config.Tabs, {
            Name = name,
            Config = config or {}
        })
        return self
    end

    --// Event handlers
    function WindowBuilder:OnClose(callback)
        self._config.OnClose = callback
        return self
    end

    function WindowBuilder:OnMinimize(callback)
        self._config.OnMinimize = callback
        return self
    end

    function WindowBuilder:OnMaximize(callback)
        self._config.OnMaximize = callback
        return self
    end

    function WindowBuilder:OnResize(callback)
        self._config.OnResize = callback
        return self
    end

    function WindowBuilder:OnDrag(callback)
        self._config.OnDrag = callback
        return self
    end

    --// Build the window
    function WindowBuilder:Build(parent)
        -- Try to get the Components module
        local success, Components = pcall(function()
            return NexusRequire("Components")
        end)

        if success and Components and Components.Window then
            local window = Components.Window.new(self._config)

            -- Add tabs
            for _, tabConfig in ipairs(self._config.Tabs) do
                window:AddTab(tabConfig.Name, tabConfig.Config)
            end

            if parent then
                window:Mount(parent)
            end

            return window
        end

        -- Fallback: create basic window frame
        local window = Instance.new("Frame")
        window.Name = "Window_" .. self._config.Title
        window.Size = self._config.Size
        window.Position = self._config.Position
        window.AnchorPoint = self._config.AnchorPoint
        window.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        window.BorderSizePixel = 0

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = window

        -- Title bar
        if self._config.ShowTitleBar then
            local titleBar = Instance.new("Frame")
            titleBar.Name = "TitleBar"
            titleBar.Size = UDim2.new(1, 0, 0, 32)
            titleBar.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
            titleBar.BorderSizePixel = 0
            titleBar.Parent = window

            local titleCorner = Instance.new("UICorner")
            titleCorner.CornerRadius = UDim.new(0, 8)
            titleCorner.Parent = titleBar

            local title = Instance.new("TextLabel")
            title.Name = "Title"
            title.Size = UDim2.new(1, -80, 1, 0)
            title.Position = UDim2.new(0, 10, 0, 0)
            title.BackgroundTransparency = 1
            title.Text = self._config.Title
            title.TextColor3 = Color3.fromRGB(255, 255, 255)
            title.TextSize = 14
            title.Font = Enum.Font.GothamMedium
            title.TextXAlignment = Enum.TextXAlignment.Left
            title.Parent = titleBar
        end

        -- Content area
        local content = Instance.new("Frame")
        content.Name = "Content"
        content.Size = UDim2.new(1, -16, 1, self._config.ShowTitleBar and -40 or -8)
        content.Position = UDim2.new(0, 8, 0, self._config.ShowTitleBar and 36 or 4)
        content.BackgroundTransparency = 1
        content.Parent = window

        if parent then
            window.Parent = parent
        end

        return window
    end

    return WindowBuilder


end


-- ============================================================================
-- Module: NexusUI/Builders/Tab
-- ============================================================================
NexusUI_Modules["NexusUI/Builders/Tab"] = function()
    local script = CreateMockScript("NexusUI/Builders/Tab")
    
    --[[
        NexusUI Tab Builder
        Builder pattern for creating tab systems
    ]]

    --// Tab Builder
    local TabBuilder = {}
    TabBuilder.__index = TabBuilder
    TabBuilder.ClassName = "TabBuilder"

    --// Constructor
    function TabBuilder.new()
        local self = setmetatable({}, TabBuilder)

        self._config = {
            Position = "Top", -- Top, Bottom, Left, Right
            Style = "Default", -- Default, Pills, Underline, Vertical
            TabHeight = 32,
            TabWidth = nil, -- Auto if nil
            Padding = 4,
            Spacing = 4,
            ShowIcons = true,
            Animated = true,
            Theme = nil,
            DefaultTab = 1,
            OnTabChanged = nil,
        }

        self._tabs = {}

        return self
    end

    --// Static create
    function TabBuilder.Create()
        return TabBuilder.new()
    end

    --// Position
    function TabBuilder:Position(position)
        self._config.Position = position
        return self
    end

    --// Style
    function TabBuilder:Style(style)
        self._config.Style = style
        return self
    end

    --// Tab dimensions
    function TabBuilder:TabHeight(height)
        self._config.TabHeight = height
        return self
    end

    function TabBuilder:TabWidth(width)
        self._config.TabWidth = width
        return self
    end

    --// Spacing
    function TabBuilder:Padding(padding)
        self._config.Padding = padding
        return self
    end

    function TabBuilder:Spacing(spacing)
        self._config.Spacing = spacing
        return self
    end

    --// Show icons
    function TabBuilder:ShowIcons(value)
        self._config.ShowIcons = value
        return self
    end

    --// Animated
    function TabBuilder:Animated(value)
        self._config.Animated = value
        return self
    end

    --// Theme
    function TabBuilder:Theme(theme)
        self._config.Theme = theme
        return self
    end

    --// Default tab
    function TabBuilder:DefaultTab(index)
        self._config.DefaultTab = index
        return self
    end

    --// Event handler
    function TabBuilder:OnTabChanged(callback)
        self._config.OnTabChanged = callback
        return self
    end

    --// Add tab
    function TabBuilder:AddTab(name, config)
        config = config or {}
        table.insert(self._tabs, {
            Name = name,
            Icon = config.Icon,
            Content = config.Content,
            OnSelected = config.OnSelected,
            OnDeselected = config.OnDeselected,
            Disabled = config.Disabled or false,
        })
        return self
    end

    --// Build the tab system
    function TabBuilder:Build(parent)
        local isVertical = self._config.Position == "Left" or self._config.Position == "Right"

        -- Container
        local container = Instance.new("Frame")
        container.Name = "TabSystem"
        container.Size = UDim2.new(1, 0, 1, 0)
        container.BackgroundTransparency = 1

        -- Tab bar
        local tabBar = Instance.new("Frame")
        tabBar.Name = "TabBar"
        tabBar.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
        tabBar.BorderSizePixel = 0

        if isVertical then
            tabBar.Size = UDim2.new(0, 120, 1, 0)
            tabBar.Position = self._config.Position == "Left" and UDim2.new(0, 0, 0, 0) or UDim2.new(1, -120, 0, 0)
        else
            tabBar.Size = UDim2.new(1, 0, 0, self._config.TabHeight + self._config.Padding * 2)
            tabBar.Position = self._config.Position == "Top" and UDim2.new(0, 0, 0, 0) or UDim2.new(0, 0, 1, -(self._config.TabHeight + self._config.Padding * 2))
        end

        tabBar.Parent = container

        local tabBarCorner = Instance.new("UICorner")
        tabBarCorner.CornerRadius = UDim.new(0, 6)
        tabBarCorner.Parent = tabBar

        -- Tab layout
        local layout = Instance.new("UIListLayout")
        layout.FillDirection = isVertical and Enum.FillDirection.Vertical or Enum.FillDirection.Horizontal
        layout.Padding = UDim.new(0, self._config.Spacing)
        layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
        layout.VerticalAlignment = Enum.VerticalAlignment.Top
        layout.Parent = tabBar

        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, self._config.Padding)
        padding.PaddingBottom = UDim.new(0, self._config.Padding)
        padding.PaddingLeft = UDim.new(0, self._config.Padding)
        padding.PaddingRight = UDim.new(0, self._config.Padding)
        padding.Parent = tabBar

        -- Content area
        local contentArea = Instance.new("Frame")
        contentArea.Name = "ContentArea"
        contentArea.BackgroundTransparency = 1

        if isVertical then
            local barWidth = 120 + self._config.Padding
            if self._config.Position == "Left" then
                contentArea.Size = UDim2.new(1, -barWidth, 1, 0)
                contentArea.Position = UDim2.new(0, barWidth, 0, 0)
            else
                contentArea.Size = UDim2.new(1, -barWidth, 1, 0)
                contentArea.Position = UDim2.new(0, 0, 0, 0)
            end
        else
            local barHeight = self._config.TabHeight + self._config.Padding * 2
            if self._config.Position == "Top" then
                contentArea.Size = UDim2.new(1, 0, 1, -barHeight)
                contentArea.Position = UDim2.new(0, 0, 0, barHeight)
            else
                contentArea.Size = UDim2.new(1, 0, 1, -barHeight)
                contentArea.Position = UDim2.new(0, 0, 0, 0)
            end
        end

        contentArea.Parent = container

        -- Create tabs
        local tabButtons = {}
        local tabContents = {}
        local activeTab = nil

        local function selectTab(index)
            if activeTab == index then return end

            -- Deselect current
            if activeTab then
                local oldButton = tabButtons[activeTab]
                local oldContent = tabContents[activeTab]
                if oldButton then
                    oldButton.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
                end
                if oldContent then
                    oldContent.Visible = false
                end

                local tabConfig = self._tabs[activeTab]
                if tabConfig and tabConfig.OnDeselected then
                    tabConfig.OnDeselected()
                end
            end

            -- Select new
            activeTab = index
            local newButton = tabButtons[index]
            local newContent = tabContents[index]

            if newButton then
                newButton.BackgroundColor3 = Color3.fromRGB(60, 130, 255)
            end
            if newContent then
                newContent.Visible = true
            end

            local tabConfig = self._tabs[index]
            if tabConfig and tabConfig.OnSelected then
                tabConfig.OnSelected()
            end

            if self._config.OnTabChanged then
                self._config.OnTabChanged(index, tabConfig.Name)
            end
        end

        for i, tabConfig in ipairs(self._tabs) do
            -- Tab button
            local button = Instance.new("TextButton")
            button.Name = "Tab_" .. tabConfig.Name
            button.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
            button.BorderSizePixel = 0
            button.Text = tabConfig.Name
            button.TextColor3 = Color3.fromRGB(255, 255, 255)
            button.TextSize = 12
            button.Font = Enum.Font.GothamMedium
            button.AutoButtonColor = false

            if isVertical then
                button.Size = UDim2.new(1, 0, 0, self._config.TabHeight)
            else
                local width = self._config.TabWidth or (string.len(tabConfig.Name) * 8 + 24)
                button.Size = UDim2.new(0, width, 1, 0)
            end

            local buttonCorner = Instance.new("UICorner")
            buttonCorner.CornerRadius = UDim.new(0, 4)
            buttonCorner.Parent = button

            button.MouseButton1Click:Connect(function()
                if not tabConfig.Disabled then
                    selectTab(i)
                end
            end)

            button.Parent = tabBar
            tabButtons[i] = button

            -- Tab content
            local content = Instance.new("Frame")
            content.Name = "Content_" .. tabConfig.Name
            content.Size = UDim2.new(1, 0, 1, 0)
            content.BackgroundTransparency = 1
            content.Visible = false
            content.Parent = contentArea
            tabContents[i] = content
        end

        -- Select default tab
        selectTab(self._config.DefaultTab)

        if parent then
            container.Parent = parent
        end

        -- Return interface
        return {
            Instance = container,
            TabBar = tabBar,
            ContentArea = contentArea,
            TabButtons = tabButtons,
            TabContents = tabContents,
            SelectTab = selectTab,
            GetActiveTab = function() return activeTab end,
            GetTabContent = function(index) return tabContents[index] end,
        }
    end

    return TabBuilder


end


-- ============================================================================
-- Module: NexusUI/Builders/Section
-- ============================================================================
NexusUI_Modules["NexusUI/Builders/Section"] = function()
    local script = CreateMockScript("NexusUI/Builders/Section")
    
    --[[
        NexusUI Section Builder
        Builder pattern for creating sections
    ]]

    --// Section Builder
    local SectionBuilder = {}
    SectionBuilder.__index = SectionBuilder
    SectionBuilder.ClassName = "SectionBuilder"

    --// Constructor
    function SectionBuilder.new()
        local self = setmetatable({}, SectionBuilder)

        self._config = {
            Title = "Section",
            Collapsible = true,
            Collapsed = false,
            Padding = 12,
            Spacing = 8,
            HeaderHeight = 32,
            ShowDivider = false,
            ShowIcon = false,
            Icon = nil,
            Theme = nil,
            OnToggle = nil,
        }

        self._elements = {}

        return self
    end

    --// Static create
    function SectionBuilder.Create()
        return SectionBuilder.new()
    end

    --// Title
    function SectionBuilder:Title(title)
        self._config.Title = title
        return self
    end

    --// Collapsible
    function SectionBuilder:Collapsible(value)
        self._config.Collapsible = value
        return self
    end

    --// Start collapsed
    function SectionBuilder:Collapsed(value)
        self._config.Collapsed = value
        return self
    end

    --// Padding
    function SectionBuilder:Padding(padding)
        self._config.Padding = padding
        return self
    end

    --// Spacing
    function SectionBuilder:Spacing(spacing)
        self._config.Spacing = spacing
        return self
    end

    --// Header height
    function SectionBuilder:HeaderHeight(height)
        self._config.HeaderHeight = height
        return self
    end

    --// Show divider
    function SectionBuilder:ShowDivider(value)
        self._config.ShowDivider = value
        return self
    end

    --// Icon
    function SectionBuilder:Icon(icon)
        self._config.ShowIcon = true
        self._config.Icon = icon
        return self
    end

    --// Theme
    function SectionBuilder:Theme(theme)
        self._config.Theme = theme
        return self
    end

    --// On toggle callback
    function SectionBuilder:OnToggle(callback)
        self._config.OnToggle = callback
        return self
    end

    --// Add element
    function SectionBuilder:AddElement(element)
        table.insert(self._elements, element)
        return self
    end

    --// Add label
    function SectionBuilder:AddLabel(text, config)
        table.insert(self._elements, {
            Type = "Label",
            Text = text,
            Config = config or {}
        })
        return self
    end

    --// Add button
    function SectionBuilder:AddButton(text, callback, config)
        table.insert(self._elements, {
            Type = "Button",
            Text = text,
            Callback = callback,
            Config = config or {}
        })
        return self
    end

    --// Add toggle
    function SectionBuilder:AddToggle(text, default, callback, config)
        table.insert(self._elements, {
            Type = "Toggle",
            Text = text,
            Default = default,
            Callback = callback,
            Config = config or {}
        })
        return self
    end

    --// Add slider
    function SectionBuilder:AddSlider(text, min, max, default, callback, config)
        table.insert(self._elements, {
            Type = "Slider",
            Text = text,
            Min = min,
            Max = max,
            Default = default,
            Callback = callback,
            Config = config or {}
        })
        return self
    end

    --// Add input
    function SectionBuilder:AddInput(placeholder, default, callback, config)
        table.insert(self._elements, {
            Type = "Input",
            Placeholder = placeholder,
            Default = default,
            Callback = callback,
            Config = config or {}
        })
        return self
    end

    --// Add dropdown
    function SectionBuilder:AddDropdown(text, options, default, callback, config)
        table.insert(self._elements, {
            Type = "Dropdown",
            Text = text,
            Options = options,
            Default = default,
            Callback = callback,
            Config = config or {}
        })
        return self
    end

    --// Add color picker
    function SectionBuilder:AddColorPicker(text, default, callback, config)
        table.insert(self._elements, {
            Type = "ColorPicker",
            Text = text,
            Default = default,
            Callback = callback,
            Config = config or {}
        })
        return self
    end

    --// Add keybind
    function SectionBuilder:AddKeybind(text, default, callback, config)
        table.insert(self._elements, {
            Type = "Keybind",
            Text = text,
            Default = default,
            Callback = callback,
            Config = config or {}
        })
        return self
    end

    --// Build the section
    function SectionBuilder:Build(parent)
        local isCollapsed = self._config.Collapsed

        -- Container
        local container = Instance.new("Frame")
        container.Name = "Section_" .. self._config.Title
        container.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
        container.BorderSizePixel = 0
        container.AutomaticSize = Enum.AutomaticSize.Y
        container.Size = UDim2.new(1, 0, 0, 0)

        local containerCorner = Instance.new("UICorner")
        containerCorner.CornerRadius = UDim.new(0, 8)
        containerCorner.Parent = container

        -- Header
        local header = Instance.new("TextButton")
        header.Name = "Header"
        header.Size = UDim2.new(1, 0, 0, self._config.HeaderHeight)
        header.BackgroundTransparency = 1
        header.Text = ""
        header.AutoButtonColor = false
        header.Parent = container

        -- Arrow icon
        local arrow = Instance.new("TextLabel")
        arrow.Name = "Arrow"
        arrow.Size = UDim2.new(0, 20, 0, 20)
        arrow.Position = UDim2.new(0, 8, 0.5, 0)
        arrow.AnchorPoint = Vector2.new(0, 0.5)
        arrow.BackgroundTransparency = 1
        arrow.Text = isCollapsed and "▶" or "▼"
        arrow.TextColor3 = Color3.fromRGB(150, 150, 150)
        arrow.TextSize = 10
        arrow.Font = Enum.Font.GothamBold
        arrow.Parent = header

        -- Title
        local title = Instance.new("TextLabel")
        title.Name = "Title"
        title.Size = UDim2.new(1, -40, 1, 0)
        title.Position = UDim2.new(0, 32, 0, 0)
        title.BackgroundTransparency = 1
        title.Text = self._config.Title
        title.TextColor3 = Color3.fromRGB(255, 255, 255)
        title.TextSize = 13
        title.Font = Enum.Font.GothamMedium
        title.TextXAlignment = Enum.TextXAlignment.Left
        title.Parent = header

        -- Content container
        local content = Instance.new("Frame")
        content.Name = "Content"
        content.Size = UDim2.new(1, 0, 0, 0)
        content.Position = UDim2.new(0, 0, 0, self._config.HeaderHeight)
        content.BackgroundTransparency = 1
        content.AutomaticSize = Enum.AutomaticSize.Y
        content.Visible = not isCollapsed
        content.Parent = container

        local contentLayout = Instance.new("UIListLayout")
        contentLayout.FillDirection = Enum.FillDirection.Vertical
        contentLayout.Padding = UDim.new(0, self._config.Spacing)
        contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
        contentLayout.Parent = content

        local contentPadding = Instance.new("UIPadding")
        contentPadding.PaddingTop = UDim.new(0, 4)
        contentPadding.PaddingBottom = UDim.new(0, self._config.Padding)
        contentPadding.PaddingLeft = UDim.new(0, self._config.Padding)
        contentPadding.PaddingRight = UDim.new(0, self._config.Padding)
        contentPadding.Parent = content

        -- Toggle function
        local function toggle()
            if not self._config.Collapsible then return end

            isCollapsed = not isCollapsed
            arrow.Text = isCollapsed and "▶" or "▼"
            content.Visible = not isCollapsed

            if self._config.OnToggle then
                self._config.OnToggle(isCollapsed)
            end
        end

        header.MouseButton1Click:Connect(toggle)

        -- Create elements (simplified - actual implementation would use Components module)
        for i, element in ipairs(self._elements) do
            local elementFrame = Instance.new("Frame")
            elementFrame.Name = element.Type .. "_" .. i
            elementFrame.Size = UDim2.new(1, 0, 0, 32)
            elementFrame.BackgroundTransparency = 1
            elementFrame.LayoutOrder = i

            if element.Type == "Label" then
                local label = Instance.new("TextLabel")
                label.Size = UDim2.new(1, 0, 1, 0)
                label.BackgroundTransparency = 1
                label.Text = element.Text
                label.TextColor3 = Color3.fromRGB(200, 200, 200)
                label.TextSize = 12
                label.Font = Enum.Font.Gotham
                label.TextXAlignment = Enum.TextXAlignment.Left
                label.Parent = elementFrame

            elseif element.Type == "Button" then
                local button = Instance.new("TextButton")
                button.Size = UDim2.new(1, 0, 1, 0)
                button.BackgroundColor3 = Color3.fromRGB(60, 130, 255)
                button.BorderSizePixel = 0
                button.Text = element.Text
                button.TextColor3 = Color3.fromRGB(255, 255, 255)
                button.TextSize = 12
                button.Font = Enum.Font.GothamMedium
                button.AutoButtonColor = false
                button.Parent = elementFrame

                local btnCorner = Instance.new("UICorner")
                btnCorner.CornerRadius = UDim.new(0, 4)
                btnCorner.Parent = button

                button.MouseButton1Click:Connect(function()
                    if element.Callback then
                        element.Callback()
                    end
                end)
            end

            elementFrame.Parent = content
        end

        if parent then
            container.Parent = parent
        end

        -- Return interface
        return {
            Instance = container,
            Header = header,
            Content = content,
            Toggle = toggle,
            IsCollapsed = function() return isCollapsed end,
            SetCollapsed = function(collapsed)
                if collapsed ~= isCollapsed then
                    toggle()
                end
            end,
        }
    end

    return SectionBuilder


end


-- ============================================================================
-- Module: NexusUI/Builders/Form
-- ============================================================================
NexusUI_Modules["NexusUI/Builders/Form"] = function()
    local script = CreateMockScript("NexusUI/Builders/Form")
    
    --[[
        NexusUI Form Builder
        Builder pattern for creating forms
    ]]

    --// Form Builder
    local FormBuilder = {}
    FormBuilder.__index = FormBuilder
    FormBuilder.ClassName = "FormBuilder"

    --// Constructor
    function FormBuilder.new()
        local self = setmetatable({}, FormBuilder)

        self._config = {
            Title = "Form",
            ShowTitle = true,
            Padding = 16,
            Spacing = 12,
            LabelWidth = 120,
            ShowSubmit = true,
            SubmitText = "Submit",
            ShowReset = false,
            ResetText = "Reset",
            ShowCancel = false,
            CancelText = "Cancel",
            Validation = true,
            Theme = nil,
            OnSubmit = nil,
            OnReset = nil,
            OnCancel = nil,
            OnChange = nil,
        }

        self._fields = {}

        return self
    end

    --// Static create
    function FormBuilder.Create()
        return FormBuilder.new()
    end

    --// Title
    function FormBuilder:Title(title)
        self._config.Title = title
        return self
    end

    --// Show title
    function FormBuilder:ShowTitle(value)
        self._config.ShowTitle = value
        return self
    end

    --// Padding
    function FormBuilder:Padding(padding)
        self._config.Padding = padding
        return self
    end

    --// Spacing
    function FormBuilder:Spacing(spacing)
        self._config.Spacing = spacing
        return self
    end

    --// Label width
    function FormBuilder:LabelWidth(width)
        self._config.LabelWidth = width
        return self
    end

    --// Submit button
    function FormBuilder:ShowSubmit(value, text)
        self._config.ShowSubmit = value
        if text then
            self._config.SubmitText = text
        end
        return self
    end

    --// Reset button
    function FormBuilder:ShowReset(value, text)
        self._config.ShowReset = value
        if text then
            self._config.ResetText = text
        end
        return self
    end

    --// Cancel button
    function FormBuilder:ShowCancel(value, text)
        self._config.ShowCancel = value
        if text then
            self._config.CancelText = text
        end
        return self
    end

    --// Validation
    function FormBuilder:Validation(value)
        self._config.Validation = value
        return self
    end

    --// Theme
    function FormBuilder:Theme(theme)
        self._config.Theme = theme
        return self
    end

    --// Event handlers
    function FormBuilder:OnSubmit(callback)
        self._config.OnSubmit = callback
        return self
    end

    function FormBuilder:OnReset(callback)
        self._config.OnReset = callback
        return self
    end

    function FormBuilder:OnCancel(callback)
        self._config.OnCancel = callback
        return self
    end

    function FormBuilder:OnChange(callback)
        self._config.OnChange = callback
        return self
    end

    --// Add field
    function FormBuilder:AddField(config)
        table.insert(self._fields, config)
        return self
    end

    --// Add text input
    function FormBuilder:AddTextInput(name, label, config)
        config = config or {}
        table.insert(self._fields, {
            Type = "TextInput",
            Name = name,
            Label = label,
            Placeholder = config.Placeholder or "",
            Default = config.Default or "",
            Required = config.Required or false,
            Validate = config.Validate,
            MaxLength = config.MaxLength,
            Password = config.Password or false,
        })
        return self
    end

    --// Add number input
    function FormBuilder:AddNumberInput(name, label, config)
        config = config or {}
        table.insert(self._fields, {
            Type = "NumberInput",
            Name = name,
            Label = label,
            Default = config.Default or 0,
            Min = config.Min,
            Max = config.Max,
            Step = config.Step or 1,
            Required = config.Required or false,
        })
        return self
    end

    --// Add checkbox
    function FormBuilder:AddCheckbox(name, label, config)
        config = config or {}
        table.insert(self._fields, {
            Type = "Checkbox",
            Name = name,
            Label = label,
            Default = config.Default or false,
        })
        return self
    end

    --// Add radio group
    function FormBuilder:AddRadioGroup(name, label, options, config)
        config = config or {}
        table.insert(self._fields, {
            Type = "RadioGroup",
            Name = name,
            Label = label,
            Options = options,
            Default = config.Default,
            Required = config.Required or false,
        })
        return self
    end

    --// Add select/dropdown
    function FormBuilder:AddSelect(name, label, options, config)
        config = config or {}
        table.insert(self._fields, {
            Type = "Select",
            Name = name,
            Label = label,
            Options = options,
            Default = config.Default,
            Multiple = config.Multiple or false,
            Required = config.Required or false,
        })
        return self
    end

    --// Add textarea
    function FormBuilder:AddTextArea(name, label, config)
        config = config or {}
        table.insert(self._fields, {
            Type = "TextArea",
            Name = name,
            Label = label,
            Placeholder = config.Placeholder or "",
            Default = config.Default or "",
            Rows = config.Rows or 4,
            Required = config.Required or false,
            MaxLength = config.MaxLength,
        })
        return self
    end

    --// Add slider
    function FormBuilder:AddSlider(name, label, min, max, config)
        config = config or {}
        table.insert(self._fields, {
            Type = "Slider",
            Name = name,
            Label = label,
            Min = min,
            Max = max,
            Default = config.Default or min,
            Step = config.Step or 1,
        })
        return self
    end

    --// Add color picker
    function FormBuilder:AddColorPicker(name, label, config)
        config = config or {}
        table.insert(self._fields, {
            Type = "ColorPicker",
            Name = name,
            Label = label,
            Default = config.Default or Color3.fromRGB(255, 255, 255),
        })
        return self
    end

    --// Add date picker
    function FormBuilder:AddDatePicker(name, label, config)
        config = config or {}
        table.insert(self._fields, {
            Type = "DatePicker",
            Name = name,
            Label = label,
            Default = config.Default,
            MinDate = config.MinDate,
            MaxDate = config.MaxDate,
            Required = config.Required or false,
        })
        return self
    end

    --// Add divider
    function FormBuilder:AddDivider()
        table.insert(self._fields, {
            Type = "Divider",
        })
        return self
    end

    --// Add spacer
    function FormBuilder:AddSpacer(height)
        table.insert(self._fields, {
            Type = "Spacer",
            Height = height or 16,
        })
        return self
    end

    --// Build the form
    function FormBuilder:Build(parent)
        local formValues = {}
        local fieldInstances = {}

        -- Container
        local container = Instance.new("Frame")
        container.Name = "Form_" .. self._config.Title
        container.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        container.BorderSizePixel = 0
        container.AutomaticSize = Enum.AutomaticSize.Y
        container.Size = UDim2.new(1, 0, 0, 0)

        local containerCorner = Instance.new("UICorner")
        containerCorner.CornerRadius = UDim.new(0, 8)
        containerCorner.Parent = container

        local containerPadding = Instance.new("UIPadding")
        containerPadding.PaddingTop = UDim.new(0, self._config.Padding)
        containerPadding.PaddingBottom = UDim.new(0, self._config.Padding)
        containerPadding.PaddingLeft = UDim.new(0, self._config.Padding)
        containerPadding.PaddingRight = UDim.new(0, self._config.Padding)
        containerPadding.Parent = container

        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Vertical
        layout.Padding = UDim.new(0, self._config.Spacing)
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Parent = container

        -- Title
        if self._config.ShowTitle then
            local title = Instance.new("TextLabel")
            title.Name = "Title"
            title.Size = UDim2.new(1, 0, 0, 24)
            title.BackgroundTransparency = 1
            title.Text = self._config.Title
            title.TextColor3 = Color3.fromRGB(255, 255, 255)
            title.TextSize = 16
            title.Font = Enum.Font.GothamBold
            title.TextXAlignment = Enum.TextXAlignment.Left
            title.LayoutOrder = 0
            title.Parent = container
        end

        -- Create fields
        for i, field in ipairs(self._fields) do
            local fieldFrame = Instance.new("Frame")
            fieldFrame.Name = "Field_" .. (field.Name or i)
            fieldFrame.Size = UDim2.new(1, 0, 0, 32)
            fieldFrame.BackgroundTransparency = 1
            fieldFrame.LayoutOrder = i

            if field.Type == "Divider" then
                fieldFrame.Size = UDim2.new(1, 0, 0, 1)
                fieldFrame.BackgroundTransparency = 0
                fieldFrame.BackgroundColor3 = Color3.fromRGB(60, 60, 70)

            elseif field.Type == "Spacer" then
                fieldFrame.Size = UDim2.new(1, 0, 0, field.Height)

            elseif field.Type == "TextArea" then
                fieldFrame.Size = UDim2.new(1, 0, 0, field.Rows * 20 + 16)

                local label = Instance.new("TextLabel")
                label.Size = UDim2.new(0, self._config.LabelWidth, 0, 20)
                label.BackgroundTransparency = 1
                label.Text = field.Label .. (field.Required and " *" or "")
                label.TextColor3 = Color3.fromRGB(200, 200, 200)
                label.TextSize = 12
                label.Font = Enum.Font.Gotham
                label.TextXAlignment = Enum.TextXAlignment.Left
                label.Parent = fieldFrame

                local input = Instance.new("TextBox")
                input.Name = "Input"
                input.Size = UDim2.new(1, -self._config.LabelWidth - 8, 1, 0)
                input.Position = UDim2.new(0, self._config.LabelWidth + 8, 0, 0)
                input.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
                input.BorderSizePixel = 0
                input.Text = field.Default or ""
                input.PlaceholderText = field.Placeholder or ""
                input.TextColor3 = Color3.fromRGB(255, 255, 255)
                input.PlaceholderColor3 = Color3.fromRGB(120, 120, 120)
                input.TextSize = 12
                input.Font = Enum.Font.Gotham
                input.TextXAlignment = Enum.TextXAlignment.Left
                input.TextYAlignment = Enum.TextYAlignment.Top
                input.MultiLine = true
                input.TextWrapped = true
                input.ClearTextOnFocus = false
                input.Parent = fieldFrame

                local inputCorner = Instance.new("UICorner")
                inputCorner.CornerRadius = UDim.new(0, 4)
                inputCorner.Parent = input

                local inputPadding = Instance.new("UIPadding")
                inputPadding.PaddingTop = UDim.new(0, 8)
                inputPadding.PaddingLeft = UDim.new(0, 8)
                inputPadding.Parent = input

                formValues[field.Name] = field.Default or ""
                fieldInstances[field.Name] = input

                input:GetPropertyChangedSignal("Text"):Connect(function()
                    formValues[field.Name] = input.Text
                    if self._config.OnChange then
                        self._config.OnChange(field.Name, input.Text)
                    end
                end)

            else
                -- Generic field with label and input
                if field.Label then
                    local label = Instance.new("TextLabel")
                    label.Size = UDim2.new(0, self._config.LabelWidth, 1, 0)
                    label.BackgroundTransparency = 1
                    label.Text = field.Label .. (field.Required and " *" or "")
                    label.TextColor3 = Color3.fromRGB(200, 200, 200)
                    label.TextSize = 12
                    label.Font = Enum.Font.Gotham
                    label.TextXAlignment = Enum.TextXAlignment.Left
                    label.Parent = fieldFrame
                end

                if field.Type == "TextInput" then
                    local input = Instance.new("TextBox")
                    input.Name = "Input"
                    input.Size = UDim2.new(1, -self._config.LabelWidth - 8, 0, 28)
                    input.Position = UDim2.new(0, self._config.LabelWidth + 8, 0.5, 0)
                    input.AnchorPoint = Vector2.new(0, 0.5)
                    input.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
                    input.BorderSizePixel = 0
                    input.Text = field.Default or ""
                    input.PlaceholderText = field.Placeholder or ""
                    input.TextColor3 = Color3.fromRGB(255, 255, 255)
                    input.PlaceholderColor3 = Color3.fromRGB(120, 120, 120)
                    input.TextSize = 12
                    input.Font = Enum.Font.Gotham
                    input.ClearTextOnFocus = false
                    input.Parent = fieldFrame

                    local inputCorner = Instance.new("UICorner")
                    inputCorner.CornerRadius = UDim.new(0, 4)
                    inputCorner.Parent = input

                    local inputPadding = Instance.new("UIPadding")
                    inputPadding.PaddingLeft = UDim.new(0, 8)
                    inputPadding.PaddingRight = UDim.new(0, 8)
                    inputPadding.Parent = input

                    formValues[field.Name] = field.Default or ""
                    fieldInstances[field.Name] = input

                    input:GetPropertyChangedSignal("Text"):Connect(function()
                        formValues[field.Name] = input.Text
                        if self._config.OnChange then
                            self._config.OnChange(field.Name, input.Text)
                        end
                    end)

                elseif field.Type == "Checkbox" then
                    local checkbox = Instance.new("TextButton")
                    checkbox.Name = "Checkbox"
                    checkbox.Size = UDim2.new(0, 20, 0, 20)
                    checkbox.Position = UDim2.new(0, self._config.LabelWidth + 8, 0.5, 0)
                    checkbox.AnchorPoint = Vector2.new(0, 0.5)
                    checkbox.BackgroundColor3 = field.Default and Color3.fromRGB(60, 130, 255) or Color3.fromRGB(40, 40, 45)
                    checkbox.BorderSizePixel = 0
                    checkbox.Text = field.Default and "✓" or ""
                    checkbox.TextColor3 = Color3.fromRGB(255, 255, 255)
                    checkbox.TextSize = 14
                    checkbox.Font = Enum.Font.GothamBold
                    checkbox.AutoButtonColor = false
                    checkbox.Parent = fieldFrame

                    local checkboxCorner = Instance.new("UICorner")
                    checkboxCorner.CornerRadius = UDim.new(0, 4)
                    checkboxCorner.Parent = checkbox

                    formValues[field.Name] = field.Default or false
                    fieldInstances[field.Name] = checkbox

                    checkbox.MouseButton1Click:Connect(function()
                        formValues[field.Name] = not formValues[field.Name]
                        checkbox.Text = formValues[field.Name] and "✓" or ""
                        checkbox.BackgroundColor3 = formValues[field.Name] and Color3.fromRGB(60, 130, 255) or Color3.fromRGB(40, 40, 45)
                        if self._config.OnChange then
                            self._config.OnChange(field.Name, formValues[field.Name])
                        end
                    end)
                end
            end

            fieldFrame.Parent = container
        end

        -- Buttons container
        if self._config.ShowSubmit or self._config.ShowReset or self._config.ShowCancel then
            local buttonsFrame = Instance.new("Frame")
            buttonsFrame.Name = "Buttons"
            buttonsFrame.Size = UDim2.new(1, 0, 0, 36)
            buttonsFrame.BackgroundTransparency = 1
            buttonsFrame.LayoutOrder = 9999
            buttonsFrame.Parent = container

            local buttonsLayout = Instance.new("UIListLayout")
            buttonsLayout.FillDirection = Enum.FillDirection.Horizontal
            buttonsLayout.Padding = UDim.new(0, 8)
            buttonsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
            buttonsLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            buttonsLayout.Parent = buttonsFrame

            if self._config.ShowCancel then
                local cancelBtn = Instance.new("TextButton")
                cancelBtn.Name = "Cancel"
                cancelBtn.Size = UDim2.new(0, 80, 0, 32)
                cancelBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 55)
                cancelBtn.BorderSizePixel = 0
                cancelBtn.Text = self._config.CancelText
                cancelBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
                cancelBtn.TextSize = 12
                cancelBtn.Font = Enum.Font.GothamMedium
                cancelBtn.AutoButtonColor = false
                cancelBtn.LayoutOrder = 1
                cancelBtn.Parent = buttonsFrame

                local cancelCorner = Instance.new("UICorner")
                cancelCorner.CornerRadius = UDim.new(0, 4)
                cancelCorner.Parent = cancelBtn

                cancelBtn.MouseButton1Click:Connect(function()
                    if self._config.OnCancel then
                        self._config.OnCancel()
                    end
                end)
            end

            if self._config.ShowReset then
                local resetBtn = Instance.new("TextButton")
                resetBtn.Name = "Reset"
                resetBtn.Size = UDim2.new(0, 80, 0, 32)
                resetBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 65)
                resetBtn.BorderSizePixel = 0
                resetBtn.Text = self._config.ResetText
                resetBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
                resetBtn.TextSize = 12
                resetBtn.Font = Enum.Font.GothamMedium
                resetBtn.AutoButtonColor = false
                resetBtn.LayoutOrder = 2
                resetBtn.Parent = buttonsFrame

                local resetCorner = Instance.new("UICorner")
                resetCorner.CornerRadius = UDim.new(0, 4)
                resetCorner.Parent = resetBtn

                resetBtn.MouseButton1Click:Connect(function()
                    -- Reset all fields
                    for _, field in ipairs(self._fields) do
                        if field.Name and field.Default ~= nil then
                            formValues[field.Name] = field.Default
                        end
                    end
                    if self._config.OnReset then
                        self._config.OnReset()
                    end
                end)
            end

            if self._config.ShowSubmit then
                local submitBtn = Instance.new("TextButton")
                submitBtn.Name = "Submit"
                submitBtn.Size = UDim2.new(0, 100, 0, 32)
                submitBtn.BackgroundColor3 = Color3.fromRGB(60, 130, 255)
                submitBtn.BorderSizePixel = 0
                submitBtn.Text = self._config.SubmitText
                submitBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
                submitBtn.TextSize = 12
                submitBtn.Font = Enum.Font.GothamMedium
                submitBtn.AutoButtonColor = false
                submitBtn.LayoutOrder = 3
                submitBtn.Parent = buttonsFrame

                local submitCorner = Instance.new("UICorner")
                submitCorner.CornerRadius = UDim.new(0, 4)
                submitCorner.Parent = submitBtn

                submitBtn.MouseButton1Click:Connect(function()
                    if self._config.OnSubmit then
                        self._config.OnSubmit(formValues)
                    end
                end)
            end
        end

        if parent then
            container.Parent = parent
        end

        -- Return interface
        return {
            Instance = container,
            GetValues = function() return formValues end,
            GetValue = function(name) return formValues[name] end,
            SetValue = function(name, value)
                formValues[name] = value
                -- Update UI if needed
            end,
            Reset = function()
                for _, field in ipairs(self._fields) do
                    if field.Name and field.Default ~= nil then
                        formValues[field.Name] = field.Default
                    end
                end
            end,
            Submit = function()
                if self._config.OnSubmit then
                    self._config.OnSubmit(formValues)
                end
            end,
        }
    end

    return FormBuilder


end


-- ============================================================================
-- Module: NexusUI/Builders/Menu
-- ============================================================================
NexusUI_Modules["NexusUI/Builders/Menu"] = function()
    local script = CreateMockScript("NexusUI/Builders/Menu")
    
    --[[
        NexusUI Menu Builder
        Builder pattern for creating menus
    ]]

    --// Menu Builder
    local MenuBuilder = {}
    MenuBuilder.__index = MenuBuilder
    MenuBuilder.ClassName = "MenuBuilder"

    --// Constructor
    function MenuBuilder.new()
        local self = setmetatable({}, MenuBuilder)

        self._config = {
            Type = "Context", -- Context, Dropdown, Sidebar
            Width = 200,
            MaxHeight = 400,
            ShowIcons = true,
            ShowShortcuts = true,
            Animated = true,
            Theme = nil,
            OnClose = nil,
        }

        self._items = {}

        return self
    end

    --// Static create
    function MenuBuilder.Create()
        return MenuBuilder.new()
    end

    --// Context menu
    function MenuBuilder.Context()
        local builder = MenuBuilder.new()
        builder._config.Type = "Context"
        return builder
    end

    --// Dropdown menu
    function MenuBuilder.Dropdown()
        local builder = MenuBuilder.new()
        builder._config.Type = "Dropdown"
        return builder
    end

    --// Sidebar menu
    function MenuBuilder.Sidebar()
        local builder = MenuBuilder.new()
        builder._config.Type = "Sidebar"
        builder._config.Width = 250
        return builder
    end

    --// Width
    function MenuBuilder:Width(width)
        self._config.Width = width
        return self
    end

    --// Max height
    function MenuBuilder:MaxHeight(height)
        self._config.MaxHeight = height
        return self
    end

    --// Show icons
    function MenuBuilder:ShowIcons(value)
        self._config.ShowIcons = value
        return self
    end

    --// Show shortcuts
    function MenuBuilder:ShowShortcuts(value)
        self._config.ShowShortcuts = value
        return self
    end

    --// Animated
    function MenuBuilder:Animated(value)
        self._config.Animated = value
        return self
    end

    --// Theme
    function MenuBuilder:Theme(theme)
        self._config.Theme = theme
        return self
    end

    --// On close
    function MenuBuilder:OnClose(callback)
        self._config.OnClose = callback
        return self
    end

    --// Add item
    function MenuBuilder:AddItem(text, callback, config)
        config = config or {}
        table.insert(self._items, {
            Type = "Item",
            Text = text,
            Callback = callback,
            Icon = config.Icon,
            Shortcut = config.Shortcut,
            Disabled = config.Disabled or false,
        })
        return self
    end

    --// Add separator
    function MenuBuilder:AddSeparator()
        table.insert(self._items, {
            Type = "Separator"
        })
        return self
    end

    --// Add header
    function MenuBuilder:AddHeader(text)
        table.insert(self._items, {
            Type = "Header",
            Text = text
        })
        return self
    end

    --// Add submenu
    function MenuBuilder:AddSubmenu(text, items, config)
        config = config or {}
        table.insert(self._items, {
            Type = "Submenu",
            Text = text,
            Items = items,
            Icon = config.Icon,
        })
        return self
    end

    --// Add checkbox item
    function MenuBuilder:AddCheckbox(text, checked, callback, config)
        config = config or {}
        table.insert(self._items, {
            Type = "Checkbox",
            Text = text,
            Checked = checked,
            Callback = callback,
            Icon = config.Icon,
        })
        return self
    end

    --// Add radio item
    function MenuBuilder:AddRadio(text, group, selected, callback, config)
        config = config or {}
        table.insert(self._items, {
            Type = "Radio",
            Text = text,
            Group = group,
            Selected = selected,
            Callback = callback,
        })
        return self
    end

    --// Build the menu
    function MenuBuilder:Build(parent, position)
        local isOpen = false

        -- Container
        local container = Instance.new("Frame")
        container.Name = "Menu"
        container.Size = UDim2.new(0, self._config.Width, 0, 0)
        container.Position = position or UDim2.new(0, 0, 0, 0)
        container.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        container.BorderSizePixel = 0
        container.AutomaticSize = Enum.AutomaticSize.Y
        container.ClipsDescendants = true
        container.Visible = false
        container.ZIndex = 1000

        local containerCorner = Instance.new("UICorner")
        containerCorner.CornerRadius = UDim.new(0, 8)
        containerCorner.Parent = container

        local containerStroke = Instance.new("UIStroke")
        containerStroke.Color = Color3.fromRGB(60, 60, 70)
        containerStroke.Thickness = 1
        containerStroke.Parent = container

        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Vertical
        layout.Padding = UDim.new(0, 0)
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Parent = container

        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, 4)
        padding.PaddingBottom = UDim.new(0, 4)
        padding.Parent = container

        -- Close function
        local function close()
            if not isOpen then return end
            isOpen = false
            container.Visible = false
            if self._config.OnClose then
                self._config.OnClose()
            end
        end

        -- Create items
        for i, item in ipairs(self._items) do
            local itemFrame

            if item.Type == "Separator" then
                itemFrame = Instance.new("Frame")
                itemFrame.Name = "Separator"
                itemFrame.Size = UDim2.new(1, -16, 0, 9)
                itemFrame.BackgroundTransparency = 1
                itemFrame.LayoutOrder = i

                local line = Instance.new("Frame")
                line.Size = UDim2.new(1, 0, 0, 1)
                line.Position = UDim2.new(0, 0, 0.5, 0)
                line.AnchorPoint = Vector2.new(0, 0.5)
                line.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
                line.BorderSizePixel = 0
                line.Parent = itemFrame

                local itemPadding = Instance.new("UIPadding")
                itemPadding.PaddingLeft = UDim.new(0, 8)
                itemPadding.PaddingRight = UDim.new(0, 8)
                itemPadding.Parent = itemFrame

            elseif item.Type == "Header" then
                itemFrame = Instance.new("Frame")
                itemFrame.Name = "Header"
                itemFrame.Size = UDim2.new(1, 0, 0, 24)
                itemFrame.BackgroundTransparency = 1
                itemFrame.LayoutOrder = i

                local text = Instance.new("TextLabel")
                text.Size = UDim2.new(1, -16, 1, 0)
                text.Position = UDim2.new(0, 8, 0, 0)
                text.BackgroundTransparency = 1
                text.Text = item.Text
                text.TextColor3 = Color3.fromRGB(120, 120, 130)
                text.TextSize = 11
                text.Font = Enum.Font.GothamMedium
                text.TextXAlignment = Enum.TextXAlignment.Left
                text.Parent = itemFrame

            else
                itemFrame = Instance.new("TextButton")
                itemFrame.Name = "Item_" .. item.Text
                itemFrame.Size = UDim2.new(1, 0, 0, 32)
                itemFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
                itemFrame.BackgroundTransparency = 1
                itemFrame.BorderSizePixel = 0
                itemFrame.Text = ""
                itemFrame.AutoButtonColor = false
                itemFrame.LayoutOrder = i

                local textLabel = Instance.new("TextLabel")
                textLabel.Name = "Text"
                textLabel.Size = UDim2.new(1, self._config.ShowIcons and -60 or -16, 1, 0)
                textLabel.Position = UDim2.new(0, self._config.ShowIcons and 36 or 12, 0, 0)
                textLabel.BackgroundTransparency = 1
                textLabel.Text = item.Text
                textLabel.TextColor3 = item.Disabled and Color3.fromRGB(100, 100, 100) or Color3.fromRGB(255, 255, 255)
                textLabel.TextSize = 13
                textLabel.Font = Enum.Font.Gotham
                textLabel.TextXAlignment = Enum.TextXAlignment.Left
                textLabel.Parent = itemFrame

                -- Checkbox indicator
                if item.Type == "Checkbox" then
                    local check = Instance.new("TextLabel")
                    check.Name = "Check"
                    check.Size = UDim2.new(0, 20, 0, 20)
                    check.Position = UDim2.new(0, 8, 0.5, 0)
                    check.AnchorPoint = Vector2.new(0, 0.5)
                    check.BackgroundTransparency = 1
                    check.Text = item.Checked and "✓" or ""
                    check.TextColor3 = Color3.fromRGB(60, 130, 255)
                    check.TextSize = 14
                    check.Font = Enum.Font.GothamBold
                    check.Parent = itemFrame
                end

                -- Shortcut
                if item.Shortcut and self._config.ShowShortcuts then
                    local shortcut = Instance.new("TextLabel")
                    shortcut.Name = "Shortcut"
                    shortcut.Size = UDim2.new(0, 60, 1, 0)
                    shortcut.Position = UDim2.new(1, -68, 0, 0)
                    shortcut.BackgroundTransparency = 1
                    shortcut.Text = item.Shortcut
                    shortcut.TextColor3 = Color3.fromRGB(100, 100, 110)
                    shortcut.TextSize = 11
                    shortcut.Font = Enum.Font.Gotham
                    shortcut.TextXAlignment = Enum.TextXAlignment.Right
                    shortcut.Parent = itemFrame
                end

                -- Hover effect
                itemFrame.MouseEnter:Connect(function()
                    if not item.Disabled then
                        itemFrame.BackgroundTransparency = 0
                        itemFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
                    end
                end)

                itemFrame.MouseLeave:Connect(function()
                    itemFrame.BackgroundTransparency = 1
                end)

                -- Click handler
                itemFrame.MouseButton1Click:Connect(function()
                    if item.Disabled then return end

                    if item.Type == "Checkbox" then
                        item.Checked = not item.Checked
                        local check = itemFrame:FindFirstChild("Check")
                        if check then
                            check.Text = item.Checked and "✓" or ""
                        end
                        if item.Callback then
                            item.Callback(item.Checked)
                        end
                    else
                        if item.Callback then
                            item.Callback()
                        end
                        close()
                    end
                end)
            end

            if itemFrame then
                itemFrame.Parent = container
            end
        end

        if parent then
            container.Parent = parent
        end

        -- Return interface
        return {
            Instance = container,
            Open = function(pos)
                if pos then
                    container.Position = pos
                end
                isOpen = true
                container.Visible = true
            end,
            Close = close,
            IsOpen = function() return isOpen end,
            SetPosition = function(pos)
                container.Position = pos
            end,
        }
    end

    return MenuBuilder


end


-- ============================================================================
-- Module: NexusUI/Builders/Toolbar
-- ============================================================================
NexusUI_Modules["NexusUI/Builders/Toolbar"] = function()
    local script = CreateMockScript("NexusUI/Builders/Toolbar")
    
    --[[
        NexusUI Toolbar Builder
        Builder pattern for creating toolbars
    ]]

    --// Toolbar Builder
    local ToolbarBuilder = {}
    ToolbarBuilder.__index = ToolbarBuilder
    ToolbarBuilder.ClassName = "ToolbarBuilder"

    --// Constructor
    function ToolbarBuilder.new()
        local self = setmetatable({}, ToolbarBuilder)

        self._config = {
            Position = "Top", -- Top, Bottom, Left, Right
            Height = 40,
            Width = 50,
            Padding = 8,
            Spacing = 4,
            ShowLabels = false,
            IconSize = 20,
            Theme = nil,
        }

        self._items = {}

        return self
    end

    --// Static create
    function ToolbarBuilder.Create()
        return ToolbarBuilder.new()
    end

    --// Position
    function ToolbarBuilder:Position(position)
        self._config.Position = position
        return self
    end

    --// Height (for horizontal)
    function ToolbarBuilder:Height(height)
        self._config.Height = height
        return self
    end

    --// Width (for vertical)
    function ToolbarBuilder:Width(width)
        self._config.Width = width
        return self
    end

    --// Padding
    function ToolbarBuilder:Padding(padding)
        self._config.Padding = padding
        return self
    end

    --// Spacing
    function ToolbarBuilder:Spacing(spacing)
        self._config.Spacing = spacing
        return self
    end

    --// Show labels
    function ToolbarBuilder:ShowLabels(value)
        self._config.ShowLabels = value
        return self
    end

    --// Icon size
    function ToolbarBuilder:IconSize(size)
        self._config.IconSize = size
        return self
    end

    --// Theme
    function ToolbarBuilder:Theme(theme)
        self._config.Theme = theme
        return self
    end

    --// Add button
    function ToolbarBuilder:AddButton(id, config)
        config = config or {}
        table.insert(self._items, {
            Type = "Button",
            Id = id,
            Icon = config.Icon,
            Label = config.Label,
            Tooltip = config.Tooltip,
            Callback = config.Callback,
            Disabled = config.Disabled or false,
        })
        return self
    end

    --// Add toggle button
    function ToolbarBuilder:AddToggle(id, config)
        config = config or {}
        table.insert(self._items, {
            Type = "Toggle",
            Id = id,
            Icon = config.Icon,
            IconActive = config.IconActive or config.Icon,
            Label = config.Label,
            Tooltip = config.Tooltip,
            Active = config.Active or false,
            Callback = config.Callback,
        })
        return self
    end

    --// Add separator
    function ToolbarBuilder:AddSeparator()
        table.insert(self._items, {
            Type = "Separator"
        })
        return self
    end

    --// Add spacer
    function ToolbarBuilder:AddSpacer()
        table.insert(self._items, {
            Type = "Spacer"
        })
        return self
    end

    --// Add dropdown
    function ToolbarBuilder:AddDropdown(id, config)
        config = config or {}
        table.insert(self._items, {
            Type = "Dropdown",
            Id = id,
            Icon = config.Icon,
            Label = config.Label,
            Options = config.Options or {},
            Selected = config.Selected,
            Callback = config.Callback,
        })
        return self
    end

    --// Add group
    function ToolbarBuilder:AddGroup(items)
        table.insert(self._items, {
            Type = "Group",
            Items = items
        })
        return self
    end

    --// Build the toolbar
    function ToolbarBuilder:Build(parent)
        local isVertical = self._config.Position == "Left" or self._config.Position == "Right"
        local buttonStates = {}

        -- Container
        local container = Instance.new("Frame")
        container.Name = "Toolbar"
        container.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        container.BorderSizePixel = 0

        if isVertical then
            container.Size = UDim2.new(0, self._config.Width, 1, 0)
            if self._config.Position == "Right" then
                container.Position = UDim2.new(1, -self._config.Width, 0, 0)
            end
        else
            container.Size = UDim2.new(1, 0, 0, self._config.Height)
            if self._config.Position == "Bottom" then
                container.Position = UDim2.new(0, 0, 1, -self._config.Height)
            end
        end

        local layout = Instance.new("UIListLayout")
        layout.FillDirection = isVertical and Enum.FillDirection.Vertical or Enum.FillDirection.Horizontal
        layout.Padding = UDim.new(0, self._config.Spacing)
        layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Parent = container

        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, self._config.Padding)
        padding.PaddingBottom = UDim.new(0, self._config.Padding)
        padding.PaddingLeft = UDim.new(0, self._config.Padding)
        padding.PaddingRight = UDim.new(0, self._config.Padding)
        padding.Parent = container

        -- Create items
        local buttons = {}

        for i, item in ipairs(self._items) do
            local itemFrame

            if item.Type == "Separator" then
                itemFrame = Instance.new("Frame")
                itemFrame.Name = "Separator"
                if isVertical then
                    itemFrame.Size = UDim2.new(1, -8, 0, 1)
                else
                    itemFrame.Size = UDim2.new(0, 1, 1, -8)
                end
                itemFrame.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
                itemFrame.BorderSizePixel = 0
                itemFrame.LayoutOrder = i

            elseif item.Type == "Spacer" then
                itemFrame = Instance.new("Frame")
                itemFrame.Name = "Spacer"
                itemFrame.BackgroundTransparency = 1
                itemFrame.LayoutOrder = i
                -- Spacer will be sized by layout

            elseif item.Type == "Button" or item.Type == "Toggle" then
                local buttonSize = self._config.Height - self._config.Padding * 2

                itemFrame = Instance.new("TextButton")
                itemFrame.Name = "Button_" .. (item.Id or i)
                itemFrame.Size = UDim2.new(0, self._config.ShowLabels and 80 or buttonSize, 0, buttonSize)
                itemFrame.BackgroundColor3 = (item.Type == "Toggle" and item.Active) and Color3.fromRGB(60, 130, 255) or Color3.fromRGB(40, 40, 45)
                itemFrame.BorderSizePixel = 0
                itemFrame.Text = ""
                itemFrame.AutoButtonColor = false
                itemFrame.LayoutOrder = i

                local buttonCorner = Instance.new("UICorner")
                buttonCorner.CornerRadius = UDim.new(0, 6)
                buttonCorner.Parent = itemFrame

                -- Icon placeholder (would use actual icon asset)
                local icon = Instance.new("TextLabel")
                icon.Name = "Icon"
                icon.Size = UDim2.new(0, self._config.IconSize, 0, self._config.IconSize)
                icon.Position = self._config.ShowLabels and UDim2.new(0, 8, 0.5, 0) or UDim2.new(0.5, 0, 0.5, 0)
                icon.AnchorPoint = self._config.ShowLabels and Vector2.new(0, 0.5) or Vector2.new(0.5, 0.5)
                icon.BackgroundTransparency = 1
                icon.Text = item.Icon or "●"
                icon.TextColor3 = Color3.fromRGB(255, 255, 255)
                icon.TextSize = self._config.IconSize
                icon.Font = Enum.Font.Gotham
                icon.Parent = itemFrame

                if self._config.ShowLabels and item.Label then
                    local label = Instance.new("TextLabel")
                    label.Name = "Label"
                    label.Size = UDim2.new(1, -36, 1, 0)
                    label.Position = UDim2.new(0, 32, 0, 0)
                    label.BackgroundTransparency = 1
                    label.Text = item.Label
                    label.TextColor3 = Color3.fromRGB(255, 255, 255)
                    label.TextSize = 11
                    label.Font = Enum.Font.Gotham
                    label.TextXAlignment = Enum.TextXAlignment.Left
                    label.Parent = itemFrame
                end

                -- Store state
                if item.Type == "Toggle" then
                    buttonStates[item.Id] = item.Active
                end

                -- Hover effect
                itemFrame.MouseEnter:Connect(function()
                    if not item.Disabled then
                        if item.Type == "Toggle" and buttonStates[item.Id] then
                            itemFrame.BackgroundColor3 = Color3.fromRGB(70, 140, 255)
                        else
                            itemFrame.BackgroundColor3 = Color3.fromRGB(55, 55, 60)
                        end
                    end
                end)

                itemFrame.MouseLeave:Connect(function()
                    if item.Type == "Toggle" and buttonStates[item.Id] then
                        itemFrame.BackgroundColor3 = Color3.fromRGB(60, 130, 255)
                    else
                        itemFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
                    end
                end)

                -- Click handler
                itemFrame.MouseButton1Click:Connect(function()
                    if item.Disabled then return end

                    if item.Type == "Toggle" then
                        buttonStates[item.Id] = not buttonStates[item.Id]
                        itemFrame.BackgroundColor3 = buttonStates[item.Id] and Color3.fromRGB(60, 130, 255) or Color3.fromRGB(40, 40, 45)
                        if item.Callback then
                            item.Callback(buttonStates[item.Id])
                        end
                    else
                        if item.Callback then
                            item.Callback()
                        end
                    end
                end)

                buttons[item.Id] = itemFrame
            end

            if itemFrame then
                itemFrame.Parent = container
            end
        end

        if parent then
            container.Parent = parent
        end

        -- Return interface
        return {
            Instance = container,
            Buttons = buttons,
            GetState = function(id) return buttonStates[id] end,
            SetState = function(id, state)
                buttonStates[id] = state
                local btn = buttons[id]
                if btn then
                    btn.BackgroundColor3 = state and Color3.fromRGB(60, 130, 255) or Color3.fromRGB(40, 40, 45)
                end
            end,
            EnableButton = function(id)
                local item = nil
                for _, it in ipairs(self._items) do
                    if it.Id == id then item = it break end
                end
                if item then item.Disabled = false end
            end,
            DisableButton = function(id)
                local item = nil
                for _, it in ipairs(self._items) do
                    if it.Id == id then item = it break end
                end
                if item then item.Disabled = true end
            end,
        }
    end

    return ToolbarBuilder


end


-- ============================================================================
-- Module: NexusUI/Builders/Dialog
-- ============================================================================
NexusUI_Modules["NexusUI/Builders/Dialog"] = function()
    local script = CreateMockScript("NexusUI/Builders/Dialog")
    
    --[[
        NexusUI Dialog Builder
        Builder pattern for creating dialogs
    ]]

    --// Dialog Builder
    local DialogBuilder = {}
    DialogBuilder.__index = DialogBuilder
    DialogBuilder.ClassName = "DialogBuilder"

    --// Constructor
    function DialogBuilder.new()
        local self = setmetatable({}, DialogBuilder)

        self._config = {
            Title = "Dialog",
            Message = "",
            Type = "Default", -- Default, Alert, Confirm, Prompt, Custom
            Width = 400,
            ShowOverlay = true,
            OverlayDismiss = true,
            Animated = true,
            Icon = nil,
            Theme = nil,
            Buttons = {},
            OnClose = nil,
        }

        self._content = nil

        return self
    end

    --// Static create
    function DialogBuilder.Create()
        return DialogBuilder.new()
    end

    --// Alert dialog
    function DialogBuilder.Alert(title, message)
        local builder = DialogBuilder.new()
        builder._config.Type = "Alert"
        builder._config.Title = title
        builder._config.Message = message
        builder:AddButton("OK", nil, { Primary = true })
        return builder
    end

    --// Confirm dialog
    function DialogBuilder.Confirm(title, message)
        local builder = DialogBuilder.new()
        builder._config.Type = "Confirm"
        builder._config.Title = title
        builder._config.Message = message
        builder:AddButton("Cancel", nil)
        builder:AddButton("Confirm", nil, { Primary = true })
        return builder
    end

    --// Prompt dialog
    function DialogBuilder.Prompt(title, message, placeholder)
        local builder = DialogBuilder.new()
        builder._config.Type = "Prompt"
        builder._config.Title = title
        builder._config.Message = message
        builder._config.Placeholder = placeholder
        builder:AddButton("Cancel", nil)
        builder:AddButton("OK", nil, { Primary = true })
        return builder
    end

    --// Title
    function DialogBuilder:Title(title)
        self._config.Title = title
        return self
    end

    --// Message
    function DialogBuilder:Message(message)
        self._config.Message = message
        return self
    end

    --// Width
    function DialogBuilder:Width(width)
        self._config.Width = width
        return self
    end

    --// Show overlay
    function DialogBuilder:ShowOverlay(value)
        self._config.ShowOverlay = value
        return self
    end

    --// Overlay dismiss
    function DialogBuilder:OverlayDismiss(value)
        self._config.OverlayDismiss = value
        return self
    end

    --// Animated
    function DialogBuilder:Animated(value)
        self._config.Animated = value
        return self
    end

    --// Icon
    function DialogBuilder:Icon(icon)
        self._config.Icon = icon
        return self
    end

    --// Theme
    function DialogBuilder:Theme(theme)
        self._config.Theme = theme
        return self
    end

    --// On close
    function DialogBuilder:OnClose(callback)
        self._config.OnClose = callback
        return self
    end

    --// Add button
    function DialogBuilder:AddButton(text, callback, config)
        config = config or {}
        table.insert(self._config.Buttons, {
            Text = text,
            Callback = callback,
            Primary = config.Primary or false,
            Danger = config.Danger or false,
            Close = config.Close ~= false, -- Default true
        })
        return self
    end

    --// Set custom content
    function DialogBuilder:Content(builder)
        self._content = builder
        return self
    end

    --// Build the dialog
    function DialogBuilder:Build(parent)
        local isOpen = false
        local inputValue = ""
        local result = nil

        -- Overlay
        local overlay
        if self._config.ShowOverlay then
            overlay = Instance.new("Frame")
            overlay.Name = "DialogOverlay"
            overlay.Size = UDim2.new(1, 0, 1, 0)
            overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            overlay.BackgroundTransparency = 0.5
            overlay.BorderSizePixel = 0
            overlay.ZIndex = 999
            overlay.Visible = false

            if parent then
                overlay.Parent = parent
            end
        end

        -- Dialog container
        local dialog = Instance.new("Frame")
        dialog.Name = "Dialog"
        dialog.Size = UDim2.new(0, self._config.Width, 0, 0)
        dialog.Position = UDim2.new(0.5, 0, 0.5, 0)
        dialog.AnchorPoint = Vector2.new(0.5, 0.5)
        dialog.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
        dialog.BorderSizePixel = 0
        dialog.AutomaticSize = Enum.AutomaticSize.Y
        dialog.ZIndex = 1000
        dialog.Visible = false

        local dialogCorner = Instance.new("UICorner")
        dialogCorner.CornerRadius = UDim.new(0, 12)
        dialogCorner.Parent = dialog

        local dialogPadding = Instance.new("UIPadding")
        dialogPadding.PaddingTop = UDim.new(0, 20)
        dialogPadding.PaddingBottom = UDim.new(0, 16)
        dialogPadding.PaddingLeft = UDim.new(0, 20)
        dialogPadding.PaddingRight = UDim.new(0, 20)
        dialogPadding.Parent = dialog

        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Vertical
        layout.Padding = UDim.new(0, 12)
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Parent = dialog

        -- Title
        local title = Instance.new("TextLabel")
        title.Name = "Title"
        title.Size = UDim2.new(1, 0, 0, 24)
        title.BackgroundTransparency = 1
        title.Text = self._config.Title
        title.TextColor3 = Color3.fromRGB(255, 255, 255)
        title.TextSize = 18
        title.Font = Enum.Font.GothamBold
        title.TextXAlignment = Enum.TextXAlignment.Left
        title.LayoutOrder = 1
        title.Parent = dialog

        -- Message
        if self._config.Message and self._config.Message ~= "" then
            local message = Instance.new("TextLabel")
            message.Name = "Message"
            message.Size = UDim2.new(1, 0, 0, 0)
            message.BackgroundTransparency = 1
            message.Text = self._config.Message
            message.TextColor3 = Color3.fromRGB(180, 180, 180)
            message.TextSize = 14
            message.Font = Enum.Font.Gotham
            message.TextXAlignment = Enum.TextXAlignment.Left
            message.TextWrapped = true
            message.AutomaticSize = Enum.AutomaticSize.Y
            message.LayoutOrder = 2
            message.Parent = dialog
        end

        -- Prompt input
        local promptInput
        if self._config.Type == "Prompt" then
            promptInput = Instance.new("TextBox")
            promptInput.Name = "Input"
            promptInput.Size = UDim2.new(1, 0, 0, 36)
            promptInput.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
            promptInput.BorderSizePixel = 0
            promptInput.Text = ""
            promptInput.PlaceholderText = self._config.Placeholder or "Enter text..."
            promptInput.TextColor3 = Color3.fromRGB(255, 255, 255)
            promptInput.PlaceholderColor3 = Color3.fromRGB(120, 120, 120)
            promptInput.TextSize = 14
            promptInput.Font = Enum.Font.Gotham
            promptInput.ClearTextOnFocus = false
            promptInput.LayoutOrder = 3
            promptInput.Parent = dialog

            local inputCorner = Instance.new("UICorner")
            inputCorner.CornerRadius = UDim.new(0, 6)
            inputCorner.Parent = promptInput

            local inputPadding = Instance.new("UIPadding")
            inputPadding.PaddingLeft = UDim.new(0, 12)
            inputPadding.PaddingRight = UDim.new(0, 12)
            inputPadding.Parent = promptInput

            promptInput:GetPropertyChangedSignal("Text"):Connect(function()
                inputValue = promptInput.Text
            end)
        end

        -- Custom content
        if self._content then
            local contentFrame = Instance.new("Frame")
            contentFrame.Name = "Content"
            contentFrame.Size = UDim2.new(1, 0, 0, 0)
            contentFrame.BackgroundTransparency = 1
            contentFrame.AutomaticSize = Enum.AutomaticSize.Y
            contentFrame.LayoutOrder = 4
            contentFrame.Parent = dialog

            if typeof(self._content) == "table" and self._content.Build then
                self._content:Build(contentFrame)
            elseif typeof(self._content) == "Instance" then
                self._content.Parent = contentFrame
            end
        end

        -- Close function
        local function close(buttonResult)
            if not isOpen then return end
            isOpen = false
            result = buttonResult

            dialog.Visible = false
            if overlay then
                overlay.Visible = false
            end

            if self._config.OnClose then
                self._config.OnClose(result, inputValue)
            end
        end

        -- Buttons
        if #self._config.Buttons > 0 then
            local buttonsFrame = Instance.new("Frame")
            buttonsFrame.Name = "Buttons"
            buttonsFrame.Size = UDim2.new(1, 0, 0, 36)
            buttonsFrame.BackgroundTransparency = 1
            buttonsFrame.LayoutOrder = 10
            buttonsFrame.Parent = dialog

            local buttonsLayout = Instance.new("UIListLayout")
            buttonsLayout.FillDirection = Enum.FillDirection.Horizontal
            buttonsLayout.Padding = UDim.new(0, 8)
            buttonsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
            buttonsLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            buttonsLayout.Parent = buttonsFrame

            for i, btnConfig in ipairs(self._config.Buttons) do
                local btn = Instance.new("TextButton")
                btn.Name = "Button_" .. btnConfig.Text
                btn.Size = UDim2.new(0, 90, 0, 34)
                btn.BorderSizePixel = 0
                btn.Text = btnConfig.Text
                btn.TextColor3 = Color3.fromRGB(255, 255, 255)
                btn.TextSize = 13
                btn.Font = Enum.Font.GothamMedium
                btn.AutoButtonColor = false
                btn.LayoutOrder = i

                if btnConfig.Primary then
                    btn.BackgroundColor3 = Color3.fromRGB(60, 130, 255)
                elseif btnConfig.Danger then
                    btn.BackgroundColor3 = Color3.fromRGB(220, 60, 60)
                else
                    btn.BackgroundColor3 = Color3.fromRGB(55, 55, 60)
                end

                local btnCorner = Instance.new("UICorner")
                btnCorner.CornerRadius = UDim.new(0, 6)
                btnCorner.Parent = btn

                btn.MouseButton1Click:Connect(function()
                    if btnConfig.Callback then
                        btnConfig.Callback(inputValue)
                    end
                    if btnConfig.Close then
                        close(btnConfig.Text)
                    end
                end)

                btn.Parent = buttonsFrame
            end
        end

        -- Overlay click to dismiss
        if overlay and self._config.OverlayDismiss then
            local overlayBtn = Instance.new("TextButton")
            overlayBtn.Size = UDim2.new(1, 0, 1, 0)
            overlayBtn.BackgroundTransparency = 1
            overlayBtn.Text = ""
            overlayBtn.Parent = overlay

            overlayBtn.MouseButton1Click:Connect(function()
                close(nil)
            end)
        end

        if parent then
            dialog.Parent = parent
        end

        -- Return interface
        return {
            Instance = dialog,
            Overlay = overlay,
            Show = function()
                isOpen = true
                result = nil
                inputValue = ""
                if promptInput then
                    promptInput.Text = ""
                end
                if overlay then
                    overlay.Visible = true
                end
                dialog.Visible = true
            end,
            Hide = function()
                close(nil)
            end,
            IsOpen = function() return isOpen end,
            GetResult = function() return result end,
            GetInputValue = function() return inputValue end,
        }
    end

    return DialogBuilder


end


-- ============================================================================
-- Module: NexusUI/Builders/Card
-- ============================================================================
NexusUI_Modules["NexusUI/Builders/Card"] = function()
    local script = CreateMockScript("NexusUI/Builders/Card")
    
    --[[
        NexusUI Card Builder
        Builder pattern for creating cards
    ]]

    --// Card Builder
    local CardBuilder = {}
    CardBuilder.__index = CardBuilder
    CardBuilder.ClassName = "CardBuilder"

    --// Constructor
    function CardBuilder.new()
        local self = setmetatable({}, CardBuilder)

        self._config = {
            Title = nil,
            Subtitle = nil,
            Image = nil,
            ImageHeight = 150,
            Content = nil,
            Footer = nil,
            Width = nil, -- Auto
            Padding = 16,
            Spacing = 12,
            Rounded = 12,
            Elevated = true,
            Clickable = false,
            Theme = nil,
            OnClick = nil,
            OnHover = nil,
        }

        self._actions = {}
        self._badges = {}

        return self
    end

    --// Static create
    function CardBuilder.Create()
        return CardBuilder.new()
    end

    --// Title
    function CardBuilder:Title(title)
        self._config.Title = title
        return self
    end

    --// Subtitle
    function CardBuilder:Subtitle(subtitle)
        self._config.Subtitle = subtitle
        return self
    end

    --// Image
    function CardBuilder:Image(imageId, height)
        self._config.Image = imageId
        if height then
            self._config.ImageHeight = height
        end
        return self
    end

    --// Content
    function CardBuilder:Content(content)
        self._config.Content = content
        return self
    end

    --// Footer
    function CardBuilder:Footer(footer)
        self._config.Footer = footer
        return self
    end

    --// Width
    function CardBuilder:Width(width)
        self._config.Width = width
        return self
    end

    --// Padding
    function CardBuilder:Padding(padding)
        self._config.Padding = padding
        return self
    end

    --// Spacing
    function CardBuilder:Spacing(spacing)
        self._config.Spacing = spacing
        return self
    end

    --// Rounded
    function CardBuilder:Rounded(radius)
        self._config.Rounded = radius
        return self
    end

    --// Elevated
    function CardBuilder:Elevated(value)
        self._config.Elevated = value
        return self
    end

    --// Clickable
    function CardBuilder:Clickable(value)
        self._config.Clickable = value
        return self
    end

    --// Theme
    function CardBuilder:Theme(theme)
        self._config.Theme = theme
        return self
    end

    --// On click
    function CardBuilder:OnClick(callback)
        self._config.OnClick = callback
        self._config.Clickable = true
        return self
    end

    --// On hover
    function CardBuilder:OnHover(callback)
        self._config.OnHover = callback
        return self
    end

    --// Add action button
    function CardBuilder:AddAction(text, callback, config)
        config = config or {}
        table.insert(self._actions, {
            Text = text,
            Callback = callback,
            Icon = config.Icon,
            Primary = config.Primary or false,
        })
        return self
    end

    --// Add badge
    function CardBuilder:AddBadge(text, config)
        config = config or {}
        table.insert(self._badges, {
            Text = text,
            Color = config.Color or Color3.fromRGB(60, 130, 255),
            TextColor = config.TextColor or Color3.fromRGB(255, 255, 255),
        })
        return self
    end

    --// Build the card
    function CardBuilder:Build(parent)
        -- Container
        local container
        if self._config.Clickable then
            container = Instance.new("TextButton")
            container.Text = ""
            container.AutoButtonColor = false
        else
            container = Instance.new("Frame")
        end

        container.Name = "Card"
        container.Size = self._config.Width and UDim2.new(0, self._config.Width, 0, 0) or UDim2.new(1, 0, 0, 0)
        container.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
        container.BorderSizePixel = 0
        container.AutomaticSize = Enum.AutomaticSize.Y

        local containerCorner = Instance.new("UICorner")
        containerCorner.CornerRadius = UDim.new(0, self._config.Rounded)
        containerCorner.Parent = container

        -- Shadow for elevated cards
        if self._config.Elevated then
            local shadow = Instance.new("ImageLabel")
            shadow.Name = "Shadow"
            shadow.Size = UDim2.new(1, 16, 1, 16)
            shadow.Position = UDim2.new(0.5, 0, 0.5, 4)
            shadow.AnchorPoint = Vector2.new(0.5, 0.5)
            shadow.BackgroundTransparency = 1
            shadow.Image = "rbxassetid://6015897843"
            shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
            shadow.ImageTransparency = 0.7
            shadow.ScaleType = Enum.ScaleType.Slice
            shadow.SliceCenter = Rect.new(49, 49, 450, 450)
            shadow.ZIndex = -1
            shadow.Parent = container
        end

        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Vertical
        layout.Padding = UDim.new(0, 0)
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Parent = container

        local layoutOrder = 0

        -- Image
        if self._config.Image then
            local imageContainer = Instance.new("Frame")
            imageContainer.Name = "ImageContainer"
            imageContainer.Size = UDim2.new(1, 0, 0, self._config.ImageHeight)
            imageContainer.BackgroundTransparency = 1
            imageContainer.ClipsDescendants = true
            imageContainer.LayoutOrder = layoutOrder
            imageContainer.Parent = container
            layoutOrder = layoutOrder + 1

            local image = Instance.new("ImageLabel")
            image.Name = "Image"
            image.Size = UDim2.new(1, 0, 1, 0)
            image.BackgroundTransparency = 1
            image.Image = self._config.Image
            image.ScaleType = Enum.ScaleType.Crop
            image.Parent = imageContainer

            -- Rounded top corners
            local imageCorner = Instance.new("UICorner")
            imageCorner.CornerRadius = UDim.new(0, self._config.Rounded)
            imageCorner.Parent = imageContainer

            -- Badges overlay
            if #self._badges > 0 then
                local badgesContainer = Instance.new("Frame")
                badgesContainer.Name = "Badges"
                badgesContainer.Size = UDim2.new(1, -16, 0, 0)
                badgesContainer.Position = UDim2.new(0, 8, 0, 8)
                badgesContainer.BackgroundTransparency = 1
                badgesContainer.AutomaticSize = Enum.AutomaticSize.Y
                badgesContainer.Parent = imageContainer

                local badgesLayout = Instance.new("UIListLayout")
                badgesLayout.FillDirection = Enum.FillDirection.Horizontal
                badgesLayout.Padding = UDim.new(0, 4)
                badgesLayout.Parent = badgesContainer

                for _, badge in ipairs(self._badges) do
                    local badgeFrame = Instance.new("Frame")
                    badgeFrame.Size = UDim2.new(0, 0, 0, 22)
                    badgeFrame.BackgroundColor3 = badge.Color
                    badgeFrame.AutomaticSize = Enum.AutomaticSize.X

                    local badgeCorner = Instance.new("UICorner")
                    badgeCorner.CornerRadius = UDim.new(0, 4)
                    badgeCorner.Parent = badgeFrame

                    local badgePadding = Instance.new("UIPadding")
                    badgePadding.PaddingLeft = UDim.new(0, 8)
                    badgePadding.PaddingRight = UDim.new(0, 8)
                    badgePadding.Parent = badgeFrame

                    local badgeText = Instance.new("TextLabel")
                    badgeText.Size = UDim2.new(0, 0, 1, 0)
                    badgeText.BackgroundTransparency = 1
                    badgeText.Text = badge.Text
                    badgeText.TextColor3 = badge.TextColor
                    badgeText.TextSize = 11
                    badgeText.Font = Enum.Font.GothamMedium
                    badgeText.AutomaticSize = Enum.AutomaticSize.X
                    badgeText.Parent = badgeFrame

                    badgeFrame.Parent = badgesContainer
                end
            end
        end

        -- Body container
        local body = Instance.new("Frame")
        body.Name = "Body"
        body.Size = UDim2.new(1, 0, 0, 0)
        body.BackgroundTransparency = 1
        body.AutomaticSize = Enum.AutomaticSize.Y
        body.LayoutOrder = layoutOrder
        body.Parent = container
        layoutOrder = layoutOrder + 1

        local bodyPadding = Instance.new("UIPadding")
        bodyPadding.PaddingTop = UDim.new(0, self._config.Padding)
        bodyPadding.PaddingBottom = UDim.new(0, self._config.Padding)
        bodyPadding.PaddingLeft = UDim.new(0, self._config.Padding)
        bodyPadding.PaddingRight = UDim.new(0, self._config.Padding)
        bodyPadding.Parent = body

        local bodyLayout = Instance.new("UIListLayout")
        bodyLayout.FillDirection = Enum.FillDirection.Vertical
        bodyLayout.Padding = UDim.new(0, self._config.Spacing)
        bodyLayout.SortOrder = Enum.SortOrder.LayoutOrder
        bodyLayout.Parent = body

        local bodyOrder = 0

        -- Title
        if self._config.Title then
            local title = Instance.new("TextLabel")
            title.Name = "Title"
            title.Size = UDim2.new(1, 0, 0, 0)
            title.BackgroundTransparency = 1
            title.Text = self._config.Title
            title.TextColor3 = Color3.fromRGB(255, 255, 255)
            title.TextSize = 16
            title.Font = Enum.Font.GothamBold
            title.TextXAlignment = Enum.TextXAlignment.Left
            title.TextWrapped = true
            title.AutomaticSize = Enum.AutomaticSize.Y
            title.LayoutOrder = bodyOrder
            title.Parent = body
            bodyOrder = bodyOrder + 1
        end

        -- Subtitle
        if self._config.Subtitle then
            local subtitle = Instance.new("TextLabel")
            subtitle.Name = "Subtitle"
            subtitle.Size = UDim2.new(1, 0, 0, 0)
            subtitle.BackgroundTransparency = 1
            subtitle.Text = self._config.Subtitle
            subtitle.TextColor3 = Color3.fromRGB(140, 140, 150)
            subtitle.TextSize = 12
            subtitle.Font = Enum.Font.Gotham
            subtitle.TextXAlignment = Enum.TextXAlignment.Left
            subtitle.TextWrapped = true
            subtitle.AutomaticSize = Enum.AutomaticSize.Y
            subtitle.LayoutOrder = bodyOrder
            subtitle.Parent = body
            bodyOrder = bodyOrder + 1
        end

        -- Content
        if self._config.Content then
            local content = Instance.new("TextLabel")
            content.Name = "Content"
            content.Size = UDim2.new(1, 0, 0, 0)
            content.BackgroundTransparency = 1
            content.Text = self._config.Content
            content.TextColor3 = Color3.fromRGB(180, 180, 180)
            content.TextSize = 13
            content.Font = Enum.Font.Gotham
            content.TextXAlignment = Enum.TextXAlignment.Left
            content.TextWrapped = true
            content.AutomaticSize = Enum.AutomaticSize.Y
            content.LayoutOrder = bodyOrder
            content.Parent = body
            bodyOrder = bodyOrder + 1
        end

        -- Actions
        if #self._actions > 0 then
            local actionsFrame = Instance.new("Frame")
            actionsFrame.Name = "Actions"
            actionsFrame.Size = UDim2.new(1, 0, 0, 32)
            actionsFrame.BackgroundTransparency = 1
            actionsFrame.LayoutOrder = bodyOrder
            actionsFrame.Parent = body

            local actionsLayout = Instance.new("UIListLayout")
            actionsLayout.FillDirection = Enum.FillDirection.Horizontal
            actionsLayout.Padding = UDim.new(0, 8)
            actionsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
            actionsLayout.Parent = actionsFrame

            for i, action in ipairs(self._actions) do
                local btn = Instance.new("TextButton")
                btn.Name = "Action_" .. action.Text
                btn.Size = UDim2.new(0, 80, 0, 30)
                btn.BackgroundColor3 = action.Primary and Color3.fromRGB(60, 130, 255) or Color3.fromRGB(50, 50, 55)
                btn.BorderSizePixel = 0
                btn.Text = action.Text
                btn.TextColor3 = Color3.fromRGB(255, 255, 255)
                btn.TextSize = 12
                btn.Font = Enum.Font.GothamMedium
                btn.AutoButtonColor = false
                btn.LayoutOrder = i
                btn.Parent = actionsFrame

                local btnCorner = Instance.new("UICorner")
                btnCorner.CornerRadius = UDim.new(0, 4)
                btnCorner.Parent = btn

                btn.MouseButton1Click:Connect(function()
                    if action.Callback then
                        action.Callback()
                    end
                end)
            end
        end

        -- Footer
        if self._config.Footer then
            local footer = Instance.new("Frame")
            footer.Name = "Footer"
            footer.Size = UDim2.new(1, 0, 0, 40)
            footer.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            footer.LayoutOrder = layoutOrder
            footer.Parent = container

            local footerPadding = Instance.new("UIPadding")
            footerPadding.PaddingLeft = UDim.new(0, self._config.Padding)
            footerPadding.PaddingRight = UDim.new(0, self._config.Padding)
            footerPadding.Parent = footer

            local footerText = Instance.new("TextLabel")
            footerText.Size = UDim2.new(1, 0, 1, 0)
            footerText.BackgroundTransparency = 1
            footerText.Text = self._config.Footer
            footerText.TextColor3 = Color3.fromRGB(120, 120, 130)
            footerText.TextSize = 11
            footerText.Font = Enum.Font.Gotham
            footerText.TextXAlignment = Enum.TextXAlignment.Left
            footerText.Parent = footer
        end

        -- Click handling
        if self._config.Clickable then
            container.MouseEnter:Connect(function()
                container.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
                if self._config.OnHover then
                    self._config.OnHover(true)
                end
            end)

            container.MouseLeave:Connect(function()
                container.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
                if self._config.OnHover then
                    self._config.OnHover(false)
                end
            end)

            container.MouseButton1Click:Connect(function()
                if self._config.OnClick then
                    self._config.OnClick()
                end
            end)
        end

        if parent then
            container.Parent = parent
        end

        return container
    end

    return CardBuilder


end


-- ============================================================================
-- Module: NexusUI/Builders/List
-- ============================================================================
NexusUI_Modules["NexusUI/Builders/List"] = function()
    local script = CreateMockScript("NexusUI/Builders/List")
    
    --[[
        NexusUI List Builder
        Builder pattern for creating lists
    ]]

    --// List Builder
    local ListBuilder = {}
    ListBuilder.__index = ListBuilder
    ListBuilder.ClassName = "ListBuilder"

    --// Constructor
    function ListBuilder.new()
        local self = setmetatable({}, ListBuilder)

        self._config = {
            Type = "Default", -- Default, Ordered, Unordered, Checklist, Inline
            ItemHeight = 40,
            Padding = 8,
            Spacing = 4,
            ShowDividers = false,
            ShowIcons = false,
            Selectable = false,
            MultiSelect = false,
            Sortable = false,
            Searchable = false,
            Theme = nil,
            OnSelect = nil,
            OnCheck = nil,
            OnReorder = nil,
        }

        self._items = {}

        return self
    end

    --// Static create
    function ListBuilder.Create()
        return ListBuilder.new()
    end

    --// Type
    function ListBuilder:Type(listType)
        self._config.Type = listType
        return self
    end

    --// Item height
    function ListBuilder:ItemHeight(height)
        self._config.ItemHeight = height
        return self
    end

    --// Padding
    function ListBuilder:Padding(padding)
        self._config.Padding = padding
        return self
    end

    --// Spacing
    function ListBuilder:Spacing(spacing)
        self._config.Spacing = spacing
        return self
    end

    --// Show dividers
    function ListBuilder:ShowDividers(value)
        self._config.ShowDividers = value
        return self
    end

    --// Show icons
    function ListBuilder:ShowIcons(value)
        self._config.ShowIcons = value
        return self
    end

    --// Selectable
    function ListBuilder:Selectable(value)
        self._config.Selectable = value
        return self
    end

    --// Multi select
    function ListBuilder:MultiSelect(value)
        self._config.MultiSelect = value
        return self
    end

    --// Sortable
    function ListBuilder:Sortable(value)
        self._config.Sortable = value
        return self
    end

    --// Searchable
    function ListBuilder:Searchable(value)
        self._config.Searchable = value
        return self
    end

    --// Theme
    function ListBuilder:Theme(theme)
        self._config.Theme = theme
        return self
    end

    --// On select
    function ListBuilder:OnSelect(callback)
        self._config.OnSelect = callback
        return self
    end

    --// On check
    function ListBuilder:OnCheck(callback)
        self._config.OnCheck = callback
        return self
    end

    --// On reorder
    function ListBuilder:OnReorder(callback)
        self._config.OnReorder = callback
        return self
    end

    --// Add item
    function ListBuilder:AddItem(config)
        if type(config) == "string" then
            config = { Text = config }
        end
        table.insert(self._items, {
            Text = config.Text or "",
            Subtitle = config.Subtitle,
            Icon = config.Icon,
            Checked = config.Checked or false,
            Disabled = config.Disabled or false,
            Data = config.Data,
            OnClick = config.OnClick,
        })
        return self
    end

    --// Add items
    function ListBuilder:AddItems(items)
        for _, item in ipairs(items) do
            self:AddItem(item)
        end
        return self
    end

    --// Clear items
    function ListBuilder:Clear()
        self._items = {}
        return self
    end

    --// Build the list
    function ListBuilder:Build(parent)
        local selectedItems = {}
        local itemFrames = {}
        local searchFilter = ""

        -- Container
        local container = Instance.new("Frame")
        container.Name = "List"
        container.Size = UDim2.new(1, 0, 1, 0)
        container.BackgroundTransparency = 1

        local containerLayout = Instance.new("UIListLayout")
        containerLayout.FillDirection = Enum.FillDirection.Vertical
        containerLayout.Padding = UDim.new(0, 0)
        containerLayout.SortOrder = Enum.SortOrder.LayoutOrder
        containerLayout.Parent = container

        -- Search box
        local searchBox
        if self._config.Searchable then
            local searchFrame = Instance.new("Frame")
            searchFrame.Name = "SearchFrame"
            searchFrame.Size = UDim2.new(1, 0, 0, 36)
            searchFrame.BackgroundTransparency = 1
            searchFrame.LayoutOrder = 0
            searchFrame.Parent = container

            searchBox = Instance.new("TextBox")
            searchBox.Name = "SearchBox"
            searchBox.Size = UDim2.new(1, -16, 0, 32)
            searchBox.Position = UDim2.new(0, 8, 0.5, 0)
            searchBox.AnchorPoint = Vector2.new(0, 0.5)
            searchBox.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
            searchBox.BorderSizePixel = 0
            searchBox.Text = ""
            searchBox.PlaceholderText = "Search..."
            searchBox.TextColor3 = Color3.fromRGB(255, 255, 255)
            searchBox.PlaceholderColor3 = Color3.fromRGB(120, 120, 120)
            searchBox.TextSize = 13
            searchBox.Font = Enum.Font.Gotham
            searchBox.ClearTextOnFocus = false
            searchBox.Parent = searchFrame

            local searchCorner = Instance.new("UICorner")
            searchCorner.CornerRadius = UDim.new(0, 6)
            searchCorner.Parent = searchBox

            local searchPadding = Instance.new("UIPadding")
            searchPadding.PaddingLeft = UDim.new(0, 12)
            searchPadding.PaddingRight = UDim.new(0, 12)
            searchPadding.Parent = searchBox
        end

        -- Scrolling frame for items
        local scrollFrame = Instance.new("ScrollingFrame")
        scrollFrame.Name = "ItemsScroll"
        scrollFrame.Size = UDim2.new(1, 0, 1, self._config.Searchable and -40 or 0)
        scrollFrame.BackgroundTransparency = 1
        scrollFrame.BorderSizePixel = 0
        scrollFrame.ScrollBarThickness = 4
        scrollFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 110)
        scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
        scrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
        scrollFrame.LayoutOrder = 1
        scrollFrame.Parent = container

        local itemsLayout = Instance.new("UIListLayout")
        itemsLayout.FillDirection = Enum.FillDirection.Vertical
        itemsLayout.Padding = UDim.new(0, self._config.Spacing)
        itemsLayout.SortOrder = Enum.SortOrder.LayoutOrder
        itemsLayout.Parent = scrollFrame

        local itemsPadding = Instance.new("UIPadding")
        itemsPadding.PaddingTop = UDim.new(0, self._config.Padding)
        itemsPadding.PaddingBottom = UDim.new(0, self._config.Padding)
        itemsPadding.PaddingLeft = UDim.new(0, self._config.Padding)
        itemsPadding.PaddingRight = UDim.new(0, self._config.Padding)
        itemsPadding.Parent = scrollFrame

        -- Select function
        local function selectItem(index)
            if not self._config.Selectable then return end

            local item = self._items[index]
            if item.Disabled then return end

            if self._config.MultiSelect then
                selectedItems[index] = not selectedItems[index]
            else
                for i in pairs(selectedItems) do
                    selectedItems[i] = false
                end
                selectedItems[index] = true
            end

            -- Update visuals
            for i, frame in pairs(itemFrames) do
                if selectedItems[i] then
                    frame.BackgroundColor3 = Color3.fromRGB(60, 130, 255)
                    frame.BackgroundTransparency = 0.8
                else
                    frame.BackgroundTransparency = 1
                end
            end

            if self._config.OnSelect then
                local selected = {}
                for i, isSelected in pairs(selectedItems) do
                    if isSelected then
                        table.insert(selected, i)
                    end
                end
                self._config.OnSelect(selected, index)
            end
        end

        -- Check function (for checklist)
        local function checkItem(index, checked)
            self._items[index].Checked = checked
            if self._config.OnCheck then
                self._config.OnCheck(index, checked)
            end
        end

        -- Filter function
        local function filterItems()
            for i, frame in pairs(itemFrames) do
                local item = self._items[i]
                local visible = searchFilter == "" or string.find(string.lower(item.Text), string.lower(searchFilter))
                frame.Visible = visible
            end
        end

        -- Create items
        for i, item in ipairs(self._items) do
            local itemFrame = Instance.new("TextButton")
            itemFrame.Name = "Item_" .. i
            itemFrame.Size = UDim2.new(1, 0, 0, self._config.ItemHeight)
            itemFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
            itemFrame.BackgroundTransparency = 1
            itemFrame.BorderSizePixel = 0
            itemFrame.Text = ""
            itemFrame.AutoButtonColor = false
            itemFrame.LayoutOrder = i

            -- Checklist checkbox
            if self._config.Type == "Checklist" then
                local checkbox = Instance.new("TextButton")
                checkbox.Name = "Checkbox"
                checkbox.Size = UDim2.new(0, 20, 0, 20)
                checkbox.Position = UDim2.new(0, 8, 0.5, 0)
                checkbox.AnchorPoint = Vector2.new(0, 0.5)
                checkbox.BackgroundColor3 = item.Checked and Color3.fromRGB(60, 130, 255) or Color3.fromRGB(50, 50, 55)
                checkbox.BorderSizePixel = 0
                checkbox.Text = item.Checked and "✓" or ""
                checkbox.TextColor3 = Color3.fromRGB(255, 255, 255)
                checkbox.TextSize = 14
                checkbox.Font = Enum.Font.GothamBold
                checkbox.AutoButtonColor = false
                checkbox.Parent = itemFrame

                local checkboxCorner = Instance.new("UICorner")
                checkboxCorner.CornerRadius = UDim.new(0, 4)
                checkboxCorner.Parent = checkbox

                checkbox.MouseButton1Click:Connect(function()
                    item.Checked = not item.Checked
                    checkbox.Text = item.Checked and "✓" or ""
                    checkbox.BackgroundColor3 = item.Checked and Color3.fromRGB(60, 130, 255) or Color3.fromRGB(50, 50, 55)
                    checkItem(i, item.Checked)
                end)
            end

            -- Ordered list number
            if self._config.Type == "Ordered" then
                local number = Instance.new("TextLabel")
                number.Name = "Number"
                number.Size = UDim2.new(0, 24, 1, 0)
                number.Position = UDim2.new(0, 8, 0, 0)
                number.BackgroundTransparency = 1
                number.Text = tostring(i) .. "."
                number.TextColor3 = Color3.fromRGB(100, 100, 110)
                number.TextSize = 13
                number.Font = Enum.Font.GothamMedium
                number.TextXAlignment = Enum.TextXAlignment.Left
                number.Parent = itemFrame
            end

            -- Unordered list bullet
            if self._config.Type == "Unordered" then
                local bullet = Instance.new("TextLabel")
                bullet.Name = "Bullet"
                bullet.Size = UDim2.new(0, 16, 1, 0)
                bullet.Position = UDim2.new(0, 12, 0, 0)
                bullet.BackgroundTransparency = 1
                bullet.Text = "•"
                bullet.TextColor3 = Color3.fromRGB(100, 100, 110)
                bullet.TextSize = 16
                bullet.Font = Enum.Font.Gotham
                bullet.Parent = itemFrame
            end

            -- Text position offset
            local textOffset = 8
            if self._config.Type == "Checklist" then
                textOffset = 36
            elseif self._config.Type == "Ordered" or self._config.Type == "Unordered" then
                textOffset = 32
            end
            if self._config.ShowIcons and item.Icon then
                textOffset = textOffset + 28
            end

            -- Icon
            if self._config.ShowIcons and item.Icon then
                local iconLabel = Instance.new("TextLabel")
                iconLabel.Name = "Icon"
                iconLabel.Size = UDim2.new(0, 20, 0, 20)
                iconLabel.Position = UDim2.new(0, textOffset - 28, 0.5, 0)
                iconLabel.AnchorPoint = Vector2.new(0, 0.5)
                iconLabel.BackgroundTransparency = 1
                iconLabel.Text = item.Icon
                iconLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
                iconLabel.TextSize = 16
                iconLabel.Font = Enum.Font.Gotham
                iconLabel.Parent = itemFrame
            end

            -- Main text
            local text = Instance.new("TextLabel")
            text.Name = "Text"
            text.Size = UDim2.new(1, -textOffset - 8, item.Subtitle and 0.5 or 1, 0)
            text.Position = UDim2.new(0, textOffset, 0, item.Subtitle and 4 or 0)
            text.BackgroundTransparency = 1
            text.Text = item.Text
            text.TextColor3 = item.Disabled and Color3.fromRGB(100, 100, 100) or Color3.fromRGB(255, 255, 255)
            text.TextSize = 13
            text.Font = Enum.Font.Gotham
            text.TextXAlignment = Enum.TextXAlignment.Left
            text.TextYAlignment = item.Subtitle and Enum.TextYAlignment.Bottom or Enum.TextYAlignment.Center
            text.Parent = itemFrame

            -- Subtitle
            if item.Subtitle then
                local subtitle = Instance.new("TextLabel")
                subtitle.Name = "Subtitle"
                subtitle.Size = UDim2.new(1, -textOffset - 8, 0.5, 0)
                subtitle.Position = UDim2.new(0, textOffset, 0.5, -2)
                subtitle.BackgroundTransparency = 1
                subtitle.Text = item.Subtitle
                subtitle.TextColor3 = Color3.fromRGB(120, 120, 130)
                subtitle.TextSize = 11
                subtitle.Font = Enum.Font.Gotham
                subtitle.TextXAlignment = Enum.TextXAlignment.Left
                subtitle.TextYAlignment = Enum.TextYAlignment.Top
                subtitle.Parent = itemFrame
            end

            -- Divider
            if self._config.ShowDividers and i < #self._items then
                local divider = Instance.new("Frame")
                divider.Name = "Divider"
                divider.Size = UDim2.new(1, -16, 0, 1)
                divider.Position = UDim2.new(0, 8, 1, 0)
                divider.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
                divider.BorderSizePixel = 0
                divider.Parent = itemFrame
            end

            -- Hover effect
            itemFrame.MouseEnter:Connect(function()
                if not selectedItems[i] then
                    itemFrame.BackgroundTransparency = 0.9
                    itemFrame.BackgroundColor3 = Color3.fromRGB(55, 55, 60)
                end
            end)

            itemFrame.MouseLeave:Connect(function()
                if not selectedItems[i] then
                    itemFrame.BackgroundTransparency = 1
                end
            end)

            -- Click handler
            itemFrame.MouseButton1Click:Connect(function()
                if item.OnClick then
                    item.OnClick()
                end
                selectItem(i)
            end)

            itemFrame.Parent = scrollFrame
            itemFrames[i] = itemFrame
        end

        -- Search functionality
        if searchBox then
            searchBox:GetPropertyChangedSignal("Text"):Connect(function()
                searchFilter = searchBox.Text
                filterItems()
            end)
        end

        if parent then
            container.Parent = parent
        end

        -- Return interface
        return {
            Instance = container,
            ScrollFrame = scrollFrame,
            GetSelected = function()
                local selected = {}
                for i, isSelected in pairs(selectedItems) do
                    if isSelected then
                        table.insert(selected, i)
                    end
                end
                return selected
            end,
            ClearSelection = function()
                selectedItems = {}
                for _, frame in pairs(itemFrames) do
                    frame.BackgroundTransparency = 1
                end
            end,
            GetChecked = function()
                local checked = {}
                for i, item in ipairs(self._items) do
                    if item.Checked then
                        table.insert(checked, i)
                    end
                end
                return checked
            end,
            SetSearch = function(text)
                if searchBox then
                    searchBox.Text = text
                end
            end,
            Refresh = function()
                filterItems()
            end,
        }
    end

    return ListBuilder


end


-- ============================================================================
-- Module: NexusUI/Builders/init
-- ============================================================================
NexusUI_Modules["NexusUI/Builders/init"] = function()
    local script = CreateMockScript("NexusUI/Builders/init")
    
    --[[
        NexusUI Builders Module
        Builder patterns for easy UI creation
    ]]

    --// Builders Module
    local Builders = {}

    Builders.UI = NexusRequire("NexusUI/Builders/UI")
    Builders.Window = NexusRequire("NexusUI/Builders/Window")
    Builders.Tab = NexusRequire("NexusUI/Builders/Tab")
    Builders.Section = NexusRequire("NexusUI/Builders/Section")
    Builders.Form = NexusRequire("NexusUI/Builders/Form")
    Builders.Menu = NexusRequire("NexusUI/Builders/Menu")
    Builders.Toolbar = NexusRequire("NexusUI/Builders/Toolbar")
    Builders.Dialog = NexusRequire("NexusUI/Builders/Dialog")
    Builders.Card = NexusRequire("NexusUI/Builders/Card")
    Builders.List = NexusRequire("NexusUI/Builders/List")

    return Builders


end


-- ============================================================================
-- Module: NexusUI/Version
-- ============================================================================
NexusUI_Modules["NexusUI/Version"] = function()
    local script = CreateMockScript("NexusUI/Version")
    
    --[[
        NexusUI Version Information
    ]]

    local Version = {
        Major = 1,
        Minor = 0,
        Patch = 0,
        Build = "release",

        -- Full version string
        String = "1.0.0",

        -- Build info
        BuildDate = "2026-01-19",

        -- Feature flags
        Features = {
            LiquidGlass = true,
            Glassmorphism = true,
            Animations = true,
            Themes = true,
            Sounds = true,
            Hotkeys = true,
            ConfigSystem = true,
            CloudSync = true,
            ESP = true,
            PerformanceMonitor = true,
            Visualizers = true,
            Builders = true,
        },

        -- Statistics
        Stats = {
            TotalFiles = 200,
            TotalThemes = 25,
            TotalComponents = 50,
            TotalEffects = 8,
            TotalVisualizers = 13,
        },

        -- Changelog
        Changelog = {
            ["1.0.0"] = {
                "Initial release",
                "25 built-in themes",
                "Liquid glass and glassmorphism effects",
                "Comprehensive component library",
                "Animation engine with springs and easing",
                "Performance monitoring system",
                "ESP and executor-specific components",
                "Builder patterns for easy UI creation",
                "Sound system with presets",
                "Configuration save/load with cloud sync",
                "Global hotkey management",
            },
        },
    }

    function Version.GetFull()
        return string.format("%d.%d.%d-%s", 
            Version.Major, 
            Version.Minor, 
            Version.Patch, 
            Version.Build
        )
    end

    function Version.Compare(other)
        local otherMajor, otherMinor, otherPatch = other:match("(%d+)%.(%d+)%.(%d+)")
        otherMajor = tonumber(otherMajor) or 0
        otherMinor = tonumber(otherMinor) or 0
        otherPatch = tonumber(otherPatch) or 0

        if Version.Major > otherMajor then return 1 end
        if Version.Major < otherMajor then return -1 end
        if Version.Minor > otherMinor then return 1 end
        if Version.Minor < otherMinor then return -1 end
        if Version.Patch > otherPatch then return 1 end
        if Version.Patch < otherPatch then return -1 end
        return 0
    end

    function Version.IsNewerThan(other)
        return Version.Compare(other) > 0
    end

    function Version.IsOlderThan(other)
        return Version.Compare(other) < 0
    end

    return Version


end


-- ============================================================================
-- Module: NexusUI/Debug
-- ============================================================================
NexusUI_Modules["NexusUI/Debug"] = function()
    local script = CreateMockScript("NexusUI/Debug")
    
    --[[
        NexusUI Debug Module
        Debugging utilities and development tools
    ]]

    local Debug = {}
    Debug.__index = Debug

    --// Configuration
    Debug.Enabled = false
    Debug.LogLevel = "INFO" -- DEBUG, INFO, WARN, ERROR
    Debug.ShowTimestamp = true
    Debug.MaxLogHistory = 500

    --// Internal state
    local _logs = {}
    local _breakpoints = {}
    local _watches = {}
    local _startTime = os.clock()

    --// Log levels
    local LogLevels = {
        DEBUG = 1,
        INFO = 2,
        WARN = 3,
        ERROR = 4,
    }

    --// Get current log level value
    local function GetLogLevelValue(level)
        return LogLevels[level] or 2
    end

    --// Format timestamp
    local function FormatTimestamp()
        local elapsed = os.clock() - _startTime
        return string.format("[%07.3f]", elapsed)
    end

    --// Internal log function
    local function InternalLog(level, message, ...)
        if not Debug.Enabled then return end
        if GetLogLevelValue(level) < GetLogLevelValue(Debug.LogLevel) then return end

        local formattedMessage = string.format(message, ...)
        local timestamp = Debug.ShowTimestamp and FormatTimestamp() or ""
        local fullMessage = string.format("%s [%s] %s", timestamp, level, formattedMessage)

        -- Store in history
        table.insert(_logs, {
            Level = level,
            Message = formattedMessage,
            Timestamp = os.clock() - _startTime,
            FullMessage = fullMessage,
        })

        -- Trim history
        while #_logs > Debug.MaxLogHistory do
            table.remove(_logs, 1)
        end

        -- Output
        if level == "ERROR" then
            warn("[NexusUI]", fullMessage)
        else
            print("[NexusUI]", fullMessage)
        end
    end

    --// Public logging functions
    function Debug.Log(message, ...)
        InternalLog("DEBUG", message, ...)
    end

    function Debug.Info(message, ...)
        InternalLog("INFO", message, ...)
    end

    function Debug.Warn(message, ...)
        InternalLog("WARN", message, ...)
    end

    function Debug.Error(message, ...)
        InternalLog("ERROR", message, ...)
    end

    --// Enable/disable debugging
    function Debug.Enable()
        Debug.Enabled = true
        Debug.Info("Debug mode enabled")
    end

    function Debug.Disable()
        Debug.Info("Debug mode disabled")
        Debug.Enabled = false
    end

    --// Set log level
    function Debug.SetLogLevel(level)
        if LogLevels[level] then
            Debug.LogLevel = level
            Debug.Info("Log level set to %s", level)
        end
    end

    --// Get log history
    function Debug.GetLogs(level)
        if not level then
            return _logs
        end

        local filtered = {}
        for _, log in ipairs(_logs) do
            if log.Level == level then
                table.insert(filtered, log)
            end
        end
        return filtered
    end

    --// Clear logs
    function Debug.ClearLogs()
        _logs = {}
        Debug.Info("Log history cleared")
    end

    --// Performance timing
    local _timers = {}

    function Debug.StartTimer(name)
        _timers[name] = os.clock()
    end

    function Debug.EndTimer(name)
        local startTime = _timers[name]
        if startTime then
            local elapsed = (os.clock() - startTime) * 1000
            Debug.Info("Timer [%s]: %.2f ms", name, elapsed)
            _timers[name] = nil
            return elapsed
        end
        return 0
    end

    --// Memory tracking
    function Debug.GetMemoryUsage()
        return collectgarbage("count")
    end

    function Debug.LogMemory(label)
        local kb = Debug.GetMemoryUsage()
        Debug.Info("Memory [%s]: %.2f KB (%.2f MB)", label or "current", kb, kb / 1024)
    end

    --// Instance counting
    function Debug.CountInstances(parent, className)
        local count = 0
        for _, child in ipairs(parent:GetDescendants()) do
            if not className or child.ClassName == className then
                count = count + 1
            end
        end
        return count
    end

    --// Watch values (call each frame to track changes)
    function Debug.Watch(name, getValue)
        _watches[name] = {
            GetValue = getValue,
            LastValue = nil,
            ChangeCount = 0,
        }
    end

    function Debug.Unwatch(name)
        _watches[name] = nil
    end

    function Debug.UpdateWatches()
        for name, watch in pairs(_watches) do
            local newValue = watch.GetValue()
            if newValue ~= watch.LastValue then
                watch.ChangeCount = watch.ChangeCount + 1
                Debug.Log("Watch [%s] changed: %s -> %s", name, tostring(watch.LastValue), tostring(newValue))
                watch.LastValue = newValue
            end
        end
    end

    function Debug.GetWatches()
        local result = {}
        for name, watch in pairs(_watches) do
            result[name] = {
                Value = watch.LastValue,
                ChangeCount = watch.ChangeCount,
            }
        end
        return result
    end

    --// Assertion helper
    function Debug.Assert(condition, message, ...)
        if not condition then
            Debug.Error("Assertion failed: " .. (message and string.format(message, ...) or "no message"))
            error("NexusUI Assertion Failed")
        end
    end

    --// Stack trace
    function Debug.PrintStack(message)
        Debug.Warn("%s\n%s", message or "Stack trace:", debug.traceback())
    end

    --// Inspect table
    function Debug.Inspect(tbl, name, depth)
        depth = depth or 3
        name = name or "table"

        local function inspect(t, indent, currentDepth)
            if currentDepth > depth then
                return "..."
            end

            if type(t) ~= "table" then
                return tostring(t)
            end

            local lines = {"{"}
            for k, v in pairs(t) do
                local key = type(k) == "string" and k or string.format("[%s]", tostring(k))
                local value = type(v) == "table" and inspect(v, indent .. "  ", currentDepth + 1) or tostring(v)
                table.insert(lines, string.format("%s%s = %s,", indent .. "  ", key, value))
            end
            table.insert(lines, indent .. "}")
            return table.concat(lines, "\n")
        end

        Debug.Log("%s = %s", name, inspect(tbl, "", 1))
    end

    --// Performance profiler
    local _profiles = {}

    function Debug.Profile(name, func)
        return function(...)
            local start = os.clock()
            local results = {func(...)}
            local elapsed = (os.clock() - start) * 1000

            if not _profiles[name] then
                _profiles[name] = {
                    Calls = 0,
                    TotalTime = 0,
                    MinTime = math.huge,
                    MaxTime = 0,
                }
            end

            local profile = _profiles[name]
            profile.Calls = profile.Calls + 1
            profile.TotalTime = profile.TotalTime + elapsed
            profile.MinTime = math.min(profile.MinTime, elapsed)
            profile.MaxTime = math.max(profile.MaxTime, elapsed)

            return unpack(results)
        end
    end

    function Debug.GetProfiles()
        local result = {}
        for name, profile in pairs(_profiles) do
            result[name] = {
                Calls = profile.Calls,
                TotalTime = profile.TotalTime,
                AvgTime = profile.TotalTime / profile.Calls,
                MinTime = profile.MinTime,
                MaxTime = profile.MaxTime,
            }
        end
        return result
    end

    function Debug.PrintProfiles()
        Debug.Info("=== Performance Profiles ===")
        for name, profile in pairs(_profiles) do
            Debug.Info("%s: %d calls, avg %.2f ms, total %.2f ms", 
                name, 
                profile.Calls, 
                profile.TotalTime / profile.Calls,
                profile.TotalTime
            )
        end
    end

    function Debug.ClearProfiles()
        _profiles = {}
    end

    return Debug


end


-- ============================================================================
-- Module: NexusUI/init
-- ============================================================================
NexusUI_Modules["NexusUI/init"] = function()
    local script = CreateMockScript("NexusUI/init")
    
    --[[
        NexusUI - Ultimate Roblox Executor UI Library
        Version: 1.0.0

        A premium 80,000+ line UI library featuring:
        - Liquid glass effects and glassmorphism
        - 25+ beautiful themes
        - Advanced animation engine with spring physics
        - Comprehensive component system
        - FPS monitoring and performance tools
        - Config save/load system
        - Sound effects
        - And much more!

        Usage:
            local NexusUI = loadstring(game:HttpGet("..."))()
            local Window = NexusUI:CreateWindow({
                Title = "My App",
                Theme = "LiquidGlass"
            })
    ]]

    --// Services
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local TweenService = game:GetService("TweenService")
    local HttpService = game:GetService("HttpService")
    local CoreGui = game:GetService("CoreGui")
    local TextService = game:GetService("TextService")
    local ContentProvider = game:GetService("ContentProvider")
    local MarketplaceService = game:GetService("MarketplaceService")
    local SoundService = game:GetService("SoundService")
    local GuiService = game:GetService("GuiService")
    local StarterGui = game:GetService("StarterGui")
    local Lighting = game:GetService("Lighting")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Workspace = game:GetService("Workspace")

    --// Constants
    local LIBRARY_NAME = "NexusUI"
    local LIBRARY_VERSION = "1.0.0"
    local LIBRARY_BUILD = 1000
    local DEBUG_MODE = false
    local PERFORMANCE_MODE = false

    --// Local Player
    local LocalPlayer = Players.LocalPlayer
    local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
    local Mouse = LocalPlayer:GetMouse()

    --// Module References (lazy loaded)
    local Core = nil
    local Animation = nil
    local Themes = nil
    local Components = nil
    local Features = nil
    local Layout = nil
    local Assets = nil
    local Builders = nil

    --// Library State
    local LibraryState = {
        Initialized = false,
        Windows = {},
        ActiveWindow = nil,
        GlobalTheme = "Midnight",
        GlobalSoundPack = "Default",
        GlobalConfig = {},
        Connections = {},
        Instances = {},
        FPSEnabled = false,
        SoundsEnabled = true,
        AnimationsEnabled = true,
        PerformanceMode = false,
        LastFrameTime = 0,
        FrameCount = 0,
        CurrentFPS = 60,
        AverageFPS = 60,
        PeakFPS = 60,
        LowFPS = 60,
        MemoryUsage = 0,
        NetworkPing = 0,
        StartTime = os.clock(),
        SessionId = HttpService:GenerateGUID(false),
        ErrorLog = {},
        WarningLog = {},
        InfoLog = {},
    }

    --// Utility Functions
    local function Log(level, message, ...)
        local formattedMessage = string.format(message, ...)
        local timestamp = os.date("%H:%M:%S")
        local logEntry = {
            Level = level,
            Message = formattedMessage,
            Timestamp = timestamp,
            Time = os.clock()
        }

        if level == "ERROR" then
            table.insert(LibraryState.ErrorLog, logEntry)
            if DEBUG_MODE then
                warn(string.format("[%s] [ERROR] %s: %s", LIBRARY_NAME, timestamp, formattedMessage))
            end
        elseif level == "WARN" then
            table.insert(LibraryState.WarningLog, logEntry)
            if DEBUG_MODE then
                warn(string.format("[%s] [WARN] %s: %s", LIBRARY_NAME, timestamp, formattedMessage))
            end
        elseif level == "INFO" then
            table.insert(LibraryState.InfoLog, logEntry)
            if DEBUG_MODE then
                print(string.format("[%s] [INFO] %s: %s", LIBRARY_NAME, timestamp, formattedMessage))
            end
        end

        return logEntry
    end

    local function SafeCall(func, ...)
        local success, result = pcall(func, ...)
        if not success then
            Log("ERROR", "SafeCall failed: %s", tostring(result))
            return nil, result
        end
        return result, nil
    end

    local function DeepCopy(original, copies)
        copies = copies or {}
        local originalType = type(original)
        local copy

        if originalType == "table" then
            if copies[original] then
                copy = copies[original]
            else
                copy = {}
                copies[original] = copy
                for originalKey, originalValue in next, original, nil do
                    copy[DeepCopy(originalKey, copies)] = DeepCopy(originalValue, copies)
                end
                setmetatable(copy, DeepCopy(getmetatable(original), copies))
            end
        else
            copy = original
        end

        return copy
    end

    local function MergeTables(base, override)
        local result = DeepCopy(base)

        for key, value in pairs(override) do
            if type(value) == "table" and type(result[key]) == "table" then
                result[key] = MergeTables(result[key], value)
            else
                result[key] = value
            end
        end

        return result
    end

    local function GenerateUID(prefix)
        prefix = prefix or "nexus"
        local chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        local uid = prefix .. "_"

        for i = 1, 16 do
            local randomIndex = math.random(1, #chars)
            uid = uid .. chars:sub(randomIndex, randomIndex)
        end

        return uid .. "_" .. tostring(os.clock()):gsub("%.", "")
    end

    local function Lerp(a, b, t)
        return a + (b - a) * t
    end

    local function LerpColor3(c1, c2, t)
        return Color3.new(
            Lerp(c1.R, c2.R, t),
            Lerp(c1.G, c2.G, t),
            Lerp(c1.B, c2.B, t)
        )
    end

    local function LerpUDim2(u1, u2, t)
        return UDim2.new(
            Lerp(u1.X.Scale, u2.X.Scale, t),
            Lerp(u1.X.Offset, u2.X.Offset, t),
            Lerp(u1.Y.Scale, u2.Y.Scale, t),
            Lerp(u1.Y.Offset, u2.Y.Offset, t)
        )
    end

    local function Clamp(value, min, max)
        return math.max(min, math.min(max, value))
    end

    local function Round(value, decimals)
        decimals = decimals or 0
        local mult = 10 ^ decimals
        return math.floor(value * mult + 0.5) / mult
    end

    local function Map(value, inMin, inMax, outMin, outMax)
        return outMin + (value - inMin) * (outMax - outMin) / (inMax - inMin)
    end

    local function Debounce(func, delay)
        local lastCall = 0
        return function(...)
            local now = os.clock()
            if now - lastCall >= delay then
                lastCall = now
                return func(...)
            end
        end
    end

    local function Throttle(func, delay)
        local lastCall = 0
        local scheduled = false
        local args = nil

        return function(...)
            args = {...}
            local now = os.clock()

            if now - lastCall >= delay then
                lastCall = now
                return func(unpack(args))
            elseif not scheduled then
                scheduled = true
                task.delay(delay - (now - lastCall), function()
                    scheduled = false
                    lastCall = os.clock()
                    func(unpack(args))
                end)
            end
        end
    end

    local function IsValidInstance(instance)
        if instance == nil then return false end
        local success, result = pcall(function()
            return instance.Parent ~= nil or instance.ClassName ~= nil
        end)
        return success and result ~= nil
    end

    local function SafeDestroy(instance)
        if IsValidInstance(instance) then
            pcall(function()
                instance:Destroy()
            end)
        end
    end

    local function WaitForChild(parent, childName, timeout)
        timeout = timeout or 5
        local child = parent:FindFirstChild(childName)

        if child then
            return child
        end

        local startTime = os.clock()
        while os.clock() - startTime < timeout do
            child = parent:FindFirstChild(childName)
            if child then
                return child
            end
            task.wait()
        end

        return nil
    end

    local function CreateInstance(className, properties)
        local instance = Instance.new(className)

        for property, value in pairs(properties or {}) do
            if property ~= "Parent" then
                pcall(function()
                    instance[property] = value
                end)
            end
        end

        if properties and properties.Parent then
            instance.Parent = properties.Parent
        end

        return instance
    end

    local function GetScreenSize()
        local viewport = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize
        if viewport then
            return viewport.X, viewport.Y
        end
        return 1920, 1080
    end

    local function GetMousePosition()
        return UserInputService:GetMouseLocation()
    end

    local function IsMouseOver(guiObject)
        if not IsValidInstance(guiObject) then return false end

        local mousePos = GetMousePosition()
        local objPos = guiObject.AbsolutePosition
        local objSize = guiObject.AbsoluteSize

        return mousePos.X >= objPos.X and 
               mousePos.X <= objPos.X + objSize.X and
               mousePos.Y >= objPos.Y and 
               mousePos.Y <= objPos.Y + objSize.Y
    end

    local function GetTextSize(text, fontSize, font, maxWidth)
        maxWidth = maxWidth or math.huge
        local textSize = TextService:GetTextSize(
            text,
            fontSize,
            font,
            Vector2.new(maxWidth, math.huge)
        )
        return textSize.X, textSize.Y
    end

    local function TruncateText(text, maxLength, suffix)
        suffix = suffix or "..."
        if #text <= maxLength then
            return text
        end
        return text:sub(1, maxLength - #suffix) .. suffix
    end

    local function FormatNumber(num, decimals)
        decimals = decimals or 0

        if num >= 1e9 then
            return Round(num / 1e9, decimals) .. "B"
        elseif num >= 1e6 then
            return Round(num / 1e6, decimals) .. "M"
        elseif num >= 1e3 then
            return Round(num / 1e3, decimals) .. "K"
        else
            return Round(num, decimals)
        end
    end

    local function FormatTime(seconds)
        local hours = math.floor(seconds / 3600)
        local minutes = math.floor((seconds % 3600) / 60)
        local secs = math.floor(seconds % 60)

        if hours > 0 then
            return string.format("%02d:%02d:%02d", hours, minutes, secs)
        else
            return string.format("%02d:%02d", minutes, secs)
        end
    end

    local function HSVToRGB(h, s, v)
        local r, g, b
        local i = math.floor(h * 6)
        local f = h * 6 - i
        local p = v * (1 - s)
        local q = v * (1 - f * s)
        local t = v * (1 - (1 - f) * s)

        i = i % 6

        if i == 0 then r, g, b = v, t, p
        elseif i == 1 then r, g, b = q, v, p
        elseif i == 2 then r, g, b = p, v, t
        elseif i == 3 then r, g, b = p, q, v
        elseif i == 4 then r, g, b = t, p, v
        elseif i == 5 then r, g, b = v, p, q
        end

        return Color3.new(r, g, b)
    end

    local function RGBToHSV(color)
        local r, g, b = color.R, color.G, color.B
        local max = math.max(r, g, b)
        local min = math.min(r, g, b)
        local h, s, v

        v = max
        local d = max - min

        if max == 0 then
            s = 0
        else
            s = d / max
        end

        if max == min then
            h = 0
        else
            if max == r then
                h = (g - b) / d
                if g < b then h = h + 6 end
            elseif max == g then
                h = (b - r) / d + 2
            else
                h = (r - g) / d + 4
            end
            h = h / 6
        end

        return h, s, v
    end

    local function HexToRGB(hex)
        hex = hex:gsub("#", "")

        if #hex == 3 then
            hex = hex:sub(1, 1):rep(2) .. hex:sub(2, 2):rep(2) .. hex:sub(3, 3):rep(2)
        end

        local r = tonumber(hex:sub(1, 2), 16) / 255
        local g = tonumber(hex:sub(3, 4), 16) / 255
        local b = tonumber(hex:sub(5, 6), 16) / 255

        return Color3.new(r, g, b)
    end

    local function RGBToHex(color)
        return string.format("#%02X%02X%02X",
            math.floor(color.R * 255 + 0.5),
            math.floor(color.G * 255 + 0.5),
            math.floor(color.B * 255 + 0.5)
        )
    end

    local function Lighten(color, amount)
        amount = amount or 0.1
        local h, s, v = RGBToHSV(color)
        v = math.min(1, v + amount)
        return HSVToRGB(h, s, v)
    end

    local function Darken(color, amount)
        amount = amount or 0.1
        local h, s, v = RGBToHSV(color)
        v = math.max(0, v - amount)
        return HSVToRGB(h, s, v)
    end

    local function Saturate(color, amount)
        amount = amount or 0.1
        local h, s, v = RGBToHSV(color)
        s = math.min(1, s + amount)
        return HSVToRGB(h, s, v)
    end

    local function Desaturate(color, amount)
        amount = amount or 0.1
        local h, s, v = RGBToHSV(color)
        s = math.max(0, s - amount)
        return HSVToRGB(h, s, v)
    end

    local function GetContrastColor(backgroundColor)
        local luminance = 0.299 * backgroundColor.R + 0.587 * backgroundColor.G + 0.114 * backgroundColor.B
        return luminance > 0.5 and Color3.new(0, 0, 0) or Color3.new(1, 1, 1)
    end

    local function BlendColors(color1, color2, mode, amount)
        amount = amount or 0.5
        mode = mode or "normal"

        if mode == "normal" then
            return LerpColor3(color1, color2, amount)
        elseif mode == "multiply" then
            return Color3.new(
                color1.R * color2.R,
                color1.G * color2.G,
                color1.B * color2.B
            )
        elseif mode == "screen" then
            return Color3.new(
                1 - (1 - color1.R) * (1 - color2.R),
                1 - (1 - color1.G) * (1 - color2.G),
                1 - (1 - color1.B) * (1 - color2.B)
            )
        elseif mode == "overlay" then
            local function overlay(base, blend)
                if base < 0.5 then
                    return 2 * base * blend
                else
                    return 1 - 2 * (1 - base) * (1 - blend)
                end
            end
            return Color3.new(
                overlay(color1.R, color2.R),
                overlay(color1.G, color2.G),
                overlay(color1.B, color2.B)
            )
        elseif mode == "add" then
            return Color3.new(
                math.min(1, color1.R + color2.R * amount),
                math.min(1, color1.G + color2.G * amount),
                math.min(1, color1.B + color2.B * amount)
            )
        end

        return LerpColor3(color1, color2, amount)
    end

    --// NexusUI Main Class
    local NexusUI = {}
    NexusUI.__index = NexusUI
    NexusUI.Version = LIBRARY_VERSION
    NexusUI.Build = LIBRARY_BUILD
    NexusUI.Name = LIBRARY_NAME

    -- Internal state access
    NexusUI._State = LibraryState
    NexusUI._Utility = {
        Log = Log,
        SafeCall = SafeCall,
        DeepCopy = DeepCopy,
        MergeTables = MergeTables,
        GenerateUID = GenerateUID,
        Lerp = Lerp,
        LerpColor3 = LerpColor3,
        LerpUDim2 = LerpUDim2,
        Clamp = Clamp,
        Round = Round,
        Map = Map,
        Debounce = Debounce,
        Throttle = Throttle,
        IsValidInstance = IsValidInstance,
        SafeDestroy = SafeDestroy,
        WaitForChild = WaitForChild,
        CreateInstance = CreateInstance,
        GetScreenSize = GetScreenSize,
        GetMousePosition = GetMousePosition,
        IsMouseOver = IsMouseOver,
        GetTextSize = GetTextSize,
        TruncateText = TruncateText,
        FormatNumber = FormatNumber,
        FormatTime = FormatTime,
        HSVToRGB = HSVToRGB,
        RGBToHSV = RGBToHSV,
        HexToRGB = HexToRGB,
        RGBToHex = RGBToHex,
        Lighten = Lighten,
        Darken = Darken,
        Saturate = Saturate,
        Desaturate = Desaturate,
        GetContrastColor = GetContrastColor,
        BlendColors = BlendColors,
    }

    --// Module Loading
    local function LoadModule(moduleName)
        local modulePath = script:FindFirstChild(moduleName, true)
        if modulePath then
            local success, result = pcall(require, modulePath)
            if success then
                return result
            else
                Log("ERROR", "Failed to load module %s: %s", moduleName, tostring(result))
            end
        else
            Log("WARN", "Module not found: %s", moduleName)
        end
        return nil
    end

    local function InitializeModules()
        Log("INFO", "Initializing NexusUI modules...")

        -- Load Core modules
        Core = LoadModule("Core") or {}
        Core.Services = LoadModule("Services") or {}
        Core.StateManager = LoadModule("StateManager") or {}
        Core.EventSystem = LoadModule("EventSystem") or {}
        Core.SignalClass = LoadModule("SignalClass") or {}
        Core.Maid = LoadModule("Maid") or {}
        Core.Promise = LoadModule("Promise") or {}
        Core.Types = LoadModule("Types") or {}
        Core.Constants = LoadModule("Constants") or {}
        Core.InstancePool = LoadModule("InstancePool") or {}
        Core.ScreenGui = LoadModule("ScreenGui") or {}
        Core.Utility = LoadModule("Utility") or {}

        -- Load Animation modules
        Animation = LoadModule("Animation") or {}

        -- Load Theme modules
        Themes = LoadModule("Themes") or {}

        -- Load Component modules
        Components = LoadModule("Components") or {}

        -- Load Feature modules
        Features = LoadModule("Features") or {}

        -- Load Layout modules
        Layout = LoadModule("Layout") or {}

        -- Load Asset modules
        Assets = LoadModule("Assets") or {}

        -- Load Builder modules
        Builders = LoadModule("Builders") or {}

        Log("INFO", "Module initialization complete")
    end

    --// Library Initialization
    function NexusUI:Initialize(config)
        if LibraryState.Initialized then
            Log("WARN", "NexusUI already initialized")
            return self
        end

        config = config or {}

        -- Apply configuration
        LibraryState.GlobalTheme = config.Theme or "Midnight"
        LibraryState.GlobalSoundPack = config.SoundPack or "Default"
        LibraryState.SoundsEnabled = config.SoundsEnabled ~= false
        LibraryState.AnimationsEnabled = config.AnimationsEnabled ~= false
        LibraryState.PerformanceMode = config.PerformanceMode or false
        DEBUG_MODE = config.DebugMode or false
        PERFORMANCE_MODE = config.PerformanceMode or false

        -- Initialize modules
        InitializeModules()

        -- Create main ScreenGui
        self:CreateScreenGui()

        -- Start performance monitoring
        self:StartPerformanceMonitor()

        -- Mark as initialized
        LibraryState.Initialized = true
        LibraryState.StartTime = os.clock()

        Log("INFO", "NexusUI v%s initialized successfully", LIBRARY_VERSION)

        return self
    end

    --// ScreenGui Management
    function NexusUI:CreateScreenGui()
        -- Destroy existing ScreenGui if present
        local existingGui = CoreGui:FindFirstChild(LIBRARY_NAME)
        if existingGui then
            existingGui:Destroy()
        end

        -- Also check PlayerGui as fallback
        local existingPlayerGui = PlayerGui:FindFirstChild(LIBRARY_NAME)
        if existingPlayerGui then
            existingPlayerGui:Destroy()
        end

        -- Create new ScreenGui
        local screenGui = CreateInstance("ScreenGui", {
            Name = LIBRARY_NAME,
            DisplayOrder = 999999,
            IgnoreGuiInset = true,
            ResetOnSpawn = false,
            ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
        })

        -- Try to parent to CoreGui, fallback to PlayerGui
        local success = pcall(function()
            screenGui.Parent = CoreGui
        end)

        if not success then
            screenGui.Parent = PlayerGui
        end

        LibraryState.ScreenGui = screenGui

        -- Create container frames
        self:CreateContainerFrames()

        return screenGui
    end

    function NexusUI:CreateContainerFrames()
        local screenGui = LibraryState.ScreenGui

        -- Main container for windows
        local windowContainer = CreateInstance("Frame", {
            Name = "WindowContainer",
            BackgroundTransparency = 1,
            Size = UDim2.fromScale(1, 1),
            Parent = screenGui
        })
        LibraryState.WindowContainer = windowContainer

        -- Container for notifications
        local notificationContainer = CreateInstance("Frame", {
            Name = "NotificationContainer",
            BackgroundTransparency = 1,
            Size = UDim2.fromScale(1, 1),
            Parent = screenGui
        })
        LibraryState.NotificationContainer = notificationContainer

        -- Container for modals/overlays
        local modalContainer = CreateInstance("Frame", {
            Name = "ModalContainer",
            BackgroundTransparency = 1,
            Size = UDim2.fromScale(1, 1),
            Visible = false,
            Parent = screenGui
        })
        LibraryState.ModalContainer = modalContainer

        -- Container for tooltips
        local tooltipContainer = CreateInstance("Frame", {
            Name = "TooltipContainer",
            BackgroundTransparency = 1,
            Size = UDim2.fromScale(1, 1),
            Parent = screenGui
        })
        LibraryState.TooltipContainer = tooltipContainer

        -- Container for context menus
        local contextMenuContainer = CreateInstance("Frame", {
            Name = "ContextMenuContainer",
            BackgroundTransparency = 1,
            Size = UDim2.fromScale(1, 1),
            Parent = screenGui
        })
        LibraryState.ContextMenuContainer = contextMenuContainer

        -- Container for FPS/performance overlay
        local performanceContainer = CreateInstance("Frame", {
            Name = "PerformanceContainer",
            BackgroundTransparency = 1,
            Size = UDim2.fromScale(1, 1),
            Parent = screenGui
        })
        LibraryState.PerformanceContainer = performanceContainer

        -- Container for watermarks
        local watermarkContainer = CreateInstance("Frame", {
            Name = "WatermarkContainer",
            BackgroundTransparency = 1,
            Size = UDim2.fromScale(1, 1),
            Parent = screenGui
        })
        LibraryState.WatermarkContainer = watermarkContainer

        -- Container for ESP elements
        local espContainer = CreateInstance("Frame", {
            Name = "ESPContainer",
            BackgroundTransparency = 1,
            Size = UDim2.fromScale(1, 1),
            Parent = screenGui
        })
        LibraryState.ESPContainer = espContainer
    end

    --// Performance Monitoring
    function NexusUI:StartPerformanceMonitor()
        local lastTime = os.clock()
        local frameCount = 0
        local fpsHistory = {}
        local maxHistorySize = 60

        local connection = RunService.Heartbeat:Connect(function(deltaTime)
            frameCount = frameCount + 1
            local currentTime = os.clock()
            local elapsed = currentTime - lastTime

            if elapsed >= 1 then
                local fps = frameCount / elapsed
                LibraryState.CurrentFPS = Round(fps, 1)

                -- Update history
                table.insert(fpsHistory, fps)
                if #fpsHistory > maxHistorySize then
                    table.remove(fpsHistory, 1)
                end

                -- Calculate statistics
                local total = 0
                local peak = 0
                local low = math.huge

                for _, v in ipairs(fpsHistory) do
                    total = total + v
                    peak = math.max(peak, v)
                    low = math.min(low, v)
                end

                LibraryState.AverageFPS = Round(total / #fpsHistory, 1)
                LibraryState.PeakFPS = Round(peak, 1)
                LibraryState.LowFPS = Round(low, 1)

                -- Memory usage
                LibraryState.MemoryUsage = Round(collectgarbage("count") / 1024, 2)

                -- Reset counters
                frameCount = 0
                lastTime = currentTime
            end

            LibraryState.LastFrameTime = deltaTime
        end)

        table.insert(LibraryState.Connections, connection)

        -- Network ping monitoring (simplified)
        local pingConnection = RunService.Heartbeat:Connect(Throttle(function()
            local stats = Players.LocalPlayer:FindFirstChild("PlayerScripts")
            if stats then
                local ping = Players.LocalPlayer:GetNetworkPing()
                LibraryState.NetworkPing = Round(ping * 1000, 0)
            end
        end, 1))

        table.insert(LibraryState.Connections, pingConnection)
    end

    --// Window Creation
    function NexusUI:CreateWindow(config)
        config = config or {}

        -- Initialize if not already done
        if not LibraryState.Initialized then
            self:Initialize()
        end

        -- Load window builder
        local WindowBuilder = Builders.WindowBuilder or NexusRequire("NexusUI/Builders/WindowBuilder")

        local window = WindowBuilder.new({
            Title = config.Title or "NexusUI Window",
            Subtitle = config.Subtitle or "",
            Theme = config.Theme or LibraryState.GlobalTheme,
            Size = config.Size or UDim2.fromOffset(600, 450),
            Position = config.Position or UDim2.fromScale(0.5, 0.5),
            AnchorPoint = config.AnchorPoint or Vector2.new(0.5, 0.5),
            MinSize = config.MinSize or Vector2.new(400, 300),
            MaxSize = config.MaxSize or Vector2.new(1200, 900),
            Resizable = config.Resizable ~= false,
            Draggable = config.Draggable ~= false,
            Closeable = config.Closeable ~= false,
            Minimizable = config.Minimizable ~= false,
            EnableFPS = config.EnableFPS or false,
            SoundPack = config.SoundPack or LibraryState.GlobalSoundPack,
            Icon = config.Icon or nil,
            ShowIcon = config.ShowIcon ~= false,
            Keybind = config.Keybind or Enum.KeyCode.RightControl,
            SavePosition = config.SavePosition ~= false,
            LoadPosition = config.LoadPosition ~= false,
            CloseCallback = config.CloseCallback or nil,
            MinimizeCallback = config.MinimizeCallback or nil,
            FocusCallback = config.FocusCallback or nil,
            Parent = LibraryState.WindowContainer
        })

        table.insert(LibraryState.Windows, window)
        LibraryState.ActiveWindow = window

        Log("INFO", "Created window: %s", config.Title or "NexusUI Window")

        return window
    end

    --// Theme Management
    function NexusUI:SetTheme(themeName)
        LibraryState.GlobalTheme = themeName

        -- Apply theme to all windows
        for _, window in ipairs(LibraryState.Windows) do
            if window and window.SetTheme then
                window:SetTheme(themeName)
            end
        end

        Log("INFO", "Theme changed to: %s", themeName)
    end

    function NexusUI:GetTheme()
        return LibraryState.GlobalTheme
    end

    function NexusUI:GetAvailableThemes()
        return Themes and Themes:GetAvailableThemes() or {
            "Midnight", "Obsidian", "Carbon", "Dracula", "OneDark", "TokyoNight",
            "Snow", "Cream", "Paper", "Daylight",
            "Neon", "Cyberpunk", "Vaporwave", "Synthwave", "Sunset",
            "LiquidGlass", "FrostedGlass", "AcrylicBlue", "MicaDark",
            "RGB", "Matrix", "Hacker", "MinimalGaming", "Retro"
        }
    end

    --// Sound Management
    function NexusUI:SetSoundPack(soundPackName)
        LibraryState.GlobalSoundPack = soundPackName

        -- Apply sound pack to all windows
        for _, window in ipairs(LibraryState.Windows) do
            if window and window.SetSoundPack then
                window:SetSoundPack(soundPackName)
            end
        end

        Log("INFO", "Sound pack changed to: %s", soundPackName)
    end

    function NexusUI:EnableSounds(enabled)
        LibraryState.SoundsEnabled = enabled
    end

    function NexusUI:PlaySound(soundName)
        if not LibraryState.SoundsEnabled then return end

        if Features and Features.Sound and Features.Sound.Play then
            Features.Sound:Play(soundName, LibraryState.GlobalSoundPack)
        end
    end

    --// Configuration Management
    function NexusUI:SaveConfig(configName)
        configName = configName or "Default"

        local configData = {
            Theme = LibraryState.GlobalTheme,
            SoundPack = LibraryState.GlobalSoundPack,
            SoundsEnabled = LibraryState.SoundsEnabled,
            AnimationsEnabled = LibraryState.AnimationsEnabled,
            Windows = {},
            Components = {}
        }

        -- Collect window configurations
        for i, window in ipairs(LibraryState.Windows) do
            if window and window.GetConfig then
                configData.Windows[i] = window:GetConfig()
            end
        end

        -- Save to file
        if Features and Features.Config and Features.Config.Save then
            Features.Config:Save(configName, configData)
        else
            -- Fallback: Use writefile if available
            local success, err = pcall(function()
                if writefile then
                    local json = HttpService:JSONEncode(configData)
                    writefile("NexusUI/Configs/" .. configName .. ".json", json)
                end
            end)

            if not success then
                Log("ERROR", "Failed to save config: %s", tostring(err))
            end
        end

        Log("INFO", "Config saved: %s", configName)
    end

    function NexusUI:LoadConfig(configName)
        configName = configName or "Default"

        local configData = nil

        if Features and Features.Config and Features.Config.Load then
            configData = Features.Config:Load(configName)
        else
            -- Fallback: Use readfile if available
            local success, result = pcall(function()
                if readfile and isfile then
                    local path = "NexusUI/Configs/" .. configName .. ".json"
                    if isfile(path) then
                        local json = readfile(path)
                        return HttpService:JSONDecode(json)
                    end
                end
                return nil
            end)

            if success then
                configData = result
            else
                Log("ERROR", "Failed to load config: %s", tostring(result))
            end
        end

        if configData then
            -- Apply configuration
            if configData.Theme then
                self:SetTheme(configData.Theme)
            end
            if configData.SoundPack then
                self:SetSoundPack(configData.SoundPack)
            end
            if configData.SoundsEnabled ~= nil then
                LibraryState.SoundsEnabled = configData.SoundsEnabled
            end
            if configData.AnimationsEnabled ~= nil then
                LibraryState.AnimationsEnabled = configData.AnimationsEnabled
            end

            -- Apply window configurations
            for i, windowConfig in pairs(configData.Windows or {}) do
                local window = LibraryState.Windows[i]
                if window and window.SetConfig then
                    window:SetConfig(windowConfig)
                end
            end

            Log("INFO", "Config loaded: %s", configName)
            return true
        end

        return false
    end

    function NexusUI:DeleteConfig(configName)
        configName = configName or "Default"

        local success = pcall(function()
            if delfile and isfile then
                local path = "NexusUI/Configs/" .. configName .. ".json"
                if isfile(path) then
                    delfile(path)
                end
            end
        end)

        if success then
            Log("INFO", "Config deleted: %s", configName)
        end

        return success
    end

    function NexusUI:GetConfigs()
        local configs = {}

        local success = pcall(function()
            if listfiles and isfolder then
                local path = "NexusUI/Configs"
                if isfolder(path) then
                    for _, file in ipairs(listfiles(path)) do
                        local name = file:match("([^/\\]+)%.json$")
                        if name then
                            table.insert(configs, name)
                        end
                    end
                end
            end
        end)

        return configs
    end

    --// Notification System
    function NexusUI:Notify(config)
        config = config or {}

        local notification = {
            Title = config.Title or "Notification",
            Content = config.Content or config.Message or "",
            Type = config.Type or "Info", -- Info, Success, Warning, Error
            Duration = config.Duration or 5,
            Icon = config.Icon or nil,
            Callback = config.Callback or nil,
            Actions = config.Actions or nil
        }

        if Components and Components.Notifications and Components.Notifications.Toast then
            return Components.Notifications.Toast:Show(notification)
        end

        Log("INFO", "Notification: [%s] %s - %s", notification.Type, notification.Title, notification.Content)
    end

    function NexusUI:Alert(config)
        config = config or {}

        if Components and Components.Notifications and Components.Notifications.Alert then
            return Components.Notifications.Alert:Show(config)
        end
    end

    function NexusUI:Confirm(config)
        config = config or {}

        if Components and Components.Notifications and Components.Notifications.Confirm then
            return Components.Notifications.Confirm:Show(config)
        end
    end

    function NexusUI:Prompt(config)
        config = config or {}

        if Components and Components.Notifications and Components.Notifications.Prompt then
            return Components.Notifications.Prompt:Show(config)
        end
    end

    --// Performance Info
    function NexusUI:GetFPS()
        return LibraryState.CurrentFPS
    end

    function NexusUI:GetAverageFPS()
        return LibraryState.AverageFPS
    end

    function NexusUI:GetPing()
        return LibraryState.NetworkPing
    end

    function NexusUI:GetMemoryUsage()
        return LibraryState.MemoryUsage
    end

    function NexusUI:GetPerformanceStats()
        return {
            FPS = LibraryState.CurrentFPS,
            AverageFPS = LibraryState.AverageFPS,
            PeakFPS = LibraryState.PeakFPS,
            LowFPS = LibraryState.LowFPS,
            Ping = LibraryState.NetworkPing,
            Memory = LibraryState.MemoryUsage,
            FrameTime = LibraryState.LastFrameTime * 1000,
            Uptime = os.clock() - LibraryState.StartTime
        }
    end

    --// Cleanup
    function NexusUI:Destroy()
        Log("INFO", "Destroying NexusUI...")

        -- Disconnect all connections
        for _, connection in ipairs(LibraryState.Connections) do
            if connection and connection.Connected then
                connection:Disconnect()
            end
        end
        LibraryState.Connections = {}

        -- Destroy all windows
        for _, window in ipairs(LibraryState.Windows) do
            if window and window.Destroy then
                window:Destroy()
            end
        end
        LibraryState.Windows = {}

        -- Destroy ScreenGui
        if LibraryState.ScreenGui then
            SafeDestroy(LibraryState.ScreenGui)
        end

        -- Reset state
        LibraryState.Initialized = false
        LibraryState.ActiveWindow = nil

        Log("INFO", "NexusUI destroyed")
    end

    --// Toggle Visibility
    function NexusUI:Toggle()
        if LibraryState.ScreenGui then
            LibraryState.ScreenGui.Enabled = not LibraryState.ScreenGui.Enabled
        end
    end

    function NexusUI:Show()
        if LibraryState.ScreenGui then
            LibraryState.ScreenGui.Enabled = true
        end
    end

    function NexusUI:Hide()
        if LibraryState.ScreenGui then
            LibraryState.ScreenGui.Enabled = false
        end
    end

    function NexusUI:IsVisible()
        return LibraryState.ScreenGui and LibraryState.ScreenGui.Enabled or false
    end

    --// Debug Utilities
    function NexusUI:EnableDebugMode(enabled)
        DEBUG_MODE = enabled
    end

    function NexusUI:GetErrorLog()
        return DeepCopy(LibraryState.ErrorLog)
    end

    function NexusUI:GetWarningLog()
        return DeepCopy(LibraryState.WarningLog)
    end

    function NexusUI:GetInfoLog()
        return DeepCopy(LibraryState.InfoLog)
    end

    function NexusUI:ClearLogs()
        LibraryState.ErrorLog = {}
        LibraryState.WarningLog = {}
        LibraryState.InfoLog = {}
    end

    --// Module Accessors
    function NexusUI:GetCore()
        return Core
    end

    function NexusUI:GetAnimation()
        return Animation
    end

    function NexusUI:GetThemes()
        return Themes
    end

    function NexusUI:GetComponents()
        return Components
    end

    function NexusUI:GetFeatures()
        return Features
    end

    function NexusUI:GetLayout()
        return Layout
    end

    function NexusUI:GetAssets()
        return Assets
    end

    function NexusUI:GetBuilders()
        return Builders
    end

    --// Global Input Handling
    local function SetupGlobalInput()
        local connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end

            -- Handle global keybinds
            if input.KeyCode then
                -- Toggle visibility keybind
                for _, window in ipairs(LibraryState.Windows) do
                    if window and window.Keybind and input.KeyCode == window.Keybind then
                        if window.Toggle then
                            window:Toggle()
                        end
                    end
                end

                -- Close on Escape (if enabled)
                if input.KeyCode == Enum.KeyCode.Escape then
                    -- Close any open modals or context menus
                    if LibraryState.ModalContainer and LibraryState.ModalContainer.Visible then
                        LibraryState.ModalContainer.Visible = false
                    end
                end
            end
        end)

        table.insert(LibraryState.Connections, connection)
    end

    SetupGlobalInput()

    --// Auto-cleanup on player leaving
    Players.PlayerRemoving:Connect(function(player)
        if player == LocalPlayer then
            NexusUI:Destroy()
        end
    end)

    --// Finalize and return
    Log("INFO", "NexusUI v%s loaded", LIBRARY_VERSION)

    return NexusUI


end


-- ============================================================================
-- Module: NexusUI_Compiled
-- ============================================================================
NexusUI_Modules["NexusUI_Compiled"] = function()
    local script = CreateMockScript("NexusUI_Compiled")
    
    --[[
    ╔═══════════════════════════════════════════════════════════════════════════════╗
    ║                                                                               ║
    ║   ███╗   ██╗███████╗██╗  ██╗██╗   ██╗███████╗██╗   ██╗██╗                     ║
    ║   ████╗  ██║██╔════╝╚██╗██╔╝██║   ██║██╔════╝██║   ██║██║                     ║
    ║   ██╔██╗ ██║█████╗   ╚███╔╝ ██║   ██║███████╗██║   ██║██║                     ║
    ║   ██║╚██╗██║██╔══╝   ██╔██╗ ██║   ██║╚════██║██║   ██║██║                     ║
    ║   ██║ ╚████║███████╗██╔╝ ██╗╚██████╔╝███████║╚██████╔╝██║                     ║
    ║   ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚══════╝ ╚═════╝ ╚═╝                     ║
    ║                                                                               ║
    ║   Premium UI Library for Roblox Executors                                     ║
    ║   Version: 1.0.0 | Compiled: 2026-01-19 21:05:15                          ║
    ║                                                                               ║
    ╠═══════════════════════════════════════════════════════════════════════════════╣
    ║                                                                               ║
    ║   Features:                                                                   ║
    ║   • 25+ Beautiful Themes with Liquid Glass Effects                            ║
    ║   • Advanced Animation Engine with Springs & Easing                           ║
    ║   • Comprehensive Component Library (50+ Components)                          ║
    ║   • Performance Monitoring (FPS, Memory, Network)                             ║
    ║   • ESP, Aimbot, and Executor-Specific Components                             ║
    ║   • Builder Patterns for Easy UI Creation                                     ║
    ║   • Sound System & Global Hotkey Management                                   ║
    ║   • Config Save/Load with Cloud Sync Support                                  ║
    ║                                                                               ║
    ║   Usage:                                                                      ║
    ║       local NexusUI = loadstring(game:HttpGet("URL"))()                       ║
    ║       local Window = NexusUI:CreateWindow({ Title = "My Script" })           ║
    ║                                                                               ║
    ╚═══════════════════════════════════════════════════════════════════════════════╝
    --]]

    -- ============================================================================
    -- NexusUI Runtime Module System
    -- ============================================================================

    local NexusUI_Modules = {}
    local NexusUI_Loaded = {}

    local function NexusRequire(modulePath)
        -- Check if already loaded
        if NexusUI_Loaded[modulePath] then
            return NexusUI_Loaded[modulePath]
        end

        -- Check if module exists
        local moduleFunc = NexusUI_Modules[modulePath]
        if moduleFunc then
            local result = moduleFunc()
            NexusUI_Loaded[modulePath] = result
            return result
        end

        -- Module not found
        warn("[NexusUI] Module not found:", modulePath)
        return nil
    end

    -- Mock script object for module compatibility
    local function CreateMockScript(modulePath)
        local parts = {}
        for part in modulePath:gmatch("[^/]+") do
            table.insert(parts, part)
        end

        local mock = {
            Name = parts[#parts]:gsub("%.lua$", ""),
        }

        -- Create Parent chain
        local current = mock
        for i = #parts - 1, 1, -1 do
            local parent = { Name = parts[i]:gsub("%.lua$", "") }
            current.Parent = parent
            current = parent
        end

        return mock
    end


    -- ============================================================================
    -- Module: NexusUI/Core/Services
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/Services"] = function()
        local script = CreateMockScript("NexusUI/Core/Services")

        --[[
            NexusUI Services Module
            Cached access to Roblox services for optimal performance

            Features:
            - Lazy loading of services
            - Service caching
            - Safe service access
            - Service availability checking
            - Mock services for testing
        ]]

        --// Service Cache
        local ServiceCache = {}
        local ServiceAvailability = {}

        --// Service Definitions
        local ServiceDefinitions = {
            -- Core Services
            Players = "Players",
            RunService = "RunService",
            UserInputService = "UserInputService",
            TweenService = "TweenService",
            HttpService = "HttpService",
            ContentProvider = "ContentProvider",
            TextService = "TextService",
            GuiService = "GuiService",

            -- Storage Services
            ReplicatedStorage = "ReplicatedStorage",
            ServerStorage = "ServerStorage",
            ServerScriptService = "ServerScriptService",
            StarterGui = "StarterGui",
            StarterPlayer = "StarterPlayer",
            StarterPack = "StarterPack",

            -- Game Services
            Workspace = "Workspace",
            Lighting = "Lighting",
            SoundService = "SoundService",
            Chat = "Chat",
            Teams = "Teams",

            -- Player Services
            CoreGui = "CoreGui",
            LocalizationService = "LocalizationService",
            PolicyService = "PolicyService",

            -- Network Services
            NetworkClient = "NetworkClient",
            NetworkServer = "NetworkServer",

            -- Physics Services
            PhysicsService = "PhysicsService",

            -- Other Services
            MarketplaceService = "MarketplaceService",
            BadgeService = "BadgeService",
            GamePassService = "GamePassService",
            AssetService = "AssetService",
            InsertService = "InsertService",

            -- Social Services
            SocialService = "SocialService",
            FriendService = "FriendService",

            -- Input Services
            ContextActionService = "ContextActionService",
            HapticService = "HapticService",
            VRService = "VRService",

            -- Analytics Services
            AnalyticsService = "AnalyticsService",

            -- Memory Services
            MemoryStoreService = "MemoryStoreService",

            -- Messaging Services
            MessagingService = "MessagingService",

            -- DataStore Services
            DataStoreService = "DataStoreService",

            -- Collision Services
            CollectionService = "CollectionService",

            -- Debris Service
            Debris = "Debris",

            -- Path Services
            PathfindingService = "PathfindingService",

            -- Tele Services
            TeleportService = "TeleportService",

            -- Script Services
            ScriptContext = "ScriptContext",

            -- Log Services
            LogService = "LogService",

            -- Stats Services
            Stats = "Stats",

            -- Testing Services
            TestService = "TestService",

            -- Selection Service
            Selection = "Selection",

            -- Change History Service
            ChangeHistoryService = "ChangeHistoryService",

            -- Keyframe Sequence Provider
            KeyframeSequenceProvider = "KeyframeSequenceProvider",

            -- Animation Services
            AnimationClipProvider = "AnimationClipProvider",

            -- Proximity Services
            ProximityPromptService = "ProximityPromptService",

            -- Material Service
            MaterialService = "MaterialService",

            -- Dragger Service
            DraggerService = "DraggerService",

            -- Instance Provider
            InstanceAdornmentService = "InstanceAdornmentService",
        }

        --// Services Module
        local Services = {}
        Services.__index = Services

        --// Metatable for lazy loading
        setmetatable(Services, {
            __index = function(self, serviceName)
                return self:GetService(serviceName)
            end
        })

        --// Internal Functions
        local function SafeGetService(serviceName)
            local success, service = pcall(function()
                return game:GetService(serviceName)
            end)

            if success and service then
                ServiceAvailability[serviceName] = true
                return service
            else
                ServiceAvailability[serviceName] = false
                return nil
            end
        end

        --// Public Methods
        function Services:GetService(serviceName)
            -- Check cache first
            if ServiceCache[serviceName] then
                return ServiceCache[serviceName]
            end

            -- Get the actual service name from definitions
            local actualServiceName = ServiceDefinitions[serviceName] or serviceName

            -- Try to get the service
            local service = SafeGetService(actualServiceName)

            if service then
                ServiceCache[serviceName] = service
            end

            return service
        end

        function Services:IsServiceAvailable(serviceName)
            if ServiceAvailability[serviceName] ~= nil then
                return ServiceAvailability[serviceName]
            end

            -- Try to get the service to check availability
            local service = self:GetService(serviceName)
            return service ~= nil
        end

        function Services:GetAllServices()
            local services = {}

            for name, _ in pairs(ServiceDefinitions) do
                local service = self:GetService(name)
                if service then
                    services[name] = service
                end
            end

            return services
        end

        function Services:GetAvailableServices()
            local available = {}

            for name, _ in pairs(ServiceDefinitions) do
                if self:IsServiceAvailable(name) then
                    table.insert(available, name)
                end
            end

            return available
        end

        function Services:GetUnavailableServices()
            local unavailable = {}

            for name, _ in pairs(ServiceDefinitions) do
                if not self:IsServiceAvailable(name) then
                    table.insert(unavailable, name)
                end
            end

            return unavailable
        end

        function Services:ClearCache()
            ServiceCache = {}
            ServiceAvailability = {}
        end

        function Services:PreloadServices(serviceNames)
            serviceNames = serviceNames or {}

            if #serviceNames == 0 then
                -- Preload common services
                serviceNames = {
                    "Players",
                    "RunService",
                    "UserInputService",
                    "TweenService",
                    "HttpService",
                    "TextService",
                    "ContentProvider",
                    "GuiService",
                    "SoundService",
                    "Workspace",
                    "Lighting",
                    "ReplicatedStorage",
                    "CoreGui",
                    "Debris",
                    "CollectionService",
                }
            end

            for _, name in ipairs(serviceNames) do
                self:GetService(name)
            end
        end

        function Services:GetCacheStats()
            local cached = 0
            local available = 0
            local unavailable = 0

            for _, _ in pairs(ServiceCache) do
                cached = cached + 1
            end

            for _, isAvailable in pairs(ServiceAvailability) do
                if isAvailable then
                    available = available + 1
                else
                    unavailable = unavailable + 1
                end
            end

            return {
                Cached = cached,
                Available = available,
                Unavailable = unavailable,
                Total = cached + unavailable
            }
        end

        --// Quick Access Properties (commonly used services)
        Services.Players = nil
        Services.RunService = nil
        Services.UserInputService = nil
        Services.TweenService = nil
        Services.HttpService = nil
        Services.TextService = nil
        Services.ContentProvider = nil
        Services.GuiService = nil
        Services.SoundService = nil
        Services.Workspace = nil
        Services.Lighting = nil
        Services.ReplicatedStorage = nil
        Services.CoreGui = nil
        Services.StarterGui = nil
        Services.Debris = nil
        Services.CollectionService = nil

        --// Initialize quick access
        local function InitializeQuickAccess()
            local quickServices = {
                "Players",
                "RunService",
                "UserInputService",
                "TweenService",
                "HttpService",
                "TextService",
                "ContentProvider",
                "GuiService",
                "SoundService",
                "Workspace",
                "Lighting",
                "ReplicatedStorage",
                "CoreGui",
                "StarterGui",
                "Debris",
                "CollectionService",
            }

            for _, name in ipairs(quickServices) do
                rawset(Services, name, Services:GetService(name))
            end
        end

        -- Delay initialization slightly to ensure game is loaded
        task.defer(InitializeQuickAccess)

        --// Local Player Access
        function Services:GetLocalPlayer()
            local Players = self:GetService("Players")
            return Players and Players.LocalPlayer
        end

        function Services:GetPlayerGui()
            local player = self:GetLocalPlayer()
            return player and player:FindFirstChild("PlayerGui")
        end

        function Services:GetMouse()
            local player = self:GetLocalPlayer()
            return player and player:GetMouse()
        end

        function Services:GetCamera()
            local Workspace = self:GetService("Workspace")
            return Workspace and Workspace.CurrentCamera
        end

        function Services:GetCharacter()
            local player = self:GetLocalPlayer()
            return player and player.Character
        end

        function Services:GetHumanoid()
            local character = self:GetCharacter()
            return character and character:FindFirstChildOfClass("Humanoid")
        end

        function Services:GetRootPart()
            local character = self:GetCharacter()
            return character and character:FindFirstChild("HumanoidRootPart")
        end

        --// Utility Functions
        function Services:WaitForService(serviceName, timeout)
            timeout = timeout or 10
            local startTime = os.clock()

            while os.clock() - startTime < timeout do
                local service = self:GetService(serviceName)
                if service then
                    return service
                end
                task.wait(0.1)
            end

            return nil
        end

        function Services:OnServiceReady(serviceName, callback)
            local service = self:GetService(serviceName)

            if service then
                callback(service)
                return
            end

            -- Poll for service
            task.spawn(function()
                local service = self:WaitForService(serviceName)
                if service then
                    callback(service)
                end
            end)
        end

        return Services


    end


    -- ============================================================================
    -- Module: NexusUI/Core/SignalClass
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/SignalClass"] = function()
        local script = CreateMockScript("NexusUI/Core/SignalClass")

        --[[
            NexusUI Signal Class
            A robust signal/event implementation for the UI library

            Features:
            - Signal creation and management
            - Connection handling with automatic cleanup
            - Once connections (fire once then disconnect)
            - Wait functionality with timeout
            - Priority-based firing
            - Connection throttling and debouncing
            - Error handling and logging
            - Memory leak prevention
        ]]

        --// Signal Connection Class
        local Connection = {}
        Connection.__index = Connection

        function Connection.new(signal, callback, options)
            options = options or {}

            local self = setmetatable({}, Connection)

            self._signal = signal
            self._callback = callback
            self._connected = true
            self._once = options.Once or false
            self._priority = options.Priority or 0
            self._throttle = options.Throttle or 0
            self._debounce = options.Debounce or 0
            self._lastFire = 0
            self._id = options.Id or tostring(os.clock()) .. "_" .. tostring(math.random(1000000))
            self._name = options.Name or "Connection"
            self._metadata = options.Metadata or {}

            -- Debounce state
            self._debounceScheduled = false
            self._debounceArgs = nil

            return self
        end

        function Connection:Disconnect()
            if not self._connected then
                return
            end

            self._connected = false

            if self._signal then
                self._signal:_removeConnection(self)
                self._signal = nil
            end

            self._callback = nil
        end

        function Connection:IsConnected()
            return self._connected
        end

        function Connection:GetPriority()
            return self._priority
        end

        function Connection:SetPriority(priority)
            self._priority = priority
            if self._signal then
                self._signal:_sortConnections()
            end
        end

        function Connection:GetId()
            return self._id
        end

        function Connection:GetName()
            return self._name
        end

        function Connection:GetMetadata()
            return self._metadata
        end

        function Connection:_fire(...)
            if not self._connected then
                return false
            end

            local now = os.clock()

            -- Throttle check
            if self._throttle > 0 then
                if now - self._lastFire < self._throttle then
                    return false
                end
            end

            -- Debounce handling
            if self._debounce > 0 then
                self._debounceArgs = {...}

                if not self._debounceScheduled then
                    self._debounceScheduled = true

                    task.delay(self._debounce, function()
                        if self._connected and self._debounceArgs then
                            self:_executeCallback(unpack(self._debounceArgs))
                        end
                        self._debounceScheduled = false
                        self._debounceArgs = nil
                    end)
                end

                return true
            end

            -- Direct execution
            self._lastFire = now
            self:_executeCallback(...)

            -- Handle once connections
            if self._once then
                self:Disconnect()
            end

            return true
        end

        function Connection:_executeCallback(...)
            if not self._callback then return end

            local success, err = pcall(self._callback, ...)

            if not success then
                warn(string.format("[NexusUI.Signal] Connection '%s' error: %s", self._name, tostring(err)))
            end
        end

        --// Signal Class
        local Signal = {}
        Signal.__index = Signal

        --// Signal Pool for reuse
        local SignalPool = {}
        local MaxPoolSize = 50

        function Signal.new(name)
            -- Try to get from pool
            local signal = table.remove(SignalPool)

            if signal then
                signal._name = name or "Signal"
                signal._destroyed = false
                return signal
            end

            -- Create new signal
            local self = setmetatable({}, Signal)

            self._name = name or "Signal"
            self._connections = {}
            self._connectionCount = 0
            self._destroyed = false
            self._firing = false
            self._fireCount = 0
            self._lastFireTime = 0
            self._waitingThreads = {}
            self._middleware = {}

            return self
        end

        function Signal:Connect(callback, options)
            if self._destroyed then
                warn(string.format("[NexusUI.Signal] Attempted to connect to destroyed signal '%s'", self._name))
                return nil
            end

            if type(callback) ~= "function" then
                warn("[NexusUI.Signal] Connect requires a function callback")
                return nil
            end

            options = options or {}

            local connection = Connection.new(self, callback, options)

            table.insert(self._connections, connection)
            self._connectionCount = self._connectionCount + 1

            -- Sort by priority if needed
            if options.Priority and options.Priority ~= 0 then
                self:_sortConnections()
            end

            return connection
        end

        function Signal:Once(callback, options)
            options = options or {}
            options.Once = true
            return self:Connect(callback, options)
        end

        function Signal:Wait(timeout)
            if self._destroyed then
                return nil
            end

            timeout = timeout or 30

            local thread = coroutine.running()
            local result = nil
            local timedOut = false

            -- Create waiting entry
            local waitEntry = {
                Thread = thread,
                StartTime = os.clock(),
                Timeout = timeout
            }

            table.insert(self._waitingThreads, waitEntry)

            -- Set up timeout
            local timeoutThread = task.delay(timeout, function()
                timedOut = true

                -- Remove from waiting threads
                for i, entry in ipairs(self._waitingThreads) do
                    if entry == waitEntry then
                        table.remove(self._waitingThreads, i)
                        break
                    end
                end

                -- Resume with nil
                if coroutine.status(thread) == "suspended" then
                    task.spawn(thread)
                end
            end)

            -- Wait for signal
            result = {coroutine.yield()}

            -- Cancel timeout if not timed out
            if not timedOut then
                task.cancel(timeoutThread)
            end

            if timedOut then
                return nil
            end

            return unpack(result)
        end

        function Signal:Fire(...)
            if self._destroyed then
                return
            end

            -- Prevent recursive firing issues
            if self._firing then
                task.defer(function()
                    self:Fire(...)
                end)
                return
            end

            self._firing = true
            self._fireCount = self._fireCount + 1
            self._lastFireTime = os.clock()

            -- Process middleware
            local args = {...}
            for _, middleware in ipairs(self._middleware) do
                local success, result = pcall(middleware, unpack(args))
                if success and result ~= nil then
                    if type(result) == "table" then
                        args = result
                    else
                        args = {result}
                    end
                end
            end

            -- Fire to all connections
            local connectionsToFire = {}
            for _, connection in ipairs(self._connections) do
                table.insert(connectionsToFire, connection)
            end

            for _, connection in ipairs(connectionsToFire) do
                connection:_fire(unpack(args))
            end

            -- Resume waiting threads
            local threadsToResume = {}
            for _, entry in ipairs(self._waitingThreads) do
                table.insert(threadsToResume, entry)
            end
            self._waitingThreads = {}

            for _, entry in ipairs(threadsToResume) do
                if coroutine.status(entry.Thread) == "suspended" then
                    task.spawn(entry.Thread, unpack(args))
                end
            end

            self._firing = false
        end

        function Signal:FireDeferred(...)
            task.defer(function(...)
                self:Fire(...)
            end, ...)
        end

        function Signal:FireDelayed(delay, ...)
            local args = {...}
            task.delay(delay, function()
                self:Fire(unpack(args))
            end)
        end

        function Signal:DisconnectAll()
            local connections = self._connections
            self._connections = {}
            self._connectionCount = 0

            for _, connection in ipairs(connections) do
                connection._connected = false
                connection._signal = nil
                connection._callback = nil
            end
        end

        function Signal:GetConnectionCount()
            return self._connectionCount
        end

        function Signal:GetFireCount()
            return self._fireCount
        end

        function Signal:GetLastFireTime()
            return self._lastFireTime
        end

        function Signal:GetName()
            return self._name
        end

        function Signal:IsDestroyed()
            return self._destroyed
        end

        function Signal:AddMiddleware(middleware)
            if type(middleware) ~= "function" then
                warn("[NexusUI.Signal] Middleware must be a function")
                return
            end

            table.insert(self._middleware, middleware)
        end

        function Signal:RemoveMiddleware(middleware)
            for i, mw in ipairs(self._middleware) do
                if mw == middleware then
                    table.remove(self._middleware, i)
                    return true
                end
            end
            return false
        end

        function Signal:ClearMiddleware()
            self._middleware = {}
        end

        function Signal:_removeConnection(connection)
            for i, conn in ipairs(self._connections) do
                if conn == connection then
                    table.remove(self._connections, i)
                    self._connectionCount = self._connectionCount - 1
                    break
                end
            end
        end

        function Signal:_sortConnections()
            table.sort(self._connections, function(a, b)
                return a:GetPriority() > b:GetPriority()
            end)
        end

        function Signal:Destroy()
            if self._destroyed then
                return
            end

            self._destroyed = true

            -- Disconnect all connections
            self:DisconnectAll()

            -- Clear waiting threads
            for _, entry in ipairs(self._waitingThreads) do
                if coroutine.status(entry.Thread) == "suspended" then
                    task.spawn(entry.Thread)
                end
            end
            self._waitingThreads = {}

            -- Clear middleware
            self._middleware = {}

            -- Return to pool if space available
            if #SignalPool < MaxPoolSize then
                table.insert(SignalPool, self)
            end
        end

        --// Signal Manager (for managing multiple signals)
        local SignalManager = {}
        SignalManager.__index = SignalManager

        function SignalManager.new()
            local self = setmetatable({}, SignalManager)

            self._signals = {}

            return self
        end

        function SignalManager:CreateSignal(name)
            if self._signals[name] then
                warn(string.format("[NexusUI.SignalManager] Signal '%s' already exists", name))
                return self._signals[name]
            end

            local signal = Signal.new(name)
            self._signals[name] = signal

            return signal
        end

        function SignalManager:GetSignal(name)
            return self._signals[name]
        end

        function SignalManager:RemoveSignal(name)
            local signal = self._signals[name]
            if signal then
                signal:Destroy()
                self._signals[name] = nil
                return true
            end
            return false
        end

        function SignalManager:GetAllSignals()
            local signals = {}
            for name, signal in pairs(self._signals) do
                signals[name] = signal
            end
            return signals
        end

        function SignalManager:GetSignalNames()
            local names = {}
            for name, _ in pairs(self._signals) do
                table.insert(names, name)
            end
            return names
        end

        function SignalManager:GetSignalCount()
            local count = 0
            for _ in pairs(self._signals) do
                count = count + 1
            end
            return count
        end

        function SignalManager:DestroyAll()
            for _, signal in pairs(self._signals) do
                signal:Destroy()
            end
            self._signals = {}
        end

        --// Export
        Signal.Connection = Connection
        Signal.Manager = SignalManager

        return Signal


    end


    -- ============================================================================
    -- Module: NexusUI/Core/Maid
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/Maid"] = function()
        local script = CreateMockScript("NexusUI/Core/Maid")

        --[[
            NexusUI Maid Class
            Resource cleanup and lifecycle management utility

            Features:
            - Automatic cleanup of connections, instances, and functions
            - Nested maid support
            - Task scheduling with cleanup
            - Thread management
            - Promise cleanup
            - Memory leak prevention
            - Debug tracking
        ]]

        --// Maid Class
        local Maid = {}
        Maid.__index = Maid
        Maid.ClassName = "Maid"

        --// Debug Configuration
        local DEBUG_MODE = false
        local TRACK_TASKS = false
        local MAX_TASKS_WARNING = 1000

        --// Task Types
        local TaskType = {
            Connection = "Connection",
            Instance = "Instance",
            Function = "Function",
            Thread = "Thread",
            Promise = "Promise",
            Maid = "Maid",
            Signal = "Signal",
            Table = "Table",
            Unknown = "Unknown"
        }

        --// Utility Functions
        local function GetTaskType(task)
            if task == nil then
                return TaskType.Unknown
            end

            local taskType = typeof(task)

            if taskType == "RBXScriptConnection" then
                return TaskType.Connection
            elseif taskType == "Instance" then
                return TaskType.Instance
            elseif taskType == "function" then
                return TaskType.Function
            elseif taskType == "thread" then
                return TaskType.Thread
            elseif taskType == "table" then
                -- Check for specific table types
                if task.Destroy then
                    if task.ClassName == "Maid" then
                        return TaskType.Maid
                    elseif task._connections or task.Fire then
                        return TaskType.Signal
                    end
                    return TaskType.Instance
                elseif task.Disconnect then
                    return TaskType.Connection
                elseif task.cancel or task.Cancel or task.andThen then
                    return TaskType.Promise
                end
                return TaskType.Table
            end

            return TaskType.Unknown
        end

        local function CleanupTask(task, taskType)
            taskType = taskType or GetTaskType(task)

            local success, err = pcall(function()
                if taskType == TaskType.Connection then
                    if task.Disconnect then
                        task:Disconnect()
                    elseif task.disconnect then
                        task:disconnect()
                    end
                elseif taskType == TaskType.Instance then
                    if task.Destroy then
                        task:Destroy()
                    end
                elseif taskType == TaskType.Function then
                    task()
                elseif taskType == TaskType.Thread then
                    if coroutine.status(task) ~= "dead" then
                        task.cancel(task)
                    end
                elseif taskType == TaskType.Promise then
                    if task.cancel then
                        task:cancel()
                    elseif task.Cancel then
                        task:Cancel()
                    end
                elseif taskType == TaskType.Maid then
                    task:Destroy()
                elseif taskType == TaskType.Signal then
                    if task.Destroy then
                        task:Destroy()
                    elseif task.DisconnectAll then
                        task:DisconnectAll()
                    end
                elseif taskType == TaskType.Table then
                    if task.Destroy then
                        task:Destroy()
                    elseif task.Disconnect then
                        task:Disconnect()
                    elseif task.destroy then
                        task:destroy()
                    end
                end
            end)

            if not success and DEBUG_MODE then
                warn(string.format("[NexusUI.Maid] Failed to cleanup task (%s): %s", taskType, tostring(err)))
            end

            return success
        end

        --// Constructor
        function Maid.new(name)
            local self = setmetatable({}, Maid)

            self._name = name or "Maid"
            self._tasks = {}
            self._taskCount = 0
            self._destroyed = false
            self._locked = false

            -- Debug tracking
            if TRACK_TASKS then
                self._taskHistory = {}
                self._cleanupHistory = {}
            end

            return self
        end

        --// Static Methods
        function Maid.IsMaid(value)
            return type(value) == "table" and value.ClassName == "Maid"
        end

        --// Task Management
        function Maid:GiveTask(task, key)
            if self._destroyed then
                -- Immediately cleanup if maid is destroyed
                CleanupTask(task)
                return nil
            end

            if self._locked then
                warn("[NexusUI.Maid] Cannot add tasks while maid is locked")
                return nil
            end

            if task == nil then
                return nil
            end

            -- Generate key if not provided
            if key == nil then
                self._taskCount = self._taskCount + 1
                key = self._taskCount
            end

            -- Cleanup existing task with same key
            local existingTask = self._tasks[key]
            if existingTask then
                CleanupTask(existingTask)
            end

            -- Store task
            self._tasks[key] = task

            -- Track task if enabled
            if TRACK_TASKS then
                table.insert(self._taskHistory, {
                    Key = key,
                    Type = GetTaskType(task),
                    AddedAt = os.clock()
                })
            end

            -- Warning for too many tasks
            if self._taskCount > MAX_TASKS_WARNING and DEBUG_MODE then
                warn(string.format("[NexusUI.Maid] '%s' has %d tasks, consider cleanup", self._name, self._taskCount))
            end

            return key
        end

        function Maid:Give(...)
            local keys = {}
            for _, task in ipairs({...}) do
                local key = self:GiveTask(task)
                table.insert(keys, key)
            end
            return unpack(keys)
        end

        function Maid:__index(key)
            if Maid[key] then
                return Maid[key]
            end
            return self._tasks[key]
        end

        function Maid:__newindex(key, value)
            if Maid[key] then
                rawset(self, key, value)
                return
            end

            if value == nil then
                -- Remove and cleanup task
                local task = self._tasks[key]
                if task then
                    CleanupTask(task)
                    self._tasks[key] = nil
                end
            else
                self:GiveTask(value, key)
            end
        end

        function Maid:RemoveTask(key)
            local task = self._tasks[key]

            if task then
                CleanupTask(task)
                self._tasks[key] = nil

                if TRACK_TASKS then
                    table.insert(self._cleanupHistory, {
                        Key = key,
                        CleanedAt = os.clock()
                    })
                end

                return true
            end

            return false
        end

        function Maid:GetTask(key)
            return self._tasks[key]
        end

        function Maid:HasTask(key)
            return self._tasks[key] ~= nil
        end

        function Maid:GetTaskCount()
            local count = 0
            for _ in pairs(self._tasks) do
                count = count + 1
            end
            return count
        end

        function Maid:GetTaskKeys()
            local keys = {}
            for key, _ in pairs(self._tasks) do
                table.insert(keys, key)
            end
            return keys
        end

        --// Connection Shortcuts
        function Maid:Connect(signal, callback)
            if not signal or not signal.Connect then
                warn("[NexusUI.Maid] Invalid signal passed to Connect")
                return nil
            end

            local connection = signal:Connect(callback)
            return self:GiveTask(connection)
        end

        function Maid:Once(signal, callback)
            if not signal or not signal.Once then
                warn("[NexusUI.Maid] Invalid signal passed to Once")
                return nil
            end

            local connection = signal:Once(callback)
            return self:GiveTask(connection)
        end

        function Maid:BindToRenderStep(name, priority, callback)
            local RunService = game:GetService("RunService")
            RunService:BindToRenderStep(name, priority, callback)

            return self:GiveTask(function()
                RunService:UnbindFromRenderStep(name)
            end)
        end

        --// Thread Management
        function Maid:Spawn(callback, ...)
            local thread = task.spawn(callback, ...)
            return self:GiveTask(thread)
        end

        function Maid:Defer(callback, ...)
            local thread = task.defer(callback, ...)
            return self:GiveTask(thread)
        end

        function Maid:Delay(duration, callback, ...)
            local args = {...}
            local cancelled = false

            local thread = task.delay(duration, function()
                if not cancelled then
                    callback(unpack(args))
                end
            end)

            return self:GiveTask(function()
                cancelled = true
                task.cancel(thread)
            end)
        end

        function Maid:Wait(duration)
            local thread = coroutine.running()

            self:Delay(duration, function()
                if coroutine.status(thread) == "suspended" then
                    task.spawn(thread)
                end
            end)

            coroutine.yield()
        end

        --// Instance Shortcuts
        function Maid:WrapInstance(instance)
            if not instance or not instance:IsA("Instance") then
                warn("[NexusUI.Maid] Invalid instance passed to WrapInstance")
                return nil
            end

            -- Add the instance for cleanup
            local key = self:GiveTask(instance)

            -- Also cleanup when instance is destroyed externally
            local connection = instance.Destroying:Connect(function()
                self._tasks[key] = nil
            end)
            self:GiveTask(connection)

            return key
        end

        --// Nested Maid
        function Maid:CreateSubMaid(name)
            name = name or self._name .. ".SubMaid"
            local subMaid = Maid.new(name)
            self:GiveTask(subMaid)
            return subMaid
        end

        --// Locking
        function Maid:Lock()
            self._locked = true
        end

        function Maid:Unlock()
            self._locked = false
        end

        function Maid:IsLocked()
            return self._locked
        end

        --// Cleanup
        function Maid:Clean()
            self:DoCleaning()
        end

        function Maid:DoCleaning()
            if self._destroyed then
                return
            end

            local tasks = self._tasks
            self._tasks = {}
            self._taskCount = 0

            -- Cleanup all tasks
            for key, task in pairs(tasks) do
                CleanupTask(task)

                if TRACK_TASKS then
                    table.insert(self._cleanupHistory, {
                        Key = key,
                        CleanedAt = os.clock()
                    })
                end
            end
        end

        function Maid:Destroy()
            if self._destroyed then
                return
            end

            self._destroyed = true
            self:DoCleaning()
        end

        function Maid:IsDestroyed()
            return self._destroyed
        end

        --// Debug Methods
        function Maid:GetName()
            return self._name
        end

        function Maid:SetName(name)
            self._name = name
        end

        function Maid:GetTaskHistory()
            return self._taskHistory or {}
        end

        function Maid:GetCleanupHistory()
            return self._cleanupHistory or {}
        end

        function Maid:PrintTasks()
            print(string.format("=== Maid '%s' Tasks ===", self._name))

            for key, task in pairs(self._tasks) do
                local taskType = GetTaskType(task)
                print(string.format("  [%s] %s: %s", tostring(key), taskType, tostring(task)))
            end

            print(string.format("Total: %d tasks", self:GetTaskCount()))
        end

        --// Metamethods
        function Maid:__tostring()
            return string.format("Maid<%s>(%d tasks)", self._name, self:GetTaskCount())
        end

        --// Enable debug mode
        function Maid.EnableDebug(enabled)
            DEBUG_MODE = enabled
        end

        function Maid.EnableTaskTracking(enabled)
            TRACK_TASKS = enabled
        end

        function Maid.SetMaxTasksWarning(count)
            MAX_TASKS_WARNING = count
        end

        return Maid


    end


    -- ============================================================================
    -- Module: NexusUI/Core/Promise
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/Promise"] = function()
        local script = CreateMockScript("NexusUI/Core/Promise")

        --[[
            NexusUI Promise Implementation
            A robust Promise/A+ compliant promise library

            Features:
            - Promise/A+ compliance
            - Chaining with then/catch/finally
            - Promise.all, Promise.race, Promise.allSettled
            - Timeout support
            - Retry functionality
            - Cancellation support
            - Progress tracking
            - Error handling and stack traces
        ]]

        --// Promise States
        local PromiseState = {
            Pending = "Pending",
            Fulfilled = "Fulfilled",
            Rejected = "Rejected",
            Cancelled = "Cancelled"
        }

        --// Promise Class
        local Promise = {}
        Promise.__index = Promise
        Promise.ClassName = "Promise"
        Promise.State = PromiseState

        --// Configuration
        local Config = {
            DebugMode = false,
            UnhandledRejectionWarning = true,
            DefaultTimeout = 30,
        }

        --// Utility Functions
        local function IsPromise(value)
            return type(value) == "table" and value.ClassName == "Promise"
        end

        local function IsThenable(value)
            return type(value) == "table" and type(value.andThen) == "function"
        end

        local function Pack(...)
            return {n = select("#", ...), ...}
        end

        local function Unpack(packed)
            return unpack(packed, 1, packed.n)
        end

        --// Constructor
        function Promise.new(executor)
            local self = setmetatable({}, Promise)

            self._state = PromiseState.Pending
            self._value = nil
            self._reason = nil
            self._onFulfilled = {}
            self._onRejected = {}
            self._onFinally = {}
            self._onProgress = {}
            self._cancelled = false
            self._cancellationCallbacks = {}
            self._parent = nil
            self._children = {}

            -- Execute the executor
            if executor then
                local function resolve(value)
                    self:_resolve(value)
                end

                local function reject(reason)
                    self:_reject(reason)
                end

                local function onCancel(callback)
                    if self._cancelled then
                        callback()
                    else
                        table.insert(self._cancellationCallbacks, callback)
                    end
                end

                local function progress(value)
                    self:_progress(value)
                end

                task.spawn(function()
                    local success, err = pcall(executor, resolve, reject, onCancel, progress)

                    if not success then
                        self:_reject(err)
                    end
                end)
            end

            return self
        end

        --// Static Constructors
        function Promise.resolve(value)
            return Promise.new(function(resolve)
                resolve(value)
            end)
        end

        function Promise.reject(reason)
            return Promise.new(function(_, reject)
                reject(reason)
            end)
        end

        function Promise.try(callback, ...)
            local args = Pack(...)

            return Promise.new(function(resolve, reject)
                local success, result = pcall(callback, Unpack(args))

                if success then
                    resolve(result)
                else
                    reject(result)
                end
            end)
        end

        function Promise.defer()
            local resolve, reject
            local promise = Promise.new(function(res, rej)
                resolve = res
                reject = rej
            end)

            return promise, resolve, reject
        end

        --// Combinators
        function Promise.all(promises)
            return Promise.new(function(resolve, reject, onCancel)
                local results = {}
                local remaining = #promises
                local rejected = false

                if remaining == 0 then
                    resolve(results)
                    return
                end

                onCancel(function()
                    for _, promise in ipairs(promises) do
                        if IsPromise(promise) and promise:IsPending() then
                            promise:Cancel()
                        end
                    end
                end)

                for i, promise in ipairs(promises) do
                    if not IsPromise(promise) then
                        promise = Promise.resolve(promise)
                    end

                    promise:andThen(function(value)
                        if rejected then return end

                        results[i] = value
                        remaining = remaining - 1

                        if remaining == 0 then
                            resolve(results)
                        end
                    end):catch(function(reason)
                        if rejected then return end

                        rejected = true
                        reject(reason)
                    end)
                end
            end)
        end

        function Promise.allSettled(promises)
            return Promise.new(function(resolve)
                local results = {}
                local remaining = #promises

                if remaining == 0 then
                    resolve(results)
                    return
                end

                for i, promise in ipairs(promises) do
                    if not IsPromise(promise) then
                        promise = Promise.resolve(promise)
                    end

                    promise:andThen(function(value)
                        results[i] = { status = "fulfilled", value = value }
                        remaining = remaining - 1

                        if remaining == 0 then
                            resolve(results)
                        end
                    end):catch(function(reason)
                        results[i] = { status = "rejected", reason = reason }
                        remaining = remaining - 1

                        if remaining == 0 then
                            resolve(results)
                        end
                    end)
                end
            end)
        end

        function Promise.race(promises)
            return Promise.new(function(resolve, reject, onCancel)
                local settled = false

                onCancel(function()
                    for _, promise in ipairs(promises) do
                        if IsPromise(promise) and promise:IsPending() then
                            promise:Cancel()
                        end
                    end
                end)

                for _, promise in ipairs(promises) do
                    if not IsPromise(promise) then
                        promise = Promise.resolve(promise)
                    end

                    promise:andThen(function(value)
                        if settled then return end
                        settled = true
                        resolve(value)
                    end):catch(function(reason)
                        if settled then return end
                        settled = true
                        reject(reason)
                    end)
                end
            end)
        end

        function Promise.any(promises)
            return Promise.new(function(resolve, reject, onCancel)
                local errors = {}
                local remaining = #promises
                local resolved = false

                if remaining == 0 then
                    reject("No promises provided")
                    return
                end

                onCancel(function()
                    for _, promise in ipairs(promises) do
                        if IsPromise(promise) and promise:IsPending() then
                            promise:Cancel()
                        end
                    end
                end)

                for i, promise in ipairs(promises) do
                    if not IsPromise(promise) then
                        promise = Promise.resolve(promise)
                    end

                    promise:andThen(function(value)
                        if resolved then return end
                        resolved = true
                        resolve(value)
                    end):catch(function(reason)
                        if resolved then return end

                        errors[i] = reason
                        remaining = remaining - 1

                        if remaining == 0 then
                            reject(errors)
                        end
                    end)
                end
            end)
        end

        function Promise.delay(seconds, value)
            return Promise.new(function(resolve, _, onCancel)
                local thread = task.delay(seconds, function()
                    resolve(value)
                end)

                onCancel(function()
                    task.cancel(thread)
                end)
            end)
        end

        function Promise.fromEvent(event, predicate)
            return Promise.new(function(resolve, _, onCancel)
                local connection

                connection = event:Connect(function(...)
                    if predicate then
                        local success, result = pcall(predicate, ...)
                        if not success or not result then
                            return
                        end
                    end

                    if connection then
                        connection:Disconnect()
                    end

                    resolve(...)
                end)

                onCancel(function()
                    if connection then
                        connection:Disconnect()
                    end
                end)
            end)
        end

        function Promise.retry(callback, maxAttempts, delay)
            maxAttempts = maxAttempts or 3
            delay = delay or 1

            return Promise.new(function(resolve, reject)
                local attempts = 0
                local lastError

                local function attempt()
                    attempts = attempts + 1

                    Promise.try(callback):andThen(function(value)
                        resolve(value)
                    end):catch(function(reason)
                        lastError = reason

                        if attempts < maxAttempts then
                            task.delay(delay, attempt)
                        else
                            reject(lastError)
                        end
                    end)
                end

                attempt()
            end)
        end

        --// Instance Methods
        function Promise:_resolve(value)
            if self._state ~= PromiseState.Pending then
                return
            end

            -- Handle promise resolution
            if value == self then
                self:_reject("Cannot resolve promise with itself")
                return
            end

            if IsPromise(value) then
                value:andThen(function(v)
                    self:_resolve(v)
                end):catch(function(r)
                    self:_reject(r)
                end)
                return
            end

            if IsThenable(value) then
                local called = false

                local success, err = pcall(function()
                    value:andThen(function(v)
                        if called then return end
                        called = true
                        self:_resolve(v)
                    end, function(r)
                        if called then return end
                        called = true
                        self:_reject(r)
                    end)
                end)

                if not success and not called then
                    self:_reject(err)
                end
                return
            end

            self._state = PromiseState.Fulfilled
            self._value = value

            -- Execute fulfilled callbacks
            for _, callback in ipairs(self._onFulfilled) do
                task.spawn(callback, value)
            end

            -- Execute finally callbacks
            for _, callback in ipairs(self._onFinally) do
                task.spawn(callback)
            end

            -- Clear callbacks
            self._onFulfilled = {}
            self._onRejected = {}
            self._onFinally = {}
        end

        function Promise:_reject(reason)
            if self._state ~= PromiseState.Pending then
                return
            end

            self._state = PromiseState.Rejected
            self._reason = reason

            -- Warning for unhandled rejections
            if Config.UnhandledRejectionWarning and #self._onRejected == 0 then
                task.defer(function()
                    if #self._onRejected == 0 then
                        warn("[NexusUI.Promise] Unhandled rejection:", tostring(reason))
                    end
                end)
            end

            -- Execute rejected callbacks
            for _, callback in ipairs(self._onRejected) do
                task.spawn(callback, reason)
            end

            -- Execute finally callbacks
            for _, callback in ipairs(self._onFinally) do
                task.spawn(callback)
            end

            -- Clear callbacks
            self._onFulfilled = {}
            self._onRejected = {}
            self._onFinally = {}
        end

        function Promise:_progress(value)
            for _, callback in ipairs(self._onProgress) do
                task.spawn(callback, value)
            end
        end

        function Promise:andThen(onFulfilled, onRejected)
            local child = Promise.new()
            child._parent = self
            table.insert(self._children, child)

            local function handleFulfilled(value)
                if type(onFulfilled) == "function" then
                    local success, result = pcall(onFulfilled, value)
                    if success then
                        child:_resolve(result)
                    else
                        child:_reject(result)
                    end
                else
                    child:_resolve(value)
                end
            end

            local function handleRejected(reason)
                if type(onRejected) == "function" then
                    local success, result = pcall(onRejected, reason)
                    if success then
                        child:_resolve(result)
                    else
                        child:_reject(result)
                    end
                else
                    child:_reject(reason)
                end
            end

            if self._state == PromiseState.Pending then
                table.insert(self._onFulfilled, handleFulfilled)
                table.insert(self._onRejected, handleRejected)
            elseif self._state == PromiseState.Fulfilled then
                task.spawn(handleFulfilled, self._value)
            elseif self._state == PromiseState.Rejected then
                task.spawn(handleRejected, self._reason)
            end

            return child
        end

        function Promise:catch(onRejected)
            return self:andThen(nil, onRejected)
        end

        function Promise:finally(callback)
            local child = Promise.new()

            local function handleFinally()
                local success, result = pcall(callback)

                if not success then
                    child:_reject(result)
                    return
                end

                if self._state == PromiseState.Fulfilled then
                    child:_resolve(self._value)
                else
                    child:_reject(self._reason)
                end
            end

            if self._state == PromiseState.Pending then
                table.insert(self._onFinally, handleFinally)
            else
                task.spawn(handleFinally)
            end

            return child
        end

        function Promise:progress(callback)
            if type(callback) == "function" then
                table.insert(self._onProgress, callback)
            end
            return self
        end

        function Promise:timeout(seconds, timeoutValue)
            return Promise.race({
                self,
                Promise.delay(seconds):andThen(function()
                    if timeoutValue ~= nil then
                        return timeoutValue
                    end
                    error("Promise timed out after " .. seconds .. " seconds")
                end)
            })
        end

        function Promise:Cancel()
            if self._state ~= PromiseState.Pending then
                return
            end

            self._state = PromiseState.Cancelled
            self._cancelled = true

            -- Execute cancellation callbacks
            for _, callback in ipairs(self._cancellationCallbacks) do
                task.spawn(callback)
            end

            -- Cancel children
            for _, child in ipairs(self._children) do
                if child:IsPending() then
                    child:Cancel()
                end
            end

            -- Clear callbacks
            self._onFulfilled = {}
            self._onRejected = {}
            self._onFinally = {}
            self._cancellationCallbacks = {}
        end

        function Promise:Await()
            if self._state == PromiseState.Fulfilled then
                return self._value
            elseif self._state == PromiseState.Rejected then
                error(self._reason)
            elseif self._state == PromiseState.Cancelled then
                error("Promise was cancelled")
            end

            local thread = coroutine.running()

            self:andThen(function(value)
                task.spawn(thread, true, value)
            end):catch(function(reason)
                task.spawn(thread, false, reason)
            end)

            local success, result = coroutine.yield()

            if success then
                return result
            else
                error(result)
            end
        end

        function Promise:Expect()
            return self:Await()
        end

        --// State Checking
        function Promise:IsPending()
            return self._state == PromiseState.Pending
        end

        function Promise:IsFulfilled()
            return self._state == PromiseState.Fulfilled
        end

        function Promise:IsRejected()
            return self._state == PromiseState.Rejected
        end

        function Promise:IsCancelled()
            return self._state == PromiseState.Cancelled
        end

        function Promise:GetState()
            return self._state
        end

        function Promise:GetValue()
            return self._value
        end

        function Promise:GetReason()
            return self._reason
        end

        --// Utility Methods
        function Promise:Tap(callback)
            return self:andThen(function(value)
                callback(value)
                return value
            end)
        end

        function Promise:TapError(callback)
            return self:catch(function(reason)
                callback(reason)
                error(reason)
            end)
        end

        --// Debug
        function Promise:__tostring()
            if self._state == PromiseState.Fulfilled then
                return string.format("Promise<Fulfilled>(%s)", tostring(self._value))
            elseif self._state == PromiseState.Rejected then
                return string.format("Promise<Rejected>(%s)", tostring(self._reason))
            elseif self._state == PromiseState.Cancelled then
                return "Promise<Cancelled>"
            else
                return "Promise<Pending>"
            end
        end

        --// Configuration
        function Promise.SetConfig(key, value)
            if Config[key] ~= nil then
                Config[key] = value
            end
        end

        function Promise.GetConfig(key)
            return Config[key]
        end

        return Promise


    end


    -- ============================================================================
    -- Module: NexusUI/Core/EventSystem
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/EventSystem"] = function()
        local script = CreateMockScript("NexusUI/Core/EventSystem")

        --[[
            NexusUI Event System
            A comprehensive event dispatching and subscription system

            Features:
            - Named event channels
            - Priority-based event handling
            - Event filtering and transformation
            - Event history and replay
            - Wildcard subscriptions
            - Event namespacing
            - Throttling and debouncing
            - Async event handling
        ]]

        --// Dependencies
        local SignalClass = NexusRequire("NexusUI/SignalClass")
        local Maid = NexusRequire("NexusUI/Maid")

        --// Event System Class
        local EventSystem = {}
        EventSystem.__index = EventSystem
        EventSystem.ClassName = "EventSystem"

        --// Configuration
        local Config = {
            MaxHistorySize = 100,
            EnableHistory = true,
            DebugMode = false,
            WildcardCharacter = "*",
            NamespaceSeparator = ":",
            DefaultPriority = 0,
        }

        --// Singleton Instance
        local instance = nil

        --// Event Data Class
        local EventData = {}
        EventData.__index = EventData

        function EventData.new(name, data, metadata)
            local self = setmetatable({}, EventData)

            self.Name = name
            self.Data = data
            self.Metadata = metadata or {}
            self.Timestamp = os.clock()
            self.Id = tostring(os.clock()) .. "_" .. tostring(math.random(1000000))
            self.Propagating = true
            self.DefaultPrevented = false

            return self
        end

        function EventData:StopPropagation()
            self.Propagating = false
        end

        function EventData:PreventDefault()
            self.DefaultPrevented = true
        end

        function EventData:GetNamespace()
            local parts = string.split(self.Name, Config.NamespaceSeparator)
            if #parts > 1 then
                table.remove(parts, #parts)
                return table.concat(parts, Config.NamespaceSeparator)
            end
            return nil
        end

        function EventData:GetEventName()
            local parts = string.split(self.Name, Config.NamespaceSeparator)
            return parts[#parts]
        end

        --// Subscription Class
        local Subscription = {}
        Subscription.__index = Subscription

        function Subscription.new(eventName, callback, options)
            options = options or {}

            local self = setmetatable({}, Subscription)

            self.EventName = eventName
            self.Callback = callback
            self.Priority = options.Priority or Config.DefaultPriority
            self.Once = options.Once or false
            self.Filter = options.Filter or nil
            self.Transform = options.Transform or nil
            self.Throttle = options.Throttle or 0
            self.Debounce = options.Debounce or 0
            self.Async = options.Async or false
            self.Active = true
            self.Id = tostring(os.clock()) .. "_" .. tostring(math.random(1000000))

            -- Throttle/Debounce state
            self._lastCall = 0
            self._debounceScheduled = false
            self._debounceEvent = nil

            return self
        end

        function Subscription:Unsubscribe()
            self.Active = false
        end

        function Subscription:IsActive()
            return self.Active
        end

        function Subscription:CanHandle(eventData)
            if not self.Active then
                return false
            end

            -- Check filter
            if self.Filter and not self.Filter(eventData) then
                return false
            end

            return true
        end

        function Subscription:Handle(eventData)
            if not self:CanHandle(eventData) then
                return false
            end

            local now = os.clock()

            -- Throttle check
            if self.Throttle > 0 then
                if now - self._lastCall < self.Throttle then
                    return false
                end
            end

            -- Debounce handling
            if self.Debounce > 0 then
                self._debounceEvent = eventData

                if not self._debounceScheduled then
                    self._debounceScheduled = true

                    task.delay(self.Debounce, function()
                        if self.Active and self._debounceEvent then
                            self:_execute(self._debounceEvent)
                        end
                        self._debounceScheduled = false
                        self._debounceEvent = nil
                    end)
                end

                return true
            end

            -- Direct execution
            self._lastCall = now
            self:_execute(eventData)

            -- Handle once subscriptions
            if self.Once then
                self:Unsubscribe()
            end

            return true
        end

        function Subscription:_execute(eventData)
            local data = eventData.Data

            -- Apply transform
            if self.Transform then
                local success, result = pcall(self.Transform, data, eventData)
                if success then
                    data = result
                end
            end

            -- Execute callback
            local executeCallback = function()
                local success, err = pcall(self.Callback, data, eventData)

                if not success and Config.DebugMode then
                    warn(string.format("[NexusUI.EventSystem] Handler error for '%s': %s", eventData.Name, tostring(err)))
                end
            end

            if self.Async then
                task.spawn(executeCallback)
            else
                executeCallback()
            end
        end

        --// Event System Implementation
        function EventSystem.new()
            local self = setmetatable({}, EventSystem)

            self._subscriptions = {}
            self._namespaces = {}
            self._history = {}
            self._signals = {}
            self._maid = Maid.new("EventSystem")
            self._middlewares = {}
            self._interceptors = {}

            return self
        end

        function EventSystem.GetInstance()
            if not instance then
                instance = EventSystem.new()
            end
            return instance
        end

        --// Subscription Methods
        function EventSystem:Subscribe(eventName, callback, options)
            if type(eventName) ~= "string" then
                warn("[NexusUI.EventSystem] Event name must be a string")
                return nil
            end

            if type(callback) ~= "function" then
                warn("[NexusUI.EventSystem] Callback must be a function")
                return nil
            end

            local subscription = Subscription.new(eventName, callback, options)

            -- Initialize subscription list for event
            if not self._subscriptions[eventName] then
                self._subscriptions[eventName] = {}
            end

            table.insert(self._subscriptions[eventName], subscription)

            -- Sort by priority
            table.sort(self._subscriptions[eventName], function(a, b)
                return a.Priority > b.Priority
            end)

            -- Track namespace
            local namespace = EventData.new(eventName, nil):GetNamespace()
            if namespace then
                if not self._namespaces[namespace] then
                    self._namespaces[namespace] = {}
                end
                self._namespaces[namespace][eventName] = true
            end

            return subscription
        end

        function EventSystem:Once(eventName, callback, options)
            options = options or {}
            options.Once = true
            return self:Subscribe(eventName, callback, options)
        end

        function EventSystem:Unsubscribe(subscription)
            if not subscription then return end

            subscription:Unsubscribe()

            -- Remove from subscription list
            local eventName = subscription.EventName
            local subs = self._subscriptions[eventName]

            if subs then
                for i, sub in ipairs(subs) do
                    if sub == subscription then
                        table.remove(subs, i)
                        break
                    end
                end

                -- Cleanup empty subscription lists
                if #subs == 0 then
                    self._subscriptions[eventName] = nil
                end
            end
        end

        function EventSystem:UnsubscribeAll(eventName)
            if eventName then
                local subs = self._subscriptions[eventName]
                if subs then
                    for _, sub in ipairs(subs) do
                        sub:Unsubscribe()
                    end
                    self._subscriptions[eventName] = nil
                end
            else
                for name, subs in pairs(self._subscriptions) do
                    for _, sub in ipairs(subs) do
                        sub:Unsubscribe()
                    end
                end
                self._subscriptions = {}
            end
        end

        --// Dispatch Methods
        function EventSystem:Dispatch(eventName, data, metadata)
            local eventData = EventData.new(eventName, data, metadata)

            -- Run interceptors
            for _, interceptor in ipairs(self._interceptors) do
                local success, result = pcall(interceptor, eventData)
                if success and result == false then
                    return eventData -- Interceptor blocked the event
                end
            end

            -- Run middlewares
            for _, middleware in ipairs(self._middlewares) do
                local success, result = pcall(middleware, eventData)
                if success and result then
                    eventData = result
                end
            end

            -- Add to history
            if Config.EnableHistory then
                table.insert(self._history, {
                    Event = eventData,
                    Time = os.clock()
                })

                -- Trim history
                while #self._history > Config.MaxHistorySize do
                    table.remove(self._history, 1)
                end
            end

            -- Get matching subscriptions
            local matchingSubscriptions = self:_getMatchingSubscriptions(eventName)

            -- Execute subscriptions
            for _, subscription in ipairs(matchingSubscriptions) do
                if not eventData.Propagating then
                    break
                end

                subscription:Handle(eventData)
            end

            return eventData
        end

        function EventSystem:DispatchAsync(eventName, data, metadata)
            return task.spawn(function()
                return self:Dispatch(eventName, data, metadata)
            end)
        end

        function EventSystem:DispatchDeferred(eventName, data, metadata)
            task.defer(function()
                self:Dispatch(eventName, data, metadata)
            end)
        end

        function EventSystem:DispatchDelayed(delay, eventName, data, metadata)
            task.delay(delay, function()
                self:Dispatch(eventName, data, metadata)
            end)
        end

        --// Wildcard and Pattern Matching
        function EventSystem:_getMatchingSubscriptions(eventName)
            local matching = {}

            -- Exact match
            local exactSubs = self._subscriptions[eventName]
            if exactSubs then
                for _, sub in ipairs(exactSubs) do
                    if sub:IsActive() then
                        table.insert(matching, sub)
                    end
                end
            end

            -- Wildcard matches
            for pattern, subs in pairs(self._subscriptions) do
                if pattern ~= eventName and self:_matchesPattern(eventName, pattern) then
                    for _, sub in ipairs(subs) do
                        if sub:IsActive() then
                            table.insert(matching, sub)
                        end
                    end
                end
            end

            -- Sort by priority
            table.sort(matching, function(a, b)
                return a.Priority > b.Priority
            end)

            return matching
        end

        function EventSystem:_matchesPattern(eventName, pattern)
            -- Handle wildcard character
            if string.find(pattern, Config.WildcardCharacter, 1, true) then
                local escaped = pattern:gsub("([%.%+%-%^%$%(%)%%])", "%%%1")
                local regex = escaped:gsub("%*", ".*")
                return string.match(eventName, "^" .. regex .. "$") ~= nil
            end

            return false
        end

        --// Middleware and Interceptors
        function EventSystem:AddMiddleware(middleware)
            if type(middleware) ~= "function" then
                warn("[NexusUI.EventSystem] Middleware must be a function")
                return
            end

            table.insert(self._middlewares, middleware)
        end

        function EventSystem:RemoveMiddleware(middleware)
            for i, mw in ipairs(self._middlewares) do
                if mw == middleware then
                    table.remove(self._middlewares, i)
                    return true
                end
            end
            return false
        end

        function EventSystem:AddInterceptor(interceptor)
            if type(interceptor) ~= "function" then
                warn("[NexusUI.EventSystem] Interceptor must be a function")
                return
            end

            table.insert(self._interceptors, interceptor)
        end

        function EventSystem:RemoveInterceptor(interceptor)
            for i, ic in ipairs(self._interceptors) do
                if ic == interceptor then
                    table.remove(self._interceptors, i)
                    return true
                end
            end
            return false
        end

        --// History Methods
        function EventSystem:GetHistory(eventName, limit)
            limit = limit or Config.MaxHistorySize
            local history = {}

            for i = #self._history, 1, -1 do
                local entry = self._history[i]

                if not eventName or entry.Event.Name == eventName then
                    table.insert(history, entry)

                    if #history >= limit then
                        break
                    end
                end
            end

            return history
        end

        function EventSystem:ClearHistory(eventName)
            if eventName then
                local newHistory = {}
                for _, entry in ipairs(self._history) do
                    if entry.Event.Name ~= eventName then
                        table.insert(newHistory, entry)
                    end
                end
                self._history = newHistory
            else
                self._history = {}
            end
        end

        function EventSystem:ReplayHistory(eventName, limit)
            local history = self:GetHistory(eventName, limit)

            -- Replay in chronological order
            for i = #history, 1, -1 do
                local entry = history[i]
                self:Dispatch(entry.Event.Name, entry.Event.Data, entry.Event.Metadata)
            end
        end

        --// Namespace Methods
        function EventSystem:GetNamespaceEvents(namespace)
            return self._namespaces[namespace] or {}
        end

        function EventSystem:DispatchToNamespace(namespace, data, metadata)
            local events = self._namespaces[namespace]

            if events then
                for eventName, _ in pairs(events) do
                    self:Dispatch(eventName, data, metadata)
                end
            end
        end

        function EventSystem:UnsubscribeNamespace(namespace)
            local events = self._namespaces[namespace]

            if events then
                for eventName, _ in pairs(events) do
                    self:UnsubscribeAll(eventName)
                end
                self._namespaces[namespace] = nil
            end
        end

        --// Signal Bridge
        function EventSystem:GetSignal(eventName)
            if not self._signals[eventName] then
                self._signals[eventName] = SignalClass.new(eventName)

                -- Bridge signal to event system
                self:Subscribe(eventName, function(data)
                    self._signals[eventName]:Fire(data)
                end)
            end

            return self._signals[eventName]
        end

        --// Wait Methods
        function EventSystem:Wait(eventName, timeout, predicate)
            timeout = timeout or 30

            local thread = coroutine.running()
            local result = nil
            local timedOut = false

            local subscription = self:Once(eventName, function(data, eventData)
                if predicate then
                    if not predicate(data, eventData) then
                        return
                    end
                end

                result = { Data = data, Event = eventData }

                if coroutine.status(thread) == "suspended" then
                    task.spawn(thread)
                end
            end)

            local timeoutThread = task.delay(timeout, function()
                timedOut = true
                subscription:Unsubscribe()

                if coroutine.status(thread) == "suspended" then
                    task.spawn(thread)
                end
            end)

            coroutine.yield()

            if not timedOut then
                task.cancel(timeoutThread)
            end

            if timedOut then
                return nil
            end

            return result
        end

        --// Utility Methods
        function EventSystem:HasSubscribers(eventName)
            local subs = self._subscriptions[eventName]
            return subs and #subs > 0
        end

        function EventSystem:GetSubscriberCount(eventName)
            if eventName then
                local subs = self._subscriptions[eventName]
                return subs and #subs or 0
            else
                local count = 0
                for _, subs in pairs(self._subscriptions) do
                    count = count + #subs
                end
                return count
            end
        end

        function EventSystem:GetEventNames()
            local names = {}
            for name, _ in pairs(self._subscriptions) do
                table.insert(names, name)
            end
            return names
        end

        function EventSystem:GetNamespaces()
            local namespaces = {}
            for namespace, _ in pairs(self._namespaces) do
                table.insert(namespaces, namespace)
            end
            return namespaces
        end

        --// Configuration
        function EventSystem:SetConfig(key, value)
            if Config[key] ~= nil then
                Config[key] = value
            end
        end

        function EventSystem:GetConfig(key)
            return Config[key]
        end

        --// Cleanup
        function EventSystem:Destroy()
            self:UnsubscribeAll()

            for _, signal in pairs(self._signals) do
                signal:Destroy()
            end

            self._signals = {}
            self._history = {}
            self._middlewares = {}
            self._interceptors = {}
            self._namespaces = {}
            self._maid:Destroy()
        end

        --// Export singleton instance
        return EventSystem.GetInstance()


    end


    -- ============================================================================
    -- Module: NexusUI/Core/StateManager
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/StateManager"] = function()
        local script = CreateMockScript("NexusUI/Core/StateManager")

        --[[
            NexusUI State Manager
            Centralized state management with reactive updates

            Features:
            - Global and scoped state management
            - Reactive state watching
            - State history and undo/redo
            - State persistence
            - Computed values
            - State validation
            - Batch updates
            - State snapshots
        ]]

        --// Dependencies
        local SignalClass = NexusRequire("NexusUI/SignalClass")

        --// State Manager Class
        local StateManager = {}
        StateManager.__index = StateManager
        StateManager.ClassName = "StateManager"

        --// Configuration
        local Config = {
            EnableHistory = true,
            MaxHistorySize = 50,
            EnableValidation = true,
            DebugMode = false,
            AutoPersist = false,
            PersistKey = "NexusUI_State",
        }

        --// Singleton Instance
        local instance = nil

        --// State Change Record
        local StateChange = {}
        StateChange.__index = StateChange

        function StateChange.new(key, oldValue, newValue, timestamp)
            local self = setmetatable({}, StateChange)

            self.Key = key
            self.OldValue = oldValue
            self.NewValue = newValue
            self.Timestamp = timestamp or os.clock()

            return self
        end

        --// Computed Value Class
        local ComputedValue = {}
        ComputedValue.__index = ComputedValue

        function ComputedValue.new(dependencies, computeFunc)
            local self = setmetatable({}, ComputedValue)

            self.Dependencies = dependencies
            self.ComputeFunc = computeFunc
            self.CachedValue = nil
            self.IsDirty = true

            return self
        end

        function ComputedValue:Get(stateManager)
            if self.IsDirty then
                local values = {}
                for _, dep in ipairs(self.Dependencies) do
                    values[dep] = stateManager:Get(dep)
                end

                local success, result = pcall(self.ComputeFunc, values)
                if success then
                    self.CachedValue = result
                else
                    warn("[NexusUI.StateManager] Computed value error:", tostring(result))
                end

                self.IsDirty = false
            end

            return self.CachedValue
        end

        function ComputedValue:Invalidate()
            self.IsDirty = true
        end

        --// State Manager Implementation
        function StateManager.new()
            local self = setmetatable({}, StateManager)

            -- Core state storage
            self._state = {}
            self._defaultState = {}
            self._watchers = {}
            self._computed = {}
            self._validators = {}

            -- Signals
            self._signals = {
                StateChanged = SignalClass.new("StateChanged"),
                StateReset = SignalClass.new("StateReset"),
                BatchStart = SignalClass.new("BatchStart"),
                BatchEnd = SignalClass.new("BatchEnd"),
            }

            -- History for undo/redo
            self._history = {}
            self._historyIndex = 0
            self._batchMode = false
            self._batchChanges = {}

            -- Scoped states
            self._scopes = {}

            return self
        end

        function StateManager.GetInstance()
            if not instance then
                instance = StateManager.new()
            end
            return instance
        end

        --// Core State Operations
        function StateManager:Set(key, value, options)
            options = options or {}

            -- Validation
            if Config.EnableValidation and self._validators[key] then
                local isValid, errorMsg = self._validators[key](value)
                if not isValid then
                    warn(string.format("[NexusUI.StateManager] Validation failed for '%s': %s", key, errorMsg or "Invalid value"))
                    return false
                end
            end

            local oldValue = self._state[key]

            -- Skip if value hasn't changed
            if not options.Force and self:_deepEqual(oldValue, value) then
                return false
            end

            -- Store old value for history
            if Config.EnableHistory and not self._batchMode then
                self:_recordChange(key, oldValue, value)
            end

            -- Update state
            self._state[key] = value

            -- Invalidate computed values
            self:_invalidateComputed(key)

            -- Notify watchers
            if not options.Silent then
                self:_notifyWatchers(key, value, oldValue)
                self._signals.StateChanged:Fire(key, value, oldValue)
            end

            -- Batch collection
            if self._batchMode then
                table.insert(self._batchChanges, StateChange.new(key, oldValue, value))
            end

            -- Auto persist
            if Config.AutoPersist then
                self:Persist()
            end

            return true
        end

        function StateManager:Get(key, defaultValue)
            -- Check for computed value
            if self._computed[key] then
                return self._computed[key]:Get(self)
            end

            local value = self._state[key]

            if value == nil then
                return defaultValue or self._defaultState[key]
            end

            return value
        end

        function StateManager:Has(key)
            return self._state[key] ~= nil
        end

        function StateManager:Delete(key, options)
            options = options or {}

            if not self:Has(key) then
                return false
            end

            local oldValue = self._state[key]

            if Config.EnableHistory and not self._batchMode then
                self:_recordChange(key, oldValue, nil)
            end

            self._state[key] = nil

            if not options.Silent then
                self:_notifyWatchers(key, nil, oldValue)
                self._signals.StateChanged:Fire(key, nil, oldValue)
            end

            return true
        end

        function StateManager:SetMultiple(values, options)
            for key, value in pairs(values) do
                self:Set(key, value, options)
            end
        end

        function StateManager:GetMultiple(keys)
            local values = {}
            for _, key in ipairs(keys) do
                values[key] = self:Get(key)
            end
            return values
        end

        function StateManager:GetAll()
            local copy = {}
            for key, value in pairs(self._state) do
                copy[key] = self:_deepCopy(value)
            end
            return copy
        end

        function StateManager:Clear(options)
            options = options or {}

            local oldState = self:GetAll()
            self._state = {}

            if not options.Silent then
                for key, oldValue in pairs(oldState) do
                    self:_notifyWatchers(key, nil, oldValue)
                end
                self._signals.StateReset:Fire()
            end
        end

        --// Watching State Changes
        function StateManager:Watch(key, callback, options)
            options = options or {}

            if not self._watchers[key] then
                self._watchers[key] = {}
            end

            local watcher = {
                Callback = callback,
                Priority = options.Priority or 0,
                Once = options.Once or false,
                Filter = options.Filter or nil,
                Active = true,
                Id = tostring(os.clock()) .. "_" .. tostring(math.random(1000000))
            }

            table.insert(self._watchers[key], watcher)

            -- Sort by priority
            table.sort(self._watchers[key], function(a, b)
                return a.Priority > b.Priority
            end)

            -- Fire immediately with current value if requested
            if options.Immediate and self:Has(key) then
                callback(self:Get(key), nil)
            end

            -- Return unwatch function
            return function()
                watcher.Active = false

                local watchers = self._watchers[key]
                if watchers then
                    for i, w in ipairs(watchers) do
                        if w == watcher then
                            table.remove(watchers, i)
                            break
                        end
                    end
                end
            end
        end

        function StateManager:WatchMultiple(keys, callback, options)
            options = options or {}

            local unwatchers = {}

            local function onAnyChange()
                local values = self:GetMultiple(keys)
                callback(values)
            end

            for _, key in ipairs(keys) do
                local unwatch = self:Watch(key, onAnyChange, {
                    Priority = options.Priority
                })
                table.insert(unwatchers, unwatch)
            end

            -- Fire immediately if requested
            if options.Immediate then
                onAnyChange()
            end

            -- Return combined unwatch function
            return function()
                for _, unwatch in ipairs(unwatchers) do
                    unwatch()
                end
            end
        end

        function StateManager:_notifyWatchers(key, newValue, oldValue)
            local watchers = self._watchers[key]
            if not watchers then return end

            local toRemove = {}

            for i, watcher in ipairs(watchers) do
                if watcher.Active then
                    -- Check filter
                    if watcher.Filter then
                        local pass, err = pcall(watcher.Filter, newValue, oldValue)
                        if not pass or not err then
                            continue
                        end
                    end

                    -- Execute callback
                    local success, err = pcall(watcher.Callback, newValue, oldValue)

                    if not success and Config.DebugMode then
                        warn(string.format("[NexusUI.StateManager] Watcher error for '%s': %s", key, tostring(err)))
                    end

                    -- Handle once watchers
                    if watcher.Once then
                        table.insert(toRemove, i)
                    end
                end
            end

            -- Remove once watchers
            for i = #toRemove, 1, -1 do
                table.remove(watchers, toRemove[i])
            end
        end

        --// Computed Values
        function StateManager:Computed(name, dependencies, computeFunc)
            local computed = ComputedValue.new(dependencies, computeFunc)
            self._computed[name] = computed

            -- Watch dependencies to invalidate computed value
            for _, dep in ipairs(dependencies) do
                self:Watch(dep, function()
                    computed:Invalidate()
                end)
            end

            return computed
        end

        function StateManager:_invalidateComputed(changedKey)
            for _, computed in pairs(self._computed) do
                for _, dep in ipairs(computed.Dependencies) do
                    if dep == changedKey then
                        computed:Invalidate()
                        break
                    end
                end
            end
        end

        --// Validators
        function StateManager:SetValidator(key, validator)
            self._validators[key] = validator
        end

        function StateManager:RemoveValidator(key)
            self._validators[key] = nil
        end

        function StateManager:Validate(key, value)
            local validator = self._validators[key]
            if validator then
                return validator(value)
            end
            return true
        end

        --// Default Values
        function StateManager:SetDefault(key, value)
            self._defaultState[key] = value
        end

        function StateManager:SetDefaults(defaults)
            for key, value in pairs(defaults) do
                self._defaultState[key] = value
            end
        end

        function StateManager:ResetToDefaults(keys)
            if keys then
                for _, key in ipairs(keys) do
                    local defaultValue = self._defaultState[key]
                    if defaultValue ~= nil then
                        self:Set(key, self:_deepCopy(defaultValue))
                    else
                        self:Delete(key)
                    end
                end
            else
                self._state = self:_deepCopy(self._defaultState)
                self._signals.StateReset:Fire()
            end
        end

        --// Batch Updates
        function StateManager:BeginBatch()
            if self._batchMode then
                warn("[NexusUI.StateManager] Already in batch mode")
                return
            end

            self._batchMode = true
            self._batchChanges = {}
            self._signals.BatchStart:Fire()
        end

        function StateManager:EndBatch()
            if not self._batchMode then
                warn("[NexusUI.StateManager] Not in batch mode")
                return
            end

            self._batchMode = false

            -- Record batch to history
            if Config.EnableHistory and #self._batchChanges > 0 then
                self:_recordBatch(self._batchChanges)
            end

            self._batchChanges = {}
            self._signals.BatchEnd:Fire()
        end

        function StateManager:Batch(callback)
            self:BeginBatch()

            local success, err = pcall(callback)

            self:EndBatch()

            if not success then
                warn("[NexusUI.StateManager] Batch error:", tostring(err))
            end
        end

        --// History and Undo/Redo
        function StateManager:_recordChange(key, oldValue, newValue)
            -- Remove any redo history
            while #self._history > self._historyIndex do
                table.remove(self._history)
            end

            -- Add new change
            table.insert(self._history, {
                Type = "single",
                Changes = { StateChange.new(key, oldValue, newValue) }
            })
            self._historyIndex = #self._history

            -- Trim history
            while #self._history > Config.MaxHistorySize do
                table.remove(self._history, 1)
                self._historyIndex = self._historyIndex - 1
            end
        end

        function StateManager:_recordBatch(changes)
            while #self._history > self._historyIndex do
                table.remove(self._history)
            end

            table.insert(self._history, {
                Type = "batch",
                Changes = changes
            })
            self._historyIndex = #self._history

            while #self._history > Config.MaxHistorySize do
                table.remove(self._history, 1)
                self._historyIndex = self._historyIndex - 1
            end
        end

        function StateManager:CanUndo()
            return self._historyIndex > 0
        end

        function StateManager:CanRedo()
            return self._historyIndex < #self._history
        end

        function StateManager:Undo()
            if not self:CanUndo() then
                return false
            end

            local record = self._history[self._historyIndex]
            self._historyIndex = self._historyIndex - 1

            -- Apply reverse changes
            for _, change in ipairs(record.Changes) do
                self._state[change.Key] = change.OldValue
                self:_notifyWatchers(change.Key, change.OldValue, change.NewValue)
            end

            return true
        end

        function StateManager:Redo()
            if not self:CanRedo() then
                return false
            end

            self._historyIndex = self._historyIndex + 1
            local record = self._history[self._historyIndex]

            -- Apply changes
            for _, change in ipairs(record.Changes) do
                self._state[change.Key] = change.NewValue
                self:_notifyWatchers(change.Key, change.NewValue, change.OldValue)
            end

            return true
        end

        function StateManager:ClearHistory()
            self._history = {}
            self._historyIndex = 0
        end

        function StateManager:GetHistorySize()
            return #self._history
        end

        --// Snapshots
        function StateManager:CreateSnapshot(name)
            return {
                Name = name or "Snapshot",
                State = self:_deepCopy(self._state),
                Timestamp = os.clock()
            }
        end

        function StateManager:RestoreSnapshot(snapshot, options)
            options = options or {}

            if options.Merge then
                for key, value in pairs(snapshot.State) do
                    self:Set(key, value, { Silent = options.Silent })
                end
            else
                self._state = self:_deepCopy(snapshot.State)

                if not options.Silent then
                    self._signals.StateReset:Fire()
                end
            end
        end

        --// Scoped State
        function StateManager:CreateScope(scopeName)
            if self._scopes[scopeName] then
                return self._scopes[scopeName]
            end

            local scope = {
                _manager = self,
                _prefix = scopeName .. ".",
            }

            function scope:Set(key, value, options)
                return self._manager:Set(self._prefix .. key, value, options)
            end

            function scope:Get(key, defaultValue)
                return self._manager:Get(self._prefix .. key, defaultValue)
            end

            function scope:Has(key)
                return self._manager:Has(self._prefix .. key)
            end

            function scope:Delete(key, options)
                return self._manager:Delete(self._prefix .. key, options)
            end

            function scope:Watch(key, callback, options)
                return self._manager:Watch(self._prefix .. key, callback, options)
            end

            function scope:Clear()
                for key, _ in pairs(self._manager._state) do
                    if string.sub(key, 1, #self._prefix) == self._prefix then
                        self._manager:Delete(key)
                    end
                end
            end

            self._scopes[scopeName] = scope
            return scope
        end

        function StateManager:GetScope(scopeName)
            return self._scopes[scopeName]
        end

        function StateManager:DeleteScope(scopeName)
            local scope = self._scopes[scopeName]
            if scope then
                scope:Clear()
                self._scopes[scopeName] = nil
            end
        end

        --// Persistence
        function StateManager:Persist(key)
            key = key or Config.PersistKey

            local success = pcall(function()
                if writefile then
                    local HttpService = game:GetService("HttpService")
                    local json = HttpService:JSONEncode(self._state)
                    writefile(key .. ".json", json)
                end
            end)

            return success
        end

        function StateManager:Restore(key)
            key = key or Config.PersistKey

            local success = pcall(function()
                if readfile and isfile then
                    local path = key .. ".json"
                    if isfile(path) then
                        local HttpService = game:GetService("HttpService")
                        local json = readfile(path)
                        local state = HttpService:JSONDecode(json)

                        for k, v in pairs(state) do
                            self:Set(k, v, { Silent = true })
                        end
                    end
                end
            end)

            return success
        end

        --// Utility Methods
        function StateManager:_deepCopy(original)
            if type(original) ~= "table" then
                return original
            end

            local copy = {}
            for key, value in pairs(original) do
                copy[self:_deepCopy(key)] = self:_deepCopy(value)
            end

            return copy
        end

        function StateManager:_deepEqual(a, b)
            if type(a) ~= type(b) then
                return false
            end

            if type(a) ~= "table" then
                return a == b
            end

            for key, value in pairs(a) do
                if not self:_deepEqual(value, b[key]) then
                    return false
                end
            end

            for key, value in pairs(b) do
                if a[key] == nil then
                    return false
                end
            end

            return true
        end

        --// Signals
        function StateManager:OnStateChanged(callback)
            return self._signals.StateChanged:Connect(callback)
        end

        function StateManager:OnStateReset(callback)
            return self._signals.StateReset:Connect(callback)
        end

        --// Configuration
        function StateManager:SetConfig(key, value)
            if Config[key] ~= nil then
                Config[key] = value
            end
        end

        function StateManager:GetConfig(key)
            return Config[key]
        end

        --// Debug
        function StateManager:Debug()
            print("=== StateManager Debug ===")
            print("State:")
            for key, value in pairs(self._state) do
                print(string.format("  %s = %s", key, tostring(value)))
            end
            print(string.format("Watchers: %d", self:_countWatchers()))
            print(string.format("History: %d/%d", self._historyIndex, #self._history))
            print(string.format("Computed: %d", self:_countComputed()))
        end

        function StateManager:_countWatchers()
            local count = 0
            for _, watchers in pairs(self._watchers) do
                count = count + #watchers
            end
            return count
        end

        function StateManager:_countComputed()
            local count = 0
            for _ in pairs(self._computed) do
                count = count + 1
            end
            return count
        end

        --// Cleanup
        function StateManager:Destroy()
            self:Clear({ Silent = true })
            self._watchers = {}
            self._computed = {}
            self._validators = {}
            self._history = {}
            self._scopes = {}

            for _, signal in pairs(self._signals) do
                signal:Destroy()
            end
        end

        --// Export singleton instance
        return StateManager.GetInstance()


    end


    -- ============================================================================
    -- Module: NexusUI/Core/Types
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/Types"] = function()
        local script = CreateMockScript("NexusUI/Core/Types")

        --[[
            NexusUI Type Definitions
            Comprehensive type system for the UI library

            Features:
            - Component property types
            - Theme type definitions
            - Event type definitions
            - Animation types
            - Layout types
            - Validation helpers
        ]]

        --// Types Module
        local Types = {}

        --// Base Types
        Types.Primitive = {
            String = "string",
            Number = "number",
            Boolean = "boolean",
            Table = "table",
            Function = "function",
            Nil = "nil",
            Thread = "thread",
            Userdata = "userdata",
        }

        --// Roblox Types
        Types.Roblox = {
            Instance = "Instance",
            Color3 = "Color3",
            Vector2 = "Vector2",
            Vector3 = "Vector3",
            UDim = "UDim",
            UDim2 = "UDim2",
            CFrame = "CFrame",
            Enum = "Enum",
            EnumItem = "EnumItem",
            NumberRange = "NumberRange",
            NumberSequence = "NumberSequence",
            ColorSequence = "ColorSequence",
            Rect = "Rect",
            Font = "Font",
            TweenInfo = "TweenInfo",
            RBXScriptConnection = "RBXScriptConnection",
            RBXScriptSignal = "RBXScriptSignal",
        }

        --// Component States
        Types.ComponentState = {
            Idle = "Idle",
            Hovered = "Hovered",
            Pressed = "Pressed",
            Focused = "Focused",
            Disabled = "Disabled",
            Loading = "Loading",
            Error = "Error",
            Success = "Success",
            Active = "Active",
            Selected = "Selected",
        }

        --// Component Variants
        Types.ButtonVariant = {
            Primary = "Primary",
            Secondary = "Secondary",
            Tertiary = "Tertiary",
            Ghost = "Ghost",
            Outline = "Outline",
            Link = "Link",
            Danger = "Danger",
            Success = "Success",
            Warning = "Warning",
            Info = "Info",
        }

        Types.InputVariant = {
            Default = "Default",
            Filled = "Filled",
            Outline = "Outline",
            Underline = "Underline",
            Ghost = "Ghost",
        }

        Types.Size = {
            XSmall = "XSmall",
            Small = "Small",
            Medium = "Medium",
            Large = "Large",
            XLarge = "XLarge",
            XXLarge = "XXLarge",
        }

        --// Theme Types
        Types.ThemeMode = {
            Light = "Light",
            Dark = "Dark",
            System = "System",
            Custom = "Custom",
        }

        Types.ThemeCategory = {
            Dark = "Dark",
            Light = "Light",
            Colorful = "Colorful",
            Glass = "Glass",
            Gaming = "Gaming",
        }

        --// Animation Types
        Types.EasingStyle = {
            Linear = "Linear",
            Sine = "Sine",
            Quad = "Quad",
            Cubic = "Cubic",
            Quart = "Quart",
            Quint = "Quint",
            Expo = "Expo",
            Circ = "Circ",
            Back = "Back",
            Elastic = "Elastic",
            Bounce = "Bounce",
            Spring = "Spring",
        }

        Types.EasingDirection = {
            In = "In",
            Out = "Out",
            InOut = "InOut",
            OutIn = "OutIn",
        }

        Types.AnimationState = {
            Idle = "Idle",
            Playing = "Playing",
            Paused = "Paused",
            Completed = "Completed",
            Cancelled = "Cancelled",
        }

        --// Layout Types
        Types.LayoutDirection = {
            Horizontal = "Horizontal",
            Vertical = "Vertical",
        }

        Types.Alignment = {
            Start = "Start",
            Center = "Center",
            End = "End",
            Stretch = "Stretch",
            SpaceBetween = "SpaceBetween",
            SpaceAround = "SpaceAround",
            SpaceEvenly = "SpaceEvenly",
        }

        Types.Position = {
            TopLeft = "TopLeft",
            TopCenter = "TopCenter",
            TopRight = "TopRight",
            CenterLeft = "CenterLeft",
            Center = "Center",
            CenterRight = "CenterRight",
            BottomLeft = "BottomLeft",
            BottomCenter = "BottomCenter",
            BottomRight = "BottomRight",
        }

        --// Notification Types
        Types.NotificationType = {
            Info = "Info",
            Success = "Success",
            Warning = "Warning",
            Error = "Error",
            Default = "Default",
        }

        Types.NotificationPosition = {
            TopLeft = "TopLeft",
            TopCenter = "TopCenter",
            TopRight = "TopRight",
            BottomLeft = "BottomLeft",
            BottomCenter = "BottomCenter",
            BottomRight = "BottomRight",
        }

        --// Input Types
        Types.InputType = {
            Text = "Text",
            Number = "Number",
            Password = "Password",
            Email = "Email",
            Search = "Search",
            Url = "Url",
            Tel = "Tel",
            Date = "Date",
            Time = "Time",
            DateTime = "DateTime",
            Color = "Color",
            File = "File",
            Range = "Range",
        }

        Types.KeyCode = Enum.KeyCode

        --// Effect Types
        Types.EffectType = {
            LiquidGlass = "LiquidGlass",
            Glassmorphism = "Glassmorphism",
            Acrylic = "Acrylic",
            Mica = "Mica",
            Neon = "Neon",
            Glow = "Glow",
            Shadow = "Shadow",
            Blur = "Blur",
            Gradient = "Gradient",
            Noise = "Noise",
            Particles = "Particles",
        }

        --// Sound Types
        Types.SoundType = {
            Click = "Click",
            Hover = "Hover",
            Toggle = "Toggle",
            Slide = "Slide",
            Open = "Open",
            Close = "Close",
            Success = "Success",
            Error = "Error",
            Warning = "Warning",
            Notification = "Notification",
            Type = "Type",
        }

        --// Type Definitions (for documentation/validation)
        Types.Definitions = {}

        --// Color Definition
        Types.Definitions.Color = {
            Primary = "Color3",
            Secondary = "Color3",
            Accent = "Color3",
            Background = "Color3",
            Surface = "Color3",
            Text = "Color3",
            TextMuted = "Color3",
            Border = "Color3",
            Success = "Color3",
            Warning = "Color3",
            Error = "Color3",
            Info = "Color3",
        }

        --// Theme Definition
        Types.Definitions.Theme = {
            Name = "string",
            Category = "ThemeCategory",
            Mode = "ThemeMode",
            Colors = "ColorDefinition",
            Typography = "TypographyDefinition",
            Spacing = "SpacingDefinition",
            Borders = "BorderDefinition",
            Shadows = "ShadowDefinition",
            Effects = "EffectDefinition",
            Animations = "AnimationDefinition",
        }

        --// Typography Definition
        Types.Definitions.Typography = {
            FontFamily = "Font",
            FontFamilyMono = "Font",
            FontSizeXS = "number",
            FontSizeSM = "number",
            FontSizeMD = "number",
            FontSizeLG = "number",
            FontSizeXL = "number",
            FontSizeXXL = "number",
            FontWeightLight = "Enum.FontWeight",
            FontWeightRegular = "Enum.FontWeight",
            FontWeightMedium = "Enum.FontWeight",
            FontWeightBold = "Enum.FontWeight",
            LineHeightTight = "number",
            LineHeightNormal = "number",
            LineHeightRelaxed = "number",
        }

        --// Spacing Definition
        Types.Definitions.Spacing = {
            XS = "number",
            SM = "number",
            MD = "number",
            LG = "number",
            XL = "number",
            XXL = "number",
        }

        --// Border Definition
        Types.Definitions.Border = {
            RadiusNone = "number",
            RadiusSM = "number",
            RadiusMD = "number",
            RadiusLG = "number",
            RadiusXL = "number",
            RadiusFull = "number",
            WidthNone = "number",
            WidthThin = "number",
            WidthMedium = "number",
            WidthThick = "number",
        }

        --// Shadow Definition
        Types.Definitions.Shadow = {
            None = "table",
            SM = "table",
            MD = "table",
            LG = "table",
            XL = "table",
            Inner = "table",
        }

        --// Component Props Definitions
        Types.Definitions.ButtonProps = {
            Text = "string",
            Icon = "string?",
            IconPosition = "string?",
            Variant = "ButtonVariant?",
            Size = "Size?",
            Disabled = "boolean?",
            Loading = "boolean?",
            FullWidth = "boolean?",
            Callback = "function?",
            Tooltip = "string?",
        }

        Types.Definitions.ToggleProps = {
            Value = "boolean?",
            DefaultValue = "boolean?",
            Disabled = "boolean?",
            Size = "Size?",
            Label = "string?",
            LabelPosition = "string?",
            Callback = "function?",
        }

        Types.Definitions.SliderProps = {
            Value = "number?",
            DefaultValue = "number?",
            Min = "number",
            Max = "number",
            Step = "number?",
            Disabled = "boolean?",
            ShowValue = "boolean?",
            ValueFormat = "string?",
            Callback = "function?",
        }

        Types.Definitions.TextInputProps = {
            Value = "string?",
            DefaultValue = "string?",
            Placeholder = "string?",
            Type = "InputType?",
            Disabled = "boolean?",
            ReadOnly = "boolean?",
            MaxLength = "number?",
            Pattern = "string?",
            Variant = "InputVariant?",
            Size = "Size?",
            Icon = "string?",
            IconPosition = "string?",
            ClearButton = "boolean?",
            Callback = "function?",
            OnFocus = "function?",
            OnBlur = "function?",
        }

        Types.Definitions.DropdownProps = {
            Value = "any?",
            DefaultValue = "any?",
            Options = "table",
            Placeholder = "string?",
            Disabled = "boolean?",
            Searchable = "boolean?",
            Clearable = "boolean?",
            Multi = "boolean?",
            MaxSelections = "number?",
            Callback = "function?",
        }

        Types.Definitions.WindowProps = {
            Title = "string",
            Subtitle = "string?",
            Icon = "string?",
            Size = "UDim2?",
            Position = "UDim2?",
            MinSize = "Vector2?",
            MaxSize = "Vector2?",
            Draggable = "boolean?",
            Resizable = "boolean?",
            Closeable = "boolean?",
            Minimizable = "boolean?",
            Theme = "string?",
            Keybind = "Enum.KeyCode?",
        }

        Types.Definitions.TabProps = {
            Title = "string",
            Icon = "string?",
            Disabled = "boolean?",
            Badge = "string?",
            Closeable = "boolean?",
        }

        --// Type Checking Utilities
        function Types.Is(value, typeName)
            local valueType = typeof(value)

            -- Direct type match
            if valueType == typeName then
                return true
            end

            -- Check primitive types
            if Types.Primitive[typeName] and type(value) == Types.Primitive[typeName] then
                return true
            end

            -- Check Roblox types
            if Types.Roblox[typeName] and valueType == typeName then
                return true
            end

            -- Check enum types
            if typeName:sub(1, 5) == "Enum." then
                local enumPath = typeName:split(".")
                local enum = Enum
                for i = 2, #enumPath do
                    enum = enum[enumPath[i]]
                end

                if valueType == "EnumItem" then
                    return value.EnumType == enum
                end
            end

            return false
        end

        function Types.IsOneOf(value, typeNames)
            for _, typeName in ipairs(typeNames) do
                if Types.Is(value, typeName) then
                    return true
                end
            end
            return false
        end

        function Types.IsOptional(typeName)
            return typeName:sub(-1) == "?"
        end

        function Types.GetBaseType(typeName)
            if Types.IsOptional(typeName) then
                return typeName:sub(1, -2)
            end
            return typeName
        end

        function Types.Validate(value, typeName)
            if value == nil then
                if Types.IsOptional(typeName) then
                    return true, nil
                else
                    return false, "Value is required"
                end
            end

            local baseType = Types.GetBaseType(typeName)

            if not Types.Is(value, baseType) then
                return false, string.format("Expected %s, got %s", baseType, typeof(value))
            end

            return true, nil
        end

        function Types.ValidateProps(props, definition)
            local errors = {}

            for propName, typeName in pairs(definition) do
                local isValid, error = Types.Validate(props[propName], typeName)

                if not isValid then
                    table.insert(errors, string.format("%s: %s", propName, error))
                end
            end

            return #errors == 0, errors
        end

        function Types.CreateValidator(definition)
            return function(props)
                return Types.ValidateProps(props, definition)
            end
        end

        --// Default Values
        Types.Defaults = {
            ButtonVariant = Types.ButtonVariant.Primary,
            InputVariant = Types.InputVariant.Default,
            Size = Types.Size.Medium,
            EasingStyle = Types.EasingStyle.Quad,
            EasingDirection = Types.EasingDirection.Out,
            NotificationType = Types.NotificationType.Info,
            NotificationPosition = Types.NotificationPosition.TopRight,
            ThemeMode = Types.ThemeMode.Dark,
            LayoutDirection = Types.LayoutDirection.Vertical,
            Alignment = Types.Alignment.Start,
        }

        --// Type Coercion
        function Types.Coerce(value, targetType)
            local currentType = typeof(value)

            if currentType == targetType then
                return value
            end

            -- String coercion
            if targetType == "string" then
                return tostring(value)
            end

            -- Number coercion
            if targetType == "number" then
                return tonumber(value)
            end

            -- Boolean coercion
            if targetType == "boolean" then
                if type(value) == "string" then
                    return value:lower() == "true" or value == "1"
                end
                return value and true or false
            end

            -- Color3 coercion
            if targetType == "Color3" then
                if type(value) == "string" then
                    -- Try hex conversion
                    local hex = value:gsub("#", "")
                    if #hex == 6 then
                        local r = tonumber(hex:sub(1, 2), 16) / 255
                        local g = tonumber(hex:sub(3, 4), 16) / 255
                        local b = tonumber(hex:sub(5, 6), 16) / 255
                        return Color3.new(r, g, b)
                    end
                elseif type(value) == "table" then
                    if value.R and value.G and value.B then
                        return Color3.new(value.R, value.G, value.B)
                    elseif #value >= 3 then
                        return Color3.new(value[1], value[2], value[3])
                    end
                end
            end

            -- UDim2 coercion
            if targetType == "UDim2" then
                if type(value) == "table" then
                    if value.X and value.Y then
                        return UDim2.new(value.X.Scale or 0, value.X.Offset or 0, value.Y.Scale or 0, value.Y.Offset or 0)
                    elseif #value >= 4 then
                        return UDim2.new(value[1], value[2], value[3], value[4])
                    elseif #value >= 2 then
                        return UDim2.fromOffset(value[1], value[2])
                    end
                elseif type(value) == "number" then
                    return UDim2.fromOffset(value, value)
                end
            end

            -- Vector2 coercion
            if targetType == "Vector2" then
                if type(value) == "table" then
                    if value.X and value.Y then
                        return Vector2.new(value.X, value.Y)
                    elseif #value >= 2 then
                        return Vector2.new(value[1], value[2])
                    end
                elseif type(value) == "number" then
                    return Vector2.new(value, value)
                end
            end

            return value
        end

        --// Enum Helpers
        function Types.GetEnumValues(enumType)
            local values = {}
            for _, item in pairs(enumType) do
                table.insert(values, item)
            end
            return values
        end

        function Types.GetEnumNames(enumType)
            local names = {}
            for name, _ in pairs(enumType) do
                table.insert(names, name)
            end
            return names
        end

        function Types.EnumFromString(enumType, str)
            return enumType[str]
        end

        return Types


    end


    -- ============================================================================
    -- Module: NexusUI/Core/Constants
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/Constants"] = function()
        local script = CreateMockScript("NexusUI/Core/Constants")

        --[[
            NexusUI Constants
            Central repository for all library constants

            Contains:
            - Library metadata
            - Default configurations
            - UI constants
            - Animation defaults
            - Theme defaults
            - Sound defaults
            - Layout constants
        ]]

        --// Constants Module
        local Constants = {}

        --// Library Info
        Constants.Library = {
            Name = "NexusUI",
            Version = "1.0.0",
            Build = 1000,
            Author = "NexusUI Team",
            Description = "Ultimate Roblox Executor UI Library",
            Repository = "github.com/nexusui/nexusui",
            Documentation = "docs.nexusui.dev",
        }

        --// Environment
        Constants.Environment = {
            IsStudio = game:GetService("RunService"):IsStudio(),
            IsClient = game:GetService("RunService"):IsClient(),
            IsServer = game:GetService("RunService"):IsServer(),
        }

        --// Z-Index Layers
        Constants.ZIndex = {
            Base = 1,
            Component = 10,
            Elevated = 100,
            Dropdown = 200,
            Popover = 300,
            Modal = 400,
            Toast = 500,
            Tooltip = 600,
            ContextMenu = 700,
            Overlay = 800,
            PerformanceMonitor = 900,
            Watermark = 950,
            Maximum = 999,
        }

        --// Timing
        Constants.Timing = {
            -- Animation durations (seconds)
            Instant = 0,
            Fast = 0.1,
            Normal = 0.2,
            Slow = 0.3,
            Slower = 0.5,
            Slowest = 1.0,

            -- Delays
            DebounceDelay = 0.1,
            ThrottleDelay = 0.05,
            TooltipDelay = 0.5,
            DoubleClickWindow = 0.3,
            LongPressDelay = 0.5,

            -- Timeouts
            DefaultTimeout = 30,
            NetworkTimeout = 10,
            AnimationTimeout = 5,
        }

        --// Sizes
        Constants.Sizes = {
            -- Component sizes
            XSmall = {
                Height = 24,
                Padding = 6,
                FontSize = 10,
                IconSize = 12,
                BorderRadius = 4,
            },
            Small = {
                Height = 32,
                Padding = 8,
                FontSize = 12,
                IconSize = 14,
                BorderRadius = 6,
            },
            Medium = {
                Height = 40,
                Padding = 12,
                FontSize = 14,
                IconSize = 16,
                BorderRadius = 8,
            },
            Large = {
                Height = 48,
                Padding = 16,
                FontSize = 16,
                IconSize = 20,
                BorderRadius = 10,
            },
            XLarge = {
                Height = 56,
                Padding = 20,
                FontSize = 18,
                IconSize = 24,
                BorderRadius = 12,
            },
            XXLarge = {
                Height = 64,
                Padding = 24,
                FontSize = 20,
                IconSize = 28,
                BorderRadius = 14,
            },
        }

        --// Spacing
        Constants.Spacing = {
            None = 0,
            XXS = 2,
            XS = 4,
            SM = 8,
            MD = 12,
            LG = 16,
            XL = 24,
            XXL = 32,
            XXXL = 48,
        }

        --// Typography
        Constants.Typography = {
            -- Font Families
            Fonts = {
                Default = Enum.Font.GothamMedium,
                Heading = Enum.Font.GothamBold,
                Body = Enum.Font.Gotham,
                Mono = Enum.Font.Code,
                Display = Enum.Font.GothamBlack,
            },

            -- Font Sizes
            FontSizes = {
                XS = 10,
                SM = 12,
                MD = 14,
                LG = 16,
                XL = 20,
                XXL = 24,
                XXXL = 32,
                Display = 48,
            },

            -- Font Weights
            FontWeights = {
                Light = Enum.FontWeight.Light,
                Regular = Enum.FontWeight.Regular,
                Medium = Enum.FontWeight.Medium,
                SemiBold = Enum.FontWeight.SemiBold,
                Bold = Enum.FontWeight.Bold,
                ExtraBold = Enum.FontWeight.ExtraBold,
            },

            -- Line Heights
            LineHeights = {
                Tight = 1.2,
                Normal = 1.5,
                Relaxed = 1.8,
            },
        }

        --// Borders
        Constants.Borders = {
            -- Border Radius
            Radius = {
                None = 0,
                XS = 2,
                SM = 4,
                MD = 8,
                LG = 12,
                XL = 16,
                XXL = 24,
                Full = 9999,
            },

            -- Border Width
            Width = {
                None = 0,
                Thin = 1,
                Medium = 2,
                Thick = 3,
            },
        }

        --// Shadows
        Constants.Shadows = {
            None = {
                Offset = Vector2.new(0, 0),
                Radius = 0,
                Color = Color3.new(0, 0, 0),
                Transparency = 1,
            },
            XS = {
                Offset = Vector2.new(0, 1),
                Radius = 2,
                Color = Color3.new(0, 0, 0),
                Transparency = 0.9,
            },
            SM = {
                Offset = Vector2.new(0, 2),
                Radius = 4,
                Color = Color3.new(0, 0, 0),
                Transparency = 0.85,
            },
            MD = {
                Offset = Vector2.new(0, 4),
                Radius = 8,
                Color = Color3.new(0, 0, 0),
                Transparency = 0.8,
            },
            LG = {
                Offset = Vector2.new(0, 8),
                Radius = 16,
                Color = Color3.new(0, 0, 0),
                Transparency = 0.75,
            },
            XL = {
                Offset = Vector2.new(0, 16),
                Radius = 32,
                Color = Color3.new(0, 0, 0),
                Transparency = 0.7,
            },
            Inner = {
                Offset = Vector2.new(0, 2),
                Radius = 4,
                Color = Color3.new(0, 0, 0),
                Transparency = 0.95,
                Inner = true,
            },
        }

        --// Animation Defaults
        Constants.Animation = {
            -- Default tween info
            DefaultDuration = 0.2,
            DefaultEasing = Enum.EasingStyle.Quad,
            DefaultDirection = Enum.EasingDirection.Out,

            -- Spring defaults
            SpringDamping = 0.8,
            SpringFrequency = 4,
            SpringMass = 1,

            -- Preset durations
            Durations = {
                Instant = 0,
                Fast = 0.1,
                Normal = 0.2,
                Slow = 0.3,
                Slower = 0.5,
            },

            -- Easing presets
            Easings = {
                Default = { Style = Enum.EasingStyle.Quad, Direction = Enum.EasingDirection.Out },
                Smooth = { Style = Enum.EasingStyle.Sine, Direction = Enum.EasingDirection.InOut },
                Bounce = { Style = Enum.EasingStyle.Bounce, Direction = Enum.EasingDirection.Out },
                Elastic = { Style = Enum.EasingStyle.Elastic, Direction = Enum.EasingDirection.Out },
                Sharp = { Style = Enum.EasingStyle.Expo, Direction = Enum.EasingDirection.Out },
            },
        }

        --// Window Defaults
        Constants.Window = {
            DefaultSize = UDim2.fromOffset(600, 450),
            MinSize = Vector2.new(400, 300),
            MaxSize = Vector2.new(1200, 900),
            DefaultPosition = UDim2.fromScale(0.5, 0.5),
            TitleBarHeight = 36,
            TabBarHeight = 32,
            StatusBarHeight = 24,
            ResizeHandleSize = 8,
            SnapThreshold = 20,
            SnapMargin = 10,
        }

        --// Component Defaults
        Constants.Components = {
            -- Button
            Button = {
                DefaultVariant = "Primary",
                DefaultSize = "Medium",
                MinWidth = 80,
                IconSpacing = 8,
            },

            -- Toggle
            Toggle = {
                Width = 44,
                Height = 24,
                HandleSize = 20,
                HandleMargin = 2,
            },

            -- Slider
            Slider = {
                TrackHeight = 4,
                HandleSize = 16,
                MinWidth = 100,
            },

            -- TextInput
            TextInput = {
                DefaultVariant = "Default",
                DefaultSize = "Medium",
                MinWidth = 120,
                MaxLength = 10000,
            },

            -- Dropdown
            Dropdown = {
                MaxVisibleItems = 8,
                ItemHeight = 36,
                MinWidth = 150,
                MaxHeight = 300,
            },

            -- Tooltip
            Tooltip = {
                MaxWidth = 250,
                ShowDelay = 500,
                HideDelay = 100,
                Offset = Vector2.new(12, 12),
            },

            -- Modal
            Modal = {
                DefaultWidth = 480,
                MinWidth = 320,
                MaxWidth = 800,
                OverlayTransparency = 0.5,
            },

            -- Toast
            Toast = {
                DefaultDuration = 5,
                MaxVisible = 5,
                Width = 350,
                MinHeight = 60,
                Spacing = 12,
            },

            -- ScrollFrame
            ScrollFrame = {
                ScrollbarWidth = 8,
                ScrollbarMinHeight = 40,
                ScrollSpeed = 50,
                ScrollSmoothing = 0.1,
            },

            -- Tabs
            Tabs = {
                MinTabWidth = 80,
                MaxTabWidth = 200,
                TabHeight = 32,
                TabSpacing = 4,
            },
        }

        --// Notification Positions
        Constants.NotificationPositions = {
            TopLeft = {
                AnchorPoint = Vector2.new(0, 0),
                Position = UDim2.fromOffset(20, 20),
                LayoutOrder = 1,
            },
            TopCenter = {
                AnchorPoint = Vector2.new(0.5, 0),
                Position = UDim2.new(0.5, 0, 0, 20),
                LayoutOrder = 1,
            },
            TopRight = {
                AnchorPoint = Vector2.new(1, 0),
                Position = UDim2.new(1, -20, 0, 20),
                LayoutOrder = 1,
            },
            BottomLeft = {
                AnchorPoint = Vector2.new(0, 1),
                Position = UDim2.new(0, 20, 1, -20),
                LayoutOrder = -1,
            },
            BottomCenter = {
                AnchorPoint = Vector2.new(0.5, 1),
                Position = UDim2.new(0.5, 0, 1, -20),
                LayoutOrder = -1,
            },
            BottomRight = {
                AnchorPoint = Vector2.new(1, 1),
                Position = UDim2.new(1, -20, 1, -20),
                LayoutOrder = -1,
            },
        }

        --// Keyboard Shortcuts
        Constants.Keybinds = {
            ToggleUI = Enum.KeyCode.RightControl,
            Close = Enum.KeyCode.Escape,
            Confirm = Enum.KeyCode.Return,
            SelectAll = { Enum.KeyCode.LeftControl, Enum.KeyCode.A },
            Copy = { Enum.KeyCode.LeftControl, Enum.KeyCode.C },
            Paste = { Enum.KeyCode.LeftControl, Enum.KeyCode.V },
            Cut = { Enum.KeyCode.LeftControl, Enum.KeyCode.X },
            Undo = { Enum.KeyCode.LeftControl, Enum.KeyCode.Z },
            Redo = { Enum.KeyCode.LeftControl, Enum.KeyCode.Y },
            Save = { Enum.KeyCode.LeftControl, Enum.KeyCode.S },
        }

        --// Sound IDs
        Constants.Sounds = {
            Click = "rbxassetid://6895079853",
            Hover = "rbxassetid://6895079853",
            Toggle = "rbxassetid://6895079853",
            Slide = "rbxassetid://6895079853",
            Open = "rbxassetid://6895079853",
            Close = "rbxassetid://6895079853",
            Success = "rbxassetid://6895079853",
            Error = "rbxassetid://6895079853",
            Warning = "rbxassetid://6895079853",
            Notification = "rbxassetid://6895079853",
        }

        --// Performance
        Constants.Performance = {
            -- FPS thresholds
            FPSGood = 60,
            FPSWarning = 30,
            FPSCritical = 15,

            -- Memory thresholds (MB)
            MemoryWarning = 500,
            MemoryCritical = 1000,

            -- Ping thresholds (ms)
            PingGood = 50,
            PingWarning = 100,
            PingCritical = 200,

            -- Object pooling
            PoolInitialSize = 10,
            PoolMaxSize = 100,
            PoolGrowthFactor = 2,
        }

        --// Color Palette (base colors)
        Constants.Colors = {
            -- Neutrals
            White = Color3.fromRGB(255, 255, 255),
            Black = Color3.fromRGB(0, 0, 0),
            Gray50 = Color3.fromRGB(250, 250, 250),
            Gray100 = Color3.fromRGB(245, 245, 245),
            Gray200 = Color3.fromRGB(229, 229, 229),
            Gray300 = Color3.fromRGB(212, 212, 212),
            Gray400 = Color3.fromRGB(163, 163, 163),
            Gray500 = Color3.fromRGB(115, 115, 115),
            Gray600 = Color3.fromRGB(82, 82, 82),
            Gray700 = Color3.fromRGB(64, 64, 64),
            Gray800 = Color3.fromRGB(38, 38, 38),
            Gray900 = Color3.fromRGB(23, 23, 23),
            Gray950 = Color3.fromRGB(10, 10, 10),

            -- Primary colors
            Red = Color3.fromRGB(239, 68, 68),
            Orange = Color3.fromRGB(249, 115, 22),
            Amber = Color3.fromRGB(245, 158, 11),
            Yellow = Color3.fromRGB(234, 179, 8),
            Lime = Color3.fromRGB(132, 204, 22),
            Green = Color3.fromRGB(34, 197, 94),
            Emerald = Color3.fromRGB(16, 185, 129),
            Teal = Color3.fromRGB(20, 184, 166),
            Cyan = Color3.fromRGB(6, 182, 212),
            Sky = Color3.fromRGB(14, 165, 233),
            Blue = Color3.fromRGB(59, 130, 246),
            Indigo = Color3.fromRGB(99, 102, 241),
            Violet = Color3.fromRGB(139, 92, 246),
            Purple = Color3.fromRGB(168, 85, 247),
            Fuchsia = Color3.fromRGB(217, 70, 239),
            Pink = Color3.fromRGB(236, 72, 153),
            Rose = Color3.fromRGB(244, 63, 94),

            -- Semantic colors
            Success = Color3.fromRGB(34, 197, 94),
            Warning = Color3.fromRGB(245, 158, 11),
            Error = Color3.fromRGB(239, 68, 68),
            Info = Color3.fromRGB(59, 130, 246),

            -- Special
            Transparent = Color3.new(0, 0, 0),
        }

        --// Regex Patterns
        Constants.Patterns = {
            Email = "^[%w._%+-]+@[%w.-]+%.[%w]+$",
            Url = "^https?://[%w.-]+%.[%w]+",
            Phone = "^%+?%d[%d%-%(%) ]+$",
            Hex = "^#?[%x]+$",
            Number = "^%-?%d+%.?%d*$",
            Integer = "^%-?%d+$",
            Alphanumeric = "^[%w]+$",
            NoSpecialChars = "^[%w%s]+$",
        }

        --// Asset Prefixes
        Constants.AssetPrefixes = {
            RbxAsset = "rbxassetid://",
            RbxThumb = "rbxthumb://",
            Https = "https://",
            Http = "http://",
        }

        --// Instance Pool Categories
        Constants.PoolCategories = {
            Frame = "Frame",
            TextLabel = "TextLabel",
            TextButton = "TextButton",
            TextBox = "TextBox",
            ImageLabel = "ImageLabel",
            ImageButton = "ImageButton",
            ScrollingFrame = "ScrollingFrame",
            UICorner = "UICorner",
            UIStroke = "UIStroke",
            UIPadding = "UIPadding",
            UIListLayout = "UIListLayout",
            UIGridLayout = "UIGridLayout",
            UIGradient = "UIGradient",
        }

        --// Error Messages
        Constants.Errors = {
            InvalidArgument = "Invalid argument: %s",
            MissingRequired = "Missing required parameter: %s",
            TypeMismatch = "Type mismatch: expected %s, got %s",
            NotInitialized = "NexusUI is not initialized",
            AlreadyDestroyed = "Object has already been destroyed",
            InvalidComponent = "Invalid component: %s",
            InvalidTheme = "Invalid theme: %s",
            LoadFailed = "Failed to load: %s",
        }

        --// Freeze all constant tables to prevent modification
        local function DeepFreeze(t)
            if type(t) ~= "table" then return t end

            for k, v in pairs(t) do
                if type(v) == "table" then
                    DeepFreeze(v)
                end
            end

            return table.freeze(t)
        end

        -- Only freeze in production
        if not Constants.Environment.IsStudio then
            DeepFreeze(Constants)
        end

        return Constants


    end


    -- ============================================================================
    -- Module: NexusUI/Core/InstancePool
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/InstancePool"] = function()
        local script = CreateMockScript("NexusUI/Core/InstancePool")

        --[[
            NexusUI Instance Pool
            Object pooling system for efficient instance reuse

            Features:
            - Pre-allocated instance pools
            - Automatic pool growth
            - Instance recycling
            - Pool statistics
            - Memory optimization
            - Multi-category support
            - Warm-up functionality
        ]]

        --// Dependencies
        local Constants = NexusRequire("NexusUI/Constants")

        --// Instance Pool Class
        local InstancePool = {}
        InstancePool.__index = InstancePool
        InstancePool.ClassName = "InstancePool"

        --// Configuration
        local Config = {
            InitialPoolSize = 10,
            MaxPoolSize = 200,
            GrowthFactor = 2,
            ShrinkThreshold = 0.25,
            ShrinkDelay = 30,
            DebugMode = false,
            WarmUpOnCreate = true,
        }

        --// Pool Statistics
        local Stats = {
            TotalCreated = 0,
            TotalRecycled = 0,
            TotalAcquired = 0,
            TotalReleased = 0,
            CacheHits = 0,
            CacheMisses = 0,
        }

        --// Singleton Instance
        local instance = nil

        --// Pool Entry Class
        local PoolEntry = {}
        PoolEntry.__index = PoolEntry

        function PoolEntry.new(category, createFunc)
            local self = setmetatable({}, PoolEntry)

            self.Category = category
            self.CreateFunc = createFunc
            self.Available = {}
            self.InUse = {}
            self.TotalCreated = 0
            self.MaxSize = Config.MaxPoolSize
            self.LastShrinkCheck = os.clock()

            return self
        end

        function PoolEntry:Create()
            local instance

            if self.CreateFunc then
                instance = self.CreateFunc()
            else
                instance = Instance.new(self.Category)
            end

            self.TotalCreated = self.TotalCreated + 1
            Stats.TotalCreated = Stats.TotalCreated + 1

            return instance
        end

        function PoolEntry:Acquire()
            local obj = table.remove(self.Available)

            if obj then
                Stats.CacheHits = Stats.CacheHits + 1
                Stats.TotalRecycled = Stats.TotalRecycled + 1
            else
                Stats.CacheMisses = Stats.CacheMisses + 1
                obj = self:Create()
            end

            self.InUse[obj] = true
            Stats.TotalAcquired = Stats.TotalAcquired + 1

            return obj
        end

        function PoolEntry:Release(obj)
            if not obj then return end

            -- Remove from in-use
            self.InUse[obj] = nil

            -- Reset instance
            self:ResetInstance(obj)

            -- Add to available if pool not full
            if #self.Available < self.MaxSize then
                table.insert(self.Available, obj)
            else
                -- Pool is full, destroy instance
                pcall(function()
                    obj:Destroy()
                end)
            end

            Stats.TotalReleased = Stats.TotalReleased + 1
        end

        function PoolEntry:ResetInstance(obj)
            if not obj or not obj:IsA("Instance") then return end

            pcall(function()
                -- Remove from parent
                obj.Parent = nil

                -- Reset common properties based on class
                if obj:IsA("GuiObject") then
                    obj.Visible = true
                    obj.BackgroundTransparency = 0
                    obj.Size = UDim2.new(0, 100, 0, 100)
                    obj.Position = UDim2.new(0, 0, 0, 0)
                    obj.AnchorPoint = Vector2.new(0, 0)
                    obj.Rotation = 0
                    obj.ZIndex = 1
                    obj.LayoutOrder = 0
                    obj.Name = obj.ClassName

                    if obj:IsA("Frame") then
                        obj.BackgroundColor3 = Color3.new(1, 1, 1)
                    end

                    if obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox") then
                        obj.Text = ""
                        obj.TextColor3 = Color3.new(0, 0, 0)
                        obj.TextSize = 14
                        obj.Font = Enum.Font.SourceSans
                        obj.TextXAlignment = Enum.TextXAlignment.Center
                        obj.TextYAlignment = Enum.TextYAlignment.Center
                        obj.TextWrapped = false
                        obj.TextScaled = false
                        obj.RichText = false
                    end

                    if obj:IsA("ImageLabel") or obj:IsA("ImageButton") then
                        obj.Image = ""
                        obj.ImageColor3 = Color3.new(1, 1, 1)
                        obj.ImageTransparency = 0
                        obj.ScaleType = Enum.ScaleType.Stretch
                    end

                    if obj:IsA("ScrollingFrame") then
                        obj.ScrollBarThickness = 12
                        obj.ScrollingDirection = Enum.ScrollingDirection.XY
                        obj.ScrollingEnabled = true
                        obj.CanvasSize = UDim2.new(0, 0, 0, 0)
                        obj.CanvasPosition = Vector2.new(0, 0)
                    end
                end

                -- Reset UI modifiers
                if obj:IsA("UICorner") then
                    obj.CornerRadius = UDim.new(0, 8)
                end

                if obj:IsA("UIStroke") then
                    obj.Color = Color3.new(0, 0, 0)
                    obj.Thickness = 1
                    obj.Transparency = 0
                    obj.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
                end

                if obj:IsA("UIPadding") then
                    obj.PaddingTop = UDim.new(0, 0)
                    obj.PaddingBottom = UDim.new(0, 0)
                    obj.PaddingLeft = UDim.new(0, 0)
                    obj.PaddingRight = UDim.new(0, 0)
                end

                if obj:IsA("UIListLayout") then
                    obj.Padding = UDim.new(0, 0)
                    obj.FillDirection = Enum.FillDirection.Vertical
                    obj.HorizontalAlignment = Enum.HorizontalAlignment.Left
                    obj.VerticalAlignment = Enum.VerticalAlignment.Top
                    obj.SortOrder = Enum.SortOrder.LayoutOrder
                end

                if obj:IsA("UIGridLayout") then
                    obj.CellPadding = UDim2.new(0, 0, 0, 0)
                    obj.CellSize = UDim2.new(0, 100, 0, 100)
                    obj.FillDirection = Enum.FillDirection.Horizontal
                    obj.FillDirectionMaxCells = 0
                    obj.SortOrder = Enum.SortOrder.LayoutOrder
                end

                if obj:IsA("UIGradient") then
                    obj.Color = ColorSequence.new(Color3.new(1, 1, 1))
                    obj.Transparency = NumberSequence.new(0)
                    obj.Rotation = 0
                    obj.Offset = Vector2.new(0, 0)
                end

                -- Clear children (but keep UI modifiers for base instances)
                for _, child in ipairs(obj:GetChildren()) do
                    child:Destroy()
                end

                -- Clear connections (would need external tracking)
            end)
        end

        function PoolEntry:Warm(count)
            count = count or Config.InitialPoolSize

            for i = 1, count do
                if #self.Available < self.MaxSize then
                    local obj = self:Create()
                    table.insert(self.Available, obj)
                end
            end
        end

        function PoolEntry:Shrink()
            local now = os.clock()

            if now - self.LastShrinkCheck < Config.ShrinkDelay then
                return
            end

            self.LastShrinkCheck = now

            local totalCount = #self.Available + self:GetInUseCount()
            local usageRatio = self:GetInUseCount() / math.max(totalCount, 1)

            if usageRatio < Config.ShrinkThreshold and #self.Available > Config.InitialPoolSize then
                local toRemove = math.floor(#self.Available / 2)

                for i = 1, toRemove do
                    local obj = table.remove(self.Available)
                    if obj then
                        pcall(function()
                            obj:Destroy()
                        end)
                    end
                end

                if Config.DebugMode then
                    print(string.format("[InstancePool] Shrunk pool '%s' by %d instances", self.Category, toRemove))
                end
            end
        end

        function PoolEntry:GetAvailableCount()
            return #self.Available
        end

        function PoolEntry:GetInUseCount()
            local count = 0
            for _ in pairs(self.InUse) do
                count = count + 1
            end
            return count
        end

        function PoolEntry:Clear()
            -- Destroy available instances
            for _, obj in ipairs(self.Available) do
                pcall(function()
                    obj:Destroy()
                end)
            end
            self.Available = {}

            -- Clear in-use tracking (don't destroy - they're being used)
            self.InUse = {}
        end

        --// Instance Pool Implementation
        function InstancePool.new()
            local self = setmetatable({}, InstancePool)

            self._pools = {}
            self._customCreators = {}

            return self
        end

        function InstancePool.GetInstance()
            if not instance then
                instance = InstancePool.new()

                -- Initialize default pools
                if Config.WarmUpOnCreate then
                    instance:InitializeDefaultPools()
                end
            end
            return instance
        end

        function InstancePool:InitializeDefaultPools()
            local categories = {
                "Frame",
                "TextLabel",
                "TextButton",
                "TextBox",
                "ImageLabel",
                "ImageButton",
                "ScrollingFrame",
                "UICorner",
                "UIStroke",
                "UIPadding",
                "UIListLayout",
                "UIGridLayout",
                "UIGradient",
            }

            for _, category in ipairs(categories) do
                self:CreatePool(category)
                self:Warm(category, Config.InitialPoolSize)
            end
        end

        function InstancePool:CreatePool(category, createFunc)
            if self._pools[category] then
                return self._pools[category]
            end

            local pool = PoolEntry.new(category, createFunc)
            self._pools[category] = pool

            return pool
        end

        function InstancePool:GetPool(category)
            return self._pools[category]
        end

        function InstancePool:HasPool(category)
            return self._pools[category] ~= nil
        end

        function InstancePool:Acquire(category, properties)
            local pool = self._pools[category]

            if not pool then
                pool = self:CreatePool(category)
            end

            local obj = pool:Acquire()

            -- Apply properties if provided
            if properties and obj then
                for prop, value in pairs(properties) do
                    pcall(function()
                        if prop ~= "Parent" then
                            obj[prop] = value
                        end
                    end)
                end

                -- Set parent last
                if properties.Parent then
                    obj.Parent = properties.Parent
                end
            end

            return obj
        end

        function InstancePool:Release(obj)
            if not obj then return end

            local className = obj.ClassName
            local pool = self._pools[className]

            if pool then
                pool:Release(obj)
            else
                -- No pool for this type, just destroy
                pcall(function()
                    obj:Destroy()
                end)
            end
        end

        function InstancePool:ReleaseAll(objects)
            for _, obj in ipairs(objects) do
                self:Release(obj)
            end
        end

        function InstancePool:Warm(category, count)
            local pool = self._pools[category]

            if not pool then
                pool = self:CreatePool(category)
            end

            pool:Warm(count)
        end

        function InstancePool:WarmAll(count)
            for _, pool in pairs(self._pools) do
                pool:Warm(count)
            end
        end

        function InstancePool:Shrink(category)
            if category then
                local pool = self._pools[category]
                if pool then
                    pool:Shrink()
                end
            else
                for _, pool in pairs(self._pools) do
                    pool:Shrink()
                end
            end
        end

        function InstancePool:Clear(category)
            if category then
                local pool = self._pools[category]
                if pool then
                    pool:Clear()
                end
            else
                for _, pool in pairs(self._pools) do
                    pool:Clear()
                end
            end
        end

        function InstancePool:SetCustomCreator(category, createFunc)
            self._customCreators[category] = createFunc

            local pool = self._pools[category]
            if pool then
                pool.CreateFunc = createFunc
            end
        end

        --// Statistics
        function InstancePool:GetStats()
            local poolStats = {}

            for category, pool in pairs(self._pools) do
                poolStats[category] = {
                    Available = pool:GetAvailableCount(),
                    InUse = pool:GetInUseCount(),
                    TotalCreated = pool.TotalCreated,
                }
            end

            return {
                Global = {
                    TotalCreated = Stats.TotalCreated,
                    TotalRecycled = Stats.TotalRecycled,
                    TotalAcquired = Stats.TotalAcquired,
                    TotalReleased = Stats.TotalReleased,
                    CacheHits = Stats.CacheHits,
                    CacheMisses = Stats.CacheMisses,
                    HitRate = Stats.CacheHits / math.max(Stats.CacheHits + Stats.CacheMisses, 1),
                },
                Pools = poolStats,
            }
        end

        function InstancePool:GetHitRate()
            local total = Stats.CacheHits + Stats.CacheMisses
            if total == 0 then return 1 end
            return Stats.CacheHits / total
        end

        function InstancePool:GetTotalAvailable()
            local total = 0
            for _, pool in pairs(self._pools) do
                total = total + pool:GetAvailableCount()
            end
            return total
        end

        function InstancePool:GetTotalInUse()
            local total = 0
            for _, pool in pairs(self._pools) do
                total = total + pool:GetInUseCount()
            end
            return total
        end

        function InstancePool:ResetStats()
            Stats.TotalCreated = 0
            Stats.TotalRecycled = 0
            Stats.TotalAcquired = 0
            Stats.TotalReleased = 0
            Stats.CacheHits = 0
            Stats.CacheMisses = 0
        end

        --// Configuration
        function InstancePool:SetConfig(key, value)
            if Config[key] ~= nil then
                Config[key] = value
            end
        end

        function InstancePool:GetConfig(key)
            return Config[key]
        end

        --// Debug
        function InstancePool:PrintStats()
            local stats = self:GetStats()

            print("=== Instance Pool Statistics ===")
            print(string.format("Total Created: %d", stats.Global.TotalCreated))
            print(string.format("Total Recycled: %d", stats.Global.TotalRecycled))
            print(string.format("Cache Hit Rate: %.2f%%", stats.Global.HitRate * 100))
            print("")
            print("Pool Breakdown:")

            for category, poolStats in pairs(stats.Pools) do
                print(string.format("  %s: %d available, %d in use, %d created",
                    category,
                    poolStats.Available,
                    poolStats.InUse,
                    poolStats.TotalCreated
                ))
            end
        end

        --// Cleanup
        function InstancePool:Destroy()
            self:Clear()
            self._pools = {}
            self._customCreators = {}
        end

        --// Convenience Methods (static-like access)
        function InstancePool.Get(category, properties)
            return InstancePool.GetInstance():Acquire(category, properties)
        end

        function InstancePool.Return(obj)
            return InstancePool.GetInstance():Release(obj)
        end

        --// Export singleton instance
        return InstancePool.GetInstance()


    end


    -- ============================================================================
    -- Module: NexusUI/Core/ScreenGui
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/ScreenGui"] = function()
        local script = CreateMockScript("NexusUI/Core/ScreenGui")

        --[[
            NexusUI ScreenGui Manager
            Manages ScreenGui instances and container hierarchy

            Features:
            - Safe ScreenGui creation (CoreGui/PlayerGui fallback)
            - Layer management
            - Container organization
            - Display order management
            - Visibility control
            - Safe destruction
        ]]

        --// Services
        local Players = game:GetService("Players")
        local CoreGui = game:GetService("CoreGui")
        local RunService = game:GetService("RunService")

        --// Dependencies
        local Constants = NexusRequire("NexusUI/Constants")

        --// Local Player
        local LocalPlayer = Players.LocalPlayer
        local PlayerGui = LocalPlayer and LocalPlayer:WaitForChild("PlayerGui", 5)

        --// ScreenGui Manager Class
        local ScreenGuiManager = {}
        ScreenGuiManager.__index = ScreenGuiManager
        ScreenGuiManager.ClassName = "ScreenGuiManager"

        --// Configuration
        local Config = {
            LibraryName = "NexusUI",
            BaseDisplayOrder = 999999,
            UsesCoreGui = true,
            IgnoreGuiInset = true,
            ResetOnSpawn = false,
            ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
        }

        --// Container Definitions
        local ContainerDefinitions = {
            Main = {
                Name = "MainContainer",
                ZIndex = Constants.ZIndex.Base,
                Order = 1,
            },
            Windows = {
                Name = "WindowContainer",
                ZIndex = Constants.ZIndex.Component,
                Order = 2,
            },
            Dropdowns = {
                Name = "DropdownContainer",
                ZIndex = Constants.ZIndex.Dropdown,
                Order = 3,
            },
            Popovers = {
                Name = "PopoverContainer",
                ZIndex = Constants.ZIndex.Popover,
                Order = 4,
            },
            Modals = {
                Name = "ModalContainer",
                ZIndex = Constants.ZIndex.Modal,
                Order = 5,
            },
            Toasts = {
                Name = "ToastContainer",
                ZIndex = Constants.ZIndex.Toast,
                Order = 6,
            },
            Tooltips = {
                Name = "TooltipContainer",
                ZIndex = Constants.ZIndex.Tooltip,
                Order = 7,
            },
            ContextMenus = {
                Name = "ContextMenuContainer",
                ZIndex = Constants.ZIndex.ContextMenu,
                Order = 8,
            },
            Overlays = {
                Name = "OverlayContainer",
                ZIndex = Constants.ZIndex.Overlay,
                Order = 9,
            },
            Performance = {
                Name = "PerformanceContainer",
                ZIndex = Constants.ZIndex.PerformanceMonitor,
                Order = 10,
            },
            Watermarks = {
                Name = "WatermarkContainer",
                ZIndex = Constants.ZIndex.Watermark,
                Order = 11,
            },
            ESP = {
                Name = "ESPContainer",
                ZIndex = Constants.ZIndex.Maximum,
                Order = 12,
            },
        }

        --// Singleton Instance
        local instance = nil

        --// ScreenGui Manager Implementation
        function ScreenGuiManager.new()
            local self = setmetatable({}, ScreenGuiManager)

            self._screenGui = nil
            self._containers = {}
            self._visible = true
            self._destroyed = false
            self._parent = nil

            return self
        end

        function ScreenGuiManager.GetInstance()
            if not instance then
                instance = ScreenGuiManager.new()
            end
            return instance
        end

        --// Initialization
        function ScreenGuiManager:Initialize(config)
            if self._screenGui and self._screenGui.Parent then
                return self._screenGui
            end

            -- Apply config
            if config then
                for key, value in pairs(config) do
                    if Config[key] ~= nil then
                        Config[key] = value
                    end
                end
            end

            -- Create ScreenGui
            self._screenGui = self:_createScreenGui()

            -- Create containers
            self:_createContainers()

            return self._screenGui
        end

        function ScreenGuiManager:_createScreenGui()
            -- Clean up existing
            self:_cleanupExisting()

            -- Create new ScreenGui
            local screenGui = Instance.new("ScreenGui")
            screenGui.Name = Config.LibraryName
            screenGui.DisplayOrder = Config.BaseDisplayOrder
            screenGui.IgnoreGuiInset = Config.IgnoreGuiInset
            screenGui.ResetOnSpawn = Config.ResetOnSpawn
            screenGui.ZIndexBehavior = Config.ZIndexBehavior

            -- Try CoreGui first
            if Config.UsesCoreGui then
                local success = pcall(function()
                    screenGui.Parent = CoreGui
                end)

                if success then
                    self._parent = CoreGui
                    return screenGui
                end
            end

            -- Fallback to PlayerGui
            if PlayerGui then
                screenGui.Parent = PlayerGui
                self._parent = PlayerGui
            else
                warn("[NexusUI.ScreenGui] Could not find suitable parent for ScreenGui")
            end

            return screenGui
        end

        function ScreenGuiManager:_cleanupExisting()
            -- Clean from CoreGui
            local existingCore = CoreGui:FindFirstChild(Config.LibraryName)
            if existingCore then
                pcall(function()
                    existingCore:Destroy()
                end)
            end

            -- Clean from PlayerGui
            if PlayerGui then
                local existingPlayer = PlayerGui:FindFirstChild(Config.LibraryName)
                if existingPlayer then
                    pcall(function()
                        existingPlayer:Destroy()
                    end)
                end
            end
        end

        function ScreenGuiManager:_createContainers()
            if not self._screenGui then return end

            -- Sort by order
            local sortedDefs = {}
            for key, def in pairs(ContainerDefinitions) do
                table.insert(sortedDefs, { Key = key, Definition = def })
            end

            table.sort(sortedDefs, function(a, b)
                return a.Definition.Order < b.Definition.Order
            end)

            -- Create containers
            for _, entry in ipairs(sortedDefs) do
                local def = entry.Definition

                local container = Instance.new("Frame")
                container.Name = def.Name
                container.BackgroundTransparency = 1
                container.Size = UDim2.fromScale(1, 1)
                container.Position = UDim2.fromScale(0, 0)
                container.ZIndex = def.ZIndex
                container.Parent = self._screenGui

                self._containers[entry.Key] = container
            end
        end

        --// Container Access
        function ScreenGuiManager:GetContainer(containerName)
            return self._containers[containerName]
        end

        function ScreenGuiManager:GetMainContainer()
            return self._containers.Main
        end

        function ScreenGuiManager:GetWindowContainer()
            return self._containers.Windows
        end

        function ScreenGuiManager:GetDropdownContainer()
            return self._containers.Dropdowns
        end

        function ScreenGuiManager:GetPopoverContainer()
            return self._containers.Popovers
        end

        function ScreenGuiManager:GetModalContainer()
            return self._containers.Modals
        end

        function ScreenGuiManager:GetToastContainer()
            return self._containers.Toasts
        end

        function ScreenGuiManager:GetTooltipContainer()
            return self._containers.Tooltips
        end

        function ScreenGuiManager:GetContextMenuContainer()
            return self._containers.ContextMenus
        end

        function ScreenGuiManager:GetOverlayContainer()
            return self._containers.Overlays
        end

        function ScreenGuiManager:GetPerformanceContainer()
            return self._containers.Performance
        end

        function ScreenGuiManager:GetWatermarkContainer()
            return self._containers.Watermarks
        end

        function ScreenGuiManager:GetESPContainer()
            return self._containers.ESP
        end

        function ScreenGuiManager:GetAllContainers()
            local copy = {}
            for key, container in pairs(self._containers) do
                copy[key] = container
            end
            return copy
        end

        --// ScreenGui Access
        function ScreenGuiManager:GetScreenGui()
            return self._screenGui
        end

        function ScreenGuiManager:GetParent()
            return self._parent
        end

        function ScreenGuiManager:IsUsingCoreGui()
            return self._parent == CoreGui
        end

        --// Visibility Control
        function ScreenGuiManager:SetVisible(visible)
            self._visible = visible

            if self._screenGui then
                self._screenGui.Enabled = visible
            end
        end

        function ScreenGuiManager:IsVisible()
            return self._visible and self._screenGui and self._screenGui.Enabled
        end

        function ScreenGuiManager:Toggle()
            self:SetVisible(not self._visible)
            return self._visible
        end

        function ScreenGuiManager:Show()
            self:SetVisible(true)
        end

        function ScreenGuiManager:Hide()
            self:SetVisible(false)
        end

        --// Container Visibility
        function ScreenGuiManager:SetContainerVisible(containerName, visible)
            local container = self._containers[containerName]
            if container then
                container.Visible = visible
            end
        end

        function ScreenGuiManager:IsContainerVisible(containerName)
            local container = self._containers[containerName]
            return container and container.Visible
        end

        function ScreenGuiManager:ShowContainer(containerName)
            self:SetContainerVisible(containerName, true)
        end

        function ScreenGuiManager:HideContainer(containerName)
            self:SetContainerVisible(containerName, false)
        end

        --// Display Order
        function ScreenGuiManager:SetDisplayOrder(order)
            if self._screenGui then
                self._screenGui.DisplayOrder = order
            end
        end

        function ScreenGuiManager:GetDisplayOrder()
            return self._screenGui and self._screenGui.DisplayOrder or 0
        end

        function ScreenGuiManager:BringToFront()
            self:SetDisplayOrder(Config.BaseDisplayOrder + 1000)
        end

        --// ZIndex Management
        function ScreenGuiManager:SetContainerZIndex(containerName, zIndex)
            local container = self._containers[containerName]
            if container then
                container.ZIndex = zIndex
            end
        end

        function ScreenGuiManager:GetContainerZIndex(containerName)
            local container = self._containers[containerName]
            return container and container.ZIndex or 0
        end

        --// Screen Information
        function ScreenGuiManager:GetScreenSize()
            if self._screenGui then
                return self._screenGui.AbsoluteSize
            end

            local camera = workspace.CurrentCamera
            if camera then
                return camera.ViewportSize
            end

            return Vector2.new(1920, 1080)
        end

        function ScreenGuiManager:GetScreenCenter()
            local size = self:GetScreenSize()
            return Vector2.new(size.X / 2, size.Y / 2)
        end

        function ScreenGuiManager:GetGuiInset()
            local GuiService = game:GetService("GuiService")
            local inset, _ = GuiService:GetGuiInset()
            return inset
        end

        --// Safe Instance Creation
        function ScreenGuiManager:CreateInContainer(containerName, instanceType, properties)
            local container = self._containers[containerName]
            if not container then
                warn(string.format("[NexusUI.ScreenGui] Container '%s' not found", containerName))
                return nil
            end

            local instance = Instance.new(instanceType)

            if properties then
                for prop, value in pairs(properties) do
                    if prop ~= "Parent" then
                        pcall(function()
                            instance[prop] = value
                        end)
                    end
                end
            end

            instance.Parent = container

            return instance
        end

        --// Cleanup
        function ScreenGuiManager:ClearContainer(containerName)
            local container = self._containers[containerName]
            if container then
                for _, child in ipairs(container:GetChildren()) do
                    pcall(function()
                        child:Destroy()
                    end)
                end
            end
        end

        function ScreenGuiManager:ClearAllContainers()
            for containerName, _ in pairs(self._containers) do
                self:ClearContainer(containerName)
            end
        end

        function ScreenGuiManager:Destroy()
            if self._destroyed then return end

            self._destroyed = true

            -- Clear containers
            self:ClearAllContainers()
            self._containers = {}

            -- Destroy ScreenGui
            if self._screenGui then
                pcall(function()
                    self._screenGui:Destroy()
                end)
                self._screenGui = nil
            end

            self._parent = nil
        end

        function ScreenGuiManager:IsDestroyed()
            return self._destroyed
        end

        --// Reinitialization
        function ScreenGuiManager:Reinitialize(config)
            self:Destroy()
            self._destroyed = false
            return self:Initialize(config)
        end

        --// Configuration
        function ScreenGuiManager:SetConfig(key, value)
            if Config[key] ~= nil then
                Config[key] = value
            end
        end

        function ScreenGuiManager:GetConfig(key)
            return Config[key]
        end

        --// Debug
        function ScreenGuiManager:PrintInfo()
            print("=== ScreenGui Manager Info ===")
            print(string.format("ScreenGui: %s", self._screenGui and self._screenGui.Name or "None"))
            print(string.format("Parent: %s", self._parent and self._parent.Name or "None"))
            print(string.format("Visible: %s", tostring(self._visible)))
            print(string.format("Display Order: %d", self:GetDisplayOrder()))
            print(string.format("Screen Size: %s", tostring(self:GetScreenSize())))
            print("")
            print("Containers:")
            for name, container in pairs(self._containers) do
                local childCount = #container:GetChildren()
                print(string.format("  %s: %d children, ZIndex %d, Visible %s",
                    name, childCount, container.ZIndex, tostring(container.Visible)))
            end
        end

        --// Export singleton instance
        return ScreenGuiManager.GetInstance()


    end


    -- ============================================================================
    -- Module: NexusUI/Core/Utility/Math
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/Utility/Math"] = function()
        local script = CreateMockScript("NexusUI/Core/Utility/Math")

        --[[
            NexusUI Math Utilities
            Advanced mathematical functions for UI calculations

            Features:
            - Basic math operations
            - Interpolation functions
            - Geometric calculations
            - Random number generation
            - Vector math
            - Statistical functions
        ]]

        --// Math Utility Module
        local MathUtil = {}

        --// Constants
        MathUtil.PI = math.pi
        MathUtil.TAU = math.pi * 2
        MathUtil.E = 2.718281828459045
        MathUtil.PHI = 1.618033988749895 -- Golden ratio
        MathUtil.EPSILON = 1e-10
        MathUtil.DEG_TO_RAD = math.pi / 180
        MathUtil.RAD_TO_DEG = 180 / math.pi

        --// Basic Operations
        function MathUtil.Clamp(value, min, max)
            return math.max(min, math.min(max, value))
        end

        function MathUtil.Round(value, decimals)
            decimals = decimals or 0
            local mult = 10 ^ decimals
            return math.floor(value * mult + 0.5) / mult
        end

        function MathUtil.Floor(value, decimals)
            decimals = decimals or 0
            local mult = 10 ^ decimals
            return math.floor(value * mult) / mult
        end

        function MathUtil.Ceil(value, decimals)
            decimals = decimals or 0
            local mult = 10 ^ decimals
            return math.ceil(value * mult) / mult
        end

        function MathUtil.Sign(value)
            if value > 0 then return 1
            elseif value < 0 then return -1
            else return 0 end
        end

        function MathUtil.Abs(value)
            return math.abs(value)
        end

        function MathUtil.Min(...)
            return math.min(...)
        end

        function MathUtil.Max(...)
            return math.max(...)
        end

        function MathUtil.Mod(a, b)
            return a % b
        end

        function MathUtil.Pow(base, exponent)
            return base ^ exponent
        end

        function MathUtil.Sqrt(value)
            return math.sqrt(value)
        end

        function MathUtil.Cbrt(value)
            return value ^ (1/3)
        end

        function MathUtil.Log(value, base)
            base = base or math.exp(1)
            return math.log(value) / math.log(base)
        end

        function MathUtil.Log10(value)
            return math.log10(value)
        end

        function MathUtil.Exp(value)
            return math.exp(value)
        end

        --// Interpolation
        function MathUtil.Lerp(a, b, t)
            return a + (b - a) * t
        end

        function MathUtil.InverseLerp(a, b, value)
            if a == b then return 0 end
            return (value - a) / (b - a)
        end

        function MathUtil.Map(value, inMin, inMax, outMin, outMax)
            return outMin + (value - inMin) * (outMax - outMin) / (inMax - inMin)
        end

        function MathUtil.MapClamped(value, inMin, inMax, outMin, outMax)
            local t = MathUtil.Clamp((value - inMin) / (inMax - inMin), 0, 1)
            return outMin + t * (outMax - outMin)
        end

        function MathUtil.SmoothStep(edge0, edge1, x)
            local t = MathUtil.Clamp((x - edge0) / (edge1 - edge0), 0, 1)
            return t * t * (3 - 2 * t)
        end

        function MathUtil.SmootherStep(edge0, edge1, x)
            local t = MathUtil.Clamp((x - edge0) / (edge1 - edge0), 0, 1)
            return t * t * t * (t * (t * 6 - 15) + 10)
        end

        function MathUtil.CosineInterpolate(a, b, t)
            local ft = t * MathUtil.PI
            local f = (1 - math.cos(ft)) * 0.5
            return a * (1 - f) + b * f
        end

        function MathUtil.CubicInterpolate(y0, y1, y2, y3, t)
            local t2 = t * t
            local a0 = y3 - y2 - y0 + y1
            local a1 = y0 - y1 - a0
            local a2 = y2 - y0
            local a3 = y1
            return a0 * t * t2 + a1 * t2 + a2 * t + a3
        end

        function MathUtil.Hermite(p0, p1, m0, m1, t)
            local t2 = t * t
            local t3 = t2 * t
            local h00 = 2*t3 - 3*t2 + 1
            local h10 = t3 - 2*t2 + t
            local h01 = -2*t3 + 3*t2
            local h11 = t3 - t2
            return h00*p0 + h10*m0 + h01*p1 + h11*m1
        end

        --// Angle Operations
        function MathUtil.DegToRad(degrees)
            return degrees * MathUtil.DEG_TO_RAD
        end

        function MathUtil.RadToDeg(radians)
            return radians * MathUtil.RAD_TO_DEG
        end

        function MathUtil.NormalizeAngle(angle)
            angle = angle % MathUtil.TAU
            if angle < 0 then
                angle = angle + MathUtil.TAU
            end
            return angle
        end

        function MathUtil.AngleDifference(a, b)
            local diff = (b - a) % MathUtil.TAU
            if diff > MathUtil.PI then
                diff = diff - MathUtil.TAU
            end
            return diff
        end

        function MathUtil.LerpAngle(a, b, t)
            local diff = MathUtil.AngleDifference(a, b)
            return a + diff * t
        end

        function MathUtil.Sin(angle)
            return math.sin(angle)
        end

        function MathUtil.Cos(angle)
            return math.cos(angle)
        end

        function MathUtil.Tan(angle)
            return math.tan(angle)
        end

        function MathUtil.Asin(value)
            return math.asin(value)
        end

        function MathUtil.Acos(value)
            return math.acos(value)
        end

        function MathUtil.Atan(value)
            return math.atan(value)
        end

        function MathUtil.Atan2(y, x)
            return math.atan2(y, x)
        end

        --// Random Numbers
        function MathUtil.Random(min, max)
            if min and max then
                return math.random() * (max - min) + min
            elseif min then
                return math.random() * min
            else
                return math.random()
            end
        end

        function MathUtil.RandomInt(min, max)
            return math.random(min, max)
        end

        function MathUtil.RandomBool(probability)
            probability = probability or 0.5
            return math.random() < probability
        end

        function MathUtil.RandomSign()
            return math.random() < 0.5 and -1 or 1
        end

        function MathUtil.RandomInRange(range)
            return MathUtil.Random(-range, range)
        end

        function MathUtil.RandomGaussian(mean, standardDeviation)
            mean = mean or 0
            standardDeviation = standardDeviation or 1

            -- Box-Muller transform
            local u1 = math.random()
            local u2 = math.random()
            local z0 = math.sqrt(-2 * math.log(u1)) * math.cos(MathUtil.TAU * u2)

            return mean + z0 * standardDeviation
        end

        function MathUtil.RandomFromArray(array)
            return array[math.random(#array)]
        end

        function MathUtil.RandomWeighted(weights)
            local total = 0
            for _, weight in pairs(weights) do
                total = total + weight
            end

            local random = math.random() * total
            local cumulative = 0

            for key, weight in pairs(weights) do
                cumulative = cumulative + weight
                if random <= cumulative then
                    return key
                end
            end
        end

        --// Vector Operations (2D)
        function MathUtil.Vector2Length(x, y)
            return math.sqrt(x * x + y * y)
        end

        function MathUtil.Vector2LengthSquared(x, y)
            return x * x + y * y
        end

        function MathUtil.Vector2Normalize(x, y)
            local length = MathUtil.Vector2Length(x, y)
            if length == 0 then
                return 0, 0
            end
            return x / length, y / length
        end

        function MathUtil.Vector2Dot(x1, y1, x2, y2)
            return x1 * x2 + y1 * y2
        end

        function MathUtil.Vector2Cross(x1, y1, x2, y2)
            return x1 * y2 - y1 * x2
        end

        function MathUtil.Vector2Distance(x1, y1, x2, y2)
            local dx = x2 - x1
            local dy = y2 - y1
            return math.sqrt(dx * dx + dy * dy)
        end

        function MathUtil.Vector2DistanceSquared(x1, y1, x2, y2)
            local dx = x2 - x1
            local dy = y2 - y1
            return dx * dx + dy * dy
        end

        function MathUtil.Vector2Angle(x, y)
            return math.atan2(y, x)
        end

        function MathUtil.Vector2FromAngle(angle, length)
            length = length or 1
            return math.cos(angle) * length, math.sin(angle) * length
        end

        function MathUtil.Vector2Rotate(x, y, angle)
            local cos = math.cos(angle)
            local sin = math.sin(angle)
            return x * cos - y * sin, x * sin + y * cos
        end

        function MathUtil.Vector2Lerp(x1, y1, x2, y2, t)
            return MathUtil.Lerp(x1, x2, t), MathUtil.Lerp(y1, y2, t)
        end

        function MathUtil.Vector2Reflect(x, y, nx, ny)
            local dot = MathUtil.Vector2Dot(x, y, nx, ny)
            return x - 2 * dot * nx, y - 2 * dot * ny
        end

        --// Geometry
        function MathUtil.PointInRect(px, py, rx, ry, rw, rh)
            return px >= rx and px <= rx + rw and py >= ry and py <= ry + rh
        end

        function MathUtil.PointInCircle(px, py, cx, cy, radius)
            return MathUtil.Vector2DistanceSquared(px, py, cx, cy) <= radius * radius
        end

        function MathUtil.RectOverlap(r1x, r1y, r1w, r1h, r2x, r2y, r2w, r2h)
            return r1x < r2x + r2w and r1x + r1w > r2x and r1y < r2y + r2h and r1y + r1h > r2y
        end

        function MathUtil.CircleOverlap(c1x, c1y, r1, c2x, c2y, r2)
            local dist = MathUtil.Vector2Distance(c1x, c1y, c2x, c2y)
            return dist < r1 + r2
        end

        function MathUtil.LineIntersection(x1, y1, x2, y2, x3, y3, x4, y4)
            local d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)

            if math.abs(d) < MathUtil.EPSILON then
                return nil -- Lines are parallel
            end

            local t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / d
            local x = x1 + t * (x2 - x1)
            local y = y1 + t * (y2 - y1)

            return x, y
        end

        function MathUtil.ClosestPointOnLine(px, py, x1, y1, x2, y2)
            local dx = x2 - x1
            local dy = y2 - y1
            local lengthSquared = dx * dx + dy * dy

            if lengthSquared == 0 then
                return x1, y1
            end

            local t = MathUtil.Clamp(((px - x1) * dx + (py - y1) * dy) / lengthSquared, 0, 1)

            return x1 + t * dx, y1 + t * dy
        end

        --// Statistics
        function MathUtil.Sum(values)
            local sum = 0
            for _, v in ipairs(values) do
                sum = sum + v
            end
            return sum
        end

        function MathUtil.Mean(values)
            if #values == 0 then return 0 end
            return MathUtil.Sum(values) / #values
        end

        function MathUtil.Median(values)
            if #values == 0 then return 0 end

            local sorted = {}
            for _, v in ipairs(values) do
                table.insert(sorted, v)
            end
            table.sort(sorted)

            local mid = math.floor(#sorted / 2)

            if #sorted % 2 == 0 then
                return (sorted[mid] + sorted[mid + 1]) / 2
            else
                return sorted[mid + 1]
            end
        end

        function MathUtil.Mode(values)
            if #values == 0 then return nil end

            local counts = {}
            local maxCount = 0
            local mode = nil

            for _, v in ipairs(values) do
                counts[v] = (counts[v] or 0) + 1
                if counts[v] > maxCount then
                    maxCount = counts[v]
                    mode = v
                end
            end

            return mode
        end

        function MathUtil.Variance(values)
            if #values == 0 then return 0 end

            local mean = MathUtil.Mean(values)
            local sumSquares = 0

            for _, v in ipairs(values) do
                sumSquares = sumSquares + (v - mean) ^ 2
            end

            return sumSquares / #values
        end

        function MathUtil.StandardDeviation(values)
            return math.sqrt(MathUtil.Variance(values))
        end

        function MathUtil.Range(values)
            if #values == 0 then return 0 end

            local min, max = values[1], values[1]

            for _, v in ipairs(values) do
                if v < min then min = v end
                if v > max then max = v end
            end

            return max - min
        end

        --// Easing (basic)
        function MathUtil.EaseLinear(t)
            return t
        end

        function MathUtil.EaseInQuad(t)
            return t * t
        end

        function MathUtil.EaseOutQuad(t)
            return 1 - (1 - t) * (1 - t)
        end

        function MathUtil.EaseInOutQuad(t)
            if t < 0.5 then
                return 2 * t * t
            else
                return 1 - (-2 * t + 2) ^ 2 / 2
            end
        end

        function MathUtil.EaseInCubic(t)
            return t * t * t
        end

        function MathUtil.EaseOutCubic(t)
            return 1 - (1 - t) ^ 3
        end

        function MathUtil.EaseInOutCubic(t)
            if t < 0.5 then
                return 4 * t * t * t
            else
                return 1 - (-2 * t + 2) ^ 3 / 2
            end
        end

        --// Utility
        function MathUtil.IsNaN(value)
            return value ~= value
        end

        function MathUtil.IsInfinite(value)
            return value == math.huge or value == -math.huge
        end

        function MathUtil.IsFinite(value)
            return not MathUtil.IsNaN(value) and not MathUtil.IsInfinite(value)
        end

        function MathUtil.Approximately(a, b, epsilon)
            epsilon = epsilon or MathUtil.EPSILON
            return math.abs(a - b) <= epsilon
        end

        function MathUtil.Wrap(value, min, max)
            local range = max - min
            return ((value - min) % range) + min
        end

        function MathUtil.PingPong(value, length)
            local t = value % (length * 2)
            return length - math.abs(t - length)
        end

        return MathUtil


    end


    -- ============================================================================
    -- Module: NexusUI/Core/Utility/String
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/Utility/String"] = function()
        local script = CreateMockScript("NexusUI/Core/Utility/String")

        --[[
            NexusUI String Utilities
            Comprehensive string manipulation functions

            Features:
            - Basic string operations
            - Formatting and templating
            - Parsing and extraction
            - Validation
            - Encoding utilities
        ]]

        --// String Utility Module
        local StringUtil = {}

        --// Basic Operations
        function StringUtil.Trim(str)
            return str:match("^%s*(.-)%s*$")
        end

        function StringUtil.TrimLeft(str)
            return str:match("^%s*(.-)$")
        end

        function StringUtil.TrimRight(str)
            return str:match("^(.-)%s*$")
        end

        function StringUtil.ToLower(str)
            return str:lower()
        end

        function StringUtil.ToUpper(str)
            return str:upper()
        end

        function StringUtil.Capitalize(str)
            return str:sub(1, 1):upper() .. str:sub(2):lower()
        end

        function StringUtil.CapitalizeWords(str)
            return str:gsub("(%a)([%w]*)", function(first, rest)
                return first:upper() .. rest:lower()
            end)
        end

        function StringUtil.Reverse(str)
            return str:reverse()
        end

        function StringUtil.Repeat(str, count)
            return str:rep(count)
        end

        function StringUtil.PadLeft(str, length, char)
            char = char or " "
            if #str >= length then return str end
            return string.rep(char, length - #str) .. str
        end

        function StringUtil.PadRight(str, length, char)
            char = char or " "
            if #str >= length then return str end
            return str .. string.rep(char, length - #str)
        end

        function StringUtil.PadCenter(str, length, char)
            char = char or " "
            if #str >= length then return str end

            local padding = length - #str
            local leftPad = math.floor(padding / 2)
            local rightPad = padding - leftPad

            return string.rep(char, leftPad) .. str .. string.rep(char, rightPad)
        end

        --// Splitting and Joining
        function StringUtil.Split(str, delimiter, limit)
            delimiter = delimiter or ","
            limit = limit or math.huge

            local result = {}
            local pattern = "([^" .. delimiter .. "]*)" .. delimiter .. "?"

            for match in str:gmatch(pattern) do
                table.insert(result, match)
                if #result >= limit then break end
            end

            -- Remove trailing empty string if present
            if result[#result] == "" and #result > 1 then
                table.remove(result)
            end

            return result
        end

        function StringUtil.SplitByPattern(str, pattern)
            local result = {}
            local lastEnd = 1

            for start, finish in function() return str:find(pattern, lastEnd) end do
                table.insert(result, str:sub(lastEnd, start - 1))
                lastEnd = finish + 1
            end

            table.insert(result, str:sub(lastEnd))

            return result
        end

        function StringUtil.Join(strings, delimiter)
            delimiter = delimiter or ","
            return table.concat(strings, delimiter)
        end

        function StringUtil.Lines(str)
            return StringUtil.Split(str, "\n")
        end

        function StringUtil.Words(str)
            local words = {}
            for word in str:gmatch("%S+") do
                table.insert(words, word)
            end
            return words
        end

        function StringUtil.Chars(str)
            local chars = {}
            for i = 1, #str do
                table.insert(chars, str:sub(i, i))
            end
            return chars
        end

        --// Search and Replace
        function StringUtil.Contains(str, substring)
            return str:find(substring, 1, true) ~= nil
        end

        function StringUtil.StartsWith(str, prefix)
            return str:sub(1, #prefix) == prefix
        end

        function StringUtil.EndsWith(str, suffix)
            return str:sub(-#suffix) == suffix
        end

        function StringUtil.IndexOf(str, substring, startIndex)
            startIndex = startIndex or 1
            local index = str:find(substring, startIndex, true)
            return index or -1
        end

        function StringUtil.LastIndexOf(str, substring)
            local lastIndex = -1
            local startIndex = 1

            while true do
                local index = str:find(substring, startIndex, true)
                if not index then break end
                lastIndex = index
                startIndex = index + 1
            end

            return lastIndex
        end

        function StringUtil.Replace(str, search, replacement, count)
            if count then
                local result = str
                for i = 1, count do
                    result = result:gsub(search, replacement, 1)
                end
                return result
            else
                return str:gsub(search, replacement)
            end
        end

        function StringUtil.ReplaceFirst(str, search, replacement)
            return str:gsub(search, replacement, 1)
        end

        function StringUtil.Remove(str, pattern)
            return str:gsub(pattern, "")
        end

        function StringUtil.Count(str, substring)
            local count = 0
            local startIndex = 1

            while true do
                local index = str:find(substring, startIndex, true)
                if not index then break end
                count = count + 1
                startIndex = index + 1
            end

            return count
        end

        --// Substring Operations
        function StringUtil.Substring(str, startIndex, endIndex)
            return str:sub(startIndex, endIndex)
        end

        function StringUtil.Left(str, count)
            return str:sub(1, count)
        end

        function StringUtil.Right(str, count)
            return str:sub(-count)
        end

        function StringUtil.Mid(str, startIndex, length)
            return str:sub(startIndex, startIndex + length - 1)
        end

        function StringUtil.Truncate(str, maxLength, suffix)
            suffix = suffix or "..."

            if #str <= maxLength then
                return str
            end

            return str:sub(1, maxLength - #suffix) .. suffix
        end

        function StringUtil.TruncateWords(str, maxWords, suffix)
            suffix = suffix or "..."
            local words = StringUtil.Words(str)

            if #words <= maxWords then
                return str
            end

            local result = {}
            for i = 1, maxWords do
                table.insert(result, words[i])
            end

            return table.concat(result, " ") .. suffix
        end

        --// Case Conversion
        function StringUtil.CamelCase(str)
            local result = ""
            local capitalizeNext = false

            for i = 1, #str do
                local char = str:sub(i, i)

                if char:match("[%s_%-]") then
                    capitalizeNext = true
                elseif capitalizeNext then
                    result = result .. char:upper()
                    capitalizeNext = false
                elseif result == "" then
                    result = char:lower()
                else
                    result = result .. char
                end
            end

            return result
        end

        function StringUtil.PascalCase(str)
            local camel = StringUtil.CamelCase(str)
            return camel:sub(1, 1):upper() .. camel:sub(2)
        end

        function StringUtil.SnakeCase(str)
            local result = str:gsub("([A-Z])", "_%1"):gsub("^_", ""):lower()
            result = result:gsub("[%s%-]", "_")
            result = result:gsub("_+", "_")
            return result
        end

        function StringUtil.KebabCase(str)
            local result = str:gsub("([A-Z])", "-%1"):gsub("^%-", ""):lower()
            result = result:gsub("[%s_]", "-")
            result = result:gsub("%-+", "-")
            return result
        end

        function StringUtil.ConstantCase(str)
            return StringUtil.SnakeCase(str):upper()
        end

        function StringUtil.DotCase(str)
            local result = str:gsub("([A-Z])", ".%1"):gsub("^%.", ""):lower()
            result = result:gsub("[%s_%-]", ".")
            result = result:gsub("%.+", ".")
            return result
        end

        --// Formatting
        function StringUtil.Format(template, ...)
            return string.format(template, ...)
        end

        function StringUtil.Template(template, variables)
            return template:gsub("{([%w_]+)}", function(key)
                local value = variables[key]
                return value ~= nil and tostring(value) or "{" .. key .. "}"
            end)
        end

        function StringUtil.Interpolate(template, variables)
            return template:gsub("%${([%w_]+)}", function(key)
                local value = variables[key]
                return value ~= nil and tostring(value) or "${" .. key .. "}"
            end)
        end

        function StringUtil.NumberFormat(number, decimals, thousandsSep, decimalSep)
            decimals = decimals or 0
            thousandsSep = thousandsSep or ","
            decimalSep = decimalSep or "."

            local formatted = string.format("%." .. decimals .. "f", number)
            local intPart, decPart = formatted:match("([^%.]+)%.?(.*)")

            intPart = intPart:reverse():gsub("(%d%d%d)", "%1" .. thousandsSep):reverse()
            intPart = intPart:gsub("^" .. thousandsSep, "")

            if decPart and #decPart > 0 then
                return intPart .. decimalSep .. decPart
            else
                return intPart
            end
        end

        function StringUtil.Pluralize(count, singular, plural)
            plural = plural or (singular .. "s")
            return count == 1 and singular or plural
        end

        --// Validation
        function StringUtil.IsEmpty(str)
            return str == nil or str == ""
        end

        function StringUtil.IsBlank(str)
            return str == nil or StringUtil.Trim(str) == ""
        end

        function StringUtil.IsNumeric(str)
            return str:match("^%-?%d+%.?%d*$") ~= nil
        end

        function StringUtil.IsInteger(str)
            return str:match("^%-?%d+$") ~= nil
        end

        function StringUtil.IsAlpha(str)
            return str:match("^%a+$") ~= nil
        end

        function StringUtil.IsAlphanumeric(str)
            return str:match("^%w+$") ~= nil
        end

        function StringUtil.IsLower(str)
            return str == str:lower() and str:match("%a") ~= nil
        end

        function StringUtil.IsUpper(str)
            return str == str:upper() and str:match("%a") ~= nil
        end

        function StringUtil.IsHex(str)
            return str:match("^#?[%x]+$") ~= nil
        end

        function StringUtil.IsEmail(str)
            return str:match("^[%w._%+-]+@[%w.-]+%.[%w]+$") ~= nil
        end

        function StringUtil.IsUrl(str)
            return str:match("^https?://[%w.-]+%.[%w]+") ~= nil
        end

        --// Encoding
        function StringUtil.EncodeBase64(str)
            local b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
            local result = {}

            local bytes = {str:byte(1, #str)}
            local padding = (3 - #bytes % 3) % 3

            for i = 1, padding do
                table.insert(bytes, 0)
            end

            for i = 1, #bytes, 3 do
                local b1, b2, b3 = bytes[i], bytes[i+1], bytes[i+2]

                local c1 = bit32.rshift(b1, 2)
                local c2 = bit32.bor(bit32.lshift(bit32.band(b1, 3), 4), bit32.rshift(b2, 4))
                local c3 = bit32.bor(bit32.lshift(bit32.band(b2, 15), 2), bit32.rshift(b3, 6))
                local c4 = bit32.band(b3, 63)

                table.insert(result, b64chars:sub(c1+1, c1+1))
                table.insert(result, b64chars:sub(c2+1, c2+1))
                table.insert(result, b64chars:sub(c3+1, c3+1))
                table.insert(result, b64chars:sub(c4+1, c4+1))
            end

            for i = 1, padding do
                result[#result - i + 1] = "="
            end

            return table.concat(result)
        end

        function StringUtil.DecodeBase64(str)
            local b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
            local b64lookup = {}

            for i = 1, #b64chars do
                b64lookup[b64chars:sub(i, i)] = i - 1
            end

            str = str:gsub("=", "")
            local result = {}

            for i = 1, #str, 4 do
                local c1 = b64lookup[str:sub(i, i)] or 0
                local c2 = b64lookup[str:sub(i+1, i+1)] or 0
                local c3 = b64lookup[str:sub(i+2, i+2)] or 0
                local c4 = b64lookup[str:sub(i+3, i+3)] or 0

                local b1 = bit32.bor(bit32.lshift(c1, 2), bit32.rshift(c2, 4))
                local b2 = bit32.bor(bit32.lshift(bit32.band(c2, 15), 4), bit32.rshift(c3, 2))
                local b3 = bit32.bor(bit32.lshift(bit32.band(c3, 3), 6), c4)

                table.insert(result, string.char(b1))
                if str:sub(i+2, i+2) ~= "" then table.insert(result, string.char(b2)) end
                if str:sub(i+3, i+3) ~= "" then table.insert(result, string.char(b3)) end
            end

            return table.concat(result)
        end

        function StringUtil.EncodeUri(str)
            return str:gsub("[^%w%-_.~]", function(char)
                return string.format("%%%02X", string.byte(char))
            end)
        end

        function StringUtil.DecodeUri(str)
            return str:gsub("%%(%x%x)", function(hex)
                return string.char(tonumber(hex, 16))
            end)
        end

        function StringUtil.EscapeHtml(str)
            local entities = {
                ["&"] = "&amp;",
                ["<"] = "&lt;",
                [">"] = "&gt;",
                ['"'] = "&quot;",
                ["'"] = "&#39;",
            }

            return str:gsub("[&<>\"']", entities)
        end

        function StringUtil.UnescapeHtml(str)
            local entities = {
                ["&amp;"] = "&",
                ["&lt;"] = "<",
                ["&gt;"] = ">",
                ["&quot;"] = '"',
                ["&#39;"] = "'",
            }

            return str:gsub("&%w+;", entities)
        end

        function StringUtil.EscapePattern(str)
            return str:gsub("([%.%+%-%*%?%^%$%(%)%[%]%%])", "%%%1")
        end

        --// Similarity and Comparison
        function StringUtil.Compare(str1, str2, ignoreCase)
            if ignoreCase then
                str1 = str1:lower()
                str2 = str2:lower()
            end

            if str1 < str2 then return -1
            elseif str1 > str2 then return 1
            else return 0 end
        end

        function StringUtil.Equals(str1, str2, ignoreCase)
            if ignoreCase then
                return str1:lower() == str2:lower()
            end
            return str1 == str2
        end

        function StringUtil.LevenshteinDistance(str1, str2)
            local len1, len2 = #str1, #str2
            local matrix = {}

            for i = 0, len1 do
                matrix[i] = {[0] = i}
            end

            for j = 0, len2 do
                matrix[0][j] = j
            end

            for i = 1, len1 do
                for j = 1, len2 do
                    local cost = str1:sub(i, i) == str2:sub(j, j) and 0 or 1
                    matrix[i][j] = math.min(
                        matrix[i-1][j] + 1,
                        matrix[i][j-1] + 1,
                        matrix[i-1][j-1] + cost
                    )
                end
            end

            return matrix[len1][len2]
        end

        function StringUtil.Similarity(str1, str2)
            local distance = StringUtil.LevenshteinDistance(str1, str2)
            local maxLen = math.max(#str1, #str2)

            if maxLen == 0 then return 1 end

            return 1 - distance / maxLen
        end

        --// Generation
        function StringUtil.Random(length, charset)
            charset = charset or "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
            local result = {}

            for i = 1, length do
                local randomIndex = math.random(1, #charset)
                table.insert(result, charset:sub(randomIndex, randomIndex))
            end

            return table.concat(result)
        end

        function StringUtil.UUID()
            local template = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx"
            return template:gsub("[xy]", function(c)
                local v = c == "x" and math.random(0, 15) or math.random(8, 11)
                return string.format("%x", v)
            end)
        end

        return StringUtil


    end


    -- ============================================================================
    -- Module: NexusUI/Core/Utility/Table
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/Utility/Table"] = function()
        local script = CreateMockScript("NexusUI/Core/Utility/Table")

        --[[
            NexusUI Table Utilities
            Comprehensive table manipulation functions

            Features:
            - Deep operations (copy, merge, compare)
            - Array operations
            - Dictionary operations
            - Functional programming helpers
            - Serialization utilities
        ]]

        --// Table Utility Module
        local TableUtil = {}

        --// Type Checking
        function TableUtil.IsTable(value)
            return type(value) == "table"
        end

        function TableUtil.IsArray(tbl)
            if type(tbl) ~= "table" then return false end

            local count = 0
            for _ in pairs(tbl) do
                count = count + 1
            end

            return count == #tbl
        end

        function TableUtil.IsDictionary(tbl)
            if type(tbl) ~= "table" then return false end
            return not TableUtil.IsArray(tbl)
        end

        function TableUtil.IsEmpty(tbl)
            return next(tbl) == nil
        end

        --// Copying
        function TableUtil.ShallowCopy(tbl)
            if type(tbl) ~= "table" then
                return tbl
            end

            local copy = {}
            for key, value in pairs(tbl) do
                copy[key] = value
            end

            return copy
        end

        function TableUtil.DeepCopy(tbl, seen)
            if type(tbl) ~= "table" then
                return tbl
            end

            seen = seen or {}

            if seen[tbl] then
                return seen[tbl]
            end

            local copy = {}
            seen[tbl] = copy

            for key, value in pairs(tbl) do
                copy[TableUtil.DeepCopy(key, seen)] = TableUtil.DeepCopy(value, seen)
            end

            return setmetatable(copy, getmetatable(tbl))
        end

        function TableUtil.Clone(tbl)
            return TableUtil.DeepCopy(tbl)
        end

        --// Merging
        function TableUtil.Merge(base, override)
            local result = TableUtil.DeepCopy(base)

            for key, value in pairs(override) do
                if type(value) == "table" and type(result[key]) == "table" then
                    result[key] = TableUtil.Merge(result[key], value)
                else
                    result[key] = value
                end
            end

            return result
        end

        function TableUtil.MergeShallow(base, override)
            local result = TableUtil.ShallowCopy(base)

            for key, value in pairs(override) do
                result[key] = value
            end

            return result
        end

        function TableUtil.MergeMany(...)
            local result = {}

            for _, tbl in ipairs({...}) do
                result = TableUtil.Merge(result, tbl)
            end

            return result
        end

        function TableUtil.Defaults(tbl, defaults)
            local result = TableUtil.DeepCopy(tbl)

            for key, value in pairs(defaults) do
                if result[key] == nil then
                    result[key] = TableUtil.DeepCopy(value)
                elseif type(value) == "table" and type(result[key]) == "table" then
                    result[key] = TableUtil.Defaults(result[key], value)
                end
            end

            return result
        end

        --// Comparison
        function TableUtil.Equals(tbl1, tbl2)
            if tbl1 == tbl2 then return true end
            if type(tbl1) ~= "table" or type(tbl2) ~= "table" then return false end

            for key, value in pairs(tbl1) do
                if type(value) == "table" then
                    if not TableUtil.Equals(value, tbl2[key]) then
                        return false
                    end
                elseif value ~= tbl2[key] then
                    return false
                end
            end

            for key, _ in pairs(tbl2) do
                if tbl1[key] == nil then
                    return false
                end
            end

            return true
        end

        function TableUtil.Contains(tbl, value)
            for _, v in pairs(tbl) do
                if v == value then
                    return true
                end
            end
            return false
        end

        function TableUtil.ContainsKey(tbl, key)
            return tbl[key] ~= nil
        end

        --// Keys and Values
        function TableUtil.Keys(tbl)
            local keys = {}
            for key, _ in pairs(tbl) do
                table.insert(keys, key)
            end
            return keys
        end

        function TableUtil.Values(tbl)
            local values = {}
            for _, value in pairs(tbl) do
                table.insert(values, value)
            end
            return values
        end

        function TableUtil.Entries(tbl)
            local entries = {}
            for key, value in pairs(tbl) do
                table.insert(entries, {key = key, value = value})
            end
            return entries
        end

        function TableUtil.FromEntries(entries)
            local tbl = {}
            for _, entry in ipairs(entries) do
                tbl[entry.key] = entry.value
            end
            return tbl
        end

        --// Counting
        function TableUtil.Count(tbl)
            local count = 0
            for _ in pairs(tbl) do
                count = count + 1
            end
            return count
        end

        function TableUtil.Length(tbl)
            return #tbl
        end

        function TableUtil.CountBy(tbl, predicate)
            local count = 0
            for key, value in pairs(tbl) do
                if predicate(value, key) then
                    count = count + 1
                end
            end
            return count
        end

        --// Searching
        function TableUtil.Find(tbl, predicate)
            for key, value in pairs(tbl) do
                if predicate(value, key) then
                    return value, key
                end
            end
            return nil
        end

        function TableUtil.FindIndex(tbl, predicate)
            for i, value in ipairs(tbl) do
                if predicate(value, i) then
                    return i
                end
            end
            return nil
        end

        function TableUtil.IndexOf(tbl, value)
            for i, v in ipairs(tbl) do
                if v == value then
                    return i
                end
            end
            return -1
        end

        function TableUtil.LastIndexOf(tbl, value)
            for i = #tbl, 1, -1 do
                if tbl[i] == value then
                    return i
                end
            end
            return -1
        end

        function TableUtil.KeyOf(tbl, value)
            for key, v in pairs(tbl) do
                if v == value then
                    return key
                end
            end
            return nil
        end

        --// Functional Operations
        function TableUtil.Map(tbl, transform)
            local result = {}

            for key, value in pairs(tbl) do
                local newValue = transform(value, key)

                if TableUtil.IsArray(tbl) then
                    table.insert(result, newValue)
                else
                    result[key] = newValue
                end
            end

            return result
        end

        function TableUtil.Filter(tbl, predicate)
            local result = {}

            for key, value in pairs(tbl) do
                if predicate(value, key) then
                    if TableUtil.IsArray(tbl) then
                        table.insert(result, value)
                    else
                        result[key] = value
                    end
                end
            end

            return result
        end

        function TableUtil.Reject(tbl, predicate)
            return TableUtil.Filter(tbl, function(value, key)
                return not predicate(value, key)
            end)
        end

        function TableUtil.Reduce(tbl, reducer, initial)
            local accumulator = initial

            for key, value in pairs(tbl) do
                accumulator = reducer(accumulator, value, key)
            end

            return accumulator
        end

        function TableUtil.ReduceRight(tbl, reducer, initial)
            local accumulator = initial

            for i = #tbl, 1, -1 do
                accumulator = reducer(accumulator, tbl[i], i)
            end

            return accumulator
        end

        function TableUtil.ForEach(tbl, callback)
            for key, value in pairs(tbl) do
                callback(value, key)
            end
        end

        function TableUtil.Every(tbl, predicate)
            for key, value in pairs(tbl) do
                if not predicate(value, key) then
                    return false
                end
            end
            return true
        end

        function TableUtil.Some(tbl, predicate)
            for key, value in pairs(tbl) do
                if predicate(value, key) then
                    return true
                end
            end
            return false
        end

        function TableUtil.None(tbl, predicate)
            return not TableUtil.Some(tbl, predicate)
        end

        --// Array Operations
        function TableUtil.Push(tbl, ...)
            for _, value in ipairs({...}) do
                table.insert(tbl, value)
            end
            return #tbl
        end

        function TableUtil.Pop(tbl)
            return table.remove(tbl)
        end

        function TableUtil.Shift(tbl)
            return table.remove(tbl, 1)
        end

        function TableUtil.Unshift(tbl, ...)
            local args = {...}
            for i = #args, 1, -1 do
                table.insert(tbl, 1, args[i])
            end
            return #tbl
        end

        function TableUtil.Concat(...)
            local result = {}
            for _, tbl in ipairs({...}) do
                for _, value in ipairs(tbl) do
                    table.insert(result, value)
                end
            end
            return result
        end

        function TableUtil.Slice(tbl, startIndex, endIndex)
            startIndex = startIndex or 1
            endIndex = endIndex or #tbl

            if startIndex < 0 then startIndex = #tbl + startIndex + 1 end
            if endIndex < 0 then endIndex = #tbl + endIndex + 1 end

            local result = {}
            for i = startIndex, endIndex do
                table.insert(result, tbl[i])
            end
            return result
        end

        function TableUtil.Splice(tbl, startIndex, deleteCount, ...)
            deleteCount = deleteCount or #tbl - startIndex + 1
            local removed = {}

            for i = 1, deleteCount do
                table.insert(removed, table.remove(tbl, startIndex))
            end

            local insertItems = {...}
            for i = #insertItems, 1, -1 do
                table.insert(tbl, startIndex, insertItems[i])
            end

            return removed
        end

        function TableUtil.Reverse(tbl)
            local result = {}
            for i = #tbl, 1, -1 do
                table.insert(result, tbl[i])
            end
            return result
        end

        function TableUtil.Sort(tbl, comparator)
            local result = TableUtil.ShallowCopy(tbl)
            table.sort(result, comparator)
            return result
        end

        function TableUtil.SortBy(tbl, key)
            return TableUtil.Sort(tbl, function(a, b)
                return a[key] < b[key]
            end)
        end

        function TableUtil.Shuffle(tbl)
            local result = TableUtil.ShallowCopy(tbl)

            for i = #result, 2, -1 do
                local j = math.random(i)
                result[i], result[j] = result[j], result[i]
            end

            return result
        end

        function TableUtil.Unique(tbl)
            local seen = {}
            local result = {}

            for _, value in ipairs(tbl) do
                if not seen[value] then
                    seen[value] = true
                    table.insert(result, value)
                end
            end

            return result
        end

        function TableUtil.UniqueBy(tbl, key)
            local seen = {}
            local result = {}

            for _, value in ipairs(tbl) do
                local k = type(key) == "function" and key(value) or value[key]
                if not seen[k] then
                    seen[k] = true
                    table.insert(result, value)
                end
            end

            return result
        end

        function TableUtil.Flatten(tbl, depth)
            depth = depth or 1
            local result = {}

            for _, value in ipairs(tbl) do
                if type(value) == "table" and depth > 0 then
                    for _, innerValue in ipairs(TableUtil.Flatten(value, depth - 1)) do
                        table.insert(result, innerValue)
                    end
                else
                    table.insert(result, value)
                end
            end

            return result
        end

        function TableUtil.FlattenDeep(tbl)
            return TableUtil.Flatten(tbl, math.huge)
        end

        --// Grouping and Partitioning
        function TableUtil.GroupBy(tbl, key)
            local result = {}

            for _, value in ipairs(tbl) do
                local k = type(key) == "function" and key(value) or value[key]

                if not result[k] then
                    result[k] = {}
                end

                table.insert(result[k], value)
            end

            return result
        end

        function TableUtil.Partition(tbl, predicate)
            local pass = {}
            local fail = {}

            for key, value in pairs(tbl) do
                if predicate(value, key) then
                    table.insert(pass, value)
                else
                    table.insert(fail, value)
                end
            end

            return pass, fail
        end

        function TableUtil.Chunk(tbl, size)
            local result = {}
            local chunk = {}

            for _, value in ipairs(tbl) do
                table.insert(chunk, value)

                if #chunk >= size then
                    table.insert(result, chunk)
                    chunk = {}
                end
            end

            if #chunk > 0 then
                table.insert(result, chunk)
            end

            return result
        end

        --// Set Operations
        function TableUtil.Union(...)
            local seen = {}
            local result = {}

            for _, tbl in ipairs({...}) do
                for _, value in ipairs(tbl) do
                    if not seen[value] then
                        seen[value] = true
                        table.insert(result, value)
                    end
                end
            end

            return result
        end

        function TableUtil.Intersection(tbl1, tbl2)
            local set = {}
            for _, value in ipairs(tbl2) do
                set[value] = true
            end

            local result = {}
            for _, value in ipairs(tbl1) do
                if set[value] then
                    table.insert(result, value)
                end
            end

            return result
        end

        function TableUtil.Difference(tbl1, tbl2)
            local set = {}
            for _, value in ipairs(tbl2) do
                set[value] = true
            end

            local result = {}
            for _, value in ipairs(tbl1) do
                if not set[value] then
                    table.insert(result, value)
                end
            end

            return result
        end

        function TableUtil.SymmetricDifference(tbl1, tbl2)
            return TableUtil.Union(
                TableUtil.Difference(tbl1, tbl2),
                TableUtil.Difference(tbl2, tbl1)
            )
        end

        --// Object Operations
        function TableUtil.Pick(tbl, keys)
            local result = {}

            for _, key in ipairs(keys) do
                result[key] = tbl[key]
            end

            return result
        end

        function TableUtil.Omit(tbl, keys)
            local keySet = {}
            for _, key in ipairs(keys) do
                keySet[key] = true
            end

            local result = {}
            for key, value in pairs(tbl) do
                if not keySet[key] then
                    result[key] = value
                end
            end

            return result
        end

        function TableUtil.Invert(tbl)
            local result = {}
            for key, value in pairs(tbl) do
                result[value] = key
            end
            return result
        end

        function TableUtil.MapKeys(tbl, transform)
            local result = {}
            for key, value in pairs(tbl) do
                result[transform(key, value)] = value
            end
            return result
        end

        function TableUtil.MapValues(tbl, transform)
            local result = {}
            for key, value in pairs(tbl) do
                result[key] = transform(value, key)
            end
            return result
        end

        --// Math Operations
        function TableUtil.Sum(tbl)
            local sum = 0
            for _, value in ipairs(tbl) do
                sum = sum + value
            end
            return sum
        end

        function TableUtil.Average(tbl)
            if #tbl == 0 then return 0 end
            return TableUtil.Sum(tbl) / #tbl
        end

        function TableUtil.Min(tbl)
            local min = nil
            for _, value in ipairs(tbl) do
                if min == nil or value < min then
                    min = value
                end
            end
            return min
        end

        function TableUtil.Max(tbl)
            local max = nil
            for _, value in ipairs(tbl) do
                if max == nil or value > max then
                    max = value
                end
            end
            return max
        end

        function TableUtil.MinBy(tbl, key)
            local min = nil
            local minValue = nil

            for _, item in ipairs(tbl) do
                local value = type(key) == "function" and key(item) or item[key]
                if minValue == nil or value < minValue then
                    minValue = value
                    min = item
                end
            end

            return min
        end

        function TableUtil.MaxBy(tbl, key)
            local max = nil
            local maxValue = nil

            for _, item in ipairs(tbl) do
                local value = type(key) == "function" and key(item) or item[key]
                if maxValue == nil or value > maxValue then
                    maxValue = value
                    max = item
                end
            end

            return max
        end

        --// Random Selection
        function TableUtil.Sample(tbl)
            if #tbl == 0 then return nil end
            return tbl[math.random(#tbl)]
        end

        function TableUtil.SampleSize(tbl, n)
            local shuffled = TableUtil.Shuffle(tbl)
            return TableUtil.Slice(shuffled, 1, math.min(n, #shuffled))
        end

        --// Safe Access
        function TableUtil.Get(tbl, path, default)
            local current = tbl

            for _, key in ipairs(type(path) == "table" and path or {path}) do
                if type(current) ~= "table" then
                    return default
                end
                current = current[key]
            end

            return current ~= nil and current or default
        end

        function TableUtil.Set(tbl, path, value)
            local keys = type(path) == "table" and path or {path}
            local current = tbl

            for i = 1, #keys - 1 do
                local key = keys[i]
                if type(current[key]) ~= "table" then
                    current[key] = {}
                end
                current = current[key]
            end

            current[keys[#keys]] = value
        end

        function TableUtil.Has(tbl, path)
            return TableUtil.Get(tbl, path) ~= nil
        end

        --// Freezing
        function TableUtil.Freeze(tbl)
            return table.freeze(tbl)
        end

        function TableUtil.DeepFreeze(tbl)
            for key, value in pairs(tbl) do
                if type(value) == "table" then
                    TableUtil.DeepFreeze(value)
                end
            end
            return table.freeze(tbl)
        end

        function TableUtil.IsFrozen(tbl)
            return table.isfrozen(tbl)
        end

        --// Clear
        function TableUtil.Clear(tbl)
            for key in pairs(tbl) do
                tbl[key] = nil
            end
            return tbl
        end

        function TableUtil.Assign(target, ...)
            for _, source in ipairs({...}) do
                for key, value in pairs(source) do
                    target[key] = value
                end
            end
            return target
        end

        return TableUtil


    end


    -- ============================================================================
    -- Module: NexusUI/Core/Utility/Color
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/Utility/Color"] = function()
        local script = CreateMockScript("NexusUI/Core/Utility/Color")

        --[[
            NexusUI Color Utilities
            Comprehensive color manipulation and conversion functions

            Features:
            - Color space conversions (RGB, HSV, HSL, HEX)
            - Color manipulation (lighten, darken, saturate, etc.)
            - Color blending and mixing
            - Palette generation
            - Accessibility helpers
        ]]

        --// Color Utility Module
        local ColorUtil = {}

        --// Constants
        ColorUtil.WHITE = Color3.new(1, 1, 1)
        ColorUtil.BLACK = Color3.new(0, 0, 0)
        ColorUtil.RED = Color3.new(1, 0, 0)
        ColorUtil.GREEN = Color3.new(0, 1, 0)
        ColorUtil.BLUE = Color3.new(0, 0, 1)
        ColorUtil.YELLOW = Color3.new(1, 1, 0)
        ColorUtil.CYAN = Color3.new(0, 1, 1)
        ColorUtil.MAGENTA = Color3.new(1, 0, 1)
        ColorUtil.TRANSPARENT = Color3.new(0, 0, 0)

        --// RGB Operations
        function ColorUtil.FromRGB(r, g, b)
            return Color3.new(r / 255, g / 255, b / 255)
        end

        function ColorUtil.ToRGB(color)
            return math.floor(color.R * 255 + 0.5),
                   math.floor(color.G * 255 + 0.5),
                   math.floor(color.B * 255 + 0.5)
        end

        function ColorUtil.FromRGBA(r, g, b, a)
            return Color3.new(r / 255, g / 255, b / 255), a / 255
        end

        function ColorUtil.GetComponents(color)
            return color.R, color.G, color.B
        end

        --// Hex Conversion
        function ColorUtil.FromHex(hex)
            hex = hex:gsub("#", "")

            if #hex == 3 then
                hex = hex:sub(1, 1):rep(2) .. hex:sub(2, 2):rep(2) .. hex:sub(3, 3):rep(2)
            end

            if #hex == 8 then
                -- RGBA format
                local r = tonumber(hex:sub(1, 2), 16) / 255
                local g = tonumber(hex:sub(3, 4), 16) / 255
                local b = tonumber(hex:sub(5, 6), 16) / 255
                local a = tonumber(hex:sub(7, 8), 16) / 255
                return Color3.new(r, g, b), a
            end

            local r = tonumber(hex:sub(1, 2), 16) / 255
            local g = tonumber(hex:sub(3, 4), 16) / 255
            local b = tonumber(hex:sub(5, 6), 16) / 255

            return Color3.new(r, g, b)
        end

        function ColorUtil.ToHex(color, includeHash)
            includeHash = includeHash ~= false
            local r, g, b = ColorUtil.ToRGB(color)
            local hex = string.format("%02X%02X%02X", r, g, b)
            return includeHash and "#" .. hex or hex
        end

        function ColorUtil.ToHexA(color, alpha, includeHash)
            includeHash = includeHash ~= false
            local r, g, b = ColorUtil.ToRGB(color)
            local a = math.floor(alpha * 255 + 0.5)
            local hex = string.format("%02X%02X%02X%02X", r, g, b, a)
            return includeHash and "#" .. hex or hex
        end

        --// HSV Conversion
        function ColorUtil.FromHSV(h, s, v)
            local r, g, b
            local i = math.floor(h * 6)
            local f = h * 6 - i
            local p = v * (1 - s)
            local q = v * (1 - f * s)
            local t = v * (1 - (1 - f) * s)

            i = i % 6

            if i == 0 then r, g, b = v, t, p
            elseif i == 1 then r, g, b = q, v, p
            elseif i == 2 then r, g, b = p, v, t
            elseif i == 3 then r, g, b = p, q, v
            elseif i == 4 then r, g, b = t, p, v
            elseif i == 5 then r, g, b = v, p, q
            end

            return Color3.new(r, g, b)
        end

        function ColorUtil.ToHSV(color)
            local r, g, b = color.R, color.G, color.B
            local max = math.max(r, g, b)
            local min = math.min(r, g, b)
            local h, s, v

            v = max
            local d = max - min

            if max == 0 then
                s = 0
            else
                s = d / max
            end

            if max == min then
                h = 0
            else
                if max == r then
                    h = (g - b) / d
                    if g < b then h = h + 6 end
                elseif max == g then
                    h = (b - r) / d + 2
                else
                    h = (r - g) / d + 4
                end
                h = h / 6
            end

            return h, s, v
        end

        --// HSL Conversion
        function ColorUtil.FromHSL(h, s, l)
            local r, g, b

            if s == 0 then
                r, g, b = l, l, l
            else
                local function hueToRgb(p, q, t)
                    if t < 0 then t = t + 1 end
                    if t > 1 then t = t - 1 end
                    if t < 1/6 then return p + (q - p) * 6 * t end
                    if t < 1/2 then return q end
                    if t < 2/3 then return p + (q - p) * (2/3 - t) * 6 end
                    return p
                end

                local q = l < 0.5 and l * (1 + s) or l + s - l * s
                local p = 2 * l - q

                r = hueToRgb(p, q, h + 1/3)
                g = hueToRgb(p, q, h)
                b = hueToRgb(p, q, h - 1/3)
            end

            return Color3.new(r, g, b)
        end

        function ColorUtil.ToHSL(color)
            local r, g, b = color.R, color.G, color.B
            local max = math.max(r, g, b)
            local min = math.min(r, g, b)
            local h, s, l

            l = (max + min) / 2

            if max == min then
                h, s = 0, 0
            else
                local d = max - min

                if l > 0.5 then
                    s = d / (2 - max - min)
                else
                    s = d / (max + min)
                end

                if max == r then
                    h = (g - b) / d + (g < b and 6 or 0)
                elseif max == g then
                    h = (b - r) / d + 2
                else
                    h = (r - g) / d + 4
                end

                h = h / 6
            end

            return h, s, l
        end

        --// Color Manipulation
        function ColorUtil.Lighten(color, amount)
            amount = amount or 0.1
            local h, s, l = ColorUtil.ToHSL(color)
            l = math.min(1, l + amount)
            return ColorUtil.FromHSL(h, s, l)
        end

        function ColorUtil.Darken(color, amount)
            amount = amount or 0.1
            local h, s, l = ColorUtil.ToHSL(color)
            l = math.max(0, l - amount)
            return ColorUtil.FromHSL(h, s, l)
        end

        function ColorUtil.Saturate(color, amount)
            amount = amount or 0.1
            local h, s, v = ColorUtil.ToHSV(color)
            s = math.min(1, s + amount)
            return ColorUtil.FromHSV(h, s, v)
        end

        function ColorUtil.Desaturate(color, amount)
            amount = amount or 0.1
            local h, s, v = ColorUtil.ToHSV(color)
            s = math.max(0, s - amount)
            return ColorUtil.FromHSV(h, s, v)
        end

        function ColorUtil.Grayscale(color)
            local luminance = ColorUtil.GetLuminance(color)
            return Color3.new(luminance, luminance, luminance)
        end

        function ColorUtil.Invert(color)
            return Color3.new(1 - color.R, 1 - color.G, 1 - color.B)
        end

        function ColorUtil.RotateHue(color, degrees)
            local h, s, v = ColorUtil.ToHSV(color)
            h = (h + degrees / 360) % 1
            return ColorUtil.FromHSV(h, s, v)
        end

        function ColorUtil.SetHue(color, hue)
            local _, s, v = ColorUtil.ToHSV(color)
            return ColorUtil.FromHSV(hue, s, v)
        end

        function ColorUtil.SetSaturation(color, saturation)
            local h, _, v = ColorUtil.ToHSV(color)
            return ColorUtil.FromHSV(h, saturation, v)
        end

        function ColorUtil.SetValue(color, value)
            local h, s, _ = ColorUtil.ToHSV(color)
            return ColorUtil.FromHSV(h, s, value)
        end

        function ColorUtil.SetLightness(color, lightness)
            local h, s, _ = ColorUtil.ToHSL(color)
            return ColorUtil.FromHSL(h, s, lightness)
        end

        function ColorUtil.SetAlpha(color, alpha)
            return color, alpha
        end

        --// Color Blending
        function ColorUtil.Lerp(color1, color2, t)
            return Color3.new(
                color1.R + (color2.R - color1.R) * t,
                color1.G + (color2.G - color1.G) * t,
                color1.B + (color2.B - color1.B) * t
            )
        end

        function ColorUtil.Mix(color1, color2, ratio)
            ratio = ratio or 0.5
            return ColorUtil.Lerp(color1, color2, ratio)
        end

        function ColorUtil.Blend(color1, color2, mode, amount)
            amount = amount or 0.5
            mode = mode or "normal"

            if mode == "normal" then
                return ColorUtil.Lerp(color1, color2, amount)

            elseif mode == "multiply" then
                return Color3.new(
                    color1.R * color2.R,
                    color1.G * color2.G,
                    color1.B * color2.B
                )

            elseif mode == "screen" then
                return Color3.new(
                    1 - (1 - color1.R) * (1 - color2.R),
                    1 - (1 - color1.G) * (1 - color2.G),
                    1 - (1 - color1.B) * (1 - color2.B)
                )

            elseif mode == "overlay" then
                local function overlay(base, blend)
                    if base < 0.5 then
                        return 2 * base * blend
                    else
                        return 1 - 2 * (1 - base) * (1 - blend)
                    end
                end
                return Color3.new(
                    overlay(color1.R, color2.R),
                    overlay(color1.G, color2.G),
                    overlay(color1.B, color2.B)
                )

            elseif mode == "add" then
                return Color3.new(
                    math.min(1, color1.R + color2.R * amount),
                    math.min(1, color1.G + color2.G * amount),
                    math.min(1, color1.B + color2.B * amount)
                )

            elseif mode == "subtract" then
                return Color3.new(
                    math.max(0, color1.R - color2.R * amount),
                    math.max(0, color1.G - color2.G * amount),
                    math.max(0, color1.B - color2.B * amount)
                )

            elseif mode == "difference" then
                return Color3.new(
                    math.abs(color1.R - color2.R),
                    math.abs(color1.G - color2.G),
                    math.abs(color1.B - color2.B)
                )

            elseif mode == "softlight" then
                local function softlight(base, blend)
                    if blend < 0.5 then
                        return base - (1 - 2 * blend) * base * (1 - base)
                    else
                        local d
                        if base < 0.25 then
                            d = ((16 * base - 12) * base + 4) * base
                        else
                            d = math.sqrt(base)
                        end
                        return base + (2 * blend - 1) * (d - base)
                    end
                end
                return Color3.new(
                    softlight(color1.R, color2.R),
                    softlight(color1.G, color2.G),
                    softlight(color1.B, color2.B)
                )

            elseif mode == "hardlight" then
                local function hardlight(base, blend)
                    if blend < 0.5 then
                        return 2 * base * blend
                    else
                        return 1 - 2 * (1 - base) * (1 - blend)
                    end
                end
                return Color3.new(
                    hardlight(color1.R, color2.R),
                    hardlight(color1.G, color2.G),
                    hardlight(color1.B, color2.B)
                )
            end

            return ColorUtil.Lerp(color1, color2, amount)
        end

        --// Luminance and Contrast
        function ColorUtil.GetLuminance(color)
            -- Using relative luminance formula (WCAG)
            local function linearize(c)
                if c <= 0.03928 then
                    return c / 12.92
                else
                    return ((c + 0.055) / 1.055) ^ 2.4
                end
            end

            local r = linearize(color.R)
            local g = linearize(color.G)
            local b = linearize(color.B)

            return 0.2126 * r + 0.7152 * g + 0.0722 * b
        end

        function ColorUtil.GetPerceivedBrightness(color)
            -- Using perceived brightness formula
            return math.sqrt(
                0.299 * color.R ^ 2 +
                0.587 * color.G ^ 2 +
                0.114 * color.B ^ 2
            )
        end

        function ColorUtil.GetContrastRatio(color1, color2)
            local l1 = ColorUtil.GetLuminance(color1)
            local l2 = ColorUtil.GetLuminance(color2)

            local lighter = math.max(l1, l2)
            local darker = math.min(l1, l2)

            return (lighter + 0.05) / (darker + 0.05)
        end

        function ColorUtil.GetContrastColor(backgroundColor, lightColor, darkColor)
            lightColor = lightColor or ColorUtil.WHITE
            darkColor = darkColor or ColorUtil.BLACK

            local brightness = ColorUtil.GetPerceivedBrightness(backgroundColor)
            return brightness > 0.5 and darkColor or lightColor
        end

        function ColorUtil.IsLight(color)
            return ColorUtil.GetPerceivedBrightness(color) > 0.5
        end

        function ColorUtil.IsDark(color)
            return ColorUtil.GetPerceivedBrightness(color) <= 0.5
        end

        function ColorUtil.MeetsContrastRatio(color1, color2, ratio)
            ratio = ratio or 4.5 -- WCAG AA standard
            return ColorUtil.GetContrastRatio(color1, color2) >= ratio
        end

        --// Palette Generation
        function ColorUtil.Complementary(color)
            return ColorUtil.RotateHue(color, 180)
        end

        function ColorUtil.Triadic(color)
            return {
                color,
                ColorUtil.RotateHue(color, 120),
                ColorUtil.RotateHue(color, 240)
            }
        end

        function ColorUtil.Tetradic(color)
            return {
                color,
                ColorUtil.RotateHue(color, 90),
                ColorUtil.RotateHue(color, 180),
                ColorUtil.RotateHue(color, 270)
            }
        end

        function ColorUtil.Analogous(color, spread)
            spread = spread or 30
            return {
                ColorUtil.RotateHue(color, -spread),
                color,
                ColorUtil.RotateHue(color, spread)
            }
        end

        function ColorUtil.SplitComplementary(color, spread)
            spread = spread or 30
            return {
                color,
                ColorUtil.RotateHue(color, 180 - spread),
                ColorUtil.RotateHue(color, 180 + spread)
            }
        end

        function ColorUtil.Monochromatic(color, count)
            count = count or 5
            local h, s, l = ColorUtil.ToHSL(color)
            local colors = {}

            for i = 1, count do
                local newL = (i - 1) / (count - 1)
                table.insert(colors, ColorUtil.FromHSL(h, s, newL))
            end

            return colors
        end

        function ColorUtil.Shades(color, count)
            count = count or 5
            local colors = {}

            for i = 1, count do
                local amount = (i - 1) / (count - 1)
                table.insert(colors, ColorUtil.Lerp(color, ColorUtil.BLACK, amount))
            end

            return colors
        end

        function ColorUtil.Tints(color, count)
            count = count or 5
            local colors = {}

            for i = 1, count do
                local amount = (i - 1) / (count - 1)
                table.insert(colors, ColorUtil.Lerp(color, ColorUtil.WHITE, amount))
            end

            return colors
        end

        function ColorUtil.Tones(color, count)
            count = count or 5
            local gray = Color3.new(0.5, 0.5, 0.5)
            local colors = {}

            for i = 1, count do
                local amount = (i - 1) / (count - 1)
                table.insert(colors, ColorUtil.Lerp(color, gray, amount))
            end

            return colors
        end

        function ColorUtil.Gradient(color1, color2, steps)
            steps = steps or 10
            local colors = {}

            for i = 1, steps do
                local t = (i - 1) / (steps - 1)
                table.insert(colors, ColorUtil.Lerp(color1, color2, t))
            end

            return colors
        end

        function ColorUtil.GradientMulti(colorStops, steps)
            steps = steps or 10
            local colors = {}

            for i = 1, steps do
                local t = (i - 1) / (steps - 1)
                local totalStops = #colorStops
                local scaledT = t * (totalStops - 1)
                local stopIndex = math.floor(scaledT) + 1
                local localT = scaledT - math.floor(scaledT)

                if stopIndex >= totalStops then
                    table.insert(colors, colorStops[totalStops])
                else
                    table.insert(colors, ColorUtil.Lerp(colorStops[stopIndex], colorStops[stopIndex + 1], localT))
                end
            end

            return colors
        end

        --// ColorSequence Helpers
        function ColorUtil.CreateColorSequence(colors)
            local keypoints = {}

            for i, color in ipairs(colors) do
                local time = (i - 1) / (#colors - 1)
                table.insert(keypoints, ColorSequenceKeypoint.new(time, color))
            end

            return ColorSequence.new(keypoints)
        end

        function ColorUtil.CreateColorSequenceFromStops(stops)
            local keypoints = {}

            for _, stop in ipairs(stops) do
                table.insert(keypoints, ColorSequenceKeypoint.new(stop.Time, stop.Color))
            end

            return ColorSequence.new(keypoints)
        end

        function ColorUtil.SampleColorSequence(colorSequence, t)
            local keypoints = colorSequence.Keypoints

            for i = 1, #keypoints - 1 do
                local current = keypoints[i]
                local next = keypoints[i + 1]

                if t >= current.Time and t <= next.Time then
                    local localT = (t - current.Time) / (next.Time - current.Time)
                    return ColorUtil.Lerp(current.Value, next.Value, localT)
                end
            end

            return keypoints[#keypoints].Value
        end

        --// Random Colors
        function ColorUtil.Random()
            return Color3.new(math.random(), math.random(), math.random())
        end

        function ColorUtil.RandomHue(saturation, value)
            saturation = saturation or 1
            value = value or 1
            return ColorUtil.FromHSV(math.random(), saturation, value)
        end

        function ColorUtil.RandomPastel()
            return ColorUtil.FromHSL(math.random(), 0.7, 0.8)
        end

        function ColorUtil.RandomVibrant()
            return ColorUtil.FromHSV(math.random(), 1, 1)
        end

        --// Named Colors
        ColorUtil.Named = {
            -- Basic colors
            White = Color3.fromRGB(255, 255, 255),
            Black = Color3.fromRGB(0, 0, 0),
            Red = Color3.fromRGB(255, 0, 0),
            Green = Color3.fromRGB(0, 255, 0),
            Blue = Color3.fromRGB(0, 0, 255),
            Yellow = Color3.fromRGB(255, 255, 0),
            Cyan = Color3.fromRGB(0, 255, 255),
            Magenta = Color3.fromRGB(255, 0, 255),

            -- Extended palette
            Orange = Color3.fromRGB(255, 165, 0),
            Pink = Color3.fromRGB(255, 192, 203),
            Purple = Color3.fromRGB(128, 0, 128),
            Violet = Color3.fromRGB(238, 130, 238),
            Indigo = Color3.fromRGB(75, 0, 130),
            Teal = Color3.fromRGB(0, 128, 128),
            Lime = Color3.fromRGB(0, 255, 0),
            Olive = Color3.fromRGB(128, 128, 0),
            Maroon = Color3.fromRGB(128, 0, 0),
            Navy = Color3.fromRGB(0, 0, 128),
            Aqua = Color3.fromRGB(0, 255, 255),
            Silver = Color3.fromRGB(192, 192, 192),
            Gray = Color3.fromRGB(128, 128, 128),
            Gold = Color3.fromRGB(255, 215, 0),
            Coral = Color3.fromRGB(255, 127, 80),
            Salmon = Color3.fromRGB(250, 128, 114),
            Turquoise = Color3.fromRGB(64, 224, 208),
            SlateBlue = Color3.fromRGB(106, 90, 205),
            Crimson = Color3.fromRGB(220, 20, 60),
        }

        function ColorUtil.FromName(name)
            return ColorUtil.Named[name]
        end

        return ColorUtil


    end


    -- ============================================================================
    -- Module: NexusUI/Core/Utility/Bezier
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/Utility/Bezier"] = function()
        local script = CreateMockScript("NexusUI/Core/Utility/Bezier")

        --[[
            NexusUI Bezier Curve Utilities
            Bezier curve calculations for smooth animations

            Features:
            - Linear, quadratic, and cubic bezier curves
            - Bezier easing functions
            - Path interpolation
            - Curve fitting
        ]]

        --// Bezier Utility Module
        local BezierUtil = {}

        --// Constants
        local NEWTON_ITERATIONS = 4
        local NEWTON_MIN_SLOPE = 0.001
        local SUBDIVISION_PRECISION = 0.0000001
        local SUBDIVISION_MAX_ITERATIONS = 10

        --// Linear Bezier (Lerp)
        function BezierUtil.Linear(p0, p1, t)
            return p0 + (p1 - p0) * t
        end

        --// Quadratic Bezier
        function BezierUtil.Quadratic(p0, p1, p2, t)
            local t1 = 1 - t
            return t1 * t1 * p0 + 2 * t1 * t * p1 + t * t * p2
        end

        function BezierUtil.QuadraticDerivative(p0, p1, p2, t)
            return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1)
        end

        --// Cubic Bezier
        function BezierUtil.Cubic(p0, p1, p2, p3, t)
            local t1 = 1 - t
            local t1_2 = t1 * t1
            local t1_3 = t1_2 * t1
            local t_2 = t * t
            local t_3 = t_2 * t

            return t1_3 * p0 + 3 * t1_2 * t * p1 + 3 * t1 * t_2 * p2 + t_3 * p3
        end

        function BezierUtil.CubicDerivative(p0, p1, p2, p3, t)
            local t1 = 1 - t
            return 3 * t1 * t1 * (p1 - p0) + 6 * t1 * t * (p2 - p1) + 3 * t * t * (p3 - p2)
        end

        function BezierUtil.CubicSecondDerivative(p0, p1, p2, p3, t)
            return 6 * (1 - t) * (p2 - 2 * p1 + p0) + 6 * t * (p3 - 2 * p2 + p1)
        end

        --// Vector2 Bezier
        function BezierUtil.QuadraticVector2(p0, p1, p2, t)
            return Vector2.new(
                BezierUtil.Quadratic(p0.X, p1.X, p2.X, t),
                BezierUtil.Quadratic(p0.Y, p1.Y, p2.Y, t)
            )
        end

        function BezierUtil.CubicVector2(p0, p1, p2, p3, t)
            return Vector2.new(
                BezierUtil.Cubic(p0.X, p1.X, p2.X, p3.X, t),
                BezierUtil.Cubic(p0.Y, p1.Y, p2.Y, p3.Y, t)
            )
        end

        --// UDim2 Bezier
        function BezierUtil.CubicUDim2(p0, p1, p2, p3, t)
            return UDim2.new(
                BezierUtil.Cubic(p0.X.Scale, p1.X.Scale, p2.X.Scale, p3.X.Scale, t),
                BezierUtil.Cubic(p0.X.Offset, p1.X.Offset, p2.X.Offset, p3.X.Offset, t),
                BezierUtil.Cubic(p0.Y.Scale, p1.Y.Scale, p2.Y.Scale, p3.Y.Scale, t),
                BezierUtil.Cubic(p0.Y.Offset, p1.Y.Offset, p2.Y.Offset, p3.Y.Offset, t)
            )
        end

        --// Cubic Bezier Easing Function
        -- Creates a cubic bezier easing function from control points
        -- Similar to CSS cubic-bezier(x1, y1, x2, y2)
        function BezierUtil.CreateEasing(x1, y1, x2, y2)
            -- Validate control points
            x1 = math.max(0, math.min(1, x1))
            x2 = math.max(0, math.min(1, x2))

            -- Pre-compute sample table for faster lookup
            local sampleTableSize = 11
            local sampleTable = {}

            local function calcBezier(t, a1, a2)
                return ((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1 * t
            end

            local function getSlope(t, a1, a2)
                return 3 * (1 - 3 * a2 + 3 * a1) * t * t + 2 * (3 * a2 - 6 * a1) * t + 3 * a1
            end

            -- Build sample table
            for i = 0, sampleTableSize - 1 do
                sampleTable[i] = calcBezier(i / (sampleTableSize - 1), x1, x2)
            end

            local function getTForX(x)
                local intervalStart = 0
                local currentSample = 1
                local lastSample = sampleTableSize - 1

                while currentSample ~= lastSample and sampleTable[currentSample] <= x do
                    intervalStart = intervalStart + 1 / (sampleTableSize - 1)
                    currentSample = currentSample + 1
                end
                currentSample = currentSample - 1

                local dist = (x - sampleTable[currentSample]) / (sampleTable[currentSample + 1] - sampleTable[currentSample])
                local guessForT = intervalStart + dist / (sampleTableSize - 1)

                local initialSlope = getSlope(guessForT, x1, x2)

                if initialSlope >= NEWTON_MIN_SLOPE then
                    -- Newton-Raphson iteration
                    for i = 1, NEWTON_ITERATIONS do
                        local currentSlope = getSlope(guessForT, x1, x2)
                        if currentSlope == 0 then break end
                        local currentX = calcBezier(guessForT, x1, x2) - x
                        guessForT = guessForT - currentX / currentSlope
                    end
                    return guessForT
                elseif initialSlope == 0 then
                    return guessForT
                else
                    -- Binary subdivision
                    local aA = intervalStart
                    local aB = intervalStart + 1 / (sampleTableSize - 1)
                    local currentX, currentT

                    repeat
                        currentT = aA + (aB - aA) / 2
                        currentX = calcBezier(currentT, x1, x2) - x

                        if currentX > 0 then
                            aB = currentT
                        else
                            aA = currentT
                        end
                    until math.abs(currentX) < SUBDIVISION_PRECISION

                    return currentT
                end
            end

            return function(t)
                if t == 0 or t == 1 then
                    return t
                end
                return calcBezier(getTForX(t), y1, y2)
            end
        end

        --// Common Easing Presets
        BezierUtil.Easings = {
            -- Standard
            Linear = BezierUtil.CreateEasing(0, 0, 1, 1),

            -- Sine
            EaseInSine = BezierUtil.CreateEasing(0.47, 0, 0.745, 0.715),
            EaseOutSine = BezierUtil.CreateEasing(0.39, 0.575, 0.565, 1),
            EaseInOutSine = BezierUtil.CreateEasing(0.445, 0.05, 0.55, 0.95),

            -- Quad
            EaseInQuad = BezierUtil.CreateEasing(0.55, 0.085, 0.68, 0.53),
            EaseOutQuad = BezierUtil.CreateEasing(0.25, 0.46, 0.45, 0.94),
            EaseInOutQuad = BezierUtil.CreateEasing(0.455, 0.03, 0.515, 0.955),

            -- Cubic
            EaseInCubic = BezierUtil.CreateEasing(0.55, 0.055, 0.675, 0.19),
            EaseOutCubic = BezierUtil.CreateEasing(0.215, 0.61, 0.355, 1),
            EaseInOutCubic = BezierUtil.CreateEasing(0.645, 0.045, 0.355, 1),

            -- Quart
            EaseInQuart = BezierUtil.CreateEasing(0.895, 0.03, 0.685, 0.22),
            EaseOutQuart = BezierUtil.CreateEasing(0.165, 0.84, 0.44, 1),
            EaseInOutQuart = BezierUtil.CreateEasing(0.77, 0, 0.175, 1),

            -- Quint
            EaseInQuint = BezierUtil.CreateEasing(0.755, 0.05, 0.855, 0.06),
            EaseOutQuint = BezierUtil.CreateEasing(0.23, 1, 0.32, 1),
            EaseInOutQuint = BezierUtil.CreateEasing(0.86, 0, 0.07, 1),

            -- Expo
            EaseInExpo = BezierUtil.CreateEasing(0.95, 0.05, 0.795, 0.035),
            EaseOutExpo = BezierUtil.CreateEasing(0.19, 1, 0.22, 1),
            EaseInOutExpo = BezierUtil.CreateEasing(1, 0, 0, 1),

            -- Circ
            EaseInCirc = BezierUtil.CreateEasing(0.6, 0.04, 0.98, 0.335),
            EaseOutCirc = BezierUtil.CreateEasing(0.075, 0.82, 0.165, 1),
            EaseInOutCirc = BezierUtil.CreateEasing(0.785, 0.135, 0.15, 0.86),

            -- Back
            EaseInBack = BezierUtil.CreateEasing(0.6, -0.28, 0.735, 0.045),
            EaseOutBack = BezierUtil.CreateEasing(0.175, 0.885, 0.32, 1.275),
            EaseInOutBack = BezierUtil.CreateEasing(0.68, -0.55, 0.265, 1.55),

            -- Custom smooth
            Smooth = BezierUtil.CreateEasing(0.25, 0.1, 0.25, 1),
            Sharp = BezierUtil.CreateEasing(0.4, 0, 0.6, 1),
            Standard = BezierUtil.CreateEasing(0.4, 0, 0.2, 1),
            Decelerate = BezierUtil.CreateEasing(0, 0, 0.2, 1),
            Accelerate = BezierUtil.CreateEasing(0.4, 0, 1, 1),
        }

        --// Get easing by name
        function BezierUtil.GetEasing(name)
            return BezierUtil.Easings[name] or BezierUtil.Easings.Linear
        end

        --// Path Operations
        function BezierUtil.SamplePath(points, samples)
            samples = samples or 100
            local result = {}

            for i = 0, samples do
                local t = i / samples
                table.insert(result, BezierUtil.GetPointOnPath(points, t))
            end

            return result
        end

        function BezierUtil.GetPointOnPath(points, t)
            local n = #points

            if n == 2 then
                return BezierUtil.Linear(points[1], points[2], t)
            elseif n == 3 then
                return BezierUtil.Quadratic(points[1], points[2], points[3], t)
            elseif n == 4 then
                return BezierUtil.Cubic(points[1], points[2], points[3], points[4], t)
            else
                -- De Casteljau's algorithm for higher-order bezier
                local newPoints = {}
                for i = 1, n - 1 do
                    table.insert(newPoints, BezierUtil.Linear(points[i], points[i + 1], t))
                end
                return BezierUtil.GetPointOnPath(newPoints, t)
            end
        end

        function BezierUtil.GetPathLength(points, samples)
            samples = samples or 100
            local length = 0
            local lastPoint = nil

            for i = 0, samples do
                local t = i / samples
                local point = BezierUtil.GetPointOnPath(points, t)

                if lastPoint then
                    if typeof(point) == "Vector2" then
                        length = length + (point - lastPoint).Magnitude
                    elseif typeof(point) == "number" then
                        length = length + math.abs(point - lastPoint)
                    end
                end

                lastPoint = point
            end

            return length
        end

        function BezierUtil.GetTangent(points, t)
            local n = #points

            if n == 2 then
                return points[2] - points[1]
            elseif n == 3 then
                return BezierUtil.QuadraticDerivative(points[1], points[2], points[3], t)
            elseif n == 4 then
                return BezierUtil.CubicDerivative(points[1], points[2], points[3], points[4], t)
            end

            return nil
        end

        function BezierUtil.GetNormal(points, t)
            local tangent = BezierUtil.GetTangent(points, t)

            if typeof(tangent) == "Vector2" then
                return Vector2.new(-tangent.Y, tangent.X).Unit
            end

            return nil
        end

        --// Arc Length Parameterization
        function BezierUtil.CreateArcLengthTable(points, samples)
            samples = samples or 100
            local table = {}
            local totalLength = 0
            local lastPoint = nil

            for i = 0, samples do
                local t = i / samples
                local point = BezierUtil.GetPointOnPath(points, t)

                if lastPoint then
                    if typeof(point) == "Vector2" then
                        totalLength = totalLength + (point - lastPoint).Magnitude
                    elseif typeof(point) == "number" then
                        totalLength = totalLength + math.abs(point - lastPoint)
                    end
                end

                table[i] = { T = t, Length = totalLength }
                lastPoint = point
            end

            -- Normalize lengths
            for i = 0, samples do
                table[i].NormalizedLength = table[i].Length / totalLength
            end

            return table, totalLength
        end

        function BezierUtil.GetTAtArcLength(arcLengthTable, normalizedLength)
            local samples = #arcLengthTable

            for i = 1, samples do
                if arcLengthTable[i].NormalizedLength >= normalizedLength then
                    local prev = arcLengthTable[i - 1]
                    local curr = arcLengthTable[i]

                    local lerpT = (normalizedLength - prev.NormalizedLength) / 
                                 (curr.NormalizedLength - prev.NormalizedLength)

                    return prev.T + (curr.T - prev.T) * lerpT
                end
            end

            return 1
        end

        --// Bezier Curve Class
        local BezierCurve = {}
        BezierCurve.__index = BezierCurve

        function BezierUtil.CreateCurve(points)
            local self = setmetatable({}, BezierCurve)

            self.Points = points
            self.ArcLengthTable = nil
            self.TotalLength = 0

            return self
        end

        function BezierCurve:GetPoint(t)
            return BezierUtil.GetPointOnPath(self.Points, t)
        end

        function BezierCurve:GetTangent(t)
            return BezierUtil.GetTangent(self.Points, t)
        end

        function BezierCurve:GetNormal(t)
            return BezierUtil.GetNormal(self.Points, t)
        end

        function BezierCurve:GetLength()
            if self.TotalLength == 0 then
                self.ArcLengthTable, self.TotalLength = BezierUtil.CreateArcLengthTable(self.Points)
            end
            return self.TotalLength
        end

        function BezierCurve:GetPointAtDistance(distance)
            if not self.ArcLengthTable then
                self:GetLength()
            end

            local normalizedDistance = distance / self.TotalLength
            local t = BezierUtil.GetTAtArcLength(self.ArcLengthTable, normalizedDistance)

            return self:GetPoint(t)
        end

        function BezierCurve:Sample(count)
            return BezierUtil.SamplePath(self.Points, count)
        end

        function BezierCurve:SampleUniform(count)
            if not self.ArcLengthTable then
                self:GetLength()
            end

            local result = {}

            for i = 0, count do
                local normalizedLength = i / count
                local t = BezierUtil.GetTAtArcLength(self.ArcLengthTable, normalizedLength)
                table.insert(result, self:GetPoint(t))
            end

            return result
        end

        --// Curve Splitting
        function BezierUtil.SplitCubic(p0, p1, p2, p3, t)
            local p01 = BezierUtil.Linear(p0, p1, t)
            local p12 = BezierUtil.Linear(p1, p2, t)
            local p23 = BezierUtil.Linear(p2, p3, t)

            local p012 = BezierUtil.Linear(p01, p12, t)
            local p123 = BezierUtil.Linear(p12, p23, t)

            local p0123 = BezierUtil.Linear(p012, p123, t)

            return {
                { p0, p01, p012, p0123 },
                { p0123, p123, p23, p3 }
            }
        end

        return BezierUtil


    end


    -- ============================================================================
    -- Module: NexusUI/Core/Utility/UUID
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/Utility/UUID"] = function()
        local script = CreateMockScript("NexusUI/Core/Utility/UUID")

        --[[
            NexusUI UUID Utilities
            Universal Unique Identifier generation

            Features:
            - UUID v4 generation
            - Short ID generation
            - Sequential ID generation
            - Custom format IDs
        ]]

        --// UUID Utility Module
        local UUIDUtil = {}

        --// Services
        local HttpService = game:GetService("HttpService")

        --// Charset for short IDs
        local CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
        local CHARSET_SAFE = "0123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz"  -- Without confusing chars
        local CHARSET_NUMBERS = "0123456789"
        local CHARSET_LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
        local CHARSET_HEX = "0123456789abcdef"

        --// Sequential counter
        local sequentialCounter = 0
        local lastTimestamp = 0

        --// UUID v4 Generation
        function UUIDUtil.V4()
            return HttpService:GenerateGUID(false)
        end

        function UUIDUtil.V4WithBraces()
            return HttpService:GenerateGUID(true)
        end

        --// Simple UUID (without hyphens)
        function UUIDUtil.Simple()
            return UUIDUtil.V4():gsub("-", "")
        end

        --// Short ID Generation
        function UUIDUtil.Short(length, charset)
            length = length or 8
            charset = charset or CHARSET

            local result = {}
            local charsetLength = #charset

            for i = 1, length do
                local randomIndex = math.random(1, charsetLength)
                table.insert(result, charset:sub(randomIndex, randomIndex))
            end

            return table.concat(result)
        end

        function UUIDUtil.ShortSafe(length)
            return UUIDUtil.Short(length, CHARSET_SAFE)
        end

        function UUIDUtil.Numeric(length)
            return UUIDUtil.Short(length, CHARSET_NUMBERS)
        end

        function UUIDUtil.Alphabetic(length)
            return UUIDUtil.Short(length, CHARSET_LETTERS)
        end

        function UUIDUtil.Hex(length)
            return UUIDUtil.Short(length, CHARSET_HEX)
        end

        --// Prefixed IDs
        function UUIDUtil.Prefixed(prefix, length)
            prefix = prefix or "id"
            length = length or 12
            return prefix .. "_" .. UUIDUtil.Short(length)
        end

        --// Timestamped IDs
        function UUIDUtil.Timestamped(prefix)
            prefix = prefix or ""
            local timestamp = os.time()
            local random = UUIDUtil.Short(6)

            if prefix ~= "" then
                return prefix .. "_" .. timestamp .. "_" .. random
            else
                return timestamp .. "_" .. random
            end
        end

        function UUIDUtil.TimestampedShort()
            -- Base36 encoded timestamp + random
            local timestamp = os.time()
            local base36 = UUIDUtil.ToBase36(timestamp)
            local random = UUIDUtil.Short(4)
            return base36 .. random
        end

        --// Sequential IDs
        function UUIDUtil.Sequential(prefix)
            prefix = prefix or "seq"
            sequentialCounter = sequentialCounter + 1
            return prefix .. "_" .. string.format("%08d", sequentialCounter)
        end

        function UUIDUtil.ResetSequential()
            sequentialCounter = 0
        end

        function UUIDUtil.GetSequentialCount()
            return sequentialCounter
        end

        --// Time-based Sequential (ULID-like)
        function UUIDUtil.TimeSequential()
            local timestamp = os.time() * 1000 + (os.clock() % 1) * 1000

            if timestamp == lastTimestamp then
                sequentialCounter = sequentialCounter + 1
            else
                lastTimestamp = timestamp
                sequentialCounter = 0
            end

            local timePart = UUIDUtil.ToBase62(timestamp)
            local randomPart = UUIDUtil.Short(10)

            -- Pad time part to consistent length
            timePart = string.rep("0", 10 - #timePart) .. timePart

            return timePart .. randomPart
        end

        --// Base Conversion
        function UUIDUtil.ToBase36(number)
            local chars = "0123456789abcdefghijklmnopqrstuvwxyz"
            local result = {}

            if number == 0 then
                return "0"
            end

            while number > 0 do
                local remainder = number % 36
                table.insert(result, 1, chars:sub(remainder + 1, remainder + 1))
                number = math.floor(number / 36)
            end

            return table.concat(result)
        end

        function UUIDUtil.FromBase36(str)
            local chars = "0123456789abcdefghijklmnopqrstuvwxyz"
            local result = 0

            str = str:lower()

            for i = 1, #str do
                local char = str:sub(i, i)
                local value = chars:find(char) - 1
                result = result * 36 + value
            end

            return result
        end

        function UUIDUtil.ToBase62(number)
            local chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
            local result = {}

            if number == 0 then
                return "0"
            end

            while number > 0 do
                local remainder = number % 62
                table.insert(result, 1, chars:sub(remainder + 1, remainder + 1))
                number = math.floor(number / 62)
            end

            return table.concat(result)
        end

        function UUIDUtil.FromBase62(str)
            local chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
            local result = 0

            for i = 1, #str do
                local char = str:sub(i, i)
                local value = chars:find(char) - 1
                result = result * 62 + value
            end

            return result
        end

        --// Custom Format
        function UUIDUtil.Custom(format)
            -- Format: X = random letter, 9 = random digit, * = random alphanumeric, - = literal hyphen
            local result = {}

            for i = 1, #format do
                local char = format:sub(i, i)

                if char == "X" then
                    table.insert(result, CHARSET_LETTERS:sub(math.random(1, #CHARSET_LETTERS), math.random(1, #CHARSET_LETTERS)))
                elseif char == "x" then
                    table.insert(result, CHARSET_LETTERS:sub(math.random(27, #CHARSET_LETTERS), math.random(27, #CHARSET_LETTERS)))  -- lowercase only
                elseif char == "9" then
                    table.insert(result, CHARSET_NUMBERS:sub(math.random(1, #CHARSET_NUMBERS), math.random(1, #CHARSET_NUMBERS)))
                elseif char == "*" then
                    table.insert(result, CHARSET:sub(math.random(1, #CHARSET), math.random(1, #CHARSET)))
                elseif char == "#" then
                    table.insert(result, CHARSET_HEX:sub(math.random(1, #CHARSET_HEX), math.random(1, #CHARSET_HEX)))
                else
                    table.insert(result, char)
                end
            end

            return table.concat(result)
        end

        --// Validation
        function UUIDUtil.IsValidUUID(str)
            return str:match("^%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x$") ~= nil
        end

        function UUIDUtil.IsValidUUIDSimple(str)
            return str:match("^%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x$") ~= nil
        end

        --// UUID Parsing
        function UUIDUtil.Parse(str)
            -- Remove braces and hyphens
            str = str:gsub("[{}-]", "")

            if #str ~= 32 then
                return nil
            end

            return {
                TimeLow = str:sub(1, 8),
                TimeMid = str:sub(9, 12),
                TimeHiVersion = str:sub(13, 16),
                ClockSeq = str:sub(17, 20),
                Node = str:sub(21, 32),
            }
        end

        function UUIDUtil.Format(parsed, withBraces)
            local uuid = string.format("%s-%s-%s-%s-%s",
                parsed.TimeLow,
                parsed.TimeMid,
                parsed.TimeHiVersion,
                parsed.ClockSeq,
                parsed.Node
            )

            if withBraces then
                return "{" .. uuid .. "}"
            end

            return uuid
        end

        --// UUID Comparison
        function UUIDUtil.Compare(uuid1, uuid2)
            uuid1 = uuid1:gsub("[{}-]", ""):lower()
            uuid2 = uuid2:gsub("[{}-]", ""):lower()

            return uuid1 == uuid2
        end

        --// Namespace UUIDs (simplified)
        function UUIDUtil.NamespaceId(namespace, name)
            -- Simple hash-based namespace ID (not cryptographically secure)
            local combined = namespace .. ":" .. name
            local hash = 0

            for i = 1, #combined do
                hash = (hash * 31 + combined:byte(i)) % 0xFFFFFFFF
            end

            -- Format as UUID-like string
            return string.format("%08x-%04x-%04x-%04x-%012x",
                hash % 0xFFFFFFFF,
                hash % 0xFFFF,
                (hash % 0xFFFF) + 0x4000,  -- Version 4
                (hash % 0x3FFF) + 0x8000,  -- Variant
                hash % 0xFFFFFFFFFFFF
            )
        end

        --// Aliases
        UUIDUtil.Generate = UUIDUtil.V4
        UUIDUtil.New = UUIDUtil.V4
        UUIDUtil.Create = UUIDUtil.V4
        UUIDUtil.Random = UUIDUtil.V4

        return UUIDUtil


    end


    -- ============================================================================
    -- Module: NexusUI/Core/Utility/Debounce
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/Utility/Debounce"] = function()
        local script = CreateMockScript("NexusUI/Core/Utility/Debounce")

        --[[
            NexusUI Debounce/Throttle Utilities
            Function rate limiting utilities

            Features:
            - Debounce (trailing, leading, both)
            - Throttle
            - Rate limiting
            - Once execution
            - Cooldown management
        ]]

        --// Debounce Utility Module
        local DebounceUtil = {}

        --// Simple Debounce (trailing edge)
        function DebounceUtil.Debounce(func, delay, immediate)
            delay = delay or 0.1
            immediate = immediate or false

            local lastCallTime = 0
            local scheduled = false
            local lastArgs = nil
            local lastSelf = nil

            return function(...)
                lastArgs = {...}
                lastSelf = select(1, ...)

                local now = os.clock()

                if immediate and not scheduled then
                    func(...)
                    lastCallTime = now
                end

                if not scheduled then
                    scheduled = true

                    task.delay(delay, function()
                        scheduled = false

                        if not immediate or (now - lastCallTime >= delay) then
                            func(unpack(lastArgs))
                        end

                        lastCallTime = os.clock()
                    end)
                end
            end
        end

        --// Leading Edge Debounce
        function DebounceUtil.DebounceLeading(func, delay)
            return DebounceUtil.Debounce(func, delay, true)
        end

        --// Trailing Edge Debounce (default)
        function DebounceUtil.DebounceTrailing(func, delay)
            return DebounceUtil.Debounce(func, delay, false)
        end

        --// Both Edges Debounce
        function DebounceUtil.DebounceBoth(func, delay)
            delay = delay or 0.1

            local lastCallTime = 0
            local scheduled = false
            local lastArgs = nil
            local calledLeading = false

            return function(...)
                lastArgs = {...}
                local now = os.clock()

                -- Leading edge
                if not calledLeading then
                    func(...)
                    calledLeading = true
                    lastCallTime = now
                end

                -- Schedule trailing edge
                if scheduled then
                    return
                end

                scheduled = true

                task.delay(delay, function()
                    scheduled = false
                    calledLeading = false

                    -- Trailing edge (only if there were calls after leading)
                    if os.clock() - lastCallTime >= delay then
                        func(unpack(lastArgs))
                    end
                end)
            end
        end

        --// Throttle (execute at most once per interval)
        function DebounceUtil.Throttle(func, interval)
            interval = interval or 0.1

            local lastCallTime = 0
            local scheduled = false
            local lastArgs = nil

            return function(...)
                lastArgs = {...}
                local now = os.clock()

                if now - lastCallTime >= interval then
                    lastCallTime = now
                    return func(...)
                elseif not scheduled then
                    scheduled = true

                    task.delay(interval - (now - lastCallTime), function()
                        scheduled = false
                        lastCallTime = os.clock()
                        func(unpack(lastArgs))
                    end)
                end
            end
        end

        --// Rate Limiter (max calls per time window)
        function DebounceUtil.RateLimit(func, maxCalls, timeWindow)
            maxCalls = maxCalls or 10
            timeWindow = timeWindow or 1

            local callTimes = {}

            return function(...)
                local now = os.clock()

                -- Remove old call times
                local newCallTimes = {}
                for _, time in ipairs(callTimes) do
                    if now - time < timeWindow then
                        table.insert(newCallTimes, time)
                    end
                end
                callTimes = newCallTimes

                -- Check if within limit
                if #callTimes < maxCalls then
                    table.insert(callTimes, now)
                    return func(...)
                else
                    return nil, "Rate limit exceeded"
                end
            end, function()
                -- Returns remaining calls
                local now = os.clock()
                local validCalls = 0

                for _, time in ipairs(callTimes) do
                    if now - time < timeWindow then
                        validCalls = validCalls + 1
                    end
                end

                return maxCalls - validCalls
            end
        end

        --// Once (execute only once)
        function DebounceUtil.Once(func)
            local called = false
            local result = nil

            return function(...)
                if not called then
                    called = true
                    result = {func(...)}
                    return unpack(result)
                end
                return unpack(result or {})
            end
        end

        --// After (execute after N calls)
        function DebounceUtil.After(n, func)
            local callCount = 0

            return function(...)
                callCount = callCount + 1

                if callCount >= n then
                    return func(...)
                end
            end
        end

        --// Before (execute only for first N calls)
        function DebounceUtil.Before(n, func)
            local callCount = 0
            local lastResult = nil

            return function(...)
                callCount = callCount + 1

                if callCount <= n then
                    lastResult = {func(...)}
                    return unpack(lastResult)
                end

                return unpack(lastResult or {})
            end
        end

        --// Cooldown (simple boolean cooldown)
        function DebounceUtil.Cooldown(duration)
            duration = duration or 1

            local onCooldown = false

            return function()
                if onCooldown then
                    return false
                end

                onCooldown = true
                task.delay(duration, function()
                    onCooldown = false
                end)

                return true
            end, function()
                return not onCooldown
            end, function()
                onCooldown = false
            end
        end

        --// Cooldown Manager (for multiple keys)
        local CooldownManager = {}
        CooldownManager.__index = CooldownManager

        function DebounceUtil.CreateCooldownManager()
            local self = setmetatable({}, CooldownManager)
            self._cooldowns = {}
            return self
        end

        function CooldownManager:IsReady(key)
            local cooldown = self._cooldowns[key]

            if not cooldown then
                return true
            end

            return os.clock() >= cooldown
        end

        function CooldownManager:SetCooldown(key, duration)
            self._cooldowns[key] = os.clock() + duration
        end

        function CooldownManager:GetRemaining(key)
            local cooldown = self._cooldowns[key]

            if not cooldown then
                return 0
            end

            return math.max(0, cooldown - os.clock())
        end

        function CooldownManager:Reset(key)
            self._cooldowns[key] = nil
        end

        function CooldownManager:ResetAll()
            self._cooldowns = {}
        end

        function CooldownManager:Execute(key, duration, func, ...)
            if self:IsReady(key) then
                self:SetCooldown(key, duration)
                return func(...)
            end

            return nil, self:GetRemaining(key)
        end

        --// Memoize (cache function results)
        function DebounceUtil.Memoize(func, hashFunc)
            local cache = {}

            hashFunc = hashFunc or function(...)
                local args = {...}
                local parts = {}

                for _, arg in ipairs(args) do
                    table.insert(parts, tostring(arg))
                end

                return table.concat(parts, "_")
            end

            return function(...)
                local key = hashFunc(...)

                if cache[key] ~= nil then
                    return unpack(cache[key])
                end

                local result = {func(...)}
                cache[key] = result

                return unpack(result)
            end, function()
                cache = {}
            end
        end

        --// Memoize with TTL (time-to-live)
        function DebounceUtil.MemoizeTTL(func, ttl, hashFunc)
            ttl = ttl or 60
            local cache = {}

            hashFunc = hashFunc or function(...)
                local args = {...}
                local parts = {}

                for _, arg in ipairs(args) do
                    table.insert(parts, tostring(arg))
                end

                return table.concat(parts, "_")
            end

            return function(...)
                local key = hashFunc(...)
                local cached = cache[key]

                if cached and os.clock() - cached.Time < ttl then
                    return unpack(cached.Result)
                end

                local result = {func(...)}
                cache[key] = {
                    Result = result,
                    Time = os.clock()
                }

                return unpack(result)
            end, function()
                cache = {}
            end
        end

        --// Queue (execute functions in order with delay)
        function DebounceUtil.CreateQueue(interval)
            interval = interval or 0.1

            local queue = {}
            local processing = false

            local function processQueue()
                if processing or #queue == 0 then
                    return
                end

                processing = true

                while #queue > 0 do
                    local item = table.remove(queue, 1)
                    item.Func(unpack(item.Args))
                    task.wait(interval)
                end

                processing = false
            end

            return {
                Add = function(func, ...)
                    table.insert(queue, {
                        Func = func,
                        Args = {...}
                    })
                    processQueue()
                end,

                Clear = function()
                    queue = {}
                end,

                GetLength = function()
                    return #queue
                end,

                IsProcessing = function()
                    return processing
                end
            }
        end

        --// Batch (collect calls and execute as batch)
        function DebounceUtil.Batch(func, delay)
            delay = delay or 0.1

            local batch = {}
            local scheduled = false

            return function(item)
                table.insert(batch, item)

                if not scheduled then
                    scheduled = true

                    task.delay(delay, function()
                        scheduled = false
                        local items = batch
                        batch = {}
                        func(items)
                    end)
                end
            end
        end

        --// Retry (retry function on failure)
        function DebounceUtil.Retry(func, maxAttempts, delay, backoffMultiplier)
            maxAttempts = maxAttempts or 3
            delay = delay or 1
            backoffMultiplier = backoffMultiplier or 1

            return function(...)
                local attempts = 0
                local currentDelay = delay
                local lastError = nil

                while attempts < maxAttempts do
                    attempts = attempts + 1

                    local success, result = pcall(func, ...)

                    if success then
                        return result
                    end

                    lastError = result

                    if attempts < maxAttempts then
                        task.wait(currentDelay)
                        currentDelay = currentDelay * backoffMultiplier
                    end
                end

                error(string.format("Failed after %d attempts: %s", maxAttempts, tostring(lastError)))
            end
        end

        return DebounceUtil


    end


    -- ============================================================================
    -- Module: NexusUI/Core/Utility/DeepCopy
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/Utility/DeepCopy"] = function()
        local script = CreateMockScript("NexusUI/Core/Utility/DeepCopy")

        --[[
            NexusUI DeepCopy Utilities
            Deep cloning and comparison utilities

            Features:
            - Deep copy with cycle detection
            - Shallow copy
            - Deep comparison
            - Merge operations
            - Structural cloning
        ]]

        --// DeepCopy Utility Module
        local DeepCopyUtil = {}

        --// Deep Copy with Cycle Detection
        function DeepCopyUtil.Copy(original, seen)
            -- Handle non-tables
            if type(original) ~= "table" then
                return original
            end

            -- Initialize seen table for cycle detection
            seen = seen or {}

            -- Check for cycles
            if seen[original] then
                return seen[original]
            end

            -- Create new table
            local copy = {}
            seen[original] = copy

            -- Copy all key-value pairs
            for key, value in pairs(original) do
                copy[DeepCopyUtil.Copy(key, seen)] = DeepCopyUtil.Copy(value, seen)
            end

            -- Copy metatable if present
            local mt = getmetatable(original)
            if mt then
                setmetatable(copy, DeepCopyUtil.Copy(mt, seen))
            end

            return copy
        end

        --// Shallow Copy
        function DeepCopyUtil.ShallowCopy(original)
            if type(original) ~= "table" then
                return original
            end

            local copy = {}
            for key, value in pairs(original) do
                copy[key] = value
            end

            return copy
        end

        --// Deep Copy without Metatable
        function DeepCopyUtil.CopyWithoutMeta(original, seen)
            if type(original) ~= "table" then
                return original
            end

            seen = seen or {}

            if seen[original] then
                return seen[original]
            end

            local copy = {}
            seen[original] = copy

            for key, value in pairs(original) do
                copy[DeepCopyUtil.CopyWithoutMeta(key, seen)] = DeepCopyUtil.CopyWithoutMeta(value, seen)
            end

            return copy
        end

        --// Structured Clone (handles special types)
        function DeepCopyUtil.StructuredClone(original, seen)
            local originalType = typeof(original)

            -- Handle primitives
            if originalType == "nil" or originalType == "boolean" or 
               originalType == "number" or originalType == "string" then
                return original
            end

            -- Handle Roblox types (these are immutable, return as-is)
            if originalType == "Color3" or originalType == "Vector2" or 
               originalType == "Vector3" or originalType == "UDim" or 
               originalType == "UDim2" or originalType == "CFrame" or
               originalType == "Rect" or originalType == "NumberRange" or
               originalType == "NumberSequence" or originalType == "ColorSequence" or
               originalType == "Font" or originalType == "EnumItem" then
                return original
            end

            -- Handle Instance (can't be cloned, return reference)
            if originalType == "Instance" then
                return original
            end

            -- Handle function (return reference)
            if originalType == "function" then
                return original
            end

            -- Handle table
            if originalType == "table" then
                seen = seen or {}

                if seen[original] then
                    return seen[original]
                end

                local copy = {}
                seen[original] = copy

                for key, value in pairs(original) do
                    copy[DeepCopyUtil.StructuredClone(key, seen)] = DeepCopyUtil.StructuredClone(value, seen)
                end

                local mt = getmetatable(original)
                if mt then
                    setmetatable(copy, DeepCopyUtil.StructuredClone(mt, seen))
                end

                return copy
            end

            -- Unknown type, return as-is
            return original
        end

        --// Deep Equality Check
        function DeepCopyUtil.Equals(a, b, seen)
            -- Same reference
            if a == b then
                return true
            end

            -- Type mismatch
            if type(a) ~= type(b) then
                return false
            end

            -- Handle non-tables
            if type(a) ~= "table" then
                return a == b
            end

            -- Cycle detection
            seen = seen or {}
            local key = tostring(a) .. tostring(b)

            if seen[key] then
                return true  -- Assume equal if we've seen this pair (cycle)
            end
            seen[key] = true

            -- Compare tables
            for k, v in pairs(a) do
                if not DeepCopyUtil.Equals(v, b[k], seen) then
                    return false
                end
            end

            for k, v in pairs(b) do
                if a[k] == nil then
                    return false
                end
            end

            return true
        end

        --// Deep Merge (target is modified)
        function DeepCopyUtil.MergeInto(target, source)
            if type(target) ~= "table" or type(source) ~= "table" then
                return target
            end

            for key, value in pairs(source) do
                if type(value) == "table" and type(target[key]) == "table" then
                    DeepCopyUtil.MergeInto(target[key], value)
                else
                    target[key] = DeepCopyUtil.Copy(value)
                end
            end

            return target
        end

        --// Deep Merge (returns new table)
        function DeepCopyUtil.Merge(...)
            local result = {}

            for _, tbl in ipairs({...}) do
                if type(tbl) == "table" then
                    DeepCopyUtil.MergeInto(result, tbl)
                end
            end

            return result
        end

        --// Shallow Merge
        function DeepCopyUtil.ShallowMerge(...)
            local result = {}

            for _, tbl in ipairs({...}) do
                if type(tbl) == "table" then
                    for key, value in pairs(tbl) do
                        result[key] = value
                    end
                end
            end

            return result
        end

        --// Deep Diff (find differences between two tables)
        function DeepCopyUtil.Diff(a, b, path)
            path = path or ""
            local differences = {}

            if type(a) ~= type(b) then
                table.insert(differences, {
                    Path = path,
                    Type = "type_mismatch",
                    ValueA = a,
                    ValueB = b
                })
                return differences
            end

            if type(a) ~= "table" then
                if a ~= b then
                    table.insert(differences, {
                        Path = path,
                        Type = "value_changed",
                        ValueA = a,
                        ValueB = b
                    })
                end
                return differences
            end

            -- Check keys in a
            for key, valueA in pairs(a) do
                local newPath = path == "" and tostring(key) or (path .. "." .. tostring(key))
                local valueB = b[key]

                if valueB == nil then
                    table.insert(differences, {
                        Path = newPath,
                        Type = "removed",
                        ValueA = valueA,
                        ValueB = nil
                    })
                else
                    local subDiff = DeepCopyUtil.Diff(valueA, valueB, newPath)
                    for _, diff in ipairs(subDiff) do
                        table.insert(differences, diff)
                    end
                end
            end

            -- Check keys in b that aren't in a
            for key, valueB in pairs(b) do
                if a[key] == nil then
                    local newPath = path == "" and tostring(key) or (path .. "." .. tostring(key))
                    table.insert(differences, {
                        Path = newPath,
                        Type = "added",
                        ValueA = nil,
                        ValueB = valueB
                    })
                end
            end

            return differences
        end

        --// Apply Diff
        function DeepCopyUtil.ApplyDiff(target, diff)
            for _, change in ipairs(diff) do
                local path = change.Path
                local parts = string.split(path, ".")

                local current = target

                for i = 1, #parts - 1 do
                    local key = tonumber(parts[i]) or parts[i]
                    if type(current[key]) ~= "table" then
                        current[key] = {}
                    end
                    current = current[key]
                end

                local lastKey = tonumber(parts[#parts]) or parts[#parts]

                if change.Type == "removed" then
                    current[lastKey] = nil
                else
                    current[lastKey] = DeepCopyUtil.Copy(change.ValueB)
                end
            end

            return target
        end

        --// Deep Freeze
        function DeepCopyUtil.Freeze(tbl)
            if type(tbl) ~= "table" then
                return tbl
            end

            for key, value in pairs(tbl) do
                if type(value) == "table" then
                    DeepCopyUtil.Freeze(value)
                end
            end

            return table.freeze(tbl)
        end

        --// Is Frozen
        function DeepCopyUtil.IsFrozen(tbl)
            if type(tbl) ~= "table" then
                return false
            end

            return table.isfrozen(tbl)
        end

        --// Deep Contains (check if a contains all of b)
        function DeepCopyUtil.Contains(a, b)
            if type(a) ~= "table" or type(b) ~= "table" then
                return a == b
            end

            for key, valueB in pairs(b) do
                local valueA = a[key]

                if valueA == nil then
                    return false
                end

                if not DeepCopyUtil.Contains(valueA, valueB) then
                    return false
                end
            end

            return true
        end

        --// Pick (select specific keys)
        function DeepCopyUtil.Pick(tbl, keys)
            local result = {}

            for _, key in ipairs(keys) do
                if tbl[key] ~= nil then
                    result[key] = DeepCopyUtil.Copy(tbl[key])
                end
            end

            return result
        end

        --// Omit (exclude specific keys)
        function DeepCopyUtil.Omit(tbl, keys)
            local keySet = {}
            for _, key in ipairs(keys) do
                keySet[key] = true
            end

            local result = {}

            for key, value in pairs(tbl) do
                if not keySet[key] then
                    result[key] = DeepCopyUtil.Copy(value)
                end
            end

            return result
        end

        --// Deep Get (get nested value by path)
        function DeepCopyUtil.Get(tbl, path, default)
            local parts = type(path) == "table" and path or string.split(path, ".")
            local current = tbl

            for _, key in ipairs(parts) do
                key = tonumber(key) or key

                if type(current) ~= "table" then
                    return default
                end

                current = current[key]
            end

            if current == nil then
                return default
            end

            return current
        end

        --// Deep Set (set nested value by path)
        function DeepCopyUtil.Set(tbl, path, value)
            local parts = type(path) == "table" and path or string.split(path, ".")
            local current = tbl

            for i = 1, #parts - 1 do
                local key = tonumber(parts[i]) or parts[i]

                if type(current[key]) ~= "table" then
                    current[key] = {}
                end

                current = current[key]
            end

            local lastKey = tonumber(parts[#parts]) or parts[#parts]
            current[lastKey] = value

            return tbl
        end

        --// Aliases
        DeepCopyUtil.DeepCopy = DeepCopyUtil.Copy
        DeepCopyUtil.Clone = DeepCopyUtil.Copy
        DeepCopyUtil.DeepClone = DeepCopyUtil.Copy
        DeepCopyUtil.DeepEquals = DeepCopyUtil.Equals
        DeepCopyUtil.DeepMerge = DeepCopyUtil.Merge

        return DeepCopyUtil


    end


    -- ============================================================================
    -- Module: NexusUI/Core/Utility/Lerp
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/Utility/Lerp"] = function()
        local script = CreateMockScript("NexusUI/Core/Utility/Lerp")

        --[[
            NexusUI Lerp Utilities
            Linear interpolation for various types

            Features:
            - Basic lerp operations
            - Type-specific lerp functions
            - Inverse lerp
            - Smooth step variations
            - Remap utilities
        ]]

        --// Lerp Utility Module
        local LerpUtil = {}

        --// Basic Lerp
        function LerpUtil.Lerp(a, b, t)
            return a + (b - a) * t
        end

        function LerpUtil.LerpClamped(a, b, t)
            t = math.max(0, math.min(1, t))
            return a + (b - a) * t
        end

        function LerpUtil.LerpUnclamped(a, b, t)
            return a + (b - a) * t
        end

        --// Inverse Lerp
        function LerpUtil.InverseLerp(a, b, value)
            if a == b then
                return 0
            end
            return (value - a) / (b - a)
        end

        function LerpUtil.InverseLerpClamped(a, b, value)
            return math.max(0, math.min(1, LerpUtil.InverseLerp(a, b, value)))
        end

        --// Remap (combined inverse lerp + lerp)
        function LerpUtil.Remap(value, inMin, inMax, outMin, outMax)
            local t = LerpUtil.InverseLerp(inMin, inMax, value)
            return LerpUtil.Lerp(outMin, outMax, t)
        end

        function LerpUtil.RemapClamped(value, inMin, inMax, outMin, outMax)
            local t = LerpUtil.InverseLerpClamped(inMin, inMax, value)
            return LerpUtil.Lerp(outMin, outMax, t)
        end

        --// Color3 Lerp
        function LerpUtil.Color3(c1, c2, t)
            return Color3.new(
                LerpUtil.Lerp(c1.R, c2.R, t),
                LerpUtil.Lerp(c1.G, c2.G, t),
                LerpUtil.Lerp(c1.B, c2.B, t)
            )
        end

        function LerpUtil.Color3HSV(c1, c2, t)
            local h1, s1, v1 = Color3.toHSV(c1)
            local h2, s2, v2 = Color3.toHSV(c2)

            -- Handle hue wraparound
            local hDiff = h2 - h1
            if math.abs(hDiff) > 0.5 then
                if hDiff > 0 then
                    h1 = h1 + 1
                else
                    h2 = h2 + 1
                end
            end

            local h = LerpUtil.Lerp(h1, h2, t) % 1
            local s = LerpUtil.Lerp(s1, s2, t)
            local v = LerpUtil.Lerp(v1, v2, t)

            return Color3.fromHSV(h, s, v)
        end

        --// Vector2 Lerp
        function LerpUtil.Vector2(v1, v2, t)
            return Vector2.new(
                LerpUtil.Lerp(v1.X, v2.X, t),
                LerpUtil.Lerp(v1.Y, v2.Y, t)
            )
        end

        --// Vector3 Lerp
        function LerpUtil.Vector3(v1, v2, t)
            return Vector3.new(
                LerpUtil.Lerp(v1.X, v2.X, t),
                LerpUtil.Lerp(v1.Y, v2.Y, t),
                LerpUtil.Lerp(v1.Z, v2.Z, t)
            )
        end

        --// UDim Lerp
        function LerpUtil.UDim(u1, u2, t)
            return UDim.new(
                LerpUtil.Lerp(u1.Scale, u2.Scale, t),
                LerpUtil.Lerp(u1.Offset, u2.Offset, t)
            )
        end

        --// UDim2 Lerp
        function LerpUtil.UDim2(u1, u2, t)
            return UDim2.new(
                LerpUtil.Lerp(u1.X.Scale, u2.X.Scale, t),
                LerpUtil.Lerp(u1.X.Offset, u2.X.Offset, t),
                LerpUtil.Lerp(u1.Y.Scale, u2.Y.Scale, t),
                LerpUtil.Lerp(u1.Y.Offset, u2.Y.Offset, t)
            )
        end

        --// CFrame Lerp
        function LerpUtil.CFrame(cf1, cf2, t)
            return cf1:Lerp(cf2, t)
        end

        --// NumberRange Lerp
        function LerpUtil.NumberRange(r1, r2, t)
            return NumberRange.new(
                LerpUtil.Lerp(r1.Min, r2.Min, t),
                LerpUtil.Lerp(r1.Max, r2.Max, t)
            )
        end

        --// Rect Lerp
        function LerpUtil.Rect(rect1, rect2, t)
            return Rect.new(
                LerpUtil.Lerp(rect1.Min.X, rect2.Min.X, t),
                LerpUtil.Lerp(rect1.Min.Y, rect2.Min.Y, t),
                LerpUtil.Lerp(rect1.Max.X, rect2.Max.X, t),
                LerpUtil.Lerp(rect1.Max.Y, rect2.Max.Y, t)
            )
        end

        --// Angle Lerp (handles wraparound)
        function LerpUtil.Angle(a1, a2, t)
            local diff = (a2 - a1) % (math.pi * 2)

            if diff > math.pi then
                diff = diff - math.pi * 2
            end

            return a1 + diff * t
        end

        function LerpUtil.AngleDegrees(a1, a2, t)
            local diff = (a2 - a1) % 360

            if diff > 180 then
                diff = diff - 360
            end

            return a1 + diff * t
        end

        --// Smooth Step Variations
        function LerpUtil.SmoothStep(a, b, t)
            t = math.max(0, math.min(1, t))
            t = t * t * (3 - 2 * t)
            return a + (b - a) * t
        end

        function LerpUtil.SmootherStep(a, b, t)
            t = math.max(0, math.min(1, t))
            t = t * t * t * (t * (t * 6 - 15) + 10)
            return a + (b - a) * t
        end

        function LerpUtil.SmoothestStep(a, b, t)
            t = math.max(0, math.min(1, t))
            t = t * t * t * t * (t * (t * (t * -20 + 70) - 84) + 35)
            return a + (b - a) * t
        end

        --// Ease In/Out Variations
        function LerpUtil.EaseIn(a, b, t, power)
            power = power or 2
            t = math.max(0, math.min(1, t))
            return a + (b - a) * (t ^ power)
        end

        function LerpUtil.EaseOut(a, b, t, power)
            power = power or 2
            t = math.max(0, math.min(1, t))
            return a + (b - a) * (1 - (1 - t) ^ power)
        end

        function LerpUtil.EaseInOut(a, b, t, power)
            power = power or 2
            t = math.max(0, math.min(1, t))

            if t < 0.5 then
                return a + (b - a) * ((2 * t) ^ power) / 2
            else
                return a + (b - a) * (1 - ((-2 * t + 2) ^ power) / 2)
            end
        end

        --// Spring Lerp (simplified)
        function LerpUtil.Spring(current, target, velocity, stiffness, damping, dt)
            stiffness = stiffness or 100
            damping = damping or 10
            dt = dt or 1/60

            local displacement = current - target
            local springForce = -stiffness * displacement
            local dampingForce = -damping * velocity

            local acceleration = springForce + dampingForce
            velocity = velocity + acceleration * dt
            current = current + velocity * dt

            return current, velocity
        end

        --// Damp (exponential decay)
        function LerpUtil.Damp(current, target, smoothing, dt)
            return LerpUtil.Lerp(current, target, 1 - math.exp(-smoothing * dt))
        end

        function LerpUtil.DampVector2(current, target, smoothing, dt)
            return LerpUtil.Vector2(current, target, 1 - math.exp(-smoothing * dt))
        end

        function LerpUtil.DampVector3(current, target, smoothing, dt)
            return LerpUtil.Vector3(current, target, 1 - math.exp(-smoothing * dt))
        end

        function LerpUtil.DampColor3(current, target, smoothing, dt)
            return LerpUtil.Color3(current, target, 1 - math.exp(-smoothing * dt))
        end

        function LerpUtil.DampUDim2(current, target, smoothing, dt)
            return LerpUtil.UDim2(current, target, 1 - math.exp(-smoothing * dt))
        end

        --// Move Towards (constant speed)
        function LerpUtil.MoveTowards(current, target, maxDelta)
            local diff = target - current

            if math.abs(diff) <= maxDelta then
                return target
            end

            return current + math.sign(diff) * maxDelta
        end

        function LerpUtil.MoveTowardsVector2(current, target, maxDelta)
            local diff = target - current
            local dist = diff.Magnitude

            if dist <= maxDelta or dist == 0 then
                return target
            end

            return current + diff / dist * maxDelta
        end

        function LerpUtil.MoveTowardsVector3(current, target, maxDelta)
            local diff = target - current
            local dist = diff.Magnitude

            if dist <= maxDelta or dist == 0 then
                return target
            end

            return current + diff / dist * maxDelta
        end

        --// Ping Pong
        function LerpUtil.PingPong(t, length)
            length = length or 1
            t = t % (length * 2)
            return length - math.abs(t - length)
        end

        function LerpUtil.PingPongLerp(a, b, t)
            local pingPongT = LerpUtil.PingPong(t, 1)
            return LerpUtil.Lerp(a, b, pingPongT)
        end

        --// Repeat
        function LerpUtil.Repeat(t, length)
            length = length or 1
            return t % length
        end

        --// Delta Lerp (frame-rate independent)
        function LerpUtil.DeltaLerp(current, target, smoothTime, dt)
            local t = 1 - math.exp(-dt / smoothTime)
            return LerpUtil.Lerp(current, target, t)
        end

        --// Bezier Lerp (quadratic)
        function LerpUtil.QuadraticBezier(p0, p1, p2, t)
            local t1 = 1 - t
            return t1 * t1 * p0 + 2 * t1 * t * p1 + t * t * p2
        end

        --// Bezier Lerp (cubic)
        function LerpUtil.CubicBezier(p0, p1, p2, p3, t)
            local t1 = 1 - t
            local t1_2 = t1 * t1
            local t1_3 = t1_2 * t1
            local t_2 = t * t
            local t_3 = t_2 * t

            return t1_3 * p0 + 3 * t1_2 * t * p1 + 3 * t1 * t_2 * p2 + t_3 * p3
        end

        --// Catmull-Rom Spline
        function LerpUtil.CatmullRom(p0, p1, p2, p3, t)
            local t2 = t * t
            local t3 = t2 * t

            return 0.5 * (
                (2 * p1) +
                (-p0 + p2) * t +
                (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 +
                (-p0 + 3 * p1 - 3 * p2 + p3) * t3
            )
        end

        --// Auto Lerp (detects type)
        function LerpUtil.Auto(a, b, t)
            local typeA = typeof(a)

            if typeA == "number" then
                return LerpUtil.Lerp(a, b, t)
            elseif typeA == "Color3" then
                return LerpUtil.Color3(a, b, t)
            elseif typeA == "Vector2" then
                return LerpUtil.Vector2(a, b, t)
            elseif typeA == "Vector3" then
                return LerpUtil.Vector3(a, b, t)
            elseif typeA == "UDim" then
                return LerpUtil.UDim(a, b, t)
            elseif typeA == "UDim2" then
                return LerpUtil.UDim2(a, b, t)
            elseif typeA == "CFrame" then
                return LerpUtil.CFrame(a, b, t)
            elseif typeA == "NumberRange" then
                return LerpUtil.NumberRange(a, b, t)
            elseif typeA == "Rect" then
                return LerpUtil.Rect(a, b, t)
            end

            -- Default to returning b if t >= 0.5, else a
            return t >= 0.5 and b or a
        end

        return LerpUtil


    end


    -- ============================================================================
    -- Module: NexusUI/Core/Utility/Validate
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/Utility/Validate"] = function()
        local script = CreateMockScript("NexusUI/Core/Utility/Validate")

        --[[
            NexusUI Validation Utilities
            Input validation and sanitization functions

            Features:
            - Type validation
            - Value range validation
            - Pattern validation
            - Schema validation
            - Sanitization helpers
        ]]

        --// Validate Utility Module
        local ValidateUtil = {}

        --// Type Checking
        function ValidateUtil.IsString(value)
            return type(value) == "string"
        end

        function ValidateUtil.IsNumber(value)
            return type(value) == "number"
        end

        function ValidateUtil.IsBoolean(value)
            return type(value) == "boolean"
        end

        function ValidateUtil.IsTable(value)
            return type(value) == "table"
        end

        function ValidateUtil.IsFunction(value)
            return type(value) == "function"
        end

        function ValidateUtil.IsNil(value)
            return value == nil
        end

        function ValidateUtil.IsNotNil(value)
            return value ~= nil
        end

        function ValidateUtil.IsInstance(value)
            return typeof(value) == "Instance"
        end

        function ValidateUtil.IsColor3(value)
            return typeof(value) == "Color3"
        end

        function ValidateUtil.IsVector2(value)
            return typeof(value) == "Vector2"
        end

        function ValidateUtil.IsVector3(value)
            return typeof(value) == "Vector3"
        end

        function ValidateUtil.IsUDim(value)
            return typeof(value) == "UDim"
        end

        function ValidateUtil.IsUDim2(value)
            return typeof(value) == "UDim2"
        end

        function ValidateUtil.IsCFrame(value)
            return typeof(value) == "CFrame"
        end

        function ValidateUtil.IsEnum(value)
            return typeof(value) == "EnumItem"
        end

        --// Type Validation with Error
        function ValidateUtil.ExpectType(value, expectedType, name)
            local actualType = type(value)

            if actualType ~= expectedType then
                return false, string.format("Expected %s to be %s, got %s", name or "value", expectedType, actualType)
            end

            return true
        end

        function ValidateUtil.ExpectTypeOf(value, expectedType, name)
            local actualType = typeof(value)

            if actualType ~= expectedType then
                return false, string.format("Expected %s to be %s, got %s", name or "value", expectedType, actualType)
            end

            return true
        end

        --// Number Validation
        function ValidateUtil.IsInteger(value)
            return type(value) == "number" and value == math.floor(value)
        end

        function ValidateUtil.IsPositive(value)
            return type(value) == "number" and value > 0
        end

        function ValidateUtil.IsNegative(value)
            return type(value) == "number" and value < 0
        end

        function ValidateUtil.IsNonNegative(value)
            return type(value) == "number" and value >= 0
        end

        function ValidateUtil.IsNonPositive(value)
            return type(value) == "number" and value <= 0
        end

        function ValidateUtil.IsFinite(value)
            return type(value) == "number" and value == value and value ~= math.huge and value ~= -math.huge
        end

        function ValidateUtil.IsNaN(value)
            return type(value) == "number" and value ~= value
        end

        function ValidateUtil.IsInRange(value, min, max)
            return type(value) == "number" and value >= min and value <= max
        end

        function ValidateUtil.IsInRangeExclusive(value, min, max)
            return type(value) == "number" and value > min and value < max
        end

        --// String Validation
        function ValidateUtil.IsEmpty(value)
            return value == nil or value == ""
        end

        function ValidateUtil.IsNotEmpty(value)
            return value ~= nil and value ~= ""
        end

        function ValidateUtil.IsBlank(value)
            return value == nil or (type(value) == "string" and value:match("^%s*$") ~= nil)
        end

        function ValidateUtil.IsNotBlank(value)
            return type(value) == "string" and value:match("^%s*$") == nil
        end

        function ValidateUtil.HasMinLength(value, minLength)
            return type(value) == "string" and #value >= minLength
        end

        function ValidateUtil.HasMaxLength(value, maxLength)
            return type(value) == "string" and #value <= maxLength
        end

        function ValidateUtil.HasLength(value, length)
            return type(value) == "string" and #value == length
        end

        function ValidateUtil.HasLengthBetween(value, minLength, maxLength)
            return type(value) == "string" and #value >= minLength and #value <= maxLength
        end

        function ValidateUtil.MatchesPattern(value, pattern)
            return type(value) == "string" and value:match(pattern) ~= nil
        end

        function ValidateUtil.StartsWith(value, prefix)
            return type(value) == "string" and value:sub(1, #prefix) == prefix
        end

        function ValidateUtil.EndsWith(value, suffix)
            return type(value) == "string" and value:sub(-#suffix) == suffix
        end

        function ValidateUtil.Contains(value, substring)
            return type(value) == "string" and value:find(substring, 1, true) ~= nil
        end

        --// Format Validation
        function ValidateUtil.IsEmail(value)
            return type(value) == "string" and value:match("^[%w._%+-]+@[%w.-]+%.[%w]+$") ~= nil
        end

        function ValidateUtil.IsUrl(value)
            return type(value) == "string" and value:match("^https?://[%w.-]+") ~= nil
        end

        function ValidateUtil.IsHex(value)
            return type(value) == "string" and value:match("^#?[%x]+$") ~= nil
        end

        function ValidateUtil.IsHexColor(value)
            return type(value) == "string" and (value:match("^#[%x][%x][%x]$") ~= nil or value:match("^#[%x][%x][%x][%x][%x][%x]$") ~= nil)
        end

        function ValidateUtil.IsAlpha(value)
            return type(value) == "string" and value:match("^%a+$") ~= nil
        end

        function ValidateUtil.IsAlphanumeric(value)
            return type(value) == "string" and value:match("^%w+$") ~= nil
        end

        function ValidateUtil.IsNumeric(value)
            return type(value) == "string" and value:match("^%d+$") ~= nil
        end

        function ValidateUtil.IsUUID(value)
            return type(value) == "string" and value:match("^%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x$") ~= nil
        end

        --// Array/Table Validation
        function ValidateUtil.IsArray(value)
            if type(value) ~= "table" then
                return false
            end

            local count = 0
            for _ in pairs(value) do
                count = count + 1
            end

            return count == #value
        end

        function ValidateUtil.IsDictionary(value)
            return type(value) == "table" and not ValidateUtil.IsArray(value)
        end

        function ValidateUtil.IsEmptyTable(value)
            return type(value) == "table" and next(value) == nil
        end

        function ValidateUtil.HasKey(value, key)
            return type(value) == "table" and value[key] ~= nil
        end

        function ValidateUtil.HasKeys(value, keys)
            if type(value) ~= "table" then
                return false
            end

            for _, key in ipairs(keys) do
                if value[key] == nil then
                    return false
                end
            end

            return true
        end

        function ValidateUtil.HasMinItems(value, minItems)
            if type(value) ~= "table" then
                return false
            end

            local count = 0
            for _ in pairs(value) do
                count = count + 1
                if count >= minItems then
                    return true
                end
            end

            return count >= minItems
        end

        function ValidateUtil.HasMaxItems(value, maxItems)
            if type(value) ~= "table" then
                return false
            end

            local count = 0
            for _ in pairs(value) do
                count = count + 1
                if count > maxItems then
                    return false
                end
            end

            return true
        end

        function ValidateUtil.ContainsValue(value, searchValue)
            if type(value) ~= "table" then
                return false
            end

            for _, v in pairs(value) do
                if v == searchValue then
                    return true
                end
            end

            return false
        end

        function ValidateUtil.AllMatch(value, predicate)
            if type(value) ~= "table" then
                return false
            end

            for k, v in pairs(value) do
                if not predicate(v, k) then
                    return false
                end
            end

            return true
        end

        function ValidateUtil.AnyMatch(value, predicate)
            if type(value) ~= "table" then
                return false
            end

            for k, v in pairs(value) do
                if predicate(v, k) then
                    return true
                end
            end

            return false
        end

        --// Instance Validation
        function ValidateUtil.IsInstanceOfClass(value, className)
            return typeof(value) == "Instance" and value:IsA(className)
        end

        function ValidateUtil.HasProperty(instance, propertyName)
            if typeof(instance) ~= "Instance" then
                return false
            end

            local success = pcall(function()
                local _ = instance[propertyName]
            end)

            return success
        end

        --// Schema Validation
        function ValidateUtil.ValidateSchema(value, schema)
            local errors = {}

            if type(value) ~= "table" then
                return false, {"Value must be a table"}
            end

            for fieldName, fieldSchema in pairs(schema) do
                local fieldValue = value[fieldName]
                local isValid, error = ValidateUtil.ValidateField(fieldValue, fieldSchema, fieldName)

                if not isValid then
                    table.insert(errors, error)
                end
            end

            return #errors == 0, errors
        end

        function ValidateUtil.ValidateField(value, schema, fieldName)
            fieldName = fieldName or "field"

            -- Required check
            if schema.Required and value == nil then
                return false, string.format("%s is required", fieldName)
            end

            -- Skip further validation if nil and not required
            if value == nil then
                return true
            end

            -- Type check
            if schema.Type then
                if type(value) ~= schema.Type and typeof(value) ~= schema.Type then
                    return false, string.format("%s must be of type %s", fieldName, schema.Type)
                end
            end

            -- Number validations
            if type(value) == "number" then
                if schema.Min ~= nil and value < schema.Min then
                    return false, string.format("%s must be at least %s", fieldName, schema.Min)
                end

                if schema.Max ~= nil and value > schema.Max then
                    return false, string.format("%s must be at most %s", fieldName, schema.Max)
                end

                if schema.Integer and value ~= math.floor(value) then
                    return false, string.format("%s must be an integer", fieldName)
                end
            end

            -- String validations
            if type(value) == "string" then
                if schema.MinLength ~= nil and #value < schema.MinLength then
                    return false, string.format("%s must be at least %d characters", fieldName, schema.MinLength)
                end

                if schema.MaxLength ~= nil and #value > schema.MaxLength then
                    return false, string.format("%s must be at most %d characters", fieldName, schema.MaxLength)
                end

                if schema.Pattern and not value:match(schema.Pattern) then
                    return false, string.format("%s does not match required pattern", fieldName)
                end
            end

            -- Enum validation
            if schema.Enum then
                local found = false
                for _, enumValue in ipairs(schema.Enum) do
                    if value == enumValue then
                        found = true
                        break
                    end
                end

                if not found then
                    return false, string.format("%s must be one of: %s", fieldName, table.concat(schema.Enum, ", "))
                end
            end

            -- Custom validator
            if schema.Validator then
                local isValid, error = schema.Validator(value)
                if not isValid then
                    return false, error or string.format("%s failed custom validation", fieldName)
                end
            end

            return true
        end

        --// Create Validator Function
        function ValidateUtil.CreateValidator(schema)
            return function(value)
                return ValidateUtil.ValidateSchema(value, schema)
            end
        end

        --// Sanitization
        function ValidateUtil.Sanitize(value, options)
            options = options or {}

            if type(value) == "string" then
                -- Trim whitespace
                if options.Trim ~= false then
                    value = value:match("^%s*(.-)%s*$")
                end

                -- Remove control characters
                if options.RemoveControlChars then
                    value = value:gsub("%c", "")
                end

                -- Lowercase
                if options.Lowercase then
                    value = value:lower()
                end

                -- Uppercase
                if options.Uppercase then
                    value = value:upper()
                end

                -- Max length truncation
                if options.MaxLength and #value > options.MaxLength then
                    value = value:sub(1, options.MaxLength)
                end

                -- Default value for empty
                if options.DefaultIfEmpty and value == "" then
                    value = options.DefaultIfEmpty
                end
            elseif type(value) == "number" then
                -- Clamp
                if options.Min ~= nil then
                    value = math.max(options.Min, value)
                end

                if options.Max ~= nil then
                    value = math.min(options.Max, value)
                end

                -- Round
                if options.Round then
                    local decimals = options.RoundDecimals or 0
                    local mult = 10 ^ decimals
                    value = math.floor(value * mult + 0.5) / mult
                end

                -- Floor/Ceil
                if options.Floor then
                    value = math.floor(value)
                elseif options.Ceil then
                    value = math.ceil(value)
                end
            end

            return value
        end

        --// Assert Helpers
        function ValidateUtil.Assert(condition, message)
            if not condition then
                error(message or "Assertion failed", 2)
            end
        end

        function ValidateUtil.AssertType(value, expectedType, name)
            local isValid, error = ValidateUtil.ExpectType(value, expectedType, name)
            if not isValid then
                error(error, 2)
            end
        end

        function ValidateUtil.AssertNotNil(value, name)
            if value == nil then
                error(string.format("%s cannot be nil", name or "Value"), 2)
            end
        end

        function ValidateUtil.AssertInRange(value, min, max, name)
            if not ValidateUtil.IsInRange(value, min, max) then
                error(string.format("%s must be between %s and %s", name or "Value", min, max), 2)
            end
        end

        return ValidateUtil


    end


    -- ============================================================================
    -- Module: NexusUI/Core/Utility/init
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/Utility/init"] = function()
        local script = CreateMockScript("NexusUI/Core/Utility/init")

        --[[
            NexusUI Utility Module
            Central utility function hub

            Provides:
            - Math utilities
            - String utilities
            - Table utilities
            - Color utilities
            - Validation utilities
            - And more...
        ]]

        --// Utility Module
        local Utility = {}

        --// Load Sub-modules
        local function SafeRequire(modulePath)
            local success, result = pcall(function()
                if modulePath and modulePath:IsA("ModuleScript") then
                    return require(modulePath)
                end
                return nil
            end)

            if success then
                return result
            end

            return nil
        end

        --// Sub-module References
        Utility.Math = SafeRequire(script:FindFirstChild("Math"))
        Utility.String = SafeRequire(script:FindFirstChild("String"))
        Utility.Table = SafeRequire(script:FindFirstChild("Table"))
        Utility.Color = SafeRequire(script:FindFirstChild("Color"))
        Utility.Bezier = SafeRequire(script:FindFirstChild("Bezier"))
        Utility.UUID = SafeRequire(script:FindFirstChild("UUID"))
        Utility.Debounce = SafeRequire(script:FindFirstChild("Debounce"))
        Utility.DeepCopy = SafeRequire(script:FindFirstChild("DeepCopy"))
        Utility.Lerp = SafeRequire(script:FindFirstChild("Lerp"))
        Utility.Validate = SafeRequire(script:FindFirstChild("Validate"))

        --// Common Utility Functions (directly accessible)

        -- Type checking
        function Utility.IsNumber(value)
            return type(value) == "number"
        end

        function Utility.IsString(value)
            return type(value) == "string"
        end

        function Utility.IsBoolean(value)
            return type(value) == "boolean"
        end

        function Utility.IsTable(value)
            return type(value) == "table"
        end

        function Utility.IsFunction(value)
            return type(value) == "function"
        end

        function Utility.IsNil(value)
            return value == nil
        end

        function Utility.IsInstance(value)
            return typeof(value) == "Instance"
        end

        function Utility.IsColor3(value)
            return typeof(value) == "Color3"
        end

        function Utility.IsUDim2(value)
            return typeof(value) == "UDim2"
        end

        function Utility.IsVector2(value)
            return typeof(value) == "Vector2"
        end

        function Utility.IsVector3(value)
            return typeof(value) == "Vector3"
        end

        -- Safe operations
        function Utility.SafeCall(func, ...)
            if type(func) ~= "function" then
                return false, "Not a function"
            end
            return pcall(func, ...)
        end

        function Utility.SafeIndex(tbl, ...)
            local current = tbl
            for _, key in ipairs({...}) do
                if type(current) ~= "table" then
                    return nil
                end
                current = current[key]
            end
            return current
        end

        function Utility.SafeSet(tbl, value, ...)
            local keys = {...}
            local current = tbl

            for i = 1, #keys - 1 do
                local key = keys[i]
                if type(current[key]) ~= "table" then
                    current[key] = {}
                end
                current = current[key]
            end

            current[keys[#keys]] = value
        end

        -- Instance utilities
        function Utility.IsValidInstance(instance)
            if instance == nil then return false end

            local success, result = pcall(function()
                return instance.Parent ~= nil or instance.ClassName ~= nil
            end)

            return success and result ~= nil
        end

        function Utility.SafeDestroy(instance)
            if Utility.IsValidInstance(instance) then
                pcall(function()
                    instance:Destroy()
                end)
            end
        end

        function Utility.WaitForChild(parent, childName, timeout)
            timeout = timeout or 5

            local child = parent:FindFirstChild(childName)
            if child then return child end

            local startTime = os.clock()
            while os.clock() - startTime < timeout do
                child = parent:FindFirstChild(childName)
                if child then return child end
                task.wait()
            end

            return nil
        end

        function Utility.GetDescendants(instance, className)
            local results = {}

            for _, descendant in ipairs(instance:GetDescendants()) do
                if not className or descendant:IsA(className) then
                    table.insert(results, descendant)
                end
            end

            return results
        end

        -- Number utilities
        function Utility.Clamp(value, min, max)
            return math.max(min, math.min(max, value))
        end

        function Utility.Round(value, decimals)
            decimals = decimals or 0
            local mult = 10 ^ decimals
            return math.floor(value * mult + 0.5) / mult
        end

        function Utility.Map(value, inMin, inMax, outMin, outMax)
            return outMin + (value - inMin) * (outMax - outMin) / (inMax - inMin)
        end

        function Utility.Lerp(a, b, t)
            return a + (b - a) * t
        end

        function Utility.InverseLerp(a, b, value)
            if a == b then return 0 end
            return (value - a) / (b - a)
        end

        function Utility.SmoothStep(edge0, edge1, x)
            local t = Utility.Clamp((x - edge0) / (edge1 - edge0), 0, 1)
            return t * t * (3 - 2 * t)
        end

        function Utility.SmootherStep(edge0, edge1, x)
            local t = Utility.Clamp((x - edge0) / (edge1 - edge0), 0, 1)
            return t * t * t * (t * (t * 6 - 15) + 10)
        end

        -- String utilities
        function Utility.Trim(str)
            return str:match("^%s*(.-)%s*$")
        end

        function Utility.Split(str, delimiter)
            delimiter = delimiter or ","
            local result = {}
            for match in (str .. delimiter):gmatch("(.-)" .. delimiter) do
                table.insert(result, match)
            end
            return result
        end

        function Utility.StartsWith(str, prefix)
            return str:sub(1, #prefix) == prefix
        end

        function Utility.EndsWith(str, suffix)
            return str:sub(-#suffix) == suffix
        end

        function Utility.Contains(str, substring)
            return str:find(substring, 1, true) ~= nil
        end

        function Utility.Capitalize(str)
            return str:sub(1, 1):upper() .. str:sub(2):lower()
        end

        function Utility.CamelCase(str)
            local result = ""
            for word in str:gmatch("[%w]+") do
                if result == "" then
                    result = word:lower()
                else
                    result = result .. Utility.Capitalize(word)
                end
            end
            return result
        end

        function Utility.PascalCase(str)
            local result = ""
            for word in str:gmatch("[%w]+") do
                result = result .. Utility.Capitalize(word)
            end
            return result
        end

        function Utility.SnakeCase(str)
            return str:gsub("([A-Z])", "_%1"):gsub("^_", ""):lower()
        end

        function Utility.Truncate(str, maxLength, suffix)
            suffix = suffix or "..."
            if #str <= maxLength then
                return str
            end
            return str:sub(1, maxLength - #suffix) .. suffix
        end

        -- Table utilities
        function Utility.DeepCopy(original)
            if type(original) ~= "table" then
                return original
            end

            local copy = {}
            for key, value in pairs(original) do
                copy[Utility.DeepCopy(key)] = Utility.DeepCopy(value)
            end

            return setmetatable(copy, getmetatable(original))
        end

        function Utility.ShallowCopy(original)
            if type(original) ~= "table" then
                return original
            end

            local copy = {}
            for key, value in pairs(original) do
                copy[key] = value
            end

            return copy
        end

        function Utility.Merge(base, override)
            local result = Utility.DeepCopy(base)

            for key, value in pairs(override) do
                if type(value) == "table" and type(result[key]) == "table" then
                    result[key] = Utility.Merge(result[key], value)
                else
                    result[key] = value
                end
            end

            return result
        end

        function Utility.Keys(tbl)
            local keys = {}
            for key, _ in pairs(tbl) do
                table.insert(keys, key)
            end
            return keys
        end

        function Utility.Values(tbl)
            local values = {}
            for _, value in pairs(tbl) do
                table.insert(values, value)
            end
            return values
        end

        function Utility.Count(tbl)
            local count = 0
            for _ in pairs(tbl) do
                count = count + 1
            end
            return count
        end

        function Utility.IsEmpty(tbl)
            return next(tbl) == nil
        end

        function Utility.Find(tbl, predicate)
            for key, value in pairs(tbl) do
                if predicate(value, key) then
                    return value, key
                end
            end
            return nil
        end

        function Utility.Filter(tbl, predicate)
            local result = {}
            for key, value in pairs(tbl) do
                if predicate(value, key) then
                    if type(key) == "number" then
                        table.insert(result, value)
                    else
                        result[key] = value
                    end
                end
            end
            return result
        end

        function Utility.Map(tbl, transform)
            local result = {}
            for key, value in pairs(tbl) do
                if type(key) == "number" then
                    table.insert(result, transform(value, key))
                else
                    result[key] = transform(value, key)
                end
            end
            return result
        end

        function Utility.Reduce(tbl, reducer, initial)
            local accumulator = initial
            for key, value in pairs(tbl) do
                accumulator = reducer(accumulator, value, key)
            end
            return accumulator
        end

        function Utility.Reverse(tbl)
            local result = {}
            for i = #tbl, 1, -1 do
                table.insert(result, tbl[i])
            end
            return result
        end

        function Utility.Shuffle(tbl)
            local result = Utility.ShallowCopy(tbl)
            for i = #result, 2, -1 do
                local j = math.random(i)
                result[i], result[j] = result[j], result[i]
            end
            return result
        end

        -- Time utilities
        function Utility.Now()
            return os.clock()
        end

        function Utility.FormatTime(seconds)
            local hours = math.floor(seconds / 3600)
            local minutes = math.floor((seconds % 3600) / 60)
            local secs = math.floor(seconds % 60)

            if hours > 0 then
                return string.format("%02d:%02d:%02d", hours, minutes, secs)
            else
                return string.format("%02d:%02d", minutes, secs)
            end
        end

        function Utility.FormatTimestamp(timestamp)
            return os.date("%Y-%m-%d %H:%M:%S", timestamp)
        end

        -- Number formatting
        function Utility.FormatNumber(num, decimals)
            decimals = decimals or 0

            if num >= 1e12 then
                return Utility.Round(num / 1e12, decimals) .. "T"
            elseif num >= 1e9 then
                return Utility.Round(num / 1e9, decimals) .. "B"
            elseif num >= 1e6 then
                return Utility.Round(num / 1e6, decimals) .. "M"
            elseif num >= 1e3 then
                return Utility.Round(num / 1e3, decimals) .. "K"
            else
                return Utility.Round(num, decimals)
            end
        end

        function Utility.FormatBytes(bytes)
            local units = {"B", "KB", "MB", "GB", "TB"}
            local index = 1

            while bytes >= 1024 and index < #units do
                bytes = bytes / 1024
                index = index + 1
            end

            return string.format("%.2f %s", bytes, units[index])
        end

        function Utility.FormatPercentage(value, decimals)
            decimals = decimals or 1
            return Utility.Round(value * 100, decimals) .. "%"
        end

        -- ID generation
        function Utility.GenerateUID(prefix)
            prefix = prefix or "uid"
            local chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
            local uid = prefix .. "_"

            for i = 1, 16 do
                local randomIndex = math.random(1, #chars)
                uid = uid .. chars:sub(randomIndex, randomIndex)
            end

            return uid .. "_" .. tostring(os.clock()):gsub("%.", "")
        end

        function Utility.GenerateGUID()
            local HttpService = game:GetService("HttpService")
            return HttpService:GenerateGUID(false)
        end

        -- Debounce/Throttle
        function Utility.Debounce(func, delay)
            local lastCall = 0

            return function(...)
                local now = os.clock()
                if now - lastCall >= delay then
                    lastCall = now
                    return func(...)
                end
            end
        end

        function Utility.Throttle(func, delay)
            local lastCall = 0
            local scheduled = false
            local lastArgs = nil

            return function(...)
                lastArgs = {...}
                local now = os.clock()

                if now - lastCall >= delay then
                    lastCall = now
                    return func(...)
                elseif not scheduled then
                    scheduled = true
                    task.delay(delay - (now - lastCall), function()
                        scheduled = false
                        lastCall = os.clock()
                        func(unpack(lastArgs))
                    end)
                end
            end
        end

        -- Color utilities (basic)
        function Utility.HexToColor3(hex)
            hex = hex:gsub("#", "")

            if #hex == 3 then
                hex = hex:sub(1, 1):rep(2) .. hex:sub(2, 2):rep(2) .. hex:sub(3, 3):rep(2)
            end

            local r = tonumber(hex:sub(1, 2), 16) / 255
            local g = tonumber(hex:sub(3, 4), 16) / 255
            local b = tonumber(hex:sub(5, 6), 16) / 255

            return Color3.new(r, g, b)
        end

        function Utility.Color3ToHex(color)
            return string.format("#%02X%02X%02X",
                math.floor(color.R * 255 + 0.5),
                math.floor(color.G * 255 + 0.5),
                math.floor(color.B * 255 + 0.5)
            )
        end

        function Utility.LerpColor3(c1, c2, t)
            return Color3.new(
                Utility.Lerp(c1.R, c2.R, t),
                Utility.Lerp(c1.G, c2.G, t),
                Utility.Lerp(c1.B, c2.B, t)
            )
        end

        -- Screen utilities
        function Utility.GetScreenSize()
            local camera = workspace.CurrentCamera
            if camera then
                return camera.ViewportSize
            end
            return Vector2.new(1920, 1080)
        end

        function Utility.GetMousePosition()
            local UserInputService = game:GetService("UserInputService")
            return UserInputService:GetMouseLocation()
        end

        function Utility.IsMouseOver(guiObject)
            if not Utility.IsValidInstance(guiObject) then return false end

            local mousePos = Utility.GetMousePosition()
            local objPos = guiObject.AbsolutePosition
            local objSize = guiObject.AbsoluteSize

            return mousePos.X >= objPos.X and 
                   mousePos.X <= objPos.X + objSize.X and
                   mousePos.Y >= objPos.Y and 
                   mousePos.Y <= objPos.Y + objSize.Y
        end

        -- Text utilities
        function Utility.GetTextSize(text, fontSize, font, maxWidth)
            local TextService = game:GetService("TextService")
            maxWidth = maxWidth or math.huge

            local textSize = TextService:GetTextSize(
                text,
                fontSize,
                font,
                Vector2.new(maxWidth, math.huge)
            )

            return textSize.X, textSize.Y
        end

        return Utility


    end


    -- ============================================================================
    -- Module: NexusUI/Core/Initialization
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/Initialization"] = function()
        local script = CreateMockScript("NexusUI/Core/Initialization")

        --[[
            NexusUI Initialization Module
            Handles library bootstrap and setup procedures

            Features:
            - Environment detection
            - Dependency validation
            - Module loading orchestration
            - Error handling and recovery
            - Initialization hooks
            - Cleanup registration
        ]]

        --// Services
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local HttpService = game:GetService("HttpService")

        --// Initialization Module
        local Initialization = {}
        Initialization.__index = Initialization
        Initialization.ClassName = "Initialization"

        --// State
        local InitState = {
            Initialized = false,
            InitStartTime = 0,
            InitEndTime = 0,
            InitDuration = 0,
            Errors = {},
            Warnings = {},
            LoadedModules = {},
            Hooks = {
                PreInit = {},
                PostInit = {},
                PreDestroy = {},
                PostDestroy = {},
            },
        }

        --// Environment Info
        local Environment = {
            IsStudio = RunService:IsStudio(),
            IsClient = RunService:IsClient(),
            IsServer = RunService:IsServer(),
            IsExecutor = false,
            ExecutorName = "Unknown",
            ExecutorVersion = "Unknown",
            GameId = game.GameId,
            PlaceId = game.PlaceId,
            PlaceVersion = game.PlaceVersion,
        }

        --// Executor Detection
        local function DetectExecutor()
            local executors = {
                { Name = "Synapse X", Check = function() return syn ~= nil end },
                { Name = "Script-Ware", Check = function() return identifyexecutor and identifyexecutor():find("Script%-Ware") end },
                { Name = "Krnl", Check = function() return KRNL_LOADED ~= nil end },
                { Name = "Fluxus", Check = function() return fluxus ~= nil end },
                { Name = "Oxygen U", Check = function() return pebc_execute ~= nil end },
                { Name = "Electron", Check = function() return Electron ~= nil end },
                { Name = "Celery", Check = function() return celession ~= nil end },
                { Name = "Comet", Check = function() return Comet ~= nil end },
                { Name = "Wave", Check = function() return wave_loaded ~= nil end },
            }

            for _, executor in ipairs(executors) do
                local success, result = pcall(executor.Check)
                if success and result then
                    Environment.IsExecutor = true
                    Environment.ExecutorName = executor.Name
                    break
                end
            end

            -- Try identifyexecutor function
            if not Environment.IsExecutor then
                local success, result = pcall(function()
                    if identifyexecutor then
                        return identifyexecutor()
                    end
                    return nil
                end)

                if success and result then
                    Environment.IsExecutor = true
                    Environment.ExecutorName = result
                end
            end

            -- Get version if available
            local success, version = pcall(function()
                if getexecutorversion then
                    return getexecutorversion()
                end
                return "Unknown"
            end)

            if success then
                Environment.ExecutorVersion = version
            end
        end

        --// Dependency Checks
        local function CheckDependencies()
            local issues = {}

            -- Check for required executor functions
            local requiredFunctions = {
                -- These are optional but recommended
                { Name = "getgenv", Required = false },
                { Name = "getrenv", Required = false },
                { Name = "hookfunction", Required = false },
                { Name = "newcclosure", Required = false },
                { Name = "setclipboard", Required = false },
                { Name = "writefile", Required = false },
                { Name = "readfile", Required = false },
                { Name = "isfile", Required = false },
                { Name = "delfile", Required = false },
                { Name = "makefolder", Required = false },
                { Name = "isfolder", Required = false },
                { Name = "listfiles", Required = false },
            }

            for _, func in ipairs(requiredFunctions) do
                local exists = getfenv()[func.Name] ~= nil

                if not exists and func.Required then
                    table.insert(issues, {
                        Type = "Error",
                        Message = string.format("Required function '%s' not found", func.Name)
                    })
                elseif not exists then
                    table.insert(issues, {
                        Type = "Warning",
                        Message = string.format("Optional function '%s' not available", func.Name)
                    })
                end
            end

            return issues
        end

        --// File System Setup
        local function SetupFileSystem()
            local folders = {
                "NexusUI",
                "NexusUI/Configs",
                "NexusUI/Themes",
                "NexusUI/Cache",
                "NexusUI/Logs",
            }

            local success = pcall(function()
                if makefolder and isfolder then
                    for _, folder in ipairs(folders) do
                        if not isfolder(folder) then
                            makefolder(folder)
                        end
                    end
                end
            end)

            return success
        end

        --// Hook System
        function Initialization:AddHook(hookType, callback, priority)
            priority = priority or 0

            if not InitState.Hooks[hookType] then
                warn(string.format("[NexusUI.Init] Invalid hook type: %s", hookType))
                return
            end

            table.insert(InitState.Hooks[hookType], {
                Callback = callback,
                Priority = priority,
            })

            -- Sort by priority (higher first)
            table.sort(InitState.Hooks[hookType], function(a, b)
                return a.Priority > b.Priority
            end)
        end

        function Initialization:RemoveHook(hookType, callback)
            local hooks = InitState.Hooks[hookType]
            if not hooks then return end

            for i, hook in ipairs(hooks) do
                if hook.Callback == callback then
                    table.remove(hooks, i)
                    return true
                end
            end

            return false
        end

        local function RunHooks(hookType, ...)
            local hooks = InitState.Hooks[hookType]
            if not hooks then return end

            for _, hook in ipairs(hooks) do
                local success, err = pcall(hook.Callback, ...)

                if not success then
                    table.insert(InitState.Errors, {
                        Type = "HookError",
                        Hook = hookType,
                        Message = tostring(err),
                        Time = os.clock(),
                    })
                end
            end
        end

        --// Module Loading
        local function LoadCoreModules()
            local modules = {
                { Name = "Services", Path = script.Parent.Services },
                { Name = "SignalClass", Path = script.Parent.SignalClass },
                { Name = "Maid", Path = script.Parent.Maid },
                { Name = "Promise", Path = script.Parent.Promise },
                { Name = "Types", Path = script.Parent.Types },
                { Name = "Constants", Path = script.Parent.Constants },
                { Name = "EventSystem", Path = script.Parent.EventSystem },
                { Name = "StateManager", Path = script.Parent.StateManager },
                { Name = "InstancePool", Path = script.Parent.InstancePool },
                { Name = "ScreenGui", Path = script.Parent.ScreenGui },
            }

            for _, moduleInfo in ipairs(modules) do
                local success, result = pcall(function()
                    if moduleInfo.Path and moduleInfo.Path:IsA("ModuleScript") then
                        return require(moduleInfo.Path)
                    end
                    return nil
                end)

                if success and result then
                    InitState.LoadedModules[moduleInfo.Name] = {
                        Module = result,
                        LoadTime = os.clock(),
                    }
                else
                    table.insert(InitState.Warnings, {
                        Type = "ModuleLoadWarning",
                        Module = moduleInfo.Name,
                        Message = tostring(result),
                        Time = os.clock(),
                    })
                end
            end
        end

        --// Main Initialization
        function Initialization:Initialize(config)
            if InitState.Initialized then
                return {
                    Success = true,
                    Message = "Already initialized",
                    Environment = Environment,
                }
            end

            InitState.InitStartTime = os.clock()
            config = config or {}

            -- Run pre-init hooks
            RunHooks("PreInit", config)

            -- Detect environment
            DetectExecutor()

            -- Check dependencies
            local depIssues = CheckDependencies()
            for _, issue in ipairs(depIssues) do
                if issue.Type == "Error" then
                    table.insert(InitState.Errors, issue)
                else
                    table.insert(InitState.Warnings, issue)
                end
            end

            -- Setup file system
            if Environment.IsExecutor then
                SetupFileSystem()
            end

            -- Load core modules
            LoadCoreModules()

            -- Mark as initialized
            InitState.Initialized = true
            InitState.InitEndTime = os.clock()
            InitState.InitDuration = InitState.InitEndTime - InitState.InitStartTime

            -- Run post-init hooks
            RunHooks("PostInit", config)

            return {
                Success = #InitState.Errors == 0,
                Duration = InitState.InitDuration,
                Errors = InitState.Errors,
                Warnings = InitState.Warnings,
                Environment = Environment,
                LoadedModules = InitState.LoadedModules,
            }
        end

        function Initialization:IsInitialized()
            return InitState.Initialized
        end

        function Initialization:GetEnvironment()
            if not Environment.IsExecutor then
                DetectExecutor()
            end
            return Environment
        end

        function Initialization:GetInitDuration()
            return InitState.InitDuration
        end

        function Initialization:GetErrors()
            return InitState.Errors
        end

        function Initialization:GetWarnings()
            return InitState.Warnings
        end

        function Initialization:GetLoadedModules()
            return InitState.LoadedModules
        end

        --// Cleanup
        function Initialization:Destroy()
            if not InitState.Initialized then
                return
            end

            -- Run pre-destroy hooks
            RunHooks("PreDestroy")

            -- Cleanup loaded modules
            for name, moduleData in pairs(InitState.LoadedModules) do
                if moduleData.Module and type(moduleData.Module) == "table" and moduleData.Module.Destroy then
                    pcall(moduleData.Module.Destroy, moduleData.Module)
                end
            end

            -- Run post-destroy hooks
            RunHooks("PostDestroy")

            -- Reset state
            InitState.Initialized = false
            InitState.LoadedModules = {}
            InitState.Errors = {}
            InitState.Warnings = {}
        end

        --// Utility Functions
        function Initialization:HasFunction(funcName)
            return getfenv()[funcName] ~= nil
        end

        function Initialization:SafeCall(funcName, ...)
            local func = getfenv()[funcName]
            if not func then
                return false, "Function not found"
            end

            return pcall(func, ...)
        end

        function Initialization:GetGameInfo()
            return {
                GameId = Environment.GameId,
                PlaceId = Environment.PlaceId,
                PlaceVersion = Environment.PlaceVersion,
                JobId = game.JobId,
            }
        end

        function Initialization:GetPlayerInfo()
            local player = Players.LocalPlayer
            if not player then
                return nil
            end

            return {
                UserId = player.UserId,
                Name = player.Name,
                DisplayName = player.DisplayName,
                AccountAge = player.AccountAge,
            }
        end

        --// Debug
        function Initialization:PrintStatus()
            print("=== NexusUI Initialization Status ===")
            print(string.format("Initialized: %s", tostring(InitState.Initialized)))
            print(string.format("Duration: %.3f seconds", InitState.InitDuration))
            print("")
            print("Environment:")
            print(string.format("  Is Studio: %s", tostring(Environment.IsStudio)))
            print(string.format("  Is Executor: %s", tostring(Environment.IsExecutor)))
            print(string.format("  Executor: %s v%s", Environment.ExecutorName, Environment.ExecutorVersion))
            print("")
            print(string.format("Loaded Modules: %d", Initialization:_countTable(InitState.LoadedModules)))
            print(string.format("Errors: %d", #InitState.Errors))
            print(string.format("Warnings: %d", #InitState.Warnings))
        end

        function Initialization:_countTable(t)
            local count = 0
            for _ in pairs(t) do
                count = count + 1
            end
            return count
        end

        return Initialization


    end


    -- ============================================================================
    -- Module: NexusUI/Core/init
    -- ============================================================================
    NexusUI_Modules["NexusUI/Core/init"] = function()
        local script = CreateMockScript("NexusUI/Core/init")

        --[[
            NexusUI Core Module
            Central hub for core functionality and module loading

            Provides:
            - Module registration and loading
            - Shared utilities access
            - Service caching
            - State management bridge
            - Event system bridge
        ]]

        --// Services
        local RunService = game:GetService("RunService")
        local HttpService = game:GetService("HttpService")

        --// Module Container
        local Core = {}
        Core.__index = Core

        --// Cached Modules
        local LoadedModules = {}
        local ModuleMetadata = {}

        --// Core Configuration
        local CoreConfig = {
            LazyLoading = true,
            CacheModules = true,
            DebugMode = false,
            LogLevel = "INFO", -- DEBUG, INFO, WARN, ERROR
            MaxModuleLoadTime = 5,
            EnableHotReload = false,
        }

        --// Module Registry
        local ModuleRegistry = {
            -- Core modules
            Services = { Path = "Services", Required = true, Priority = 1 },
            Types = { Path = "Types", Required = true, Priority = 2 },
            Constants = { Path = "Constants", Required = true, Priority = 3 },
            SignalClass = { Path = "SignalClass", Required = true, Priority = 4 },
            Maid = { Path = "Maid", Required = true, Priority = 5 },
            Promise = { Path = "Promise", Required = true, Priority = 6 },
            EventSystem = { Path = "EventSystem", Required = true, Priority = 7 },
            StateManager = { Path = "StateManager", Required = true, Priority = 8 },
            InstancePool = { Path = "InstancePool", Required = false, Priority = 9 },
            ScreenGui = { Path = "ScreenGui", Required = false, Priority = 10 },
            Initialization = { Path = "Initialization", Required = false, Priority = 11 },

            -- Utility modules
            Utility = { Path = "Utility", Required = true, Priority = 100 },
            Math = { Path = "Utility.Math", Required = false, Priority = 101 },
            String = { Path = "Utility.String", Required = false, Priority = 102 },
            Table = { Path = "Utility.Table", Required = false, Priority = 103 },
            Color = { Path = "Utility.Color", Required = false, Priority = 104 },
            Bezier = { Path = "Utility.Bezier", Required = false, Priority = 105 },
            UUID = { Path = "Utility.UUID", Required = false, Priority = 106 },
            Debounce = { Path = "Utility.Debounce", Required = false, Priority = 107 },
            DeepCopy = { Path = "Utility.DeepCopy", Required = false, Priority = 108 },
            Lerp = { Path = "Utility.Lerp", Required = false, Priority = 109 },
            Validate = { Path = "Utility.Validate", Required = false, Priority = 110 },
        }

        --// Logging
        local function Log(level, message, ...)
            if CoreConfig.DebugMode or level == "ERROR" then
                local formattedMessage = string.format(message, ...)
                local prefix = string.format("[NexusUI.Core] [%s]", level)

                if level == "ERROR" then
                    warn(prefix, formattedMessage)
                elseif level == "WARN" then
                    warn(prefix, formattedMessage)
                else
                    print(prefix, formattedMessage)
                end
            end
        end

        --// Module Loading
        local function ResolveModulePath(moduleName)
            local parts = string.split(moduleName, ".")
            local current = script

            for _, part in ipairs(parts) do
                local child = current:FindFirstChild(part)
                if not child then
                    return nil
                end
                current = child
            end

            return current
        end

        local function LoadModuleInternal(moduleName)
            -- Check cache first
            if LoadedModules[moduleName] then
                return LoadedModules[moduleName]
            end

            -- Get module info from registry
            local moduleInfo = ModuleRegistry[moduleName]
            local modulePath = moduleInfo and moduleInfo.Path or moduleName

            -- Resolve module
            local moduleScript = ResolveModulePath(modulePath)

            if not moduleScript then
                -- Try direct child lookup
                moduleScript = script:FindFirstChild(moduleName, true)
            end

            if not moduleScript then
                if moduleInfo and moduleInfo.Required then
                    Log("ERROR", "Required module not found: %s", moduleName)
                else
                    Log("DEBUG", "Optional module not found: %s", moduleName)
                end
                return nil
            end

            -- Load module with timeout protection
            local startTime = os.clock()
            local success, result = pcall(function()
                return require(moduleScript)
            end)
            local loadTime = os.clock() - startTime

            if not success then
                Log("ERROR", "Failed to load module %s: %s", moduleName, tostring(result))
                return nil
            end

            -- Store metadata
            ModuleMetadata[moduleName] = {
                LoadTime = loadTime,
                LoadedAt = os.clock(),
                Path = modulePath,
                Script = moduleScript
            }

            -- Cache module
            if CoreConfig.CacheModules then
                LoadedModules[moduleName] = result
            end

            Log("DEBUG", "Loaded module: %s (%.3fs)", moduleName, loadTime)

            return result
        end

        --// Core Methods
        function Core.new()
            local self = setmetatable({}, Core)

            self._initialized = false
            self._initTime = 0
            self._modules = {}

            return self
        end

        function Core:Initialize(config)
            if self._initialized then
                Log("WARN", "Core already initialized")
                return self
            end

            local startTime = os.clock()

            -- Apply configuration
            if config then
                for key, value in pairs(config) do
                    if CoreConfig[key] ~= nil then
                        CoreConfig[key] = value
                    end
                end
            end

            Log("INFO", "Initializing Core module...")

            -- Load required modules in priority order
            local sortedModules = {}
            for name, info in pairs(ModuleRegistry) do
                if info.Required then
                    table.insert(sortedModules, { Name = name, Priority = info.Priority })
                end
            end

            table.sort(sortedModules, function(a, b)
                return a.Priority < b.Priority
            end)

            for _, moduleData in ipairs(sortedModules) do
                local module = LoadModuleInternal(moduleData.Name)
                if module then
                    self._modules[moduleData.Name] = module
                end
            end

            self._initTime = os.clock() - startTime
            self._initialized = true

            Log("INFO", "Core initialized in %.3fs", self._initTime)

            return self
        end

        function Core:LoadModule(moduleName)
            if self._modules[moduleName] then
                return self._modules[moduleName]
            end

            local module = LoadModuleInternal(moduleName)
            if module then
                self._modules[moduleName] = module
            end

            return module
        end

        function Core:GetModule(moduleName)
            return self._modules[moduleName] or LoadedModules[moduleName]
        end

        function Core:UnloadModule(moduleName)
            self._modules[moduleName] = nil
            LoadedModules[moduleName] = nil
            ModuleMetadata[moduleName] = nil

            Log("DEBUG", "Unloaded module: %s", moduleName)
        end

        function Core:ReloadModule(moduleName)
            self:UnloadModule(moduleName)
            return self:LoadModule(moduleName)
        end

        function Core:GetModuleMetadata(moduleName)
            return ModuleMetadata[moduleName]
        end

        function Core:GetAllModuleMetadata()
            local copy = {}
            for name, meta in pairs(ModuleMetadata) do
                copy[name] = {
                    LoadTime = meta.LoadTime,
                    LoadedAt = meta.LoadedAt,
                    Path = meta.Path
                }
            end
            return copy
        end

        function Core:IsModuleLoaded(moduleName)
            return LoadedModules[moduleName] ~= nil or self._modules[moduleName] ~= nil
        end

        function Core:GetLoadedModuleCount()
            local count = 0
            for _ in pairs(LoadedModules) do
                count = count + 1
            end
            return count
        end

        function Core:GetInitTime()
            return self._initTime
        end

        function Core:IsInitialized()
            return self._initialized
        end

        --// Configuration
        function Core:SetConfig(key, value)
            if CoreConfig[key] ~= nil then
                CoreConfig[key] = value
                Log("DEBUG", "Config updated: %s = %s", key, tostring(value))
            end
        end

        function Core:GetConfig(key)
            return CoreConfig[key]
        end

        function Core:GetAllConfig()
            local copy = {}
            for k, v in pairs(CoreConfig) do
                copy[k] = v
            end
            return copy
        end

        --// Utility Access (shortcuts)
        function Core:GetServices()
            return self:GetModule("Services")
        end

        function Core:GetTypes()
            return self:GetModule("Types")
        end

        function Core:GetConstants()
            return self:GetModule("Constants")
        end

        function Core:GetSignalClass()
            return self:GetModule("SignalClass")
        end

        function Core:GetMaid()
            return self:GetModule("Maid")
        end

        function Core:GetPromise()
            return self:GetModule("Promise")
        end

        function Core:GetEventSystem()
            return self:GetModule("EventSystem")
        end

        function Core:GetStateManager()
            return self:GetModule("StateManager")
        end

        function Core:GetInstancePool()
            return self:GetModule("InstancePool")
        end

        function Core:GetUtility()
            return self:GetModule("Utility")
        end

        --// Signal Creation (convenience)
        function Core:CreateSignal(name)
            local SignalClass = self:GetSignalClass()
            if SignalClass then
                return SignalClass.new(name)
            end
            return nil
        end

        --// Maid Creation (convenience)
        function Core:CreateMaid()
            local Maid = self:GetMaid()
            if Maid then
                return Maid.new()
            end
            return nil
        end

        --// Promise Creation (convenience)
        function Core:CreatePromise(executor)
            local Promise = self:GetPromise()
            if Promise then
                return Promise.new(executor)
            end
            return nil
        end

        --// Event Dispatch (convenience)
        function Core:DispatchEvent(eventName, ...)
            local EventSystem = self:GetEventSystem()
            if EventSystem then
                EventSystem:Dispatch(eventName, ...)
            end
        end

        function Core:SubscribeEvent(eventName, callback)
            local EventSystem = self:GetEventSystem()
            if EventSystem then
                return EventSystem:Subscribe(eventName, callback)
            end
            return nil
        end

        --// State Management (convenience)
        function Core:SetState(key, value)
            local StateManager = self:GetStateManager()
            if StateManager then
                StateManager:Set(key, value)
            end
        end

        function Core:GetState(key)
            local StateManager = self:GetStateManager()
            if StateManager then
                return StateManager:Get(key)
            end
            return nil
        end

        function Core:WatchState(key, callback)
            local StateManager = self:GetStateManager()
            if StateManager then
                return StateManager:Watch(key, callback)
            end
            return nil
        end

        --// Cleanup
        function Core:Destroy()
            Log("INFO", "Destroying Core module...")

            -- Unload all modules
            for name, _ in pairs(self._modules) do
                self:UnloadModule(name)
            end

            self._modules = {}
            self._initialized = false

            Log("INFO", "Core destroyed")
        end

        --// Create and return singleton instance
        local instance = Core.new()

        -- Auto-initialize with default config
        instance:Initialize()

        return instance


    end


    -- ============================================================================
    -- Module: NexusUI/Animation/SpringPhysics
    -- ============================================================================
    NexusUI_Modules["NexusUI/Animation/SpringPhysics"] = function()
        local script = CreateMockScript("NexusUI/Animation/SpringPhysics")

        --[[
            NexusUI Spring Physics
            Realistic spring-based animations

            Features:
            - Damped spring simulation
            - Configurable stiffness, damping, mass
            - Velocity-based animations
            - Multi-property springs
            - Spring presets
        ]]

        --// Services
        local RunService = game:GetService("RunService")

        --// Spring Physics Module
        local SpringPhysics = {}
        SpringPhysics.__index = SpringPhysics
        SpringPhysics.ClassName = "SpringPhysics"

        --// Spring Presets
        SpringPhysics.Presets = {
            Default = { Stiffness = 100, Damping = 10, Mass = 1 },
            Gentle = { Stiffness = 50, Damping = 8, Mass = 1 },
            Wobbly = { Stiffness = 180, Damping = 12, Mass = 1 },
            Stiff = { Stiffness = 210, Damping = 20, Mass = 1 },
            Slow = { Stiffness = 50, Damping = 15, Mass = 1 },
            Molasses = { Stiffness = 30, Damping = 20, Mass = 1 },
            Bouncy = { Stiffness = 200, Damping = 5, Mass = 1 },
            Snappy = { Stiffness = 300, Damping = 25, Mass = 1 },
            Quick = { Stiffness = 250, Damping = 18, Mass = 0.8 },
            Responsive = { Stiffness = 400, Damping = 30, Mass = 1 },
        }

        --// Active Springs
        local ActiveSprings = {}
        local SpringIdCounter = 0

        --// Generate Spring ID
        local function GenerateSpringId()
            SpringIdCounter = SpringIdCounter + 1
            return "spring_" .. SpringIdCounter
        end

        --// Spring State
        local SpringState = {
            Idle = "Idle",
            Active = "Active",
            Completed = "Completed",
            Cancelled = "Cancelled",
        }

        --// Value Operations
        local function GetValueType(value)
            return typeof(value)
        end

        local function SubtractValues(a, b)
            local valueType = typeof(a)

            if valueType == "number" then
                return a - b
            elseif valueType == "Vector2" then
                return a - b
            elseif valueType == "Vector3" then
                return a - b
            elseif valueType == "UDim" then
                return UDim.new(a.Scale - b.Scale, a.Offset - b.Offset)
            elseif valueType == "UDim2" then
                return UDim2.new(
                    a.X.Scale - b.X.Scale, a.X.Offset - b.X.Offset,
                    a.Y.Scale - b.Y.Scale, a.Y.Offset - b.Y.Offset
                )
            elseif valueType == "Color3" then
                return { R = a.R - b.R, G = a.G - b.G, B = a.B - b.B }
            end

            return 0
        end

        local function AddValues(a, b)
            local valueType = typeof(a)

            if valueType == "number" then
                return a + b
            elseif valueType == "Vector2" then
                return a + b
            elseif valueType == "Vector3" then
                return a + b
            elseif valueType == "UDim" then
                return UDim.new(a.Scale + b.Scale, a.Offset + b.Offset)
            elseif valueType == "UDim2" then
                return UDim2.new(
                    a.X.Scale + b.X.Scale, a.X.Offset + b.X.Offset,
                    a.Y.Scale + b.Y.Scale, a.Y.Offset + b.Y.Offset
                )
            elseif valueType == "Color3" and type(b) == "table" then
                return Color3.new(
                    math.clamp(a.R + b.R, 0, 1),
                    math.clamp(a.G + b.G, 0, 1),
                    math.clamp(a.B + b.B, 0, 1)
                )
            end

            return a
        end

        local function MultiplyValue(value, scalar)
            local valueType = typeof(value)

            if valueType == "number" then
                return value * scalar
            elseif valueType == "Vector2" then
                return value * scalar
            elseif valueType == "Vector3" then
                return value * scalar
            elseif valueType == "UDim" then
                return UDim.new(value.Scale * scalar, value.Offset * scalar)
            elseif valueType == "UDim2" then
                return UDim2.new(
                    value.X.Scale * scalar, value.X.Offset * scalar,
                    value.Y.Scale * scalar, value.Y.Offset * scalar
                )
            elseif type(value) == "table" and value.R then
                return { R = value.R * scalar, G = value.G * scalar, B = value.B * scalar }
            end

            return value
        end

        local function GetMagnitude(value)
            local valueType = typeof(value)

            if valueType == "number" then
                return math.abs(value)
            elseif valueType == "Vector2" then
                return value.Magnitude
            elseif valueType == "Vector3" then
                return value.Magnitude
            elseif valueType == "UDim" then
                return math.abs(value.Scale) + math.abs(value.Offset)
            elseif valueType == "UDim2" then
                return math.abs(value.X.Scale) + math.abs(value.X.Offset) +
                       math.abs(value.Y.Scale) + math.abs(value.Y.Offset)
            elseif type(value) == "table" and value.R then
                return math.abs(value.R) + math.abs(value.G) + math.abs(value.B)
            end

            return 0
        end

        local function CreateZeroValue(template)
            local valueType = typeof(template)

            if valueType == "number" then
                return 0
            elseif valueType == "Vector2" then
                return Vector2.new(0, 0)
            elseif valueType == "Vector3" then
                return Vector3.new(0, 0, 0)
            elseif valueType == "UDim" then
                return UDim.new(0, 0)
            elseif valueType == "UDim2" then
                return UDim2.new(0, 0, 0, 0)
            elseif valueType == "Color3" then
                return { R = 0, G = 0, B = 0 }
            end

            return 0
        end

        --// Spring Class
        local Spring = {}
        Spring.__index = Spring

        function Spring.new(config)
            local self = setmetatable({}, Spring)

            self.Id = GenerateSpringId()
            self.Target = config.Target
            self.Property = config.Property
            self.GoalValue = config.GoalValue

            -- Spring parameters
            local preset = config.Preset and SpringPhysics.Presets[config.Preset]
            self.Stiffness = config.Stiffness or (preset and preset.Stiffness) or 100
            self.Damping = config.Damping or (preset and preset.Damping) or 10
            self.Mass = config.Mass or (preset and preset.Mass) or 1
            self.Precision = config.Precision or 0.001

            -- Callbacks
            self.OnStart = config.OnStart
            self.OnUpdate = config.OnUpdate
            self.OnComplete = config.OnComplete

            -- State
            self.State = SpringState.Idle
            self.CurrentValue = nil
            self.Velocity = nil

            return self
        end

        function Spring:_captureCurrentValue()
            if self.Target and self.Property then
                local success, value = pcall(function()
                    return self.Target[self.Property]
                end)

                if success then
                    self.CurrentValue = value
                    self.Velocity = CreateZeroValue(value)
                end
            end
        end

        function Spring:Start()
            if self.State == SpringState.Active then
                return self
            end

            self:_captureCurrentValue()

            if self.CurrentValue == nil then
                return self
            end

            self.State = SpringState.Active

            if self.OnStart then
                pcall(self.OnStart, self)
            end

            ActiveSprings[self.Id] = self

            return self
        end

        function Spring:Stop()
            self.State = SpringState.Cancelled
            ActiveSprings[self.Id] = nil
            return self
        end

        function Spring:Cancel()
            return self:Stop()
        end

        function Spring:SetGoal(goalValue)
            self.GoalValue = goalValue

            if self.State ~= SpringState.Active then
                self:Start()
            end

            return self
        end

        function Spring:Impulse(impulseVelocity)
            if self.Velocity then
                self.Velocity = AddValues(self.Velocity, impulseVelocity)
            end

            if self.State ~= SpringState.Active then
                self:Start()
            end

            return self
        end

        function Spring:Update(deltaTime)
            if self.State ~= SpringState.Active then
                return self.State == SpringState.Completed or self.State == SpringState.Cancelled
            end

            if not self.CurrentValue or not self.GoalValue then
                return true
            end

            -- Spring physics calculation
            -- F = -k * x - c * v
            -- a = F / m
            -- v = v + a * dt
            -- x = x + v * dt

            local displacement = SubtractValues(self.CurrentValue, self.GoalValue)
            local springForce = MultiplyValue(displacement, -self.Stiffness)
            local dampingForce = MultiplyValue(self.Velocity, -self.Damping)
            local totalForce = AddValues(springForce, dampingForce)
            local acceleration = MultiplyValue(totalForce, 1 / self.Mass)

            self.Velocity = AddValues(self.Velocity, MultiplyValue(acceleration, deltaTime))
            self.CurrentValue = AddValues(self.CurrentValue, MultiplyValue(self.Velocity, deltaTime))

            -- Apply to target
            if self.Target and self.Property then
                pcall(function()
                    self.Target[self.Property] = self.CurrentValue
                end)
            end

            -- Callback
            if self.OnUpdate then
                pcall(self.OnUpdate, self.CurrentValue, self.Velocity, self)
            end

            -- Check if settled
            local displacementMag = GetMagnitude(SubtractValues(self.CurrentValue, self.GoalValue))
            local velocityMag = GetMagnitude(self.Velocity)

            if displacementMag < self.Precision and velocityMag < self.Precision then
                -- Snap to goal
                self.CurrentValue = self.GoalValue
                self.Velocity = CreateZeroValue(self.GoalValue)

                if self.Target and self.Property then
                    pcall(function()
                        self.Target[self.Property] = self.GoalValue
                    end)
                end

                self.State = SpringState.Completed

                if self.OnComplete then
                    pcall(self.OnComplete, self)
                end

                return true
            end

            return false
        end

        function Spring:GetVelocity()
            return self.Velocity
        end

        function Spring:GetCurrentValue()
            return self.CurrentValue
        end

        function Spring:GetGoalValue()
            return self.GoalValue
        end

        function Spring:IsActive()
            return self.State == SpringState.Active
        end

        function Spring:IsComplete()
            return self.State == SpringState.Completed
        end

        function Spring:Then(callback)
            local originalOnComplete = self.OnComplete

            self.OnComplete = function(spring)
                if originalOnComplete then
                    originalOnComplete(spring)
                end
                callback(spring)
            end

            return self
        end

        function Spring:Await()
            while self.State == SpringState.Active do
                task.wait()
            end
            return self
        end

        --// Spring Physics API
        function SpringPhysics.Create(target, property, goalValue, config)
            config = config or {}

            return Spring.new({
                Target = target,
                Property = property,
                GoalValue = goalValue,
                Stiffness = config.Stiffness,
                Damping = config.Damping,
                Mass = config.Mass,
                Precision = config.Precision,
                Preset = config.Preset,
                OnStart = config.OnStart,
                OnUpdate = config.OnUpdate,
                OnComplete = config.OnComplete,
            })
        end

        function SpringPhysics.To(target, property, goalValue, config)
            return SpringPhysics.Create(target, property, goalValue, config):Start()
        end

        function SpringPhysics.Animate(target, properties, config)
            config = config or {}
            local springs = {}

            for property, goalValue in pairs(properties) do
                local spring = SpringPhysics.Create(target, property, goalValue, config)
                table.insert(springs, spring)
            end

            -- Start all springs
            for _, spring in ipairs(springs) do
                spring:Start()
            end

            return springs
        end

        function SpringPhysics.CreateSimple(initialValue, goalValue, config)
            config = config or {}

            local spring = {
                CurrentValue = initialValue,
                GoalValue = goalValue,
                Velocity = CreateZeroValue(initialValue),
                Stiffness = config.Stiffness or 100,
                Damping = config.Damping or 10,
                Mass = config.Mass or 1,
                Precision = config.Precision or 0.001,
            }

            function spring:Update(deltaTime)
                local displacement = SubtractValues(self.CurrentValue, self.GoalValue)
                local springForce = MultiplyValue(displacement, -self.Stiffness)
                local dampingForce = MultiplyValue(self.Velocity, -self.Damping)
                local totalForce = AddValues(springForce, dampingForce)
                local acceleration = MultiplyValue(totalForce, 1 / self.Mass)

                self.Velocity = AddValues(self.Velocity, MultiplyValue(acceleration, deltaTime))
                self.CurrentValue = AddValues(self.CurrentValue, MultiplyValue(self.Velocity, deltaTime))

                return self.CurrentValue
            end

            function spring:SetGoal(goal)
                self.GoalValue = goal
            end

            function spring:Impulse(velocity)
                self.Velocity = AddValues(self.Velocity, velocity)
            end

            function spring:IsSettled()
                local displacementMag = GetMagnitude(SubtractValues(self.CurrentValue, self.GoalValue))
                local velocityMag = GetMagnitude(self.Velocity)
                return displacementMag < self.Precision and velocityMag < self.Precision
            end

            return spring
        end

        --// Update Loop
        function SpringPhysics.Update(deltaTime)
            local toRemove = {}

            for id, spring in pairs(ActiveSprings) do
                local completed = spring:Update(deltaTime)

                if completed then
                    table.insert(toRemove, id)
                end
            end

            for _, id in ipairs(toRemove) do
                ActiveSprings[id] = nil
            end
        end

        --// Management
        function SpringPhysics.CancelAll()
            for id, spring in pairs(ActiveSprings) do
                spring:Cancel()
            end
            ActiveSprings = {}
        end

        function SpringPhysics.CancelSpringsOf(target)
            for id, spring in pairs(ActiveSprings) do
                if spring.Target == target then
                    spring:Cancel()
                    ActiveSprings[id] = nil
                end
            end
        end

        function SpringPhysics.GetActiveCount()
            local count = 0
            for _ in pairs(ActiveSprings) do
                count = count + 1
            end
            return count
        end

        function SpringPhysics.GetSpringsOf(target)
            local springs = {}
            for id, spring in pairs(ActiveSprings) do
                if spring.Target == target then
                    table.insert(springs, spring)
                end
            end
            return springs
        end

        --// Presets
        function SpringPhysics.GetPreset(name)
            return SpringPhysics.Presets[name]
        end

        function SpringPhysics.GetPresetNames()
            local names = {}
            for name, _ in pairs(SpringPhysics.Presets) do
                table.insert(names, name)
            end
            return names
        end

        function SpringPhysics.AddPreset(name, config)
            SpringPhysics.Presets[name] = config
        end

        --// Export State
        SpringPhysics.State = SpringState

        return SpringPhysics


    end


    -- ============================================================================
    -- Module: NexusUI/Animation/EasingFunctions
    -- ============================================================================
    NexusUI_Modules["NexusUI/Animation/EasingFunctions"] = function()
        local script = CreateMockScript("NexusUI/Animation/EasingFunctions")

        --[[
            NexusUI Easing Functions
            40+ easing functions for smooth animations

            Categories:
            - Linear
            - Quad, Cubic, Quart, Quint, Expo
            - Sine, Circ
            - Back, Elastic, Bounce
            - Custom bezier-based easings
        ]]

        --// Easing Functions Module
        local EasingFunctions = {}

        --// Constants
        local PI = math.pi
        local TAU = PI * 2
        local HALF_PI = PI / 2

        --// Helper Functions
        local function Clamp(t)
            return math.max(0, math.min(1, t))
        end

        --// Linear
        function EasingFunctions.Linear(t)
            return t
        end

        --// Sine Easings
        function EasingFunctions.SineIn(t)
            return 1 - math.cos(t * HALF_PI)
        end

        function EasingFunctions.SineOut(t)
            return math.sin(t * HALF_PI)
        end

        function EasingFunctions.SineInOut(t)
            return -(math.cos(PI * t) - 1) / 2
        end

        --// Quad Easings (t^2)
        function EasingFunctions.QuadIn(t)
            return t * t
        end

        function EasingFunctions.QuadOut(t)
            return 1 - (1 - t) * (1 - t)
        end

        function EasingFunctions.QuadInOut(t)
            if t < 0.5 then
                return 2 * t * t
            else
                return 1 - (-2 * t + 2) ^ 2 / 2
            end
        end

        --// Cubic Easings (t^3)
        function EasingFunctions.CubicIn(t)
            return t * t * t
        end

        function EasingFunctions.CubicOut(t)
            return 1 - (1 - t) ^ 3
        end

        function EasingFunctions.CubicInOut(t)
            if t < 0.5 then
                return 4 * t * t * t
            else
                return 1 - (-2 * t + 2) ^ 3 / 2
            end
        end

        --// Quart Easings (t^4)
        function EasingFunctions.QuartIn(t)
            return t * t * t * t
        end

        function EasingFunctions.QuartOut(t)
            return 1 - (1 - t) ^ 4
        end

        function EasingFunctions.QuartInOut(t)
            if t < 0.5 then
                return 8 * t * t * t * t
            else
                return 1 - (-2 * t + 2) ^ 4 / 2
            end
        end

        --// Quint Easings (t^5)
        function EasingFunctions.QuintIn(t)
            return t * t * t * t * t
        end

        function EasingFunctions.QuintOut(t)
            return 1 - (1 - t) ^ 5
        end

        function EasingFunctions.QuintInOut(t)
            if t < 0.5 then
                return 16 * t * t * t * t * t
            else
                return 1 - (-2 * t + 2) ^ 5 / 2
            end
        end

        --// Expo Easings (2^t)
        function EasingFunctions.ExpoIn(t)
            if t == 0 then
                return 0
            end
            return 2 ^ (10 * t - 10)
        end

        function EasingFunctions.ExpoOut(t)
            if t == 1 then
                return 1
            end
            return 1 - 2 ^ (-10 * t)
        end

        function EasingFunctions.ExpoInOut(t)
            if t == 0 then
                return 0
            elseif t == 1 then
                return 1
            elseif t < 0.5 then
                return 2 ^ (20 * t - 10) / 2
            else
                return (2 - 2 ^ (-20 * t + 10)) / 2
            end
        end

        --// Circ Easings (circular)
        function EasingFunctions.CircIn(t)
            return 1 - math.sqrt(1 - t * t)
        end

        function EasingFunctions.CircOut(t)
            return math.sqrt(1 - (t - 1) ^ 2)
        end

        function EasingFunctions.CircInOut(t)
            if t < 0.5 then
                return (1 - math.sqrt(1 - (2 * t) ^ 2)) / 2
            else
                return (math.sqrt(1 - (-2 * t + 2) ^ 2) + 1) / 2
            end
        end

        --// Back Easings (overshoot)
        local BACK_C1 = 1.70158
        local BACK_C2 = BACK_C1 * 1.525
        local BACK_C3 = BACK_C1 + 1

        function EasingFunctions.BackIn(t)
            return BACK_C3 * t * t * t - BACK_C1 * t * t
        end

        function EasingFunctions.BackOut(t)
            return 1 + BACK_C3 * (t - 1) ^ 3 + BACK_C1 * (t - 1) ^ 2
        end

        function EasingFunctions.BackInOut(t)
            if t < 0.5 then
                return ((2 * t) ^ 2 * ((BACK_C2 + 1) * 2 * t - BACK_C2)) / 2
            else
                return ((2 * t - 2) ^ 2 * ((BACK_C2 + 1) * (t * 2 - 2) + BACK_C2) + 2) / 2
            end
        end

        --// Elastic Easings
        local ELASTIC_C4 = TAU / 3
        local ELASTIC_C5 = TAU / 4.5

        function EasingFunctions.ElasticIn(t)
            if t == 0 then
                return 0
            elseif t == 1 then
                return 1
            end
            return -2 ^ (10 * t - 10) * math.sin((t * 10 - 10.75) * ELASTIC_C4)
        end

        function EasingFunctions.ElasticOut(t)
            if t == 0 then
                return 0
            elseif t == 1 then
                return 1
            end
            return 2 ^ (-10 * t) * math.sin((t * 10 - 0.75) * ELASTIC_C4) + 1
        end

        function EasingFunctions.ElasticInOut(t)
            if t == 0 then
                return 0
            elseif t == 1 then
                return 1
            elseif t < 0.5 then
                return -(2 ^ (20 * t - 10) * math.sin((20 * t - 11.125) * ELASTIC_C5)) / 2
            else
                return (2 ^ (-20 * t + 10) * math.sin((20 * t - 11.125) * ELASTIC_C5)) / 2 + 1
            end
        end

        --// Bounce Easings
        function EasingFunctions.BounceOut(t)
            local n1 = 7.5625
            local d1 = 2.75

            if t < 1 / d1 then
                return n1 * t * t
            elseif t < 2 / d1 then
                t = t - 1.5 / d1
                return n1 * t * t + 0.75
            elseif t < 2.5 / d1 then
                t = t - 2.25 / d1
                return n1 * t * t + 0.9375
            else
                t = t - 2.625 / d1
                return n1 * t * t + 0.984375
            end
        end

        function EasingFunctions.BounceIn(t)
            return 1 - EasingFunctions.BounceOut(1 - t)
        end

        function EasingFunctions.BounceInOut(t)
            if t < 0.5 then
                return (1 - EasingFunctions.BounceOut(1 - 2 * t)) / 2
            else
                return (1 + EasingFunctions.BounceOut(2 * t - 1)) / 2
            end
        end

        --// Smooth Step Variants
        function EasingFunctions.SmoothStep(t)
            return t * t * (3 - 2 * t)
        end

        function EasingFunctions.SmootherStep(t)
            return t * t * t * (t * (t * 6 - 15) + 10)
        end

        function EasingFunctions.SmoothestStep(t)
            return t * t * t * t * (t * (t * (t * -20 + 70) - 84) + 35)
        end

        --// Custom Power Easings
        function EasingFunctions.PowerIn(power)
            return function(t)
                return t ^ power
            end
        end

        function EasingFunctions.PowerOut(power)
            return function(t)
                return 1 - (1 - t) ^ power
            end
        end

        function EasingFunctions.PowerInOut(power)
            return function(t)
                if t < 0.5 then
                    return (2 * t) ^ power / 2
                else
                    return 1 - (-2 * t + 2) ^ power / 2
                end
            end
        end

        --// Spring-like Easing (approximation)
        function EasingFunctions.Spring(t, damping)
            damping = damping or 0.4
            local frequency = 10
            return 1 - math.exp(-damping * t) * math.cos(frequency * t)
        end

        --// Anticipate (slight pullback before motion)
        function EasingFunctions.Anticipate(t, overshoot)
            overshoot = overshoot or 2
            return t * t * ((overshoot + 1) * t - overshoot)
        end

        --// Anticipate Overshoot
        function EasingFunctions.AnticipateOvershoot(t, tension)
            tension = tension or 2
            if t < 0.5 then
                return 0.5 * (2 * t) ^ 2 * ((tension + 1) * 2 * t - tension)
            else
                local adjusted = 2 * t - 2
                return 0.5 * (adjusted ^ 2 * ((tension + 1) * adjusted + tension) + 2)
            end
        end

        --// Stepped Easing (discrete steps)
        function EasingFunctions.Steps(steps, jumpEnd)
            steps = steps or 10
            jumpEnd = jumpEnd ~= false

            return function(t)
                local progress = math.floor(t * steps)
                if jumpEnd then
                    return math.min(progress / steps, 1)
                else
                    return progress / (steps - 1)
                end
            end
        end

        --// Bezier-based Custom Easing
        function EasingFunctions.CubicBezier(x1, y1, x2, y2)
            -- Newton-Raphson iteration settings
            local NEWTON_ITERATIONS = 4
            local NEWTON_MIN_SLOPE = 0.001
            local SUBDIVISION_PRECISION = 0.0000001
            local SUBDIVISION_MAX_ITERATIONS = 10

            -- Clamp control points
            x1 = math.max(0, math.min(1, x1))
            x2 = math.max(0, math.min(1, x2))

            -- Pre-compute sample table
            local sampleTableSize = 11
            local sampleTable = {}

            local function calcBezier(t, a1, a2)
                return ((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1 * t
            end

            local function getSlope(t, a1, a2)
                return 3 * (1 - 3 * a2 + 3 * a1) * t * t + 2 * (3 * a2 - 6 * a1) * t + 3 * a1
            end

            for i = 0, sampleTableSize - 1 do
                sampleTable[i] = calcBezier(i / (sampleTableSize - 1), x1, x2)
            end

            local function getTForX(x)
                local intervalStart = 0
                local currentSample = 1
                local lastSample = sampleTableSize - 1

                while currentSample ~= lastSample and sampleTable[currentSample] <= x do
                    intervalStart = intervalStart + 1 / (sampleTableSize - 1)
                    currentSample = currentSample + 1
                end
                currentSample = currentSample - 1

                local dist = (x - sampleTable[currentSample]) / 
                             (sampleTable[currentSample + 1] - sampleTable[currentSample])
                local guessForT = intervalStart + dist / (sampleTableSize - 1)

                local initialSlope = getSlope(guessForT, x1, x2)

                if initialSlope >= NEWTON_MIN_SLOPE then
                    for i = 1, NEWTON_ITERATIONS do
                        local currentSlope = getSlope(guessForT, x1, x2)
                        if currentSlope == 0 then break end
                        local currentX = calcBezier(guessForT, x1, x2) - x
                        guessForT = guessForT - currentX / currentSlope
                    end
                    return guessForT
                elseif initialSlope == 0 then
                    return guessForT
                else
                    local aA = intervalStart
                    local aB = intervalStart + 1 / (sampleTableSize - 1)
                    local currentX, currentT

                    for i = 1, SUBDIVISION_MAX_ITERATIONS do
                        currentT = aA + (aB - aA) / 2
                        currentX = calcBezier(currentT, x1, x2) - x

                        if math.abs(currentX) < SUBDIVISION_PRECISION then
                            break
                        end

                        if currentX > 0 then
                            aB = currentT
                        else
                            aA = currentT
                        end
                    end

                    return currentT
                end
            end

            return function(t)
                if t == 0 or t == 1 then
                    return t
                end
                return calcBezier(getTForX(t), y1, y2)
            end
        end

        --// Common Bezier Presets
        EasingFunctions.Ease = EasingFunctions.CubicBezier(0.25, 0.1, 0.25, 1)
        EasingFunctions.EaseIn = EasingFunctions.CubicBezier(0.42, 0, 1, 1)
        EasingFunctions.EaseOut = EasingFunctions.CubicBezier(0, 0, 0.58, 1)
        EasingFunctions.EaseInOut = EasingFunctions.CubicBezier(0.42, 0, 0.58, 1)

        --// Material Design Easings
        EasingFunctions.Standard = EasingFunctions.CubicBezier(0.4, 0, 0.2, 1)
        EasingFunctions.Decelerate = EasingFunctions.CubicBezier(0, 0, 0.2, 1)
        EasingFunctions.Accelerate = EasingFunctions.CubicBezier(0.4, 0, 1, 1)
        EasingFunctions.Sharp = EasingFunctions.CubicBezier(0.4, 0, 0.6, 1)

        --// iOS-like Easings
        EasingFunctions.DefaultiOS = EasingFunctions.CubicBezier(0.25, 0.46, 0.45, 0.94)
        EasingFunctions.SpringiOS = EasingFunctions.CubicBezier(0.5, 1.8, 0.4, 0.8)

        --// Utility Functions
        function EasingFunctions.Get(name)
            return EasingFunctions[name]
        end

        function EasingFunctions.GetAll()
            local easings = {}
            for name, func in pairs(EasingFunctions) do
                if type(func) == "function" and name ~= "Get" and name ~= "GetAll" and 
                   name ~= "GetCategories" and name ~= "GetByCategory" and
                   name ~= "CubicBezier" and name ~= "Steps" and
                   name ~= "PowerIn" and name ~= "PowerOut" and name ~= "PowerInOut" then
                    table.insert(easings, name)
                end
            end
            table.sort(easings)
            return easings
        end

        function EasingFunctions.GetCategories()
            return {
                "Linear",
                "Sine",
                "Quad",
                "Cubic",
                "Quart",
                "Quint",
                "Expo",
                "Circ",
                "Back",
                "Elastic",
                "Bounce",
                "Smooth",
                "Custom",
            }
        end

        function EasingFunctions.GetByCategory(category)
            local categoryMap = {
                Linear = {"Linear"},
                Sine = {"SineIn", "SineOut", "SineInOut"},
                Quad = {"QuadIn", "QuadOut", "QuadInOut"},
                Cubic = {"CubicIn", "CubicOut", "CubicInOut"},
                Quart = {"QuartIn", "QuartOut", "QuartInOut"},
                Quint = {"QuintIn", "QuintOut", "QuintInOut"},
                Expo = {"ExpoIn", "ExpoOut", "ExpoInOut"},
                Circ = {"CircIn", "CircOut", "CircInOut"},
                Back = {"BackIn", "BackOut", "BackInOut"},
                Elastic = {"ElasticIn", "ElasticOut", "ElasticInOut"},
                Bounce = {"BounceIn", "BounceOut", "BounceInOut"},
                Smooth = {"SmoothStep", "SmootherStep", "SmoothestStep"},
                Custom = {"Ease", "EaseIn", "EaseOut", "EaseInOut", "Standard", "Decelerate", "Accelerate", "Sharp"},
            }

            return categoryMap[category] or {}
        end

        --// Apply easing to a value
        function EasingFunctions.Apply(easingName, startValue, endValue, t)
            local easingFunc = EasingFunctions.Get(easingName) or EasingFunctions.Linear
            local easedT = easingFunc(t)

            local valueType = typeof(startValue)

            if valueType == "number" then
                return startValue + (endValue - startValue) * easedT
            elseif valueType == "Color3" then
                return Color3.new(
                    startValue.R + (endValue.R - startValue.R) * easedT,
                    startValue.G + (endValue.G - startValue.G) * easedT,
                    startValue.B + (endValue.B - startValue.B) * easedT
                )
            elseif valueType == "Vector2" then
                return startValue:Lerp(endValue, easedT)
            elseif valueType == "Vector3" then
                return startValue:Lerp(endValue, easedT)
            elseif valueType == "UDim2" then
                return UDim2.new(
                    startValue.X.Scale + (endValue.X.Scale - startValue.X.Scale) * easedT,
                    startValue.X.Offset + (endValue.X.Offset - startValue.X.Offset) * easedT,
                    startValue.Y.Scale + (endValue.Y.Scale - startValue.Y.Scale) * easedT,
                    startValue.Y.Offset + (endValue.Y.Offset - startValue.Y.Offset) * easedT
                )
            elseif valueType == "CFrame" then
                return startValue:Lerp(endValue, easedT)
            end

            return easedT >= 0.5 and endValue or startValue
        end

        return EasingFunctions


    end


    -- ============================================================================
    -- Module: NexusUI/Animation/Sequence
    -- ============================================================================
    NexusUI_Modules["NexusUI/Animation/Sequence"] = function()
        local script = CreateMockScript("NexusUI/Animation/Sequence")

        --[[
            NexusUI Animation Sequence
            Chain animations to play one after another

            Features:
            - Sequential animation execution
            - Delay between animations
            - Callbacks at each step
            - Pause/Resume/Cancel support
            - Loop support
        ]]

        --// Sequence Module
        local Sequence = {}
        Sequence.__index = Sequence
        Sequence.ClassName = "AnimationSequence"

        --// Sequence State
        local SequenceState = {
            Pending = "Pending",
            Playing = "Playing",
            Paused = "Paused",
            Completed = "Completed",
            Cancelled = "Cancelled",
        }

        --// Sequence ID Counter
        local SequenceIdCounter = 0

        local function GenerateSequenceId()
            SequenceIdCounter = SequenceIdCounter + 1
            return "seq_" .. SequenceIdCounter
        end

        --// Sequence Step
        local SequenceStep = {}
        SequenceStep.__index = SequenceStep

        function SequenceStep.new(config)
            local self = setmetatable({}, SequenceStep)

            self.Type = config.Type or "animation" -- animation, delay, callback, label
            self.Animation = config.Animation
            self.Duration = config.Duration or 0
            self.Callback = config.Callback
            self.Label = config.Label
            self.Completed = false

            return self
        end

        --// Sequence Class
        function Sequence.new(...)
            local self = setmetatable({}, Sequence)

            self.Id = GenerateSequenceId()
            self.Steps = {}
            self.CurrentStepIndex = 0
            self.State = SequenceState.Pending
            self.LoopCount = 0
            self.MaxLoops = 0 -- 0 = no loop, -1 = infinite
            self.CurrentLoop = 0
            self.Labels = {}

            -- Callbacks
            self.OnStart = nil
            self.OnStepComplete = nil
            self.OnComplete = nil
            self.OnLoop = nil

            -- Add initial animations if provided
            local animations = {...}
            for _, anim in ipairs(animations) do
                self:Add(anim)
            end

            return self
        end

        --// Adding Steps
        function Sequence:Add(animation, options)
            options = options or {}

            local step = SequenceStep.new({
                Type = "animation",
                Animation = animation,
            })

            table.insert(self.Steps, step)

            -- Add delay after if specified
            if options.DelayAfter and options.DelayAfter > 0 then
                self:AddDelay(options.DelayAfter)
            end

            return self
        end

        function Sequence:AddDelay(duration)
            local step = SequenceStep.new({
                Type = "delay",
                Duration = duration,
            })

            table.insert(self.Steps, step)

            return self
        end

        function Sequence:AddCallback(callback)
            local step = SequenceStep.new({
                Type = "callback",
                Callback = callback,
            })

            table.insert(self.Steps, step)

            return self
        end

        function Sequence:AddLabel(label)
            local step = SequenceStep.new({
                Type = "label",
                Label = label,
            })

            self.Labels[label] = #self.Steps + 1
            table.insert(self.Steps, step)

            return self
        end

        function Sequence:Insert(index, animation)
            local step = SequenceStep.new({
                Type = "animation",
                Animation = animation,
            })

            table.insert(self.Steps, index, step)

            return self
        end

        --// Playback Control
        function Sequence:Play()
            if self.State == SequenceState.Playing then
                return self
            end

            self.State = SequenceState.Playing
            self.CurrentStepIndex = 0
            self.CurrentLoop = 0

            if self.OnStart then
                pcall(self.OnStart, self)
            end

            self:_playNextStep()

            return self
        end

        function Sequence:Pause()
            if self.State == SequenceState.Playing then
                self.State = SequenceState.Paused

                -- Pause current animation if possible
                local currentStep = self.Steps[self.CurrentStepIndex]
                if currentStep and currentStep.Animation and currentStep.Animation.Pause then
                    currentStep.Animation:Pause()
                end
            end

            return self
        end

        function Sequence:Resume()
            if self.State == SequenceState.Paused then
                self.State = SequenceState.Playing

                -- Resume current animation if possible
                local currentStep = self.Steps[self.CurrentStepIndex]
                if currentStep and currentStep.Animation and currentStep.Animation.Resume then
                    currentStep.Animation:Resume()
                end
            end

            return self
        end

        function Sequence:Stop()
            self.State = SequenceState.Cancelled

            -- Stop current animation
            local currentStep = self.Steps[self.CurrentStepIndex]
            if currentStep and currentStep.Animation and currentStep.Animation.Stop then
                currentStep.Animation:Stop()
            end

            return self
        end

        function Sequence:Cancel()
            return self:Stop()
        end

        function Sequence:Restart()
            self:Stop()

            -- Reset all steps
            for _, step in ipairs(self.Steps) do
                step.Completed = false
            end

            self:Play()

            return self
        end

        function Sequence:GotoLabel(label)
            local index = self.Labels[label]
            if index then
                self.CurrentStepIndex = index - 1
                self:_playNextStep()
            end
            return self
        end

        function Sequence:GotoStep(index)
            self.CurrentStepIndex = math.max(0, math.min(index - 1, #self.Steps))
            self:_playNextStep()
            return self
        end

        --// Internal Playback
        function Sequence:_playNextStep()
            if self.State ~= SequenceState.Playing then
                return
            end

            self.CurrentStepIndex = self.CurrentStepIndex + 1

            -- Check if sequence is complete
            if self.CurrentStepIndex > #self.Steps then
                -- Check for looping
                if self.MaxLoops == -1 or self.CurrentLoop < self.MaxLoops then
                    self.CurrentLoop = self.CurrentLoop + 1
                    self.CurrentStepIndex = 0

                    -- Reset steps
                    for _, step in ipairs(self.Steps) do
                        step.Completed = false
                    end

                    if self.OnLoop then
                        pcall(self.OnLoop, self.CurrentLoop, self)
                    end

                    self:_playNextStep()
                    return
                end

                self.State = SequenceState.Completed

                if self.OnComplete then
                    pcall(self.OnComplete, self)
                end

                return
            end

            local step = self.Steps[self.CurrentStepIndex]

            if step.Type == "animation" then
                self:_playAnimationStep(step)
            elseif step.Type == "delay" then
                self:_playDelayStep(step)
            elseif step.Type == "callback" then
                self:_playCallbackStep(step)
            elseif step.Type == "label" then
                -- Labels are just markers, skip to next
                step.Completed = true
                self:_playNextStep()
            end
        end

        function Sequence:_playAnimationStep(step)
            local animation = step.Animation

            if not animation then
                step.Completed = true
                self:_onStepComplete(step)
                return
            end

            -- Set up completion handler
            local originalOnComplete = animation.OnComplete

            animation.OnComplete = function(...)
                if originalOnComplete then
                    originalOnComplete(...)
                end

                step.Completed = true
                self:_onStepComplete(step)
            end

            -- Play animation
            if animation.Play then
                animation:Play()
            elseif animation.Start then
                animation:Start()
            end
        end

        function Sequence:_playDelayStep(step)
            task.delay(step.Duration, function()
                if self.State == SequenceState.Playing then
                    step.Completed = true
                    self:_onStepComplete(step)
                end
            end)
        end

        function Sequence:_playCallbackStep(step)
            if step.Callback then
                pcall(step.Callback, self)
            end

            step.Completed = true
            self:_onStepComplete(step)
        end

        function Sequence:_onStepComplete(step)
            if self.OnStepComplete then
                pcall(self.OnStepComplete, step, self.CurrentStepIndex, self)
            end

            self:_playNextStep()
        end

        --// Configuration
        function Sequence:SetLoops(count)
            self.MaxLoops = count
            return self
        end

        function Sequence:SetOnStart(callback)
            self.OnStart = callback
            return self
        end

        function Sequence:SetOnStepComplete(callback)
            self.OnStepComplete = callback
            return self
        end

        function Sequence:SetOnComplete(callback)
            self.OnComplete = callback
            return self
        end

        function Sequence:SetOnLoop(callback)
            self.OnLoop = callback
            return self
        end

        function Sequence:Then(callback)
            local originalOnComplete = self.OnComplete

            self.OnComplete = function(seq)
                if originalOnComplete then
                    originalOnComplete(seq)
                end
                callback(seq)
            end

            return self
        end

        --// State Queries
        function Sequence:GetState()
            return self.State
        end

        function Sequence:IsPlaying()
            return self.State == SequenceState.Playing
        end

        function Sequence:IsPaused()
            return self.State == SequenceState.Paused
        end

        function Sequence:IsComplete()
            return self.State == SequenceState.Completed
        end

        function Sequence:GetCurrentStepIndex()
            return self.CurrentStepIndex
        end

        function Sequence:GetStepCount()
            return #self.Steps
        end

        function Sequence:GetProgress()
            if #self.Steps == 0 then return 1 end
            return (self.CurrentStepIndex - 1) / #self.Steps
        end

        function Sequence:GetCurrentLoop()
            return self.CurrentLoop
        end

        --// Await
        function Sequence:Await()
            while self.State == SequenceState.Playing or self.State == SequenceState.Paused do
                task.wait()
            end
            return self
        end

        --// Export State
        Sequence.State = SequenceState

        return Sequence


    end


    -- ============================================================================
    -- Module: NexusUI/Animation/Timeline
    -- ============================================================================
    NexusUI_Modules["NexusUI/Animation/Timeline"] = function()
        local script = CreateMockScript("NexusUI/Animation/Timeline")

        --[[
            NexusUI Animation Timeline
            Time-based animation orchestration

            Features:
            - Time-positioned animations
            - Parallel and sequential animations
            - Scrubbing (seek to any time)
            - Speed control
            - Labels for easy seeking
        ]]

        --// Timeline Module
        local Timeline = {}
        Timeline.__index = Timeline
        Timeline.ClassName = "AnimationTimeline"

        --// Timeline State
        local TimelineState = {
            Pending = "Pending",
            Playing = "Playing",
            Paused = "Paused",
            Completed = "Completed",
            Cancelled = "Cancelled",
        }

        --// Timeline ID Counter
        local TimelineIdCounter = 0

        local function GenerateTimelineId()
            TimelineIdCounter = TimelineIdCounter + 1
            return "timeline_" .. TimelineIdCounter
        end

        --// Timeline Entry
        local TimelineEntry = {}
        TimelineEntry.__index = TimelineEntry

        function TimelineEntry.new(config)
            local self = setmetatable({}, TimelineEntry)

            self.StartTime = config.StartTime or 0
            self.Duration = config.Duration or 0
            self.Animation = config.Animation
            self.Callback = config.Callback
            self.Label = config.Label
            self.Type = config.Type or "animation" -- animation, callback, label
            self.HasStarted = false
            self.HasCompleted = false

            return self
        end

        function TimelineEntry:GetEndTime()
            return self.StartTime + self.Duration
        end

        --// Timeline Class
        function Timeline.new()
            local self = setmetatable({}, Timeline)

            self.Id = GenerateTimelineId()
            self.Entries = {}
            self.Labels = {}
            self.Duration = 0
            self.CurrentTime = 0
            self.PlaybackSpeed = 1
            self.State = TimelineState.Pending
            self.LoopCount = 0
            self.MaxLoops = 0
            self.CurrentLoop = 0
            self.Connection = nil

            -- Callbacks
            self.OnStart = nil
            self.OnUpdate = nil
            self.OnComplete = nil
            self.OnLoop = nil

            return self
        end

        --// Adding Entries
        function Timeline:Add(animation, startTime, duration)
            local entry = TimelineEntry.new({
                StartTime = startTime or self.Duration,
                Duration = duration or (animation.Duration or 0.3),
                Animation = animation,
                Type = "animation",
            })

            table.insert(self.Entries, entry)
            self:_updateDuration()

            return self
        end

        function Timeline:AddAt(time, animation, duration)
            return self:Add(animation, time, duration)
        end

        function Timeline:AddCallback(time, callback)
            local entry = TimelineEntry.new({
                StartTime = time,
                Duration = 0,
                Callback = callback,
                Type = "callback",
            })

            table.insert(self.Entries, entry)
            self:_updateDuration()

            return self
        end

        function Timeline:AddLabel(time, label)
            local entry = TimelineEntry.new({
                StartTime = time,
                Duration = 0,
                Label = label,
                Type = "label",
            })

            self.Labels[label] = time
            table.insert(self.Entries, entry)

            return self
        end

        function Timeline:AddStagger(animations, startTime, staggerDelay, duration)
            startTime = startTime or self.Duration
            staggerDelay = staggerDelay or 0.1
            duration = duration or 0.3

            for i, animation in ipairs(animations) do
                local time = startTime + (i - 1) * staggerDelay
                self:Add(animation, time, duration)
            end

            return self
        end

        function Timeline:_updateDuration()
            local maxEndTime = 0

            for _, entry in ipairs(self.Entries) do
                local endTime = entry:GetEndTime()
                if endTime > maxEndTime then
                    maxEndTime = endTime
                end
            end

            self.Duration = maxEndTime
        end

        --// Playback Control
        function Timeline:Play()
            if self.State == TimelineState.Playing then
                return self
            end

            self.State = TimelineState.Playing

            if self.CurrentTime == 0 and self.OnStart then
                pcall(self.OnStart, self)
            end

            self:_startUpdateLoop()

            return self
        end

        function Timeline:Pause()
            if self.State == TimelineState.Playing then
                self.State = TimelineState.Paused
                self:_stopUpdateLoop()
            end

            return self
        end

        function Timeline:Resume()
            if self.State == TimelineState.Paused then
                self.State = TimelineState.Playing
                self:_startUpdateLoop()
            end

            return self
        end

        function Timeline:Stop()
            self.State = TimelineState.Cancelled
            self:_stopUpdateLoop()

            return self
        end

        function Timeline:Cancel()
            return self:Stop()
        end

        function Timeline:Restart()
            self:Stop()
            self.CurrentTime = 0
            self.CurrentLoop = 0

            -- Reset all entries
            for _, entry in ipairs(self.Entries) do
                entry.HasStarted = false
                entry.HasCompleted = false
            end

            self:Play()

            return self
        end

        function Timeline:Seek(time)
            time = math.max(0, math.min(time, self.Duration))

            local wasPlaying = self.State == TimelineState.Playing

            if wasPlaying then
                self:Pause()
            end

            -- Reset entries that come after the seek time
            for _, entry in ipairs(self.Entries) do
                if entry.StartTime > time then
                    entry.HasStarted = false
                    entry.HasCompleted = false
                elseif entry:GetEndTime() < time then
                    entry.HasStarted = true
                    entry.HasCompleted = true
                else
                    entry.HasStarted = true
                    entry.HasCompleted = false
                end
            end

            self.CurrentTime = time

            -- Update all animations to current time
            self:_updateAnimationsAtTime(time)

            if wasPlaying then
                self:Resume()
            end

            return self
        end

        function Timeline:SeekLabel(label)
            local time = self.Labels[label]
            if time then
                self:Seek(time)
            end
            return self
        end

        function Timeline:SeekProgress(progress)
            progress = math.max(0, math.min(1, progress))
            self:Seek(progress * self.Duration)
            return self
        end

        --// Update Loop
        function Timeline:_startUpdateLoop()
            if self.Connection then return end

            local RunService = game:GetService("RunService")

            self.Connection = RunService.Heartbeat:Connect(function(deltaTime)
                self:_update(deltaTime * self.PlaybackSpeed)
            end)
        end

        function Timeline:_stopUpdateLoop()
            if self.Connection then
                self.Connection:Disconnect()
                self.Connection = nil
            end
        end

        function Timeline:_update(deltaTime)
            if self.State ~= TimelineState.Playing then
                return
            end

            self.CurrentTime = self.CurrentTime + deltaTime

            -- Process entries
            for _, entry in ipairs(self.Entries) do
                -- Check if entry should start
                if not entry.HasStarted and self.CurrentTime >= entry.StartTime then
                    entry.HasStarted = true

                    if entry.Type == "animation" and entry.Animation then
                        if entry.Animation.Play then
                            entry.Animation:Play()
                        elseif entry.Animation.Start then
                            entry.Animation:Start()
                        end
                    elseif entry.Type == "callback" and entry.Callback then
                        pcall(entry.Callback, self.CurrentTime, self)
                    end
                end

                -- Check if entry should complete
                if entry.HasStarted and not entry.HasCompleted then
                    if self.CurrentTime >= entry:GetEndTime() then
                        entry.HasCompleted = true
                    end
                end
            end

            -- Update callback
            if self.OnUpdate then
                pcall(self.OnUpdate, self.CurrentTime, self:GetProgress(), self)
            end

            -- Check if timeline is complete
            if self.CurrentTime >= self.Duration then
                -- Check for looping
                if self.MaxLoops == -1 or self.CurrentLoop < self.MaxLoops then
                    self.CurrentLoop = self.CurrentLoop + 1
                    self.CurrentTime = 0

                    -- Reset entries
                    for _, entry in ipairs(self.Entries) do
                        entry.HasStarted = false
                        entry.HasCompleted = false
                    end

                    if self.OnLoop then
                        pcall(self.OnLoop, self.CurrentLoop, self)
                    end
                else
                    self.State = TimelineState.Completed
                    self:_stopUpdateLoop()

                    if self.OnComplete then
                        pcall(self.OnComplete, self)
                    end
                end
            end
        end

        function Timeline:_updateAnimationsAtTime(time)
            for _, entry in ipairs(self.Entries) do
                if entry.Type == "animation" and entry.Animation then
                    if time >= entry.StartTime and time <= entry:GetEndTime() then
                        local localProgress = (time - entry.StartTime) / entry.Duration

                        -- If animation has a SetProgress method, use it
                        if entry.Animation.SetProgress then
                            entry.Animation:SetProgress(localProgress)
                        end
                    end
                end
            end
        end

        --// Configuration
        function Timeline:SetSpeed(speed)
            self.PlaybackSpeed = speed
            return self
        end

        function Timeline:SetLoops(count)
            self.MaxLoops = count
            return self
        end

        function Timeline:SetOnStart(callback)
            self.OnStart = callback
            return self
        end

        function Timeline:SetOnUpdate(callback)
            self.OnUpdate = callback
            return self
        end

        function Timeline:SetOnComplete(callback)
            self.OnComplete = callback
            return self
        end

        function Timeline:SetOnLoop(callback)
            self.OnLoop = callback
            return self
        end

        function Timeline:Then(callback)
            local originalOnComplete = self.OnComplete

            self.OnComplete = function(tl)
                if originalOnComplete then
                    originalOnComplete(tl)
                end
                callback(tl)
            end

            return self
        end

        --// State Queries
        function Timeline:GetState()
            return self.State
        end

        function Timeline:IsPlaying()
            return self.State == TimelineState.Playing
        end

        function Timeline:IsPaused()
            return self.State == TimelineState.Paused
        end

        function Timeline:IsComplete()
            return self.State == TimelineState.Completed
        end

        function Timeline:GetCurrentTime()
            return self.CurrentTime
        end

        function Timeline:GetDuration()
            return self.Duration
        end

        function Timeline:GetProgress()
            if self.Duration == 0 then return 1 end
            return math.min(self.CurrentTime / self.Duration, 1)
        end

        function Timeline:GetSpeed()
            return self.PlaybackSpeed
        end

        function Timeline:GetCurrentLoop()
            return self.CurrentLoop
        end

        function Timeline:GetEntryCount()
            return #self.Entries
        end

        function Timeline:GetLabelTime(label)
            return self.Labels[label]
        end

        function Timeline:GetLabels()
            local labels = {}
            for label, time in pairs(self.Labels) do
                table.insert(labels, { Label = label, Time = time })
            end
            table.sort(labels, function(a, b) return a.Time < b.Time end)
            return labels
        end

        --// Await
        function Timeline:Await()
            while self.State == TimelineState.Playing or self.State == TimelineState.Paused do
                task.wait()
            end
            return self
        end

        --// Reverse Playback
        function Timeline:Reverse()
            self.PlaybackSpeed = -self.PlaybackSpeed
            return self
        end

        --// Export State
        Timeline.State = TimelineState

        return Timeline


    end


    -- ============================================================================
    -- Module: NexusUI/Animation/Keyframes
    -- ============================================================================
    NexusUI_Modules["NexusUI/Animation/Keyframes"] = function()
        local script = CreateMockScript("NexusUI/Animation/Keyframes")

        --[[
            NexusUI Keyframe Animation
            CSS-like keyframe animations

            Features:
            - Define keyframes at percentages (0-100)
            - Multiple property animations
            - Custom easing per keyframe
            - Loop and direction control
        ]]

        --// Keyframes Module
        local Keyframes = {}
        Keyframes.__index = Keyframes
        Keyframes.ClassName = "KeyframeAnimation"

        --// Dependencies
        local EasingFunctions = nil

        local function GetEasing(name)
            if not EasingFunctions then
                local easingModule = script.Parent:FindFirstChild("EasingFunctions")
                if easingModule then
                    EasingFunctions = require(easingModule)
                end
            end

            if EasingFunctions and EasingFunctions[name] then
                return EasingFunctions[name]
            end

            return function(t) return t end
        end

        --// Keyframe State
        local KeyframeState = {
            Pending = "Pending",
            Playing = "Playing",
            Paused = "Paused",
            Completed = "Completed",
            Cancelled = "Cancelled",
        }

        --// Direction
        local Direction = {
            Normal = "Normal",
            Reverse = "Reverse",
            Alternate = "Alternate",
            AlternateReverse = "AlternateReverse",
        }

        --// Keyframe ID Counter
        local KeyframeIdCounter = 0

        local function GenerateKeyframeId()
            KeyframeIdCounter = KeyframeIdCounter + 1
            return "keyframe_" .. KeyframeIdCounter
        end

        --// Value Interpolation
        local function LerpValue(a, b, t)
            local valueType = typeof(a)

            if valueType == "number" then
                return a + (b - a) * t
            elseif valueType == "Color3" then
                return Color3.new(
                    a.R + (b.R - a.R) * t,
                    a.G + (b.G - a.G) * t,
                    a.B + (b.B - a.B) * t
                )
            elseif valueType == "Vector2" then
                return Vector2.new(
                    a.X + (b.X - a.X) * t,
                    a.Y + (b.Y - a.Y) * t
                )
            elseif valueType == "Vector3" then
                return Vector3.new(
                    a.X + (b.X - a.X) * t,
                    a.Y + (b.Y - a.Y) * t,
                    a.Z + (b.Z - a.Z) * t
                )
            elseif valueType == "UDim" then
                return UDim.new(
                    a.Scale + (b.Scale - a.Scale) * t,
                    a.Offset + (b.Offset - a.Offset) * t
                )
            elseif valueType == "UDim2" then
                return UDim2.new(
                    a.X.Scale + (b.X.Scale - a.X.Scale) * t,
                    a.X.Offset + (b.X.Offset - a.X.Offset) * t,
                    a.Y.Scale + (b.Y.Scale - a.Y.Scale) * t,
                    a.Y.Offset + (b.Y.Offset - a.Y.Offset) * t
                )
            elseif valueType == "CFrame" then
                return a:Lerp(b, t)
            end

            return t >= 0.5 and b or a
        end

        --// Keyframe Definition
        local KeyframeDefinition = {}
        KeyframeDefinition.__index = KeyframeDefinition

        function KeyframeDefinition.new()
            local self = setmetatable({}, KeyframeDefinition)

            self.Frames = {} -- { Percentage, Properties, Easing }

            return self
        end

        function KeyframeDefinition:At(percentage, properties, easing)
            percentage = math.max(0, math.min(100, percentage))

            table.insert(self.Frames, {
                Percentage = percentage,
                Properties = properties,
                Easing = easing or "Linear",
            })

            -- Sort frames by percentage
            table.sort(self.Frames, function(a, b)
                return a.Percentage < b.Percentage
            end)

            return self
        end

        function KeyframeDefinition:From(properties, easing)
            return self:At(0, properties, easing)
        end

        function KeyframeDefinition:To(properties, easing)
            return self:At(100, properties, easing)
        end

        function KeyframeDefinition:GetFrameAt(percentage)
            -- Find the two frames to interpolate between
            local prevFrame = nil
            local nextFrame = nil

            for _, frame in ipairs(self.Frames) do
                if frame.Percentage <= percentage then
                    prevFrame = frame
                end
                if frame.Percentage >= percentage and not nextFrame then
                    nextFrame = frame
                end
            end

            return prevFrame, nextFrame
        end

        function KeyframeDefinition:GetValueAt(percentage, property)
            local prevFrame, nextFrame = self:GetFrameAt(percentage)

            if not prevFrame and not nextFrame then
                return nil
            end

            if not prevFrame then
                return nextFrame.Properties[property]
            end

            if not nextFrame or prevFrame == nextFrame then
                return prevFrame.Properties[property]
            end

            local prevValue = prevFrame.Properties[property]
            local nextValue = nextFrame.Properties[property]

            if prevValue == nil or nextValue == nil then
                return prevValue or nextValue
            end

            -- Calculate local progress between frames
            local range = nextFrame.Percentage - prevFrame.Percentage
            local localProgress = (percentage - prevFrame.Percentage) / range

            -- Apply easing
            local easingFunc = GetEasing(nextFrame.Easing or "Linear")
            local easedProgress = easingFunc(localProgress)

            return LerpValue(prevValue, nextValue, easedProgress)
        end

        function KeyframeDefinition:GetAllProperties()
            local properties = {}

            for _, frame in ipairs(self.Frames) do
                for prop, _ in pairs(frame.Properties) do
                    properties[prop] = true
                end
            end

            local result = {}
            for prop, _ in pairs(properties) do
                table.insert(result, prop)
            end

            return result
        end

        --// Keyframe Animation Class
        function Keyframes.new(target, keyframes, config)
            local self = setmetatable({}, Keyframes)

            self.Id = GenerateKeyframeId()
            self.Target = target
            self.KeyframeDefinition = keyframes
            self.Duration = config and config.Duration or 1
            self.Delay = config and config.Delay or 0
            self.Direction = config and config.Direction or Direction.Normal
            self.IterationCount = config and config.IterationCount or 1 -- -1 for infinite
            self.FillMode = config and config.FillMode or "forwards" -- none, forwards, backwards, both

            -- State
            self.State = KeyframeState.Pending
            self.CurrentTime = 0
            self.CurrentIteration = 0
            self.DelayRemaining = self.Delay
            self.CurrentDirection = 1 -- 1 or -1
            self.Connection = nil

            -- Callbacks
            self.OnStart = config and config.OnStart
            self.OnUpdate = config and config.OnUpdate
            self.OnIteration = config and config.OnIteration
            self.OnComplete = config and config.OnComplete

            -- Initialize direction
            if self.Direction == Direction.Reverse or self.Direction == Direction.AlternateReverse then
                self.CurrentDirection = -1
            end

            return self
        end

        function Keyframes:Play()
            if self.State == KeyframeState.Playing then
                return self
            end

            self.State = KeyframeState.Playing

            -- Apply fill mode backwards
            if self.FillMode == "backwards" or self.FillMode == "both" then
                local startPercentage = self.CurrentDirection == 1 and 0 or 100
                self:_applyFrame(startPercentage)
            end

            if self.OnStart then
                pcall(self.OnStart, self)
            end

            self:_startUpdateLoop()

            return self
        end

        function Keyframes:Pause()
            if self.State == KeyframeState.Playing then
                self.State = KeyframeState.Paused
                self:_stopUpdateLoop()
            end
            return self
        end

        function Keyframes:Resume()
            if self.State == KeyframeState.Paused then
                self.State = KeyframeState.Playing
                self:_startUpdateLoop()
            end
            return self
        end

        function Keyframes:Stop()
            self.State = KeyframeState.Cancelled
            self:_stopUpdateLoop()
            return self
        end

        function Keyframes:Cancel()
            return self:Stop()
        end

        function Keyframes:Restart()
            self:Stop()
            self.CurrentTime = 0
            self.CurrentIteration = 0
            self.DelayRemaining = self.Delay

            if self.Direction == Direction.Reverse or self.Direction == Direction.AlternateReverse then
                self.CurrentDirection = -1
            else
                self.CurrentDirection = 1
            end

            self:Play()
            return self
        end

        function Keyframes:_startUpdateLoop()
            if self.Connection then return end

            local RunService = game:GetService("RunService")

            self.Connection = RunService.Heartbeat:Connect(function(deltaTime)
                self:_update(deltaTime)
            end)
        end

        function Keyframes:_stopUpdateLoop()
            if self.Connection then
                self.Connection:Disconnect()
                self.Connection = nil
            end
        end

        function Keyframes:_update(deltaTime)
            if self.State ~= KeyframeState.Playing then
                return
            end

            -- Handle delay
            if self.DelayRemaining > 0 then
                self.DelayRemaining = self.DelayRemaining - deltaTime
                return
            end

            -- Update time
            self.CurrentTime = self.CurrentTime + deltaTime

            -- Calculate progress
            local progress = math.min(self.CurrentTime / self.Duration, 1)

            -- Apply direction
            local percentage
            if self.CurrentDirection == 1 then
                percentage = progress * 100
            else
                percentage = (1 - progress) * 100
            end

            -- Apply frame
            self:_applyFrame(percentage)

            -- Callback
            if self.OnUpdate then
                pcall(self.OnUpdate, percentage, progress, self)
            end

            -- Check for iteration complete
            if progress >= 1 then
                self.CurrentIteration = self.CurrentIteration + 1

                if self.OnIteration then
                    pcall(self.OnIteration, self.CurrentIteration, self)
                end

                -- Check if we should continue
                if self.IterationCount == -1 or self.CurrentIteration < self.IterationCount then
                    self.CurrentTime = 0

                    -- Handle direction change for alternate modes
                    if self.Direction == Direction.Alternate or self.Direction == Direction.AlternateReverse then
                        self.CurrentDirection = -self.CurrentDirection
                    end
                else
                    -- Animation complete
                    self.State = KeyframeState.Completed
                    self:_stopUpdateLoop()

                    -- Apply fill mode forwards
                    if self.FillMode == "forwards" or self.FillMode == "both" then
                        local endPercentage = self.CurrentDirection == 1 and 100 or 0
                        self:_applyFrame(endPercentage)
                    end

                    if self.OnComplete then
                        pcall(self.OnComplete, self)
                    end
                end
            end
        end

        function Keyframes:_applyFrame(percentage)
            if not self.Target or not self.KeyframeDefinition then
                return
            end

            local properties = self.KeyframeDefinition:GetAllProperties()

            for _, prop in ipairs(properties) do
                local value = self.KeyframeDefinition:GetValueAt(percentage, prop)

                if value ~= nil then
                    pcall(function()
                        self.Target[prop] = value
                    end)
                end
            end
        end

        --// Configuration
        function Keyframes:SetDuration(duration)
            self.Duration = duration
            return self
        end

        function Keyframes:SetDelay(delay)
            self.Delay = delay
            self.DelayRemaining = delay
            return self
        end

        function Keyframes:SetDirection(direction)
            self.Direction = direction
            return self
        end

        function Keyframes:SetIterationCount(count)
            self.IterationCount = count
            return self
        end

        function Keyframes:SetFillMode(mode)
            self.FillMode = mode
            return self
        end

        function Keyframes:Then(callback)
            local originalOnComplete = self.OnComplete

            self.OnComplete = function(anim)
                if originalOnComplete then
                    originalOnComplete(anim)
                end
                callback(anim)
            end

            return self
        end

        --// State Queries
        function Keyframes:GetState()
            return self.State
        end

        function Keyframes:IsPlaying()
            return self.State == KeyframeState.Playing
        end

        function Keyframes:GetProgress()
            if self.Duration == 0 then return 1 end
            return math.min(self.CurrentTime / self.Duration, 1)
        end

        function Keyframes:GetCurrentIteration()
            return self.CurrentIteration
        end

        function Keyframes:Await()
            while self.State == KeyframeState.Playing or self.State == KeyframeState.Paused do
                task.wait()
            end
            return self
        end

        --// Static Constructor
        function Keyframes.Define()
            return KeyframeDefinition.new()
        end

        function Keyframes.Create(target, keyframes, config)
            return Keyframes.new(target, keyframes, config)
        end

        --// Preset Keyframe Animations
        Keyframes.Presets = {
            FadeIn = function()
                return KeyframeDefinition.new()
                    :At(0, { BackgroundTransparency = 1 })
                    :At(100, { BackgroundTransparency = 0 }, "QuadOut")
            end,

            FadeOut = function()
                return KeyframeDefinition.new()
                    :At(0, { BackgroundTransparency = 0 })
                    :At(100, { BackgroundTransparency = 1 }, "QuadIn")
            end,

            Pulse = function()
                return KeyframeDefinition.new()
                    :At(0, { Size = UDim2.fromScale(1, 1) })
                    :At(50, { Size = UDim2.fromScale(1.1, 1.1) }, "QuadOut")
                    :At(100, { Size = UDim2.fromScale(1, 1) }, "QuadIn")
            end,

            Shake = function()
                return KeyframeDefinition.new()
                    :At(0, { Rotation = 0 })
                    :At(10, { Rotation = -5 })
                    :At(20, { Rotation = 5 })
                    :At(30, { Rotation = -5 })
                    :At(40, { Rotation = 5 })
                    :At(50, { Rotation = -3 })
                    :At(60, { Rotation = 3 })
                    :At(70, { Rotation = -2 })
                    :At(80, { Rotation = 2 })
                    :At(90, { Rotation = -1 })
                    :At(100, { Rotation = 0 })
            end,

            Bounce = function()
                return KeyframeDefinition.new()
                    :At(0, { Position = UDim2.fromScale(0.5, 0.5) })
                    :At(20, { Position = UDim2.fromScale(0.5, 0.4) }, "QuadOut")
                    :At(40, { Position = UDim2.fromScale(0.5, 0.5) }, "BounceOut")
                    :At(60, { Position = UDim2.fromScale(0.5, 0.45) }, "QuadOut")
                    :At(80, { Position = UDim2.fromScale(0.5, 0.5) }, "BounceOut")
                    :At(100, { Position = UDim2.fromScale(0.5, 0.5) })
            end,
        }

        --// Export
        Keyframes.State = KeyframeState
        Keyframes.Direction = Direction

        return Keyframes


    end


    -- ============================================================================
    -- Module: NexusUI/Animation/Tween
    -- ============================================================================
    NexusUI_Modules["NexusUI/Animation/Tween"] = function()
        local script = CreateMockScript("NexusUI/Animation/Tween")

        --[[
            NexusUI Tween System
            Enhanced tweening with advanced features

            Features:
            - Single and multi-property tweens
            - Custom easing functions
            - Tween chaining
            - Event callbacks
            - Pause/Resume support
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")
        local RunService = game:GetService("RunService")

        --// Tween Module
        local Tween = {}
        Tween.__index = Tween
        Tween.ClassName = "NexusTween"

        --// Dependencies
        local EasingFunctions = nil

        local function GetEasing(name)
            if not EasingFunctions then
                local easingModule = script.Parent:FindFirstChild("EasingFunctions")
                if easingModule then
                    EasingFunctions = require(easingModule)
                end
            end

            if EasingFunctions and EasingFunctions[name] then
                return EasingFunctions[name]
            end

            return nil
        end

        --// Tween State
        local TweenState = {
            Pending = "Pending",
            Playing = "Playing",
            Paused = "Paused",
            Completed = "Completed",
            Cancelled = "Cancelled",
        }

        --// Active Tweens
        local ActiveTweens = {}
        local TweenIdCounter = 0

        local function GenerateTweenId()
            TweenIdCounter = TweenIdCounter + 1
            return "tween_" .. TweenIdCounter
        end

        --// Value Interpolation
        local function LerpValue(a, b, t)
            local valueType = typeof(a)

            if valueType == "number" then
                return a + (b - a) * t
            elseif valueType == "Color3" then
                return Color3.new(
                    a.R + (b.R - a.R) * t,
                    a.G + (b.G - a.G) * t,
                    a.B + (b.B - a.B) * t
                )
            elseif valueType == "Vector2" then
                return Vector2.new(
                    a.X + (b.X - a.X) * t,
                    a.Y + (b.Y - a.Y) * t
                )
            elseif valueType == "Vector3" then
                return Vector3.new(
                    a.X + (b.X - a.X) * t,
                    a.Y + (b.Y - a.Y) * t,
                    a.Z + (b.Z - a.Z) * t
                )
            elseif valueType == "UDim" then
                return UDim.new(
                    a.Scale + (b.Scale - a.Scale) * t,
                    a.Offset + (b.Offset - a.Offset) * t
                )
            elseif valueType == "UDim2" then
                return UDim2.new(
                    a.X.Scale + (b.X.Scale - a.X.Scale) * t,
                    a.X.Offset + (b.X.Offset - a.X.Offset) * t,
                    a.Y.Scale + (b.Y.Scale - a.Y.Scale) * t,
                    a.Y.Offset + (b.Y.Offset - a.Y.Offset) * t
                )
            elseif valueType == "CFrame" then
                return a:Lerp(b, t)
            elseif valueType == "Rect" then
                return Rect.new(
                    LerpValue(a.Min, b.Min, t),
                    LerpValue(a.Max, b.Max, t)
                )
            elseif valueType == "NumberRange" then
                return NumberRange.new(
                    LerpValue(a.Min, b.Min, t),
                    LerpValue(a.Max, b.Max, t)
                )
            elseif valueType == "NumberSequence" then
                -- For NumberSequence, interpolate between first keypoints
                local aVal = a.Keypoints[1].Value
                local bVal = b.Keypoints[1].Value
                return NumberSequence.new(LerpValue(aVal, bVal, t))
            elseif valueType == "ColorSequence" then
                -- For ColorSequence, interpolate between first keypoints
                local aCol = a.Keypoints[1].Value
                local bCol = b.Keypoints[1].Value
                return ColorSequence.new(LerpValue(aCol, bCol, t))
            end

            return t >= 0.5 and b or a
        end

        --// Tween Class
        function Tween.new(target, properties, config)
            local self = setmetatable({}, Tween)

            self.Id = GenerateTweenId()
            self.Target = target
            self.Properties = properties
            self.Duration = config and config.Duration or 0.3
            self.Delay = config and config.Delay or 0
            self.Easing = config and config.Easing or "QuadOut"
            self.EasingFunc = nil
            self.Reversible = config and config.Reversible or false
            self.RepeatCount = config and config.RepeatCount or 0
            self.ReverseOnComplete = config and config.ReverseOnComplete or false

            -- State
            self.State = TweenState.Pending
            self.CurrentTime = 0
            self.DelayRemaining = self.Delay
            self.StartValues = {}
            self.CurrentRepeat = 0
            self.IsReversed = false
            self.Connection = nil

            -- Native tween (for hardware acceleration when possible)
            self.NativeTween = nil
            self.UseNative = config and config.UseNative

            -- Callbacks
            self.OnStart = config and config.OnStart
            self.OnUpdate = config and config.OnUpdate
            self.OnComplete = config and config.OnComplete
            self.OnRepeat = config and config.OnRepeat

            -- Resolve easing
            self:_resolveEasing()

            return self
        end

        function Tween:_resolveEasing()
            if type(self.Easing) == "function" then
                self.EasingFunc = self.Easing
            elseif type(self.Easing) == "string" then
                self.EasingFunc = GetEasing(self.Easing)
            end

            -- Fallback to linear if no easing found
            if not self.EasingFunc then
                self.EasingFunc = function(t) return t end
            end
        end

        function Tween:_captureStartValues()
            self.StartValues = {}

            if self.Target then
                for prop, _ in pairs(self.Properties) do
                    pcall(function()
                        self.StartValues[prop] = self.Target[prop]
                    end)
                end
            end
        end

        function Tween:Play()
            if self.State == TweenState.Playing then
                return self
            end

            self:_captureStartValues()
            self.State = TweenState.Playing

            if self.OnStart then
                pcall(self.OnStart, self)
            end

            -- Check if we can use native tween
            if self.UseNative ~= false and self:_canUseNative() then
                self:_playNative()
            else
                self:_playCustom()
            end

            return self
        end

        function Tween:_canUseNative()
            -- Check if easing is a Roblox enum
            if type(self.Easing) == "string" then
                local robloxEasings = {
                    "Linear", "Quad", "Cubic", "Quart", "Quint",
                    "Sine", "Expo", "Circ", "Back", "Elastic", "Bounce",
                }

                for _, name in ipairs(robloxEasings) do
                    if self.Easing:find(name) then
                        return true
                    end
                end
            end

            return false
        end

        function Tween:_getRobloxTweenInfo()
            local style = Enum.EasingStyle.Quad
            local direction = Enum.EasingDirection.Out

            -- Parse easing name
            local easingName = self.Easing or "QuadOut"

            local styleMap = {
                Linear = Enum.EasingStyle.Linear,
                Quad = Enum.EasingStyle.Quad,
                Cubic = Enum.EasingStyle.Cubic,
                Quart = Enum.EasingStyle.Quart,
                Quint = Enum.EasingStyle.Quint,
                Sine = Enum.EasingStyle.Sine,
                Expo = Enum.EasingStyle.Exponential,
                Circ = Enum.EasingStyle.Circular,
                Back = Enum.EasingStyle.Back,
                Elastic = Enum.EasingStyle.Elastic,
                Bounce = Enum.EasingStyle.Bounce,
            }

            for name, enumStyle in pairs(styleMap) do
                if easingName:find(name) then
                    style = enumStyle
                    break
                end
            end

            if easingName:find("In") then
                if easingName:find("Out") then
                    direction = Enum.EasingDirection.InOut
                else
                    direction = Enum.EasingDirection.In
                end
            elseif easingName:find("Out") then
                direction = Enum.EasingDirection.Out
            end

            return TweenInfo.new(
                self.Duration,
                style,
                direction,
                self.RepeatCount,
                self.ReverseOnComplete,
                self.Delay
            )
        end

        function Tween:_playNative()
            local tweenInfo = self:_getRobloxTweenInfo()

            self.NativeTween = TweenService:Create(self.Target, tweenInfo, self.Properties)

            self.NativeTween.Completed:Connect(function(playbackState)
                if playbackState == Enum.PlaybackState.Completed then
                    self.State = TweenState.Completed

                    if self.OnComplete then
                        pcall(self.OnComplete, self)
                    end
                elseif playbackState == Enum.PlaybackState.Cancelled then
                    self.State = TweenState.Cancelled
                end

                ActiveTweens[self.Id] = nil
            end)

            ActiveTweens[self.Id] = self
            self.NativeTween:Play()
        end

        function Tween:_playCustom()
            ActiveTweens[self.Id] = self

            self.Connection = RunService.Heartbeat:Connect(function(deltaTime)
                self:_update(deltaTime)
            end)
        end

        function Tween:_update(deltaTime)
            if self.State ~= TweenState.Playing then
                return
            end

            -- Handle delay
            if self.DelayRemaining > 0 then
                self.DelayRemaining = self.DelayRemaining - deltaTime
                return
            end

            -- Update time
            self.CurrentTime = self.CurrentTime + deltaTime

            -- Calculate progress
            local rawProgress = math.min(self.CurrentTime / self.Duration, 1)
            local progress = self.IsReversed and (1 - rawProgress) or rawProgress
            local easedProgress = self.EasingFunc(progress)

            -- Apply values
            if self.Target then
                for prop, endValue in pairs(self.Properties) do
                    local startValue = self.StartValues[prop]

                    if startValue ~= nil then
                        local currentValue = LerpValue(startValue, endValue, easedProgress)

                        pcall(function()
                            self.Target[prop] = currentValue
                        end)
                    end
                end
            end

            -- Callback
            if self.OnUpdate then
                pcall(self.OnUpdate, easedProgress, rawProgress, self)
            end

            -- Check for completion
            if rawProgress >= 1 then
                self:_onComplete()
            end
        end

        function Tween:_onComplete()
            -- Handle repeating
            if self.RepeatCount == -1 or self.CurrentRepeat < self.RepeatCount then
                self.CurrentRepeat = self.CurrentRepeat + 1
                self.CurrentTime = 0

                if self.ReverseOnComplete then
                    self.IsReversed = not self.IsReversed
                end

                if self.OnRepeat then
                    pcall(self.OnRepeat, self.CurrentRepeat, self)
                end

                return
            end

            -- Animation complete
            self.State = TweenState.Completed

            if self.Connection then
                self.Connection:Disconnect()
                self.Connection = nil
            end

            ActiveTweens[self.Id] = nil

            if self.OnComplete then
                pcall(self.OnComplete, self)
            end
        end

        function Tween:Pause()
            if self.State == TweenState.Playing then
                self.State = TweenState.Paused

                if self.NativeTween then
                    self.NativeTween:Pause()
                end

                if self.Connection then
                    self.Connection:Disconnect()
                    self.Connection = nil
                end
            end

            return self
        end

        function Tween:Resume()
            if self.State == TweenState.Paused then
                self.State = TweenState.Playing

                if self.NativeTween then
                    self.NativeTween:Play()
                else
                    self.Connection = RunService.Heartbeat:Connect(function(deltaTime)
                        self:_update(deltaTime)
                    end)
                end
            end

            return self
        end

        function Tween:Stop()
            self.State = TweenState.Cancelled

            if self.NativeTween then
                self.NativeTween:Cancel()
            end

            if self.Connection then
                self.Connection:Disconnect()
                self.Connection = nil
            end

            ActiveTweens[self.Id] = nil

            return self
        end

        function Tween:Cancel()
            return self:Stop()
        end

        function Tween:Reverse()
            if self.Reversible then
                self.IsReversed = not self.IsReversed
            end
            return self
        end

        function Tween:Then(callback)
            local originalOnComplete = self.OnComplete

            self.OnComplete = function(tween)
                if originalOnComplete then
                    originalOnComplete(tween)
                end
                callback(tween)
            end

            return self
        end

        function Tween:Chain(nextTween)
            return self:Then(function()
                nextTween:Play()
            end)
        end

        --// State Queries
        function Tween:GetState()
            return self.State
        end

        function Tween:IsPlaying()
            return self.State == TweenState.Playing
        end

        function Tween:IsPaused()
            return self.State == TweenState.Paused
        end

        function Tween:IsComplete()
            return self.State == TweenState.Completed
        end

        function Tween:GetProgress()
            if self.Duration == 0 then return 1 end
            return math.min(self.CurrentTime / self.Duration, 1)
        end

        function Tween:Await()
            while self.State == TweenState.Playing or self.State == TweenState.Paused do
                task.wait()
            end
            return self
        end

        --// Static Methods
        function Tween.To(target, properties, duration, easing)
            return Tween.new(target, properties, {
                Duration = duration or 0.3,
                Easing = easing or "QuadOut",
            }):Play()
        end

        function Tween.From(target, properties, duration, easing)
            -- Capture current values as end values
            local endValues = {}
            for prop, _ in pairs(properties) do
                pcall(function()
                    endValues[prop] = target[prop]
                end)
            end

            -- Set target to start values immediately
            for prop, value in pairs(properties) do
                pcall(function()
                    target[prop] = value
                end)
            end

            return Tween.new(target, endValues, {
                Duration = duration or 0.3,
                Easing = easing or "QuadOut",
            }):Play()
        end

        function Tween.FromTo(target, fromProperties, toProperties, duration, easing)
            -- Set start values
            for prop, value in pairs(fromProperties) do
                pcall(function()
                    target[prop] = value
                end)
            end

            return Tween.new(target, toProperties, {
                Duration = duration or 0.3,
                Easing = easing or "QuadOut",
            }):Play()
        end

        --// Global Management
        function Tween.CancelAll()
            for id, tween in pairs(ActiveTweens) do
                tween:Cancel()
            end
            ActiveTweens = {}
        end

        function Tween.CancelTweensOf(target)
            for id, tween in pairs(ActiveTweens) do
                if tween.Target == target then
                    tween:Cancel()
                end
            end
        end

        function Tween.GetTweensOf(target)
            local tweens = {}
            for id, tween in pairs(ActiveTweens) do
                if tween.Target == target then
                    table.insert(tweens, tween)
                end
            end
            return tweens
        end

        function Tween.GetActiveCount()
            local count = 0
            for _ in pairs(ActiveTweens) do
                count = count + 1
            end
            return count
        end

        --// Export
        Tween.State = TweenState

        return Tween


    end


    -- ============================================================================
    -- Module: NexusUI/Animation/Parallel
    -- ============================================================================
    NexusUI_Modules["NexusUI/Animation/Parallel"] = function()
        local script = CreateMockScript("NexusUI/Animation/Parallel")

        --[[
            NexusUI Parallel Animation
            Run multiple animations simultaneously

            Features:
            - Execute animations in parallel
            - Wait for all to complete
            - Staggered starts
            - Group control (pause/stop all)
        ]]

        --// Parallel Module
        local Parallel = {}
        Parallel.__index = Parallel
        Parallel.ClassName = "ParallelAnimation"

        --// Parallel State
        local ParallelState = {
            Pending = "Pending",
            Playing = "Playing",
            Paused = "Paused",
            Completed = "Completed",
            Cancelled = "Cancelled",
        }

        --// ID Counter
        local ParallelIdCounter = 0

        local function GenerateParallelId()
            ParallelIdCounter = ParallelIdCounter + 1
            return "parallel_" .. ParallelIdCounter
        end

        --// Parallel Class
        function Parallel.new(...)
            local self = setmetatable({}, Parallel)

            self.Id = GenerateParallelId()
            self.Animations = {}
            self.State = ParallelState.Pending
            self.CompletedCount = 0
            self.StaggerDelay = 0

            -- Callbacks
            self.OnStart = nil
            self.OnAnimationComplete = nil
            self.OnComplete = nil

            -- Add initial animations
            local animations = {...}
            for _, anim in ipairs(animations) do
                self:Add(anim)
            end

            return self
        end

        --// Adding Animations
        function Parallel:Add(animation)
            table.insert(self.Animations, {
                Animation = animation,
                Completed = false,
                Started = false,
            })
            return self
        end

        function Parallel:AddAll(animations)
            for _, anim in ipairs(animations) do
                self:Add(anim)
            end
            return self
        end

        --// Configuration
        function Parallel:SetStagger(delay)
            self.StaggerDelay = delay
            return self
        end

        function Parallel:SetOnStart(callback)
            self.OnStart = callback
            return self
        end

        function Parallel:SetOnAnimationComplete(callback)
            self.OnAnimationComplete = callback
            return self
        end

        function Parallel:SetOnComplete(callback)
            self.OnComplete = callback
            return self
        end

        --// Playback
        function Parallel:Play()
            if self.State == ParallelState.Playing then
                return self
            end

            self.State = ParallelState.Playing
            self.CompletedCount = 0

            if self.OnStart then
                pcall(self.OnStart, self)
            end

            -- Start all animations
            for i, entry in ipairs(self.Animations) do
                local animation = entry.Animation

                -- Handle stagger delay
                local delay = (i - 1) * self.StaggerDelay

                if delay > 0 then
                    task.delay(delay, function()
                        if self.State == ParallelState.Playing then
                            self:_startAnimation(entry, i)
                        end
                    end)
                else
                    self:_startAnimation(entry, i)
                end
            end

            return self
        end

        function Parallel:_startAnimation(entry, index)
            local animation = entry.Animation

            -- Set up completion handler
            local originalOnComplete = animation.OnComplete

            animation.OnComplete = function(...)
                if originalOnComplete then
                    originalOnComplete(...)
                end

                entry.Completed = true
                self.CompletedCount = self.CompletedCount + 1

                if self.OnAnimationComplete then
                    pcall(self.OnAnimationComplete, animation, index, self)
                end

                -- Check if all complete
                if self.CompletedCount >= #self.Animations then
                    self.State = ParallelState.Completed

                    if self.OnComplete then
                        pcall(self.OnComplete, self)
                    end
                end
            end

            entry.Started = true

            -- Play animation
            if animation.Play then
                animation:Play()
            elseif animation.Start then
                animation:Start()
            end
        end

        function Parallel:Pause()
            if self.State == ParallelState.Playing then
                self.State = ParallelState.Paused

                for _, entry in ipairs(self.Animations) do
                    if entry.Started and not entry.Completed then
                        if entry.Animation.Pause then
                            entry.Animation:Pause()
                        end
                    end
                end
            end

            return self
        end

        function Parallel:Resume()
            if self.State == ParallelState.Paused then
                self.State = ParallelState.Playing

                for _, entry in ipairs(self.Animations) do
                    if entry.Started and not entry.Completed then
                        if entry.Animation.Resume then
                            entry.Animation:Resume()
                        end
                    end
                end
            end

            return self
        end

        function Parallel:Stop()
            self.State = ParallelState.Cancelled

            for _, entry in ipairs(self.Animations) do
                if entry.Started and not entry.Completed then
                    if entry.Animation.Stop then
                        entry.Animation:Stop()
                    elseif entry.Animation.Cancel then
                        entry.Animation:Cancel()
                    end
                end
            end

            return self
        end

        function Parallel:Cancel()
            return self:Stop()
        end

        function Parallel:Restart()
            self:Stop()

            -- Reset all entries
            for _, entry in ipairs(self.Animations) do
                entry.Started = false
                entry.Completed = false
            end

            self:Play()

            return self
        end

        --// Chaining
        function Parallel:Then(callback)
            local originalOnComplete = self.OnComplete

            self.OnComplete = function(parallel)
                if originalOnComplete then
                    originalOnComplete(parallel)
                end
                callback(parallel)
            end

            return self
        end

        --// State Queries
        function Parallel:GetState()
            return self.State
        end

        function Parallel:IsPlaying()
            return self.State == ParallelState.Playing
        end

        function Parallel:IsPaused()
            return self.State == ParallelState.Paused
        end

        function Parallel:IsComplete()
            return self.State == ParallelState.Completed
        end

        function Parallel:GetProgress()
            if #self.Animations == 0 then return 1 end
            return self.CompletedCount / #self.Animations
        end

        function Parallel:GetCompletedCount()
            return self.CompletedCount
        end

        function Parallel:GetAnimationCount()
            return #self.Animations
        end

        function Parallel:Await()
            while self.State == ParallelState.Playing or self.State == ParallelState.Paused do
                task.wait()
            end
            return self
        end

        --// Static Constructor
        function Parallel.All(...)
            return Parallel.new(...):Play()
        end

        function Parallel.AllStaggered(animations, staggerDelay)
            local parallel = Parallel.new()
            parallel:AddAll(animations)
            parallel:SetStagger(staggerDelay or 0.05)
            return parallel:Play()
        end

        --// Export
        Parallel.State = ParallelState

        return Parallel


    end


    -- ============================================================================
    -- Module: NexusUI/Animation/Morph
    -- ============================================================================
    NexusUI_Modules["NexusUI/Animation/Morph"] = function()
        local script = CreateMockScript("NexusUI/Animation/Morph")

        --[[
            NexusUI Morph Animation
            Smooth morphing between UI states

            Features:
            - State-based morphing
            - Complex property transitions
            - Snapshot and restore
            - Interpolation between layouts
        ]]

        --// Morph Module
        local Morph = {}
        Morph.__index = Morph
        Morph.ClassName = "MorphAnimation"

        --// Dependencies
        local EasingFunctions = nil

        local function GetEasing(name)
            if not EasingFunctions then
                local easingModule = script.Parent:FindFirstChild("EasingFunctions")
                if easingModule then
                    EasingFunctions = require(easingModule)
                end
            end

            if EasingFunctions and EasingFunctions[name] then
                return EasingFunctions[name]
            end

            return function(t) return t end
        end

        --// Morph State
        local MorphState = {
            Pending = "Pending",
            Morphing = "Morphing",
            Paused = "Paused",
            Completed = "Completed",
            Cancelled = "Cancelled",
        }

        --// ID Counter
        local MorphIdCounter = 0

        local function GenerateMorphId()
            MorphIdCounter = MorphIdCounter + 1
            return "morph_" .. MorphIdCounter
        end

        --// Properties to capture
        local CaptureProperties = {
            "Position",
            "Size",
            "AnchorPoint",
            "Rotation",
            "BackgroundColor3",
            "BackgroundTransparency",
            "BorderColor3",
            "BorderSizePixel",
            "Visible",
            "ZIndex",
        }

        local TextProperties = {
            "Text",
            "TextColor3",
            "TextTransparency",
            "TextSize",
            "Font",
        }

        local ImageProperties = {
            "Image",
            "ImageColor3",
            "ImageTransparency",
            "ImageRectOffset",
            "ImageRectSize",
        }

        --// Value Interpolation
        local function CanInterpolate(value)
            local valueType = typeof(value)
            return valueType == "number" or
                   valueType == "Color3" or
                   valueType == "Vector2" or
                   valueType == "Vector3" or
                   valueType == "UDim" or
                   valueType == "UDim2" or
                   valueType == "CFrame"
        end

        local function LerpValue(a, b, t)
            local valueType = typeof(a)

            if valueType == "number" then
                return a + (b - a) * t
            elseif valueType == "Color3" then
                return Color3.new(
                    a.R + (b.R - a.R) * t,
                    a.G + (b.G - a.G) * t,
                    a.B + (b.B - a.B) * t
                )
            elseif valueType == "Vector2" then
                return Vector2.new(
                    a.X + (b.X - a.X) * t,
                    a.Y + (b.Y - a.Y) * t
                )
            elseif valueType == "Vector3" then
                return Vector3.new(
                    a.X + (b.X - a.X) * t,
                    a.Y + (b.Y - a.Y) * t,
                    a.Z + (b.Z - a.Z) * t
                )
            elseif valueType == "UDim" then
                return UDim.new(
                    a.Scale + (b.Scale - a.Scale) * t,
                    a.Offset + (b.Offset - a.Offset) * t
                )
            elseif valueType == "UDim2" then
                return UDim2.new(
                    a.X.Scale + (b.X.Scale - a.X.Scale) * t,
                    a.X.Offset + (b.X.Offset - a.X.Offset) * t,
                    a.Y.Scale + (b.Y.Scale - a.Y.Scale) * t,
                    a.Y.Offset + (b.Y.Offset - a.Y.Offset) * t
                )
            elseif valueType == "CFrame" then
                return a:Lerp(b, t)
            end

            return t >= 0.5 and b or a
        end

        --// Snapshot
        local Snapshot = {}
        Snapshot.__index = Snapshot

        function Snapshot.new(target)
            local self = setmetatable({}, Snapshot)

            self.Target = target
            self.Properties = {}
            self.Children = {}

            return self
        end

        function Snapshot:Capture()
            if not self.Target then return self end

            -- Get all relevant properties
            local propsToCapture = {unpack(CaptureProperties)}

            if self.Target:IsA("TextLabel") or self.Target:IsA("TextButton") or self.Target:IsA("TextBox") then
                for _, prop in ipairs(TextProperties) do
                    table.insert(propsToCapture, prop)
                end
            end

            if self.Target:IsA("ImageLabel") or self.Target:IsA("ImageButton") then
                for _, prop in ipairs(ImageProperties) do
                    table.insert(propsToCapture, prop)
                end
            end

            -- Capture properties
            for _, prop in ipairs(propsToCapture) do
                pcall(function()
                    self.Properties[prop] = self.Target[prop]
                end)
            end

            -- Capture children recursively
            for _, child in ipairs(self.Target:GetChildren()) do
                if child:IsA("GuiObject") then
                    local childSnapshot = Snapshot.new(child)
                    childSnapshot:Capture()
                    self.Children[child.Name] = childSnapshot
                end
            end

            return self
        end

        function Snapshot:Apply(alpha)
            alpha = alpha or 1

            for prop, value in pairs(self.Properties) do
                if alpha >= 1 then
                    pcall(function()
                        self.Target[prop] = value
                    end)
                end
            end

            return self
        end

        --// Morph Class
        function Morph.new(target, config)
            local self = setmetatable({}, Morph)

            self.Id = GenerateMorphId()
            self.Target = target
            self.Duration = config and config.Duration or 0.5
            self.Easing = config and config.Easing or "QuadInOut"
            self.EasingFunc = GetEasing(self.Easing)

            -- State
            self.State = MorphState.Pending
            self.FromSnapshot = nil
            self.ToSnapshot = nil
            self.CurrentTime = 0
            self.Connection = nil

            -- Named states
            self.States = {}
            self.CurrentState = nil

            -- Callbacks
            self.OnStart = config and config.OnStart
            self.OnUpdate = config and config.OnUpdate
            self.OnComplete = config and config.OnComplete

            return self
        end

        --// State Management
        function Morph:SaveState(stateName)
            local snapshot = Snapshot.new(self.Target)
            snapshot:Capture()
            self.States[stateName] = snapshot
            return self
        end

        function Morph:RemoveState(stateName)
            self.States[stateName] = nil
            return self
        end

        function Morph:HasState(stateName)
            return self.States[stateName] ~= nil
        end

        function Morph:GetStateNames()
            local names = {}
            for name, _ in pairs(self.States) do
                table.insert(names, name)
            end
            return names
        end

        --// Morphing
        function Morph:MorphTo(targetState, duration, easing)
            local toSnapshot

            if type(targetState) == "string" then
                toSnapshot = self.States[targetState]
                if not toSnapshot then
                    warn("Morph state not found:", targetState)
                    return self
                end
            elseif type(targetState) == "table" then
                -- Direct properties table
                toSnapshot = Snapshot.new(self.Target)
                toSnapshot.Properties = targetState
            end

            -- Capture current state as from
            self.FromSnapshot = Snapshot.new(self.Target)
            self.FromSnapshot:Capture()
            self.ToSnapshot = toSnapshot

            -- Override duration/easing if provided
            if duration then self.Duration = duration end
            if easing then
                self.Easing = easing
                self.EasingFunc = GetEasing(easing)
            end

            return self:Play()
        end

        function Morph:MorphBetween(fromState, toState, duration, easing)
            local fromSnapshot, toSnapshot

            if type(fromState) == "string" then
                fromSnapshot = self.States[fromState]
            elseif type(fromState) == "table" then
                fromSnapshot = Snapshot.new(self.Target)
                fromSnapshot.Properties = fromState
            end

            if type(toState) == "string" then
                toSnapshot = self.States[toState]
            elseif type(toState) == "table" then
                toSnapshot = Snapshot.new(self.Target)
                toSnapshot.Properties = toState
            end

            if not fromSnapshot or not toSnapshot then
                warn("Invalid morph states")
                return self
            end

            self.FromSnapshot = fromSnapshot
            self.ToSnapshot = toSnapshot

            if duration then self.Duration = duration end
            if easing then
                self.Easing = easing
                self.EasingFunc = GetEasing(easing)
            end

            -- Apply from state immediately
            fromSnapshot:Apply()

            return self:Play()
        end

        function Morph:Play()
            if self.State == MorphState.Morphing then
                return self
            end

            if not self.FromSnapshot or not self.ToSnapshot then
                -- Use current state as from if not set
                if not self.FromSnapshot then
                    self.FromSnapshot = Snapshot.new(self.Target)
                    self.FromSnapshot:Capture()
                end

                if not self.ToSnapshot then
                    warn("No target state set for morph")
                    return self
                end
            end

            self.State = MorphState.Morphing
            self.CurrentTime = 0

            if self.OnStart then
                pcall(self.OnStart, self)
            end

            self:_startUpdateLoop()

            return self
        end

        function Morph:_startUpdateLoop()
            if self.Connection then return end

            local RunService = game:GetService("RunService")

            self.Connection = RunService.Heartbeat:Connect(function(deltaTime)
                self:_update(deltaTime)
            end)
        end

        function Morph:_stopUpdateLoop()
            if self.Connection then
                self.Connection:Disconnect()
                self.Connection = nil
            end
        end

        function Morph:_update(deltaTime)
            if self.State ~= MorphState.Morphing then
                return
            end

            self.CurrentTime = self.CurrentTime + deltaTime
            local progress = math.min(self.CurrentTime / self.Duration, 1)
            local easedProgress = self.EasingFunc(progress)

            -- Interpolate all properties
            self:_applyMorph(easedProgress)

            if self.OnUpdate then
                pcall(self.OnUpdate, easedProgress, progress, self)
            end

            if progress >= 1 then
                self.State = MorphState.Completed
                self:_stopUpdateLoop()

                if self.OnComplete then
                    pcall(self.OnComplete, self)
                end
            end
        end

        function Morph:_applyMorph(t)
            if not self.Target or not self.FromSnapshot or not self.ToSnapshot then
                return
            end

            local fromProps = self.FromSnapshot.Properties
            local toProps = self.ToSnapshot.Properties

            -- Interpolate each property
            for prop, toValue in pairs(toProps) do
                local fromValue = fromProps[prop]

                if fromValue ~= nil and CanInterpolate(fromValue) then
                    local interpolated = LerpValue(fromValue, toValue, t)

                    pcall(function()
                        self.Target[prop] = interpolated
                    end)
                elseif t >= 0.5 then
                    -- For non-interpolable values, switch at midpoint
                    pcall(function()
                        self.Target[prop] = toValue
                    end)
                end
            end
        end

        function Morph:Pause()
            if self.State == MorphState.Morphing then
                self.State = MorphState.Paused
                self:_stopUpdateLoop()
            end
            return self
        end

        function Morph:Resume()
            if self.State == MorphState.Paused then
                self.State = MorphState.Morphing
                self:_startUpdateLoop()
            end
            return self
        end

        function Morph:Stop()
            self.State = MorphState.Cancelled
            self:_stopUpdateLoop()
            return self
        end

        function Morph:Cancel()
            return self:Stop()
        end

        --// Chaining
        function Morph:Then(callback)
            local originalOnComplete = self.OnComplete

            self.OnComplete = function(morph)
                if originalOnComplete then
                    originalOnComplete(morph)
                end
                callback(morph)
            end

            return self
        end

        --// State Queries
        function Morph:GetState()
            return self.State
        end

        function Morph:IsMorphing()
            return self.State == MorphState.Morphing
        end

        function Morph:GetProgress()
            if self.Duration == 0 then return 1 end
            return math.min(self.CurrentTime / self.Duration, 1)
        end

        function Morph:Await()
            while self.State == MorphState.Morphing or self.State == MorphState.Paused do
                task.wait()
            end
            return self
        end

        --// Static Methods
        function Morph.CreateSnapshot(target)
            local snapshot = Snapshot.new(target)
            return snapshot:Capture()
        end

        function Morph.To(target, properties, duration, easing)
            local morph = Morph.new(target, {
                Duration = duration or 0.5,
                Easing = easing or "QuadInOut",
            })

            return morph:MorphTo(properties)
        end

        --// Export
        Morph.State = MorphState
        Morph.Snapshot = Snapshot

        return Morph


    end


    -- ============================================================================
    -- Module: NexusUI/Animation/Transition
    -- ============================================================================
    NexusUI_Modules["NexusUI/Animation/Transition"] = function()
        local script = CreateMockScript("NexusUI/Animation/Transition")

        --[[
            NexusUI Transition System
            Pre-built transitions for common UI animations

            Features:
            - Fade transitions
            - Slide transitions
            - Scale transitions
            - Combinations
            - Custom transition builder
        ]]

        --// Transition Module
        local Transition = {}
        Transition.ClassName = "Transition"

        --// Dependencies
        local Tween = nil
        local Parallel = nil

        local function GetTween()
            if not Tween then
                local tweenModule = script.Parent:FindFirstChild("Tween")
                if tweenModule then
                    Tween = require(tweenModule)
                end
            end
            return Tween
        end

        local function GetParallel()
            if not Parallel then
                local parallelModule = script.Parent:FindFirstChild("Parallel")
                if parallelModule then
                    Parallel = require(parallelModule)
                end
            end
            return Parallel
        end

        --// Transition Config
        local DefaultConfig = {
            Duration = 0.3,
            Easing = "QuadOut",
            Delay = 0,
        }

        local function MergeConfig(config)
            local merged = {}
            for k, v in pairs(DefaultConfig) do
                merged[k] = v
            end
            if config then
                for k, v in pairs(config) do
                    merged[k] = v
                end
            end
            return merged
        end

        --// Fade Transitions
        Transition.Fade = {}

        function Transition.Fade.In(target, config)
            config = MergeConfig(config)

            target.BackgroundTransparency = 1
            target.Visible = true

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    BackgroundTransparency = 0,
                }, config):Play()
            end
        end

        function Transition.Fade.Out(target, config)
            config = MergeConfig(config)

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    BackgroundTransparency = 1,
                }, {
                    Duration = config.Duration,
                    Easing = config.Easing,
                    Delay = config.Delay,
                    OnComplete = function()
                        target.Visible = false
                    end,
                }):Play()
            end
        end

        function Transition.Fade.InOut(target, duration, holdTime, config)
            config = MergeConfig(config)
            holdTime = holdTime or 1

            Transition.Fade.In(target, config):Then(function()
                task.wait(holdTime)
                Transition.Fade.Out(target, config)
            end)
        end

        --// Slide Transitions
        Transition.Slide = {}

        function Transition.Slide.FromLeft(target, config)
            config = MergeConfig(config)

            local originalPosition = target.Position
            target.Position = UDim2.new(originalPosition.X.Scale - 1, originalPosition.X.Offset, originalPosition.Y.Scale, originalPosition.Y.Offset)
            target.Visible = true

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    Position = originalPosition,
                }, config):Play()
            end
        end

        function Transition.Slide.FromRight(target, config)
            config = MergeConfig(config)

            local originalPosition = target.Position
            target.Position = UDim2.new(originalPosition.X.Scale + 1, originalPosition.X.Offset, originalPosition.Y.Scale, originalPosition.Y.Offset)
            target.Visible = true

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    Position = originalPosition,
                }, config):Play()
            end
        end

        function Transition.Slide.FromTop(target, config)
            config = MergeConfig(config)

            local originalPosition = target.Position
            target.Position = UDim2.new(originalPosition.X.Scale, originalPosition.X.Offset, originalPosition.Y.Scale - 1, originalPosition.Y.Offset)
            target.Visible = true

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    Position = originalPosition,
                }, config):Play()
            end
        end

        function Transition.Slide.FromBottom(target, config)
            config = MergeConfig(config)

            local originalPosition = target.Position
            target.Position = UDim2.new(originalPosition.X.Scale, originalPosition.X.Offset, originalPosition.Y.Scale + 1, originalPosition.Y.Offset)
            target.Visible = true

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    Position = originalPosition,
                }, config):Play()
            end
        end

        function Transition.Slide.ToLeft(target, config)
            config = MergeConfig(config)

            local originalPosition = target.Position

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    Position = UDim2.new(originalPosition.X.Scale - 1, originalPosition.X.Offset, originalPosition.Y.Scale, originalPosition.Y.Offset),
                }, {
                    Duration = config.Duration,
                    Easing = config.Easing,
                    Delay = config.Delay,
                    OnComplete = function()
                        target.Visible = false
                        target.Position = originalPosition
                    end,
                }):Play()
            end
        end

        function Transition.Slide.ToRight(target, config)
            config = MergeConfig(config)

            local originalPosition = target.Position

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    Position = UDim2.new(originalPosition.X.Scale + 1, originalPosition.X.Offset, originalPosition.Y.Scale, originalPosition.Y.Offset),
                }, {
                    Duration = config.Duration,
                    Easing = config.Easing,
                    Delay = config.Delay,
                    OnComplete = function()
                        target.Visible = false
                        target.Position = originalPosition
                    end,
                }):Play()
            end
        end

        function Transition.Slide.ToTop(target, config)
            config = MergeConfig(config)

            local originalPosition = target.Position

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    Position = UDim2.new(originalPosition.X.Scale, originalPosition.X.Offset, originalPosition.Y.Scale - 1, originalPosition.Y.Offset),
                }, {
                    Duration = config.Duration,
                    Easing = config.Easing,
                    Delay = config.Delay,
                    OnComplete = function()
                        target.Visible = false
                        target.Position = originalPosition
                    end,
                }):Play()
            end
        end

        function Transition.Slide.ToBottom(target, config)
            config = MergeConfig(config)

            local originalPosition = target.Position

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    Position = UDim2.new(originalPosition.X.Scale, originalPosition.X.Offset, originalPosition.Y.Scale + 1, originalPosition.Y.Offset),
                }, {
                    Duration = config.Duration,
                    Easing = config.Easing,
                    Delay = config.Delay,
                    OnComplete = function()
                        target.Visible = false
                        target.Position = originalPosition
                    end,
                }):Play()
            end
        end

        --// Scale Transitions
        Transition.Scale = {}

        function Transition.Scale.In(target, config)
            config = MergeConfig(config)

            local originalSize = target.Size
            target.Size = UDim2.new(0, 0, 0, 0)
            target.Visible = true

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    Size = originalSize,
                }, config):Play()
            end
        end

        function Transition.Scale.Out(target, config)
            config = MergeConfig(config)

            local originalSize = target.Size

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    Size = UDim2.new(0, 0, 0, 0),
                }, {
                    Duration = config.Duration,
                    Easing = config.Easing,
                    Delay = config.Delay,
                    OnComplete = function()
                        target.Visible = false
                        target.Size = originalSize
                    end,
                }):Play()
            end
        end

        function Transition.Scale.Pop(target, config)
            config = MergeConfig(config)

            local originalSize = target.Size
            target.Size = UDim2.new(originalSize.X.Scale * 0.8, originalSize.X.Offset * 0.8, originalSize.Y.Scale * 0.8, originalSize.Y.Offset * 0.8)
            target.Visible = true

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    Size = originalSize,
                }, {
                    Duration = config.Duration,
                    Easing = "BackOut",
                }):Play()
            end
        end

        function Transition.Scale.Bounce(target, config)
            config = MergeConfig(config)

            local originalSize = target.Size
            target.Size = UDim2.new(0, 0, 0, 0)
            target.Visible = true

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    Size = originalSize,
                }, {
                    Duration = config.Duration,
                    Easing = "ElasticOut",
                }):Play()
            end
        end

        --// Combined Transitions
        Transition.Combined = {}

        function Transition.Combined.FadeSlideFromLeft(target, config)
            config = MergeConfig(config)

            local originalPosition = target.Position
            target.Position = UDim2.new(originalPosition.X.Scale - 0.1, originalPosition.X.Offset - 20, originalPosition.Y.Scale, originalPosition.Y.Offset)
            target.BackgroundTransparency = 1
            target.Visible = true

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    Position = originalPosition,
                    BackgroundTransparency = 0,
                }, config):Play()
            end
        end

        function Transition.Combined.FadeSlideFromRight(target, config)
            config = MergeConfig(config)

            local originalPosition = target.Position
            target.Position = UDim2.new(originalPosition.X.Scale + 0.1, originalPosition.X.Offset + 20, originalPosition.Y.Scale, originalPosition.Y.Offset)
            target.BackgroundTransparency = 1
            target.Visible = true

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    Position = originalPosition,
                    BackgroundTransparency = 0,
                }, config):Play()
            end
        end

        function Transition.Combined.FadeSlideFromTop(target, config)
            config = MergeConfig(config)

            local originalPosition = target.Position
            target.Position = UDim2.new(originalPosition.X.Scale, originalPosition.X.Offset, originalPosition.Y.Scale - 0.1, originalPosition.Y.Offset - 20)
            target.BackgroundTransparency = 1
            target.Visible = true

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    Position = originalPosition,
                    BackgroundTransparency = 0,
                }, config):Play()
            end
        end

        function Transition.Combined.FadeSlideFromBottom(target, config)
            config = MergeConfig(config)

            local originalPosition = target.Position
            target.Position = UDim2.new(originalPosition.X.Scale, originalPosition.X.Offset, originalPosition.Y.Scale + 0.1, originalPosition.Y.Offset + 20)
            target.BackgroundTransparency = 1
            target.Visible = true

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    Position = originalPosition,
                    BackgroundTransparency = 0,
                }, config):Play()
            end
        end

        function Transition.Combined.FadeScale(target, config)
            config = MergeConfig(config)

            local originalSize = target.Size
            target.Size = UDim2.new(originalSize.X.Scale * 0.95, originalSize.X.Offset * 0.95, originalSize.Y.Scale * 0.95, originalSize.Y.Offset * 0.95)
            target.BackgroundTransparency = 1
            target.Visible = true

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    Size = originalSize,
                    BackgroundTransparency = 0,
                }, config):Play()
            end
        end

        --// Flip Transitions
        Transition.Flip = {}

        function Transition.Flip.Horizontal(target, config)
            config = MergeConfig(config)

            -- Note: Roblox doesn't have true 3D transforms for UI
            -- This simulates a flip by scaling
            local originalSize = target.Size
            target.Visible = true

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    Size = UDim2.new(0, 0, originalSize.Y.Scale, originalSize.Y.Offset),
                }, {
                    Duration = config.Duration / 2,
                    Easing = "QuadIn",
                    OnComplete = function()
                        -- Flip content here if needed
                        TweenClass.new(target, {
                            Size = originalSize,
                        }, {
                            Duration = config.Duration / 2,
                            Easing = "QuadOut",
                        }):Play()
                    end,
                }):Play()
            end
        end

        function Transition.Flip.Vertical(target, config)
            config = MergeConfig(config)

            local originalSize = target.Size
            target.Visible = true

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    Size = UDim2.new(originalSize.X.Scale, originalSize.X.Offset, 0, 0),
                }, {
                    Duration = config.Duration / 2,
                    Easing = "QuadIn",
                    OnComplete = function()
                        TweenClass.new(target, {
                            Size = originalSize,
                        }, {
                            Duration = config.Duration / 2,
                            Easing = "QuadOut",
                        }):Play()
                    end,
                }):Play()
            end
        end

        --// Rotate Transitions
        Transition.Rotate = {}

        function Transition.Rotate.In(target, config)
            config = MergeConfig(config)

            target.Rotation = -90
            target.BackgroundTransparency = 1
            target.Visible = true

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    Rotation = 0,
                    BackgroundTransparency = 0,
                }, config):Play()
            end
        end

        function Transition.Rotate.Out(target, config)
            config = MergeConfig(config)

            local TweenClass = GetTween()
            if TweenClass then
                return TweenClass.new(target, {
                    Rotation = 90,
                    BackgroundTransparency = 1,
                }, {
                    Duration = config.Duration,
                    Easing = config.Easing,
                    Delay = config.Delay,
                    OnComplete = function()
                        target.Visible = false
                        target.Rotation = 0
                    end,
                }):Play()
            end
        end

        --// Transition Presets
        Transition.Presets = {
            Default = { Duration = 0.3, Easing = "QuadOut" },
            Fast = { Duration = 0.15, Easing = "QuadOut" },
            Slow = { Duration = 0.6, Easing = "QuadInOut" },
            Bouncy = { Duration = 0.5, Easing = "BackOut" },
            Elastic = { Duration = 0.7, Easing = "ElasticOut" },
            Smooth = { Duration = 0.4, Easing = "SineInOut" },
        }

        function Transition.GetPreset(name)
            return Transition.Presets[name] or Transition.Presets.Default
        end

        return Transition


    end


    -- ============================================================================
    -- Module: NexusUI/Animation/Controller
    -- ============================================================================
    NexusUI_Modules["NexusUI/Animation/Controller"] = function()
        local script = CreateMockScript("NexusUI/Animation/Controller")

        --[[
            NexusUI Animation Controller
            Central management for all animations

            Features:
            - Global animation management
            - Animation groups
            - Priority system
            - Performance monitoring
            - Batch operations
        ]]

        --// Services
        local RunService = game:GetService("RunService")

        --// Controller Module
        local Controller = {}
        Controller.__index = Controller
        Controller.ClassName = "AnimationController"

        --// Singleton Instance
        local Instance_Singleton = nil

        --// Animation Registry
        local AnimationRegistry = {}
        local AnimationGroups = {}
        local AnimationIdCounter = 0

        --// Performance Tracking
        local PerformanceStats = {
            ActiveAnimations = 0,
            TotalAnimationsPlayed = 0,
            FrameTime = 0,
            AverageFrameTime = 0,
            FrameCount = 0,
        }

        --// Generate ID
        local function GenerateAnimationId()
            AnimationIdCounter = AnimationIdCounter + 1
            return "anim_" .. AnimationIdCounter
        end

        --// Controller Singleton
        function Controller.Get()
            if not Instance_Singleton then
                Instance_Singleton = setmetatable({}, Controller)
                Instance_Singleton:_initialize()
            end
            return Instance_Singleton
        end

        function Controller:_initialize()
            self.IsEnabled = true
            self.GlobalTimeScale = 1
            self.MaxConcurrentAnimations = 100
            self.UpdateConnection = nil

            -- Start update loop
            self:_startUpdateLoop()
        end

        function Controller:_startUpdateLoop()
            if self.UpdateConnection then return end

            self.UpdateConnection = RunService.Heartbeat:Connect(function(deltaTime)
                local startTime = os.clock()

                -- Update all managed animations
                self:_update(deltaTime * self.GlobalTimeScale)

                -- Track performance
                local frameTime = os.clock() - startTime
                PerformanceStats.FrameTime = frameTime
                PerformanceStats.FrameCount = PerformanceStats.FrameCount + 1
                PerformanceStats.AverageFrameTime = (PerformanceStats.AverageFrameTime * (PerformanceStats.FrameCount - 1) + frameTime) / PerformanceStats.FrameCount
            end)
        end

        function Controller:_stopUpdateLoop()
            if self.UpdateConnection then
                self.UpdateConnection:Disconnect()
                self.UpdateConnection = nil
            end
        end

        function Controller:_update(deltaTime)
            if not self.IsEnabled then return end

            local activeCount = 0
            local toRemove = {}

            for id, animData in pairs(AnimationRegistry) do
                if animData.Animation and animData.IsActive then
                    activeCount = activeCount + 1

                    -- Check if animation has Update method
                    if animData.Animation.Update then
                        local success, err = pcall(function()
                            animData.Animation:Update(deltaTime)
                        end)

                        if not success then
                            warn("Animation update error:", err)
                            table.insert(toRemove, id)
                        end
                    end

                    -- Check if animation is complete
                    if animData.Animation.IsComplete and animData.Animation:IsComplete() then
                        animData.IsActive = false
                    end

                    if animData.Animation.State then
                        local state = animData.Animation:GetState()
                        if state == "Completed" or state == "Cancelled" then
                            animData.IsActive = false
                        end
                    end
                end
            end

            -- Clean up completed animations
            for _, id in ipairs(toRemove) do
                AnimationRegistry[id] = nil
            end

            PerformanceStats.ActiveAnimations = activeCount
        end

        --// Registration
        function Controller:Register(animation, options)
            options = options or {}

            local id = options.Id or GenerateAnimationId()

            AnimationRegistry[id] = {
                Id = id,
                Animation = animation,
                Group = options.Group,
                Priority = options.Priority or 0,
                IsActive = false,
                CreatedAt = os.clock(),
            }

            -- Add to group if specified
            if options.Group then
                if not AnimationGroups[options.Group] then
                    AnimationGroups[options.Group] = {}
                end
                table.insert(AnimationGroups[options.Group], id)
            end

            return id
        end

        function Controller:Unregister(id)
            local animData = AnimationRegistry[id]

            if animData then
                -- Remove from group
                if animData.Group and AnimationGroups[animData.Group] then
                    for i, animId in ipairs(AnimationGroups[animData.Group]) do
                        if animId == id then
                            table.remove(AnimationGroups[animData.Group], i)
                            break
                        end
                    end
                end

                -- Stop animation if active
                if animData.IsActive and animData.Animation then
                    if animData.Animation.Stop then
                        animData.Animation:Stop()
                    elseif animData.Animation.Cancel then
                        animData.Animation:Cancel()
                    end
                end

                AnimationRegistry[id] = nil
            end
        end

        --// Playback Control
        function Controller:Play(id)
            local animData = AnimationRegistry[id]

            if animData and animData.Animation then
                -- Check max concurrent
                if PerformanceStats.ActiveAnimations >= self.MaxConcurrentAnimations then
                    warn("Max concurrent animations reached")
                    return false
                end

                animData.IsActive = true
                PerformanceStats.TotalAnimationsPlayed = PerformanceStats.TotalAnimationsPlayed + 1

                if animData.Animation.Play then
                    animData.Animation:Play()
                elseif animData.Animation.Start then
                    animData.Animation:Start()
                end

                return true
            end

            return false
        end

        function Controller:Pause(id)
            local animData = AnimationRegistry[id]

            if animData and animData.Animation and animData.Animation.Pause then
                animData.Animation:Pause()
            end
        end

        function Controller:Resume(id)
            local animData = AnimationRegistry[id]

            if animData and animData.Animation and animData.Animation.Resume then
                animData.Animation:Resume()
            end
        end

        function Controller:Stop(id)
            local animData = AnimationRegistry[id]

            if animData then
                animData.IsActive = false

                if animData.Animation then
                    if animData.Animation.Stop then
                        animData.Animation:Stop()
                    elseif animData.Animation.Cancel then
                        animData.Animation:Cancel()
                    end
                end
            end
        end

        --// Group Operations
        function Controller:CreateGroup(groupName)
            if not AnimationGroups[groupName] then
                AnimationGroups[groupName] = {}
            end
            return groupName
        end

        function Controller:DeleteGroup(groupName, stopAnimations)
            if AnimationGroups[groupName] then
                if stopAnimations then
                    for _, id in ipairs(AnimationGroups[groupName]) do
                        self:Stop(id)
                    end
                end
                AnimationGroups[groupName] = nil
            end
        end

        function Controller:PlayGroup(groupName)
            if AnimationGroups[groupName] then
                for _, id in ipairs(AnimationGroups[groupName]) do
                    self:Play(id)
                end
            end
        end

        function Controller:PauseGroup(groupName)
            if AnimationGroups[groupName] then
                for _, id in ipairs(AnimationGroups[groupName]) do
                    self:Pause(id)
                end
            end
        end

        function Controller:ResumeGroup(groupName)
            if AnimationGroups[groupName] then
                for _, id in ipairs(AnimationGroups[groupName]) do
                    self:Resume(id)
                end
            end
        end

        function Controller:StopGroup(groupName)
            if AnimationGroups[groupName] then
                for _, id in ipairs(AnimationGroups[groupName]) do
                    self:Stop(id)
                end
            end
        end

        function Controller:GetGroupAnimations(groupName)
            local animations = {}
            if AnimationGroups[groupName] then
                for _, id in ipairs(AnimationGroups[groupName]) do
                    if AnimationRegistry[id] then
                        table.insert(animations, AnimationRegistry[id].Animation)
                    end
                end
            end
            return animations
        end

        --// Global Control
        function Controller:PauseAll()
            for id, animData in pairs(AnimationRegistry) do
                if animData.IsActive then
                    self:Pause(id)
                end
            end
        end

        function Controller:ResumeAll()
            for id, animData in pairs(AnimationRegistry) do
                if animData.Animation and animData.Animation.IsPaused and animData.Animation:IsPaused() then
                    self:Resume(id)
                end
            end
        end

        function Controller:StopAll()
            for id, _ in pairs(AnimationRegistry) do
                self:Stop(id)
            end
        end

        function Controller:ClearAll()
            self:StopAll()
            AnimationRegistry = {}
            AnimationGroups = {}
        end

        --// Configuration
        function Controller:SetTimeScale(scale)
            self.GlobalTimeScale = math.max(0, scale)
        end

        function Controller:GetTimeScale()
            return self.GlobalTimeScale
        end

        function Controller:SetEnabled(enabled)
            self.IsEnabled = enabled
        end

        function Controller:IsEnabled()
            return self.IsEnabled
        end

        function Controller:SetMaxConcurrent(max)
            self.MaxConcurrentAnimations = math.max(1, max)
        end

        --// Performance
        function Controller:GetStats()
            return {
                ActiveAnimations = PerformanceStats.ActiveAnimations,
                TotalPlayed = PerformanceStats.TotalAnimationsPlayed,
                FrameTime = PerformanceStats.FrameTime,
                AverageFrameTime = PerformanceStats.AverageFrameTime,
                RegisteredCount = self:GetRegisteredCount(),
                GroupCount = self:GetGroupCount(),
            }
        end

        function Controller:GetRegisteredCount()
            local count = 0
            for _ in pairs(AnimationRegistry) do
                count = count + 1
            end
            return count
        end

        function Controller:GetActiveCount()
            return PerformanceStats.ActiveAnimations
        end

        function Controller:GetGroupCount()
            local count = 0
            for _ in pairs(AnimationGroups) do
                count = count + 1
            end
            return count
        end

        function Controller:GetGroupNames()
            local names = {}
            for name, _ in pairs(AnimationGroups) do
                table.insert(names, name)
            end
            return names
        end

        --// Cleanup
        function Controller:Destroy()
            self:ClearAll()
            self:_stopUpdateLoop()
            Instance_Singleton = nil
        end

        return Controller


    end


    -- ============================================================================
    -- Module: NexusUI/Animation/Effects
    -- ============================================================================
    NexusUI_Modules["NexusUI/Animation/Effects"] = function()
        local script = CreateMockScript("NexusUI/Animation/Effects")

        --[[
            NexusUI Animation Effects
            Visual effect animations for UI elements

            Effects:
            - Pulse, Shake, Bounce
            - Glow, Ripple, Wave
            - Blur, Focus, Highlight
            - Loading indicators
        ]]

        --// Effects Module
        local Effects = {}
        Effects.ClassName = "AnimationEffects"

        --// Dependencies
        local Tween = nil
        local Keyframes = nil

        local function GetTween()
            if not Tween then
                local tweenModule = script.Parent:FindFirstChild("Tween")
                if tweenModule then
                    Tween = require(tweenModule)
                end
            end
            return Tween
        end

        local function GetKeyframes()
            if not Keyframes then
                local keyframesModule = script.Parent:FindFirstChild("Keyframes")
                if keyframesModule then
                    Keyframes = require(keyframesModule)
                end
            end
            return Keyframes
        end

        --// Active Effects
        local ActiveEffects = {}
        local EffectIdCounter = 0

        local function GenerateEffectId()
            EffectIdCounter = EffectIdCounter + 1
            return "effect_" .. EffectIdCounter
        end

        --// Pulse Effect
        function Effects.Pulse(target, config)
            config = config or {}
            local scale = config.Scale or 1.1
            local duration = config.Duration or 0.5
            local iterations = config.Iterations or -1 -- -1 = infinite

            local originalSize = target.Size
            local scaledSize = UDim2.new(
                originalSize.X.Scale * scale,
                originalSize.X.Offset * scale,
                originalSize.Y.Scale * scale,
                originalSize.Y.Offset * scale
            )

            local KeyframesClass = GetKeyframes()
            if KeyframesClass then
                local keyframeDef = KeyframesClass.Define()
                    :At(0, { Size = originalSize })
                    :At(50, { Size = scaledSize }, "SineInOut")
                    :At(100, { Size = originalSize }, "SineInOut")

                local animation = KeyframesClass.new(target, keyframeDef, {
                    Duration = duration,
                    IterationCount = iterations,
                })

                local effectId = GenerateEffectId()
                ActiveEffects[effectId] = animation
                animation:Play()

                return {
                    Id = effectId,
                    Stop = function()
                        animation:Stop()
                        target.Size = originalSize
                        ActiveEffects[effectId] = nil
                    end,
                }
            end
        end

        --// Shake Effect
        function Effects.Shake(target, config)
            config = config or {}
            local intensity = config.Intensity or 5
            local duration = config.Duration or 0.5
            local decay = config.Decay ~= false

            local originalPosition = target.Position
            local effectId = GenerateEffectId()
            local running = true

            ActiveEffects[effectId] = { Running = true }

            task.spawn(function()
                local startTime = os.clock()

                while running and (os.clock() - startTime) < duration do
                    local progress = (os.clock() - startTime) / duration
                    local currentIntensity = decay and (intensity * (1 - progress)) or intensity

                    local offsetX = (math.random() - 0.5) * 2 * currentIntensity
                    local offsetY = (math.random() - 0.5) * 2 * currentIntensity

                    target.Position = UDim2.new(
                        originalPosition.X.Scale,
                        originalPosition.X.Offset + offsetX,
                        originalPosition.Y.Scale,
                        originalPosition.Y.Offset + offsetY
                    )

                    task.wait()
                end

                target.Position = originalPosition
                ActiveEffects[effectId] = nil
            end)

            return {
                Id = effectId,
                Stop = function()
                    running = false
                    target.Position = originalPosition
                    ActiveEffects[effectId] = nil
                end,
            }
        end

        --// Bounce Effect
        function Effects.Bounce(target, config)
            config = config or {}
            local height = config.Height or 20
            local duration = config.Duration or 0.6
            local iterations = config.Iterations or 3

            local originalPosition = target.Position
            local TweenClass = GetTween()

            if TweenClass then
                local effectId = GenerateEffectId()
                local currentIteration = 0

                local function doBounce()
                    if currentIteration >= iterations then
                        target.Position = originalPosition
                        ActiveEffects[effectId] = nil
                        return
                    end

                    currentIteration = currentIteration + 1
                    local currentHeight = height * (1 - (currentIteration - 1) / iterations)

                    TweenClass.new(target, {
                        Position = UDim2.new(
                            originalPosition.X.Scale,
                            originalPosition.X.Offset,
                            originalPosition.Y.Scale,
                            originalPosition.Y.Offset - currentHeight
                        ),
                    }, {
                        Duration = duration / (iterations * 2),
                        Easing = "QuadOut",
                    }):Play():Then(function()
                        TweenClass.new(target, {
                            Position = originalPosition,
                        }, {
                            Duration = duration / (iterations * 2),
                            Easing = "BounceOut",
                        }):Play():Then(doBounce)
                    end)
                end

                ActiveEffects[effectId] = { Running = true }
                doBounce()

                return {
                    Id = effectId,
                    Stop = function()
                        target.Position = originalPosition
                        ActiveEffects[effectId] = nil
                    end,
                }
            end
        end

        --// Glow Effect (using BackgroundColor3)
        function Effects.Glow(target, config)
            config = config or {}
            local color = config.Color or Color3.fromRGB(255, 255, 100)
            local duration = config.Duration or 0.8
            local iterations = config.Iterations or -1

            local originalColor = target.BackgroundColor3

            local KeyframesClass = GetKeyframes()
            if KeyframesClass then
                local keyframeDef = KeyframesClass.Define()
                    :At(0, { BackgroundColor3 = originalColor })
                    :At(50, { BackgroundColor3 = color }, "SineInOut")
                    :At(100, { BackgroundColor3 = originalColor }, "SineInOut")

                local animation = KeyframesClass.new(target, keyframeDef, {
                    Duration = duration,
                    IterationCount = iterations,
                })

                local effectId = GenerateEffectId()
                ActiveEffects[effectId] = animation
                animation:Play()

                return {
                    Id = effectId,
                    Stop = function()
                        animation:Stop()
                        target.BackgroundColor3 = originalColor
                        ActiveEffects[effectId] = nil
                    end,
                }
            end
        end

        --// Ripple Effect (visual only, creates expanding circle)
        function Effects.Ripple(target, config)
            config = config or {}
            local color = config.Color or Color3.fromRGB(255, 255, 255)
            local duration = config.Duration or 0.6
            local origin = config.Origin or UDim2.new(0.5, 0, 0.5, 0)

            local effectId = GenerateEffectId()

            -- Create ripple element
            local ripple = Instance.new("Frame")
            ripple.Name = "Ripple"
            ripple.AnchorPoint = Vector2.new(0.5, 0.5)
            ripple.Position = origin
            ripple.Size = UDim2.new(0, 0, 0, 0)
            ripple.BackgroundColor3 = color
            ripple.BackgroundTransparency = 0.7
            ripple.BorderSizePixel = 0
            ripple.ZIndex = target.ZIndex + 1

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(1, 0)
            corner.Parent = ripple

            ripple.Parent = target

            local TweenClass = GetTween()
            if TweenClass then
                -- Get target size for ripple
                local maxSize = math.max(target.AbsoluteSize.X, target.AbsoluteSize.Y) * 2

                TweenClass.new(ripple, {
                    Size = UDim2.new(0, maxSize, 0, maxSize),
                    BackgroundTransparency = 1,
                }, {
                    Duration = duration,
                    Easing = "QuadOut",
                    OnComplete = function()
                        ripple:Destroy()
                        ActiveEffects[effectId] = nil
                    end,
                }):Play()

                ActiveEffects[effectId] = { Ripple = ripple }

                return {
                    Id = effectId,
                    Stop = function()
                        ripple:Destroy()
                        ActiveEffects[effectId] = nil
                    end,
                }
            end
        end

        --// Wave Effect (for lists/grids)
        function Effects.Wave(targets, config)
            config = config or {}
            local amplitude = config.Amplitude or 10
            local frequency = config.Frequency or 2
            local duration = config.Duration or 2
            local delay = config.Delay or 0.05

            local effectId = GenerateEffectId()
            local running = true
            local originalPositions = {}

            -- Store original positions
            for i, target in ipairs(targets) do
                originalPositions[i] = target.Position
            end

            ActiveEffects[effectId] = { Running = true }

            task.spawn(function()
                local startTime = os.clock()

                while running and (os.clock() - startTime) < duration do
                    local time = os.clock() - startTime

                    for i, target in ipairs(targets) do
                        local offset = math.sin((time * frequency * math.pi * 2) + (i * delay * 10)) * amplitude

                        target.Position = UDim2.new(
                            originalPositions[i].X.Scale,
                            originalPositions[i].X.Offset,
                            originalPositions[i].Y.Scale,
                            originalPositions[i].Y.Offset + offset
                        )
                    end

                    task.wait()
                end

                -- Restore positions
                for i, target in ipairs(targets) do
                    target.Position = originalPositions[i]
                end

                ActiveEffects[effectId] = nil
            end)

            return {
                Id = effectId,
                Stop = function()
                    running = false
                    for i, target in ipairs(targets) do
                        target.Position = originalPositions[i]
                    end
                    ActiveEffects[effectId] = nil
                end,
            }
        end

        --// Highlight Effect
        function Effects.Highlight(target, config)
            config = config or {}
            local color = config.Color or Color3.fromRGB(255, 255, 0)
            local duration = config.Duration or 1
            local thickness = config.Thickness or 2

            local effectId = GenerateEffectId()

            -- Create highlight border
            local highlight = Instance.new("Frame")
            highlight.Name = "Highlight"
            highlight.AnchorPoint = Vector2.new(0.5, 0.5)
            highlight.Position = UDim2.new(0.5, 0, 0.5, 0)
            highlight.Size = UDim2.new(1, thickness * 2, 1, thickness * 2)
            highlight.BackgroundTransparency = 1
            highlight.BorderSizePixel = 0
            highlight.ZIndex = target.ZIndex - 1

            local stroke = Instance.new("UIStroke")
            stroke.Color = color
            stroke.Thickness = thickness
            stroke.Transparency = 0
            stroke.Parent = highlight

            -- Match corner radius if target has one
            local targetCorner = target:FindFirstChildOfClass("UICorner")
            if targetCorner then
                local corner = Instance.new("UICorner")
                corner.CornerRadius = targetCorner.CornerRadius
                corner.Parent = highlight
            end

            highlight.Parent = target

            local TweenClass = GetTween()
            if TweenClass then
                -- Pulse the highlight
                local function pulseHighlight()
                    if not ActiveEffects[effectId] then return end

                    TweenClass.new(stroke, {
                        Transparency = 0.5,
                    }, {
                        Duration = duration / 2,
                        Easing = "SineInOut",
                    }):Play():Then(function()
                        if not ActiveEffects[effectId] then return end

                        TweenClass.new(stroke, {
                            Transparency = 0,
                        }, {
                            Duration = duration / 2,
                            Easing = "SineInOut",
                        }):Play():Then(pulseHighlight)
                    end)
                end

                ActiveEffects[effectId] = { Highlight = highlight }
                pulseHighlight()

                return {
                    Id = effectId,
                    Stop = function()
                        ActiveEffects[effectId] = nil
                        highlight:Destroy()
                    end,
                }
            end
        end

        --// Spin Effect
        function Effects.Spin(target, config)
            config = config or {}
            local speed = config.Speed or 360 -- degrees per second
            local duration = config.Duration or -1 -- -1 = infinite
            local direction = config.Direction or 1 -- 1 = clockwise, -1 = counter-clockwise

            local effectId = GenerateEffectId()
            local running = true
            local startRotation = target.Rotation

            ActiveEffects[effectId] = { Running = true }

            task.spawn(function()
                local startTime = os.clock()

                while running do
                    local elapsed = os.clock() - startTime

                    if duration > 0 and elapsed >= duration then
                        break
                    end

                    target.Rotation = startRotation + (elapsed * speed * direction)
                    task.wait()
                end

                target.Rotation = startRotation
                ActiveEffects[effectId] = nil
            end)

            return {
                Id = effectId,
                Stop = function()
                    running = false
                    target.Rotation = startRotation
                    ActiveEffects[effectId] = nil
                end,
            }
        end

        --// Typing Effect (for text)
        function Effects.Typing(target, config)
            config = config or {}
            local text = config.Text or target.Text
            local speed = config.Speed or 0.05 -- seconds per character
            local cursor = config.Cursor or "|"
            local showCursor = config.ShowCursor ~= false

            local effectId = GenerateEffectId()
            local running = true

            ActiveEffects[effectId] = { Running = true }

            target.Text = ""

            task.spawn(function()
                for i = 1, #text do
                    if not running then break end

                    local partial = string.sub(text, 1, i)
                    target.Text = partial .. (showCursor and cursor or "")
                    task.wait(speed)
                end

                target.Text = text
                ActiveEffects[effectId] = nil
            end)

            return {
                Id = effectId,
                Stop = function()
                    running = false
                    target.Text = text
                    ActiveEffects[effectId] = nil
                end,
            }
        end

        --// Count Effect (for numbers)
        function Effects.Count(target, config)
            config = config or {}
            local startValue = config.From or 0
            local endValue = config.To or 100
            local duration = config.Duration or 1
            local format = config.Format or "%d"
            local easing = config.Easing or "QuadOut"

            local effectId = GenerateEffectId()
            local running = true

            local EasingFunctions = nil
            local easingModule = script.Parent:FindFirstChild("EasingFunctions")
            if easingModule then
                EasingFunctions = require(easingModule)
            end

            local easingFunc = EasingFunctions and EasingFunctions[easing] or function(t) return t end

            ActiveEffects[effectId] = { Running = true }

            task.spawn(function()
                local startTime = os.clock()

                while running and (os.clock() - startTime) < duration do
                    local progress = (os.clock() - startTime) / duration
                    local easedProgress = easingFunc(progress)
                    local currentValue = startValue + (endValue - startValue) * easedProgress

                    target.Text = string.format(format, currentValue)
                    task.wait()
                end

                target.Text = string.format(format, endValue)
                ActiveEffects[effectId] = nil
            end)

            return {
                Id = effectId,
                Stop = function()
                    running = false
                    target.Text = string.format(format, endValue)
                    ActiveEffects[effectId] = nil
                end,
            }
        end

        --// Loading Spinner Effect
        function Effects.LoadingSpinner(parent, config)
            config = config or {}
            local size = config.Size or 50
            local color = config.Color or Color3.fromRGB(255, 255, 255)
            local thickness = config.Thickness or 4
            local speed = config.Speed or 1

            local effectId = GenerateEffectId()

            -- Create spinner container
            local spinner = Instance.new("Frame")
            spinner.Name = "LoadingSpinner"
            spinner.AnchorPoint = Vector2.new(0.5, 0.5)
            spinner.Position = config.Position or UDim2.new(0.5, 0, 0.5, 0)
            spinner.Size = UDim2.new(0, size, 0, size)
            spinner.BackgroundTransparency = 1
            spinner.Parent = parent

            -- Create spinner arc (using ImageLabel)
            local arc = Instance.new("ImageLabel")
            arc.Name = "Arc"
            arc.AnchorPoint = Vector2.new(0.5, 0.5)
            arc.Position = UDim2.new(0.5, 0, 0.5, 0)
            arc.Size = UDim2.new(1, 0, 1, 0)
            arc.BackgroundTransparency = 1
            arc.ImageColor3 = color
            arc.Image = "rbxassetid://6031094667" -- Circular progress image
            arc.ImageRectSize = Vector2.new(100, 100)
            arc.Parent = spinner

            local running = true

            task.spawn(function()
                while running do
                    spinner.Rotation = spinner.Rotation + (360 * speed * task.wait())
                end
            end)

            ActiveEffects[effectId] = { Spinner = spinner, Running = true }

            return {
                Id = effectId,
                Instance = spinner,
                Stop = function()
                    running = false
                    spinner:Destroy()
                    ActiveEffects[effectId] = nil
                end,
            }
        end

        --// Management
        function Effects.StopEffect(effectId)
            local effect = ActiveEffects[effectId]
            if effect and effect.Stop then
                effect:Stop()
            end
            ActiveEffects[effectId] = nil
        end

        function Effects.StopAll()
            for id, effect in pairs(ActiveEffects) do
                if type(effect) == "table" then
                    if effect.Stop then
                        pcall(effect.Stop)
                    elseif effect.Cancel then
                        pcall(effect.Cancel, effect)
                    end
                end
            end
            ActiveEffects = {}
        end

        function Effects.GetActiveCount()
            local count = 0
            for _ in pairs(ActiveEffects) do
                count = count + 1
            end
            return count
        end

        return Effects


    end


    -- ============================================================================
    -- Module: NexusUI/Animation/Stagger
    -- ============================================================================
    NexusUI_Modules["NexusUI/Animation/Stagger"] = function()
        local script = CreateMockScript("NexusUI/Animation/Stagger")

        --[[
            NexusUI Stagger Animation
            Staggered/cascading animations for lists and grids

            Features:
            - Customizable stagger delay
            - Different stagger patterns
            - Grid-aware staggering
            - Reverse stagger
        ]]

        --// Stagger Module
        local Stagger = {}
        Stagger.ClassName = "StaggerAnimation"

        --// Stagger Patterns
        Stagger.Pattern = {
            Sequential = "Sequential",     -- One after another
            Reverse = "Reverse",           -- Last to first
            Center = "Center",             -- From center outward
            Edges = "Edges",               -- From edges to center
            Random = "Random",             -- Random order
            Grid = "Grid",                 -- Grid-aware (diagonal)
            GridReverse = "GridReverse",   -- Grid reverse diagonal
        }

        --// Dependencies
        local Tween = nil
        local Transition = nil

        local function GetTween()
            if not Tween then
                local tweenModule = script.Parent:FindFirstChild("Tween")
                if tweenModule then
                    Tween = require(tweenModule)
                end
            end
            return Tween
        end

        local function GetTransition()
            if not Transition then
                local transitionModule = script.Parent:FindFirstChild("Transition")
                if transitionModule then
                    Transition = require(transitionModule)
                end
            end
            return Transition
        end

        --// Stagger State
        local StaggerState = {
            Pending = "Pending",
            Playing = "Playing",
            Completed = "Completed",
            Cancelled = "Cancelled",
        }

        --// ID Counter
        local StaggerIdCounter = 0

        local function GenerateStaggerId()
            StaggerIdCounter = StaggerIdCounter + 1
            return "stagger_" .. StaggerIdCounter
        end

        --// Calculate stagger order
        local function CalculateOrder(targets, pattern, gridColumns)
            local order = {}
            local count = #targets

            if pattern == Stagger.Pattern.Sequential then
                for i = 1, count do
                    order[i] = i
                end
            elseif pattern == Stagger.Pattern.Reverse then
                for i = 1, count do
                    order[i] = count - i + 1
                end
            elseif pattern == Stagger.Pattern.Center then
                local mid = math.ceil(count / 2)
                local left, right = mid, mid + 1
                local index = 1

                while left >= 1 or right <= count do
                    if left >= 1 then
                        order[left] = index
                        index = index + 1
                        left = left - 1
                    end
                    if right <= count then
                        order[right] = index
                        index = index + 1
                        right = right + 1
                    end
                end
            elseif pattern == Stagger.Pattern.Edges then
                local left, right = 1, count
                local index = 1

                while left <= right do
                    order[left] = index
                    index = index + 1
                    if left ~= right then
                        order[right] = index
                        index = index + 1
                    end
                    left = left + 1
                    right = right - 1
                end
            elseif pattern == Stagger.Pattern.Random then
                local indices = {}
                for i = 1, count do
                    indices[i] = i
                end

                -- Fisher-Yates shuffle
                for i = count, 2, -1 do
                    local j = math.random(i)
                    indices[i], indices[j] = indices[j], indices[i]
                end

                for i = 1, count do
                    order[indices[i]] = i
                end
            elseif pattern == Stagger.Pattern.Grid or pattern == Stagger.Pattern.GridReverse then
                gridColumns = gridColumns or 3
                local gridRows = math.ceil(count / gridColumns)

                -- Calculate diagonal order
                local maxDiagonal = gridRows + gridColumns - 1
                local index = 1

                for d = 0, maxDiagonal - 1 do
                    for row = 0, gridRows - 1 do
                        local col = d - row
                        if col >= 0 and col < gridColumns then
                            local itemIndex = row * gridColumns + col + 1
                            if itemIndex <= count then
                                if pattern == Stagger.Pattern.GridReverse then
                                    order[itemIndex] = count - index + 1
                                else
                                    order[itemIndex] = index
                                end
                                index = index + 1
                            end
                        end
                    end
                end
            end

            return order
        end

        --// Stagger Class
        local StaggerAnimation = {}
        StaggerAnimation.__index = StaggerAnimation

        function StaggerAnimation.new(targets, config)
            local self = setmetatable({}, StaggerAnimation)

            self.Id = GenerateStaggerId()
            self.Targets = targets
            self.Pattern = config and config.Pattern or Stagger.Pattern.Sequential
            self.Delay = config and config.Delay or 0.05
            self.Duration = config and config.Duration or 0.3
            self.Easing = config and config.Easing or "QuadOut"
            self.GridColumns = config and config.GridColumns
            self.AnimationType = config and config.AnimationType or "FadeIn"
            self.Properties = config and config.Properties

            -- State
            self.State = StaggerState.Pending
            self.CompletedCount = 0
            self.Animations = {}

            -- Callbacks
            self.OnStart = config and config.OnStart
            self.OnItemStart = config and config.OnItemStart
            self.OnItemComplete = config and config.OnItemComplete
            self.OnComplete = config and config.OnComplete

            return self
        end

        function StaggerAnimation:Play()
            if self.State == StaggerState.Playing then
                return self
            end

            self.State = StaggerState.Playing
            self.CompletedCount = 0

            if self.OnStart then
                pcall(self.OnStart, self)
            end

            local order = CalculateOrder(self.Targets, self.Pattern, self.GridColumns)
            local TweenClass = GetTween()
            local TransitionClass = GetTransition()

            for i, target in ipairs(self.Targets) do
                local itemOrder = order[i] or i
                local itemDelay = (itemOrder - 1) * self.Delay

                task.delay(itemDelay, function()
                    if self.State ~= StaggerState.Playing then
                        return
                    end

                    if self.OnItemStart then
                        pcall(self.OnItemStart, target, i, self)
                    end

                    local animation

                    if self.Properties then
                        -- Custom property animation
                        if TweenClass then
                            animation = TweenClass.new(target, self.Properties, {
                                Duration = self.Duration,
                                Easing = self.Easing,
                                OnComplete = function()
                                    self:_onItemComplete(target, i)
                                end,
                            }):Play()
                        end
                    elseif TransitionClass then
                        -- Use transition
                        local transitionFunc = nil

                        if self.AnimationType == "FadeIn" then
                            transitionFunc = TransitionClass.Fade.In
                        elseif self.AnimationType == "FadeOut" then
                            transitionFunc = TransitionClass.Fade.Out
                        elseif self.AnimationType == "SlideFromLeft" then
                            transitionFunc = TransitionClass.Slide.FromLeft
                        elseif self.AnimationType == "SlideFromRight" then
                            transitionFunc = TransitionClass.Slide.FromRight
                        elseif self.AnimationType == "SlideFromTop" then
                            transitionFunc = TransitionClass.Slide.FromTop
                        elseif self.AnimationType == "SlideFromBottom" then
                            transitionFunc = TransitionClass.Slide.FromBottom
                        elseif self.AnimationType == "ScaleIn" then
                            transitionFunc = TransitionClass.Scale.In
                        elseif self.AnimationType == "ScaleOut" then
                            transitionFunc = TransitionClass.Scale.Out
                        end

                        if transitionFunc then
                            animation = transitionFunc(target, {
                                Duration = self.Duration,
                                Easing = self.Easing,
                            })

                            if animation and animation.Then then
                                animation:Then(function()
                                    self:_onItemComplete(target, i)
                                end)
                            else
                                -- Fallback: wait for duration
                                task.delay(self.Duration, function()
                                    self:_onItemComplete(target, i)
                                end)
                            end
                        end
                    end

                    if animation then
                        self.Animations[i] = animation
                    end
                end)
            end

            return self
        end

        function StaggerAnimation:_onItemComplete(target, index)
            self.CompletedCount = self.CompletedCount + 1

            if self.OnItemComplete then
                pcall(self.OnItemComplete, target, index, self)
            end

            if self.CompletedCount >= #self.Targets then
                self.State = StaggerState.Completed

                if self.OnComplete then
                    pcall(self.OnComplete, self)
                end
            end
        end

        function StaggerAnimation:Stop()
            self.State = StaggerState.Cancelled

            for _, animation in pairs(self.Animations) do
                if animation and animation.Stop then
                    animation:Stop()
                elseif animation and animation.Cancel then
                    animation:Cancel()
                end
            end

            return self
        end

        function StaggerAnimation:Cancel()
            return self:Stop()
        end

        function StaggerAnimation:Then(callback)
            local originalOnComplete = self.OnComplete

            self.OnComplete = function(stagger)
                if originalOnComplete then
                    originalOnComplete(stagger)
                end
                callback(stagger)
            end

            return self
        end

        function StaggerAnimation:GetState()
            return self.State
        end

        function StaggerAnimation:GetProgress()
            if #self.Targets == 0 then return 1 end
            return self.CompletedCount / #self.Targets
        end

        function StaggerAnimation:Await()
            while self.State == StaggerState.Playing do
                task.wait()
            end
            return self
        end

        --// Static Methods
        function Stagger.Create(targets, config)
            return StaggerAnimation.new(targets, config)
        end

        function Stagger.Play(targets, delay, animationType, config)
            config = config or {}
            config.Delay = delay or config.Delay
            config.AnimationType = animationType or config.AnimationType

            return StaggerAnimation.new(targets, config):Play()
        end

        function Stagger.FadeIn(targets, delay, duration)
            return Stagger.Play(targets, delay, "FadeIn", {
                Duration = duration,
            })
        end

        function Stagger.FadeOut(targets, delay, duration)
            return Stagger.Play(targets, delay, "FadeOut", {
                Duration = duration,
            })
        end

        function Stagger.SlideIn(targets, direction, delay, duration)
            return Stagger.Play(targets, delay, "SlideFrom" .. (direction or "Left"), {
                Duration = duration,
            })
        end

        function Stagger.ScaleIn(targets, delay, duration)
            return Stagger.Play(targets, delay, "ScaleIn", {
                Duration = duration,
            })
        end

        function Stagger.Custom(targets, properties, delay, duration, easing)
            return StaggerAnimation.new(targets, {
                Properties = properties,
                Delay = delay or 0.05,
                Duration = duration or 0.3,
                Easing = easing or "QuadOut",
            }):Play()
        end

        --// Grid Stagger
        function Stagger.GridFadeIn(targets, columns, delay, duration)
            return StaggerAnimation.new(targets, {
                Pattern = Stagger.Pattern.Grid,
                GridColumns = columns,
                AnimationType = "FadeIn",
                Delay = delay or 0.03,
                Duration = duration or 0.3,
            }):Play()
        end

        function Stagger.GridScaleIn(targets, columns, delay, duration)
            return StaggerAnimation.new(targets, {
                Pattern = Stagger.Pattern.Grid,
                GridColumns = columns,
                AnimationType = "ScaleIn",
                Delay = delay or 0.03,
                Duration = duration or 0.3,
            }):Play()
        end

        --// Export
        Stagger.State = StaggerState

        return Stagger


    end


    -- ============================================================================
    -- Module: NexusUI/Animation/Interpolate
    -- ============================================================================
    NexusUI_Modules["NexusUI/Animation/Interpolate"] = function()
        local script = CreateMockScript("NexusUI/Animation/Interpolate")

        --[[
            NexusUI Interpolation Utilities
            Value interpolation for animations

            Features:
            - Linear interpolation (Lerp)
            - Smooth interpolation
            - Multi-type support
            - Path interpolation
        ]]

        --// Interpolate Module
        local Interpolate = {}
        Interpolate.ClassName = "Interpolate"

        --// Basic Lerp
        function Interpolate.Lerp(a, b, t)
            local valueType = typeof(a)

            if valueType == "number" then
                return a + (b - a) * t
            elseif valueType == "Color3" then
                return Color3.new(
                    a.R + (b.R - a.R) * t,
                    a.G + (b.G - a.G) * t,
                    a.B + (b.B - a.B) * t
                )
            elseif valueType == "Vector2" then
                return Vector2.new(
                    a.X + (b.X - a.X) * t,
                    a.Y + (b.Y - a.Y) * t
                )
            elseif valueType == "Vector3" then
                return Vector3.new(
                    a.X + (b.X - a.X) * t,
                    a.Y + (b.Y - a.Y) * t,
                    a.Z + (b.Z - a.Z) * t
                )
            elseif valueType == "UDim" then
                return UDim.new(
                    a.Scale + (b.Scale - a.Scale) * t,
                    a.Offset + (b.Offset - a.Offset) * t
                )
            elseif valueType == "UDim2" then
                return UDim2.new(
                    a.X.Scale + (b.X.Scale - a.X.Scale) * t,
                    a.X.Offset + (b.X.Offset - a.X.Offset) * t,
                    a.Y.Scale + (b.Y.Scale - a.Y.Scale) * t,
                    a.Y.Offset + (b.Y.Offset - a.Y.Offset) * t
                )
            elseif valueType == "CFrame" then
                return a:Lerp(b, t)
            elseif valueType == "Rect" then
                return Rect.new(
                    Interpolate.Lerp(a.Min, b.Min, t),
                    Interpolate.Lerp(a.Max, b.Max, t)
                )
            elseif valueType == "NumberRange" then
                return NumberRange.new(
                    Interpolate.Lerp(a.Min, b.Min, t),
                    Interpolate.Lerp(a.Max, b.Max, t)
                )
            end

            -- For non-interpolatable types, return b when t >= 0.5
            return t >= 0.5 and b or a
        end

        --// Number Interpolation
        function Interpolate.Number(a, b, t)
            return a + (b - a) * t
        end

        --// Inverse Lerp
        function Interpolate.InverseLerp(a, b, value)
            if a == b then return 0 end
            return (value - a) / (b - a)
        end

        --// Remap value from one range to another
        function Interpolate.Remap(value, inMin, inMax, outMin, outMax)
            local t = Interpolate.InverseLerp(inMin, inMax, value)
            return Interpolate.Lerp(outMin, outMax, t)
        end

        --// Clamp
        function Interpolate.Clamp(value, min, max)
            return math.max(min, math.min(max, value))
        end

        --// Clamped Lerp
        function Interpolate.ClampedLerp(a, b, t)
            return Interpolate.Lerp(a, b, Interpolate.Clamp(t, 0, 1))
        end

        --// Smooth Step (Hermite interpolation)
        function Interpolate.SmoothStep(a, b, t)
            t = Interpolate.Clamp(t, 0, 1)
            t = t * t * (3 - 2 * t)
            return Interpolate.Lerp(a, b, t)
        end

        --// Smoother Step
        function Interpolate.SmootherStep(a, b, t)
            t = Interpolate.Clamp(t, 0, 1)
            t = t * t * t * (t * (t * 6 - 15) + 10)
            return Interpolate.Lerp(a, b, t)
        end

        --// Color Interpolation (HSV)
        function Interpolate.ColorHSV(a, b, t)
            local aH, aS, aV = Color3.toHSV(a)
            local bH, bS, bV = Color3.toHSV(b)

            -- Handle hue wrapping
            local hDiff = bH - aH
            if math.abs(hDiff) > 0.5 then
                if hDiff > 0 then
                    aH = aH + 1
                else
                    bH = bH + 1
                end
            end

            local h = Interpolate.Number(aH, bH, t) % 1
            local s = Interpolate.Number(aS, bS, t)
            local v = Interpolate.Number(aV, bV, t)

            return Color3.fromHSV(h, s, v)
        end

        --// Color Interpolation (RGB)
        function Interpolate.ColorRGB(a, b, t)
            return Color3.new(
                Interpolate.Number(a.R, b.R, t),
                Interpolate.Number(a.G, b.G, t),
                Interpolate.Number(a.B, b.B, t)
            )
        end

        --// Angle Interpolation (handles wrapping)
        function Interpolate.Angle(a, b, t)
            local diff = (b - a + 180) % 360 - 180
            return a + diff * t
        end

        --// Bezier Interpolation
        function Interpolate.Bezier(points, t)
            local n = #points

            if n == 0 then return nil end
            if n == 1 then return points[1] end

            -- De Casteljau's algorithm
            local temp = {}
            for i, p in ipairs(points) do
                temp[i] = p
            end

            for i = 1, n - 1 do
                for j = 1, n - i do
                    temp[j] = Interpolate.Lerp(temp[j], temp[j + 1], t)
                end
            end

            return temp[1]
        end

        --// Catmull-Rom Spline
        function Interpolate.CatmullRom(p0, p1, p2, p3, t)
            local t2 = t * t
            local t3 = t2 * t

            local function calc(v0, v1, v2, v3)
                return 0.5 * (
                    (2 * v1) +
                    (-v0 + v2) * t +
                    (2 * v0 - 5 * v1 + 4 * v2 - v3) * t2 +
                    (-v0 + 3 * v1 - 3 * v2 + v3) * t3
                )
            end

            local valueType = typeof(p0)

            if valueType == "number" then
                return calc(p0, p1, p2, p3)
            elseif valueType == "Vector2" then
                return Vector2.new(
                    calc(p0.X, p1.X, p2.X, p3.X),
                    calc(p0.Y, p1.Y, p2.Y, p3.Y)
                )
            elseif valueType == "Vector3" then
                return Vector3.new(
                    calc(p0.X, p1.X, p2.X, p3.X),
                    calc(p0.Y, p1.Y, p2.Y, p3.Y),
                    calc(p0.Z, p1.Z, p2.Z, p3.Z)
                )
            elseif valueType == "UDim2" then
                return UDim2.new(
                    calc(p0.X.Scale, p1.X.Scale, p2.X.Scale, p3.X.Scale),
                    calc(p0.X.Offset, p1.X.Offset, p2.X.Offset, p3.X.Offset),
                    calc(p0.Y.Scale, p1.Y.Scale, p2.Y.Scale, p3.Y.Scale),
                    calc(p0.Y.Offset, p1.Y.Offset, p2.Y.Offset, p3.Y.Offset)
                )
            end

            return Interpolate.Lerp(p1, p2, t)
        end

        --// Path Interpolation
        local Path = {}
        Path.__index = Path

        function Path.new(points)
            local self = setmetatable({}, Path)

            self.Points = points or {}
            self.Closed = false

            return self
        end

        function Path:AddPoint(point)
            table.insert(self.Points, point)
            return self
        end

        function Path:SetClosed(closed)
            self.Closed = closed
            return self
        end

        function Path:GetPointAt(t)
            local count = #self.Points

            if count == 0 then return nil end
            if count == 1 then return self.Points[1] end

            if self.Closed then
                t = t % 1
            else
                t = Interpolate.Clamp(t, 0, 1)
            end

            local segmentCount = self.Closed and count or (count - 1)
            local segment = math.floor(t * segmentCount)
            local localT = (t * segmentCount) - segment

            if segment >= segmentCount then
                segment = segmentCount - 1
                localT = 1
            end

            local p1 = self.Points[segment + 1]
            local p2 = self.Points[((segment + 1) % count) + 1]

            return Interpolate.Lerp(p1, p2, localT)
        end

        function Path:GetSmoothPointAt(t)
            local count = #self.Points

            if count < 4 then
                return self:GetPointAt(t)
            end

            if self.Closed then
                t = t % 1
            else
                t = Interpolate.Clamp(t, 0, 1)
            end

            local segmentCount = self.Closed and count or (count - 1)
            local segment = math.floor(t * segmentCount)
            local localT = (t * segmentCount) - segment

            if segment >= segmentCount then
                segment = segmentCount - 1
                localT = 1
            end

            local function getPoint(i)
                if self.Closed then
                    return self.Points[((i - 1) % count) + 1]
                else
                    return self.Points[Interpolate.Clamp(i, 1, count)]
                end
            end

            local p0 = getPoint(segment)
            local p1 = getPoint(segment + 1)
            local p2 = getPoint(segment + 2)
            local p3 = getPoint(segment + 3)

            return Interpolate.CatmullRom(p0, p1, p2, p3, localT)
        end

        function Path:GetLength()
            local length = 0
            local count = #self.Points

            if count < 2 then return 0 end

            local endIndex = self.Closed and count or (count - 1)

            for i = 1, endIndex do
                local p1 = self.Points[i]
                local p2 = self.Points[(i % count) + 1]

                local diff
                local valueType = typeof(p1)

                if valueType == "Vector2" then
                    diff = (p2 - p1).Magnitude
                elseif valueType == "Vector3" then
                    diff = (p2 - p1).Magnitude
                elseif valueType == "number" then
                    diff = math.abs(p2 - p1)
                elseif valueType == "UDim2" then
                    local dx = p2.X.Offset - p1.X.Offset
                    local dy = p2.Y.Offset - p1.Y.Offset
                    diff = math.sqrt(dx * dx + dy * dy)
                else
                    diff = 1
                end

                length = length + diff
            end

            return length
        end

        --// Gradient Interpolation
        function Interpolate.Gradient(colors, t)
            t = Interpolate.Clamp(t, 0, 1)

            local count = #colors
            if count == 0 then return Color3.new(1, 1, 1) end
            if count == 1 then return colors[1] end

            local segment = math.floor(t * (count - 1))
            local localT = (t * (count - 1)) - segment

            if segment >= count - 1 then
                return colors[count]
            end

            return Interpolate.ColorRGB(colors[segment + 1], colors[segment + 2], localT)
        end

        --// Spring Interpolation (critically damped)
        function Interpolate.Spring(current, target, velocity, stiffness, damping, dt)
            stiffness = stiffness or 100
            damping = damping or 10

            local displacement = current - target
            local springForce = -stiffness * displacement
            local dampingForce = -damping * velocity
            local acceleration = springForce + dampingForce

            local newVelocity = velocity + acceleration * dt
            local newValue = current + newVelocity * dt

            return newValue, newVelocity
        end

        --// Exponential Smoothing
        function Interpolate.Damp(current, target, smoothing, dt)
            local factor = 1 - math.exp(-smoothing * dt)
            return Interpolate.Lerp(current, target, factor)
        end

        --// Type Utilities
        function Interpolate.CanInterpolate(value)
            local valueType = typeof(value)
            return valueType == "number" or
                   valueType == "Color3" or
                   valueType == "Vector2" or
                   valueType == "Vector3" or
                   valueType == "UDim" or
                   valueType == "UDim2" or
                   valueType == "CFrame" or
                   valueType == "Rect" or
                   valueType == "NumberRange"
        end

        function Interpolate.GetValueType(value)
            return typeof(value)
        end

        --// Export Path class
        Interpolate.Path = Path

        return Interpolate


    end


    -- ============================================================================
    -- Module: NexusUI/Animation/init
    -- ============================================================================
    NexusUI_Modules["NexusUI/Animation/init"] = function()
        local script = CreateMockScript("NexusUI/Animation/init")

        --[[
            NexusUI Animation System
            Comprehensive animation library for UI

            Modules:
            - SpringPhysics: Realistic spring-based animations
            - EasingFunctions: 40+ easing functions
            - Sequence: Sequential animation chains
            - Timeline: Time-based orchestration
            - Keyframes: CSS-like keyframe animations
            - Tween: Enhanced tweening system
            - Parallel: Simultaneous animations
            - Morph: State morphing
            - Transition: Pre-built transitions
            - Controller: Central management
            - Effects: Visual effect animations
            - Stagger: Staggered animations
            - Interpolate: Value interpolation
        ]]

        --// Animation Module
        local Animation = {}

        --// Load all sub-modules
        Animation.SpringPhysics = NexusRequire("NexusUI/Animation/SpringPhysics")
        Animation.Easing = NexusRequire("NexusUI/Animation/EasingFunctions")
        Animation.Sequence = NexusRequire("NexusUI/Animation/Sequence")
        Animation.Timeline = NexusRequire("NexusUI/Animation/Timeline")
        Animation.Keyframes = NexusRequire("NexusUI/Animation/Keyframes")
        Animation.Tween = NexusRequire("NexusUI/Animation/Tween")
        Animation.Parallel = NexusRequire("NexusUI/Animation/Parallel")
        Animation.Morph = NexusRequire("NexusUI/Animation/Morph")
        Animation.Transition = NexusRequire("NexusUI/Animation/Transition")
        Animation.Controller = NexusRequire("NexusUI/Animation/Controller")
        Animation.Effects = NexusRequire("NexusUI/Animation/Effects")
        Animation.Stagger = NexusRequire("NexusUI/Animation/Stagger")
        Animation.Interpolate = NexusRequire("NexusUI/Animation/Interpolate")

        --// Quick Access Aliases
        Animation.Spring = Animation.SpringPhysics
        Animation.EasingFunctions = Animation.Easing

        --// Convenience Methods

        -- Quick tween
        function Animation.To(target, properties, duration, easing)
            return Animation.Tween.To(target, properties, duration, easing)
        end

        -- Quick spring
        function Animation.SpringTo(target, property, goalValue, config)
            return Animation.SpringPhysics.To(target, property, goalValue, config)
        end

        -- Quick fade in
        function Animation.FadeIn(target, duration)
            return Animation.Transition.Fade.In(target, { Duration = duration })
        end

        -- Quick fade out
        function Animation.FadeOut(target, duration)
            return Animation.Transition.Fade.Out(target, { Duration = duration })
        end

        -- Quick slide
        function Animation.SlideIn(target, direction, duration)
            direction = direction or "Left"
            local slideFunc = Animation.Transition.Slide["From" .. direction]
            if slideFunc then
                return slideFunc(target, { Duration = duration })
            end
        end

        function Animation.SlideOut(target, direction, duration)
            direction = direction or "Left"
            local slideFunc = Animation.Transition.Slide["To" .. direction]
            if slideFunc then
                return slideFunc(target, { Duration = duration })
            end
        end

        -- Quick scale
        function Animation.ScaleIn(target, duration)
            return Animation.Transition.Scale.In(target, { Duration = duration })
        end

        function Animation.ScaleOut(target, duration)
            return Animation.Transition.Scale.Out(target, { Duration = duration })
        end

        -- Get controller singleton
        function Animation.GetController()
            return Animation.Controller.Get()
        end

        -- Create sequence
        function Animation.CreateSequence(...)
            return Animation.Sequence.new(...)
        end

        -- Create timeline
        function Animation.CreateTimeline()
            return Animation.Timeline.new()
        end

        -- Create keyframe animation
        function Animation.CreateKeyframes(target, keyframes, config)
            return Animation.Keyframes.new(target, keyframes, config)
        end

        -- Define keyframes
        function Animation.DefineKeyframes()
            return Animation.Keyframes.Define()
        end

        -- Create parallel
        function Animation.CreateParallel(...)
            return Animation.Parallel.new(...)
        end

        -- Play all animations
        function Animation.PlayAll(...)
            return Animation.Parallel.All(...)
        end

        -- Staggered animations
        function Animation.PlayStaggered(animations, delay)
            return Animation.Stagger.Play(animations, delay)
        end

        -- Get easing function
        function Animation.GetEasing(name)
            return Animation.Easing.Get(name)
        end

        -- Apply easing to value
        function Animation.ApplyEasing(easingName, startValue, endValue, t)
            return Animation.Easing.Apply(easingName, startValue, endValue, t)
        end

        -- Interpolate value
        function Animation.Lerp(a, b, t)
            return Animation.Interpolate.Lerp(a, b, t)
        end

        -- Get active animation count
        function Animation.GetActiveCount()
            return Animation.Controller.Get():GetActiveCount()
        end

        -- Stop all animations
        function Animation.StopAll()
            Animation.Controller.Get():StopAll()
            Animation.SpringPhysics.CancelAll()
            Animation.Tween.CancelAll()
        end

        -- Global time scale
        function Animation.SetTimeScale(scale)
            Animation.Controller.Get():SetTimeScale(scale)
        end

        function Animation.GetTimeScale()
            return Animation.Controller.Get():GetTimeScale()
        end

        return Animation


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Palette
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Palette"] = function()
        local script = CreateMockScript("NexusUI/Themes/Palette")

        --[[
            NexusUI Color Palette Generator
            Generate harmonious color palettes from base colors
        ]]

        --// Palette Module
        local Palette = {}
        Palette.ClassName = "ColorPalette"

        --// Color Utilities
        local function RGBtoHSL(color)
            local r, g, b = color.R, color.G, color.B
            local max = math.max(r, g, b)
            local min = math.min(r, g, b)
            local h, s, l = 0, 0, (max + min) / 2

            if max ~= min then
                local d = max - min
                s = l > 0.5 and d / (2 - max - min) or d / (max + min)

                if max == r then
                    h = (g - b) / d + (g < b and 6 or 0)
                elseif max == g then
                    h = (b - r) / d + 2
                else
                    h = (r - g) / d + 4
                end

                h = h / 6
            end

            return h, s, l
        end

        local function HSLtoRGB(h, s, l)
            local r, g, b

            if s == 0 then
                r, g, b = l, l, l
            else
                local function hue2rgb(p, q, t)
                    if t < 0 then t = t + 1 end
                    if t > 1 then t = t - 1 end
                    if t < 1/6 then return p + (q - p) * 6 * t end
                    if t < 1/2 then return q end
                    if t < 2/3 then return p + (q - p) * (2/3 - t) * 6 end
                    return p
                end

                local q = l < 0.5 and l * (1 + s) or l + s - l * s
                local p = 2 * l - q

                r = hue2rgb(p, q, h + 1/3)
                g = hue2rgb(p, q, h)
                b = hue2rgb(p, q, h - 1/3)
            end

            return Color3.new(r, g, b)
        end

        local function Clamp(value, min, max)
            return math.max(min, math.min(max, value))
        end

        --// Lighten Color
        function Palette.Lighten(color, amount)
            local h, s, l = RGBtoHSL(color)
            l = Clamp(l + amount, 0, 1)
            return HSLtoRGB(h, s, l)
        end

        --// Darken Color
        function Palette.Darken(color, amount)
            local h, s, l = RGBtoHSL(color)
            l = Clamp(l - amount, 0, 1)
            return HSLtoRGB(h, s, l)
        end

        --// Saturate Color
        function Palette.Saturate(color, amount)
            local h, s, l = RGBtoHSL(color)
            s = Clamp(s + amount, 0, 1)
            return HSLtoRGB(h, s, l)
        end

        --// Desaturate Color
        function Palette.Desaturate(color, amount)
            local h, s, l = RGBtoHSL(color)
            s = Clamp(s - amount, 0, 1)
            return HSLtoRGB(h, s, l)
        end

        --// Rotate Hue
        function Palette.RotateHue(color, degrees)
            local h, s, l = RGBtoHSL(color)
            h = (h + degrees / 360) % 1
            return HSLtoRGB(h, s, l)
        end

        --// Get Complementary Color
        function Palette.Complementary(color)
            return Palette.RotateHue(color, 180)
        end

        --// Get Analogous Colors
        function Palette.Analogous(color, angle)
            angle = angle or 30
            return {
                Palette.RotateHue(color, -angle),
                color,
                Palette.RotateHue(color, angle),
            }
        end

        --// Get Triadic Colors
        function Palette.Triadic(color)
            return {
                color,
                Palette.RotateHue(color, 120),
                Palette.RotateHue(color, 240),
            }
        end

        --// Get Tetradic Colors
        function Palette.Tetradic(color)
            return {
                color,
                Palette.RotateHue(color, 90),
                Palette.RotateHue(color, 180),
                Palette.RotateHue(color, 270),
            }
        end

        --// Get Split Complementary
        function Palette.SplitComplementary(color)
            return {
                color,
                Palette.RotateHue(color, 150),
                Palette.RotateHue(color, 210),
            }
        end

        --// Mix Two Colors
        function Palette.Mix(color1, color2, weight)
            weight = weight or 0.5
            return Color3.new(
                color1.R + (color2.R - color1.R) * weight,
                color1.G + (color2.G - color1.G) * weight,
                color1.B + (color2.B - color1.B) * weight
            )
        end

        --// Generate Color Scale (light to dark)
        function Palette.Scale(baseColor, steps)
            steps = steps or 10
            local scale = {}
            local h, s, l = RGBtoHSL(baseColor)

            for i = 1, steps do
                local newL = 0.95 - ((i - 1) / (steps - 1)) * 0.9
                scale[i] = HSLtoRGB(h, s, newL)
            end

            return scale
        end

        --// Generate from Primary Color
        function Palette.Generate(primaryColor)
            local h, s, l = RGBtoHSL(primaryColor)

            local palette = {
                -- Primary Scale
                Primary = primaryColor,
                Primary50 = HSLtoRGB(h, Clamp(s * 0.3, 0, 1), 0.97),
                Primary100 = HSLtoRGB(h, Clamp(s * 0.5, 0, 1), 0.94),
                Primary200 = HSLtoRGB(h, Clamp(s * 0.7, 0, 1), 0.86),
                Primary300 = HSLtoRGB(h, Clamp(s * 0.85, 0, 1), 0.76),
                Primary400 = HSLtoRGB(h, Clamp(s * 0.95, 0, 1), 0.64),
                Primary500 = primaryColor,
                Primary600 = HSLtoRGB(h, s, Clamp(l - 0.1, 0, 1)),
                Primary700 = HSLtoRGB(h, s, Clamp(l - 0.2, 0, 1)),
                Primary800 = HSLtoRGB(h, s, Clamp(l - 0.3, 0, 1)),
                Primary900 = HSLtoRGB(h, s, Clamp(l - 0.4, 0, 1)),

                -- Hover/Pressed variants
                PrimaryHover = Palette.Lighten(primaryColor, 0.1),
                PrimaryPressed = Palette.Darken(primaryColor, 0.1),
                PrimaryFaded = HSLtoRGB(h, Clamp(s * 0.4, 0, 1), Clamp(l + 0.3, 0, 1)),

                -- Complementary for Accent
                Accent = Palette.RotateHue(primaryColor, 180),
                AccentHover = Palette.Lighten(Palette.RotateHue(primaryColor, 180), 0.1),
                AccentPressed = Palette.Darken(Palette.RotateHue(primaryColor, 180), 0.1),

                -- Secondary (desaturated primary)
                Secondary = Palette.Desaturate(primaryColor, 0.5),
                SecondaryHover = Palette.Lighten(Palette.Desaturate(primaryColor, 0.5), 0.1),
                SecondaryPressed = Palette.Darken(Palette.Desaturate(primaryColor, 0.5), 0.1),

                -- Background colors (very dark, slightly tinted)
                Background = HSLtoRGB(h, Clamp(s * 0.1, 0, 1), 0.06),
                BackgroundAlt = HSLtoRGB(h, Clamp(s * 0.12, 0, 1), 0.09),
                BackgroundElevated = HSLtoRGB(h, Clamp(s * 0.14, 0, 1), 0.12),
                BackgroundFloating = HSLtoRGB(h, Clamp(s * 0.16, 0, 1), 0.15),

                -- Surface
                Surface = HSLtoRGB(h, Clamp(s * 0.12, 0, 1), 0.09),
                SurfaceHover = HSLtoRGB(h, Clamp(s * 0.14, 0, 1), 0.14),
                SurfaceActive = HSLtoRGB(h, Clamp(s * 0.16, 0, 1), 0.20),

                -- Border
                Border = HSLtoRGB(h, Clamp(s * 0.15, 0, 1), 0.27),
                BorderFocused = primaryColor,

                -- Glow
                Glow = primaryColor,
            }

            return palette
        end

        --// Generate Dark Theme from Primary
        function Palette.GenerateDarkTheme(primaryColor)
            local colors = Palette.Generate(primaryColor)

            -- Add standard colors
            colors.Text = Color3.fromRGB(250, 250, 250)
            colors.TextSecondary = Color3.fromRGB(161, 161, 170)
            colors.TextMuted = Color3.fromRGB(113, 113, 122)
            colors.TextInverse = Color3.fromRGB(15, 15, 15)

            colors.Success = Color3.fromRGB(34, 197, 94)
            colors.SuccessHover = Color3.fromRGB(74, 222, 128)
            colors.Warning = Color3.fromRGB(234, 179, 8)
            colors.WarningHover = Color3.fromRGB(250, 204, 21)
            colors.Error = Color3.fromRGB(239, 68, 68)
            colors.ErrorHover = Color3.fromRGB(248, 113, 113)
            colors.Info = Color3.fromRGB(59, 130, 246)
            colors.InfoHover = Color3.fromRGB(96, 165, 250)
            colors.BorderError = Color3.fromRGB(239, 68, 68)

            colors.Overlay = Color3.fromRGB(0, 0, 0)
            colors.OverlayTransparency = 0.5
            colors.Shadow = Color3.fromRGB(0, 0, 0)
            colors.ShadowTransparency = 0.5
            colors.GlowTransparency = 0.8

            colors.ScrollbarTrack = colors.BackgroundAlt
            colors.ScrollbarThumb = colors.Border
            colors.ScrollbarThumbHover = colors.TextMuted

            return colors
        end

        --// Generate Light Theme from Primary
        function Palette.GenerateLightTheme(primaryColor)
            local h, s, l = RGBtoHSL(primaryColor)

            local colors = {
                Primary = primaryColor,
                PrimaryHover = Palette.Darken(primaryColor, 0.1),
                PrimaryPressed = Palette.Darken(primaryColor, 0.2),
                PrimaryFaded = HSLtoRGB(h, Clamp(s * 0.3, 0, 1), 0.9),

                Secondary = Palette.Desaturate(primaryColor, 0.5),
                SecondaryHover = Palette.Darken(Palette.Desaturate(primaryColor, 0.5), 0.1),
                SecondaryPressed = Palette.Darken(Palette.Desaturate(primaryColor, 0.5), 0.2),

                Accent = Palette.RotateHue(primaryColor, 180),
                AccentHover = Palette.Darken(Palette.RotateHue(primaryColor, 180), 0.1),
                AccentPressed = Palette.Darken(Palette.RotateHue(primaryColor, 180), 0.2),

                Background = Color3.fromRGB(255, 255, 255),
                BackgroundAlt = Color3.fromRGB(249, 250, 251),
                BackgroundElevated = Color3.fromRGB(243, 244, 246),
                BackgroundFloating = Color3.fromRGB(255, 255, 255),

                Surface = Color3.fromRGB(249, 250, 251),
                SurfaceHover = Color3.fromRGB(243, 244, 246),
                SurfaceActive = Color3.fromRGB(229, 231, 235),

                Border = Color3.fromRGB(209, 213, 219),
                BorderFocused = primaryColor,
                BorderError = Color3.fromRGB(239, 68, 68),

                Text = Color3.fromRGB(17, 24, 39),
                TextSecondary = Color3.fromRGB(75, 85, 99),
                TextMuted = Color3.fromRGB(156, 163, 175),
                TextInverse = Color3.fromRGB(255, 255, 255),

                Success = Color3.fromRGB(22, 163, 74),
                SuccessHover = Color3.fromRGB(21, 128, 61),
                Warning = Color3.fromRGB(202, 138, 4),
                WarningHover = Color3.fromRGB(161, 98, 7),
                Error = Color3.fromRGB(220, 38, 38),
                ErrorHover = Color3.fromRGB(185, 28, 28),
                Info = Color3.fromRGB(37, 99, 235),
                InfoHover = Color3.fromRGB(29, 78, 216),

                Overlay = Color3.fromRGB(0, 0, 0),
                OverlayTransparency = 0.3,
                Shadow = Color3.fromRGB(0, 0, 0),
                ShadowTransparency = 0.85,

                Glow = primaryColor,
                GlowTransparency = 0.9,

                ScrollbarTrack = Color3.fromRGB(243, 244, 246),
                ScrollbarThumb = Color3.fromRGB(209, 213, 219),
                ScrollbarThumbHover = Color3.fromRGB(156, 163, 175),
            }

            return colors
        end

        --// Hex to Color3
        function Palette.FromHex(hex)
            hex = hex:gsub("#", "")

            local r = tonumber(hex:sub(1, 2), 16) / 255
            local g = tonumber(hex:sub(3, 4), 16) / 255
            local b = tonumber(hex:sub(5, 6), 16) / 255

            return Color3.new(r, g, b)
        end

        --// Color3 to Hex
        function Palette.ToHex(color)
            return string.format("#%02X%02X%02X",
                math.floor(color.R * 255),
                math.floor(color.G * 255),
                math.floor(color.B * 255)
            )
        end

        --// Get Contrast Color (black or white)
        function Palette.GetContrastColor(backgroundColor)
            local luminance = 0.299 * backgroundColor.R + 0.587 * backgroundColor.G + 0.114 * backgroundColor.B

            if luminance > 0.5 then
                return Color3.fromRGB(0, 0, 0)
            else
                return Color3.fromRGB(255, 255, 255)
            end
        end

        --// Predefined Palettes
        Palette.Predefined = {
            Indigo = Color3.fromRGB(99, 102, 241),
            Blue = Color3.fromRGB(59, 130, 246),
            Cyan = Color3.fromRGB(6, 182, 212),
            Teal = Color3.fromRGB(20, 184, 166),
            Green = Color3.fromRGB(34, 197, 94),
            Lime = Color3.fromRGB(132, 204, 22),
            Yellow = Color3.fromRGB(234, 179, 8),
            Orange = Color3.fromRGB(249, 115, 22),
            Red = Color3.fromRGB(239, 68, 68),
            Pink = Color3.fromRGB(236, 72, 153),
            Purple = Color3.fromRGB(168, 85, 247),
            Violet = Color3.fromRGB(139, 92, 246),
            Rose = Color3.fromRGB(244, 63, 94),
            Emerald = Color3.fromRGB(16, 185, 129),
            Sky = Color3.fromRGB(14, 165, 233),
            Amber = Color3.fromRGB(245, 158, 11),
            Fuchsia = Color3.fromRGB(217, 70, 239),
            Slate = Color3.fromRGB(100, 116, 139),
            Zinc = Color3.fromRGB(113, 113, 122),
            Stone = Color3.fromRGB(120, 113, 108),
        }

        return Palette


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Effects
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Effects"] = function()
        local script = CreateMockScript("NexusUI/Themes/Effects")

        --[[
            NexusUI Theme Effects
            Visual effects like liquid glass, blur, glow
        ]]

        --// Effects Module
        local Effects = {}
        Effects.ClassName = "ThemeEffects"

        --// Apply Liquid Glass Effect
        function Effects.ApplyLiquidGlass(element, config)
            config = config or {}

            local transparency = config.Transparency or 0.7
            local cornerRadius = config.CornerRadius or UDim.new(0, 12)
            local borderTransparency = config.BorderTransparency or 0.5
            local borderColor = config.BorderColor or Color3.fromRGB(255, 255, 255)
            local blurTint = config.BlurTint or Color3.fromRGB(30, 30, 40)

            -- Set element properties
            element.BackgroundTransparency = transparency
            element.BackgroundColor3 = blurTint
            element.BorderSizePixel = 0

            -- Add corner
            local corner = element:FindFirstChildOfClass("UICorner") or Instance.new("UICorner")
            corner.CornerRadius = cornerRadius
            corner.Parent = element

            -- Add stroke for glass border effect
            local stroke = element:FindFirstChild("GlassStroke") or Instance.new("UIStroke")
            stroke.Name = "GlassStroke"
            stroke.Color = borderColor
            stroke.Transparency = borderTransparency
            stroke.Thickness = 1
            stroke.Parent = element

            -- Add gradient for glass shimmer
            local gradient = element:FindFirstChild("GlassGradient") or Instance.new("UIGradient")
            gradient.Name = "GlassGradient"
            gradient.Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
                ColorSequenceKeypoint.new(0.5, Color3.fromRGB(200, 200, 220)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(180, 180, 200)),
            })
            gradient.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 0.9),
                NumberSequenceKeypoint.new(0.5, 0.95),
                NumberSequenceKeypoint.new(1, 0.9),
            })
            gradient.Rotation = -45
            gradient.Parent = element

            return {
                Corner = corner,
                Stroke = stroke,
                Gradient = gradient,

                Remove = function()
                    corner:Destroy()
                    stroke:Destroy()
                    gradient:Destroy()
                end,
            }
        end

        --// Apply Frosted Glass Effect
        function Effects.ApplyFrostedGlass(element, config)
            config = config or {}

            local transparency = config.Transparency or 0.6
            local cornerRadius = config.CornerRadius or UDim.new(0, 8)
            local tint = config.Tint or Color3.fromRGB(255, 255, 255)

            element.BackgroundTransparency = transparency
            element.BackgroundColor3 = tint
            element.BorderSizePixel = 0

            -- Add corner
            local corner = element:FindFirstChildOfClass("UICorner") or Instance.new("UICorner")
            corner.CornerRadius = cornerRadius
            corner.Parent = element

            -- Add noise texture for frosted effect
            local noiseOverlay = element:FindFirstChild("FrostNoise") or Instance.new("ImageLabel")
            noiseOverlay.Name = "FrostNoise"
            noiseOverlay.Size = UDim2.new(1, 0, 1, 0)
            noiseOverlay.BackgroundTransparency = 1
            noiseOverlay.ImageTransparency = 0.95
            noiseOverlay.Image = "rbxassetid://6031094678" -- Noise texture
            noiseOverlay.ScaleType = Enum.ScaleType.Tile
            noiseOverlay.TileSize = UDim2.new(0, 128, 0, 128)
            noiseOverlay.ZIndex = element.ZIndex + 1
            noiseOverlay.Parent = element

            return {
                Corner = corner,
                Noise = noiseOverlay,

                Remove = function()
                    corner:Destroy()
                    noiseOverlay:Destroy()
                end,
            }
        end

        --// Apply Glow Effect
        function Effects.ApplyGlow(element, config)
            config = config or {}

            local color = config.Color or Color3.fromRGB(99, 102, 241)
            local size = config.Size or 8
            local transparency = config.Transparency or 0.5

            -- Create glow container
            local glowContainer = Instance.new("Frame")
            glowContainer.Name = "GlowEffect"
            glowContainer.Size = UDim2.new(1, size * 2, 1, size * 2)
            glowContainer.Position = UDim2.new(0, -size, 0, -size)
            glowContainer.BackgroundColor3 = color
            glowContainer.BackgroundTransparency = transparency
            glowContainer.BorderSizePixel = 0
            glowContainer.ZIndex = element.ZIndex - 1

            -- Match corner radius
            local elementCorner = element:FindFirstChildOfClass("UICorner")
            if elementCorner then
                local corner = Instance.new("UICorner")
                corner.CornerRadius = UDim.new(elementCorner.CornerRadius.Scale, elementCorner.CornerRadius.Offset + size)
                corner.Parent = glowContainer
            else
                local corner = Instance.new("UICorner")
                corner.CornerRadius = UDim.new(0, size)
                corner.Parent = glowContainer
            end

            glowContainer.Parent = element.Parent

            return {
                Glow = glowContainer,

                SetColor = function(newColor)
                    glowContainer.BackgroundColor3 = newColor
                end,

                SetSize = function(newSize)
                    glowContainer.Size = UDim2.new(1, newSize * 2, 1, newSize * 2)
                    glowContainer.Position = UDim2.new(0, -newSize, 0, -newSize)
                end,

                Remove = function()
                    glowContainer:Destroy()
                end,
            }
        end

        --// Apply Shadow Effect
        function Effects.ApplyShadow(element, config)
            config = config or {}

            local color = config.Color or Color3.fromRGB(0, 0, 0)
            local offset = config.Offset or Vector2.new(0, 4)
            local size = config.Size or 8
            local transparency = config.Transparency or 0.6

            -- Create shadow
            local shadow = Instance.new("ImageLabel")
            shadow.Name = "ShadowEffect"
            shadow.Size = UDim2.new(1, size * 2, 1, size * 2)
            shadow.Position = UDim2.new(0, -size + offset.X, 0, -size + offset.Y)
            shadow.BackgroundTransparency = 1
            shadow.ImageColor3 = color
            shadow.ImageTransparency = transparency
            shadow.Image = "rbxassetid://6015897843" -- Shadow image
            shadow.ScaleType = Enum.ScaleType.Slice
            shadow.SliceCenter = Rect.new(49, 49, 450, 450)
            shadow.ZIndex = element.ZIndex - 1
            shadow.Parent = element.Parent

            return {
                Shadow = shadow,

                SetOffset = function(newOffset)
                    shadow.Position = UDim2.new(0, -size + newOffset.X, 0, -size + newOffset.Y)
                end,

                SetColor = function(newColor)
                    shadow.ImageColor3 = newColor
                end,

                Remove = function()
                    shadow:Destroy()
                end,
            }
        end

        --// Apply Gradient Background
        function Effects.ApplyGradient(element, config)
            config = config or {}

            local colors = config.Colors or {
                Color3.fromRGB(99, 102, 241),
                Color3.fromRGB(168, 85, 247),
            }
            local rotation = config.Rotation or 45
            local animated = config.Animated or false

            -- Build color sequence
            local colorKeypoints = {}
            for i, color in ipairs(colors) do
                local time = (i - 1) / (#colors - 1)
                table.insert(colorKeypoints, ColorSequenceKeypoint.new(time, color))
            end

            local gradient = element:FindFirstChild("GradientEffect") or Instance.new("UIGradient")
            gradient.Name = "GradientEffect"
            gradient.Color = ColorSequence.new(colorKeypoints)
            gradient.Rotation = rotation
            gradient.Parent = element

            local animConnection = nil

            if animated then
                local RunService = game:GetService("RunService")
                local offset = 0

                animConnection = RunService.Heartbeat:Connect(function(dt)
                    offset = (offset + dt * 0.5) % 2
                    gradient.Offset = Vector2.new(offset - 1, 0)
                end)
            end

            return {
                Gradient = gradient,

                SetColors = function(newColors)
                    local newKeypoints = {}
                    for i, color in ipairs(newColors) do
                        local time = (i - 1) / (#newColors - 1)
                        table.insert(newKeypoints, ColorSequenceKeypoint.new(time, color))
                    end
                    gradient.Color = ColorSequence.new(newKeypoints)
                end,

                SetRotation = function(newRotation)
                    gradient.Rotation = newRotation
                end,

                Remove = function()
                    if animConnection then
                        animConnection:Disconnect()
                    end
                    gradient:Destroy()
                end,
            }
        end

        --// Apply Neumorphism Effect
        function Effects.ApplyNeumorphism(element, config)
            config = config or {}

            local lightColor = config.LightColor or Color3.fromRGB(255, 255, 255)
            local darkColor = config.DarkColor or Color3.fromRGB(0, 0, 0)
            local distance = config.Distance or 4
            local blur = config.Blur or 8
            local cornerRadius = config.CornerRadius or UDim.new(0, 12)
            local baseColor = config.BaseColor or Color3.fromRGB(225, 228, 236)

            element.BackgroundColor3 = baseColor
            element.BorderSizePixel = 0

            -- Add corner
            local corner = element:FindFirstChildOfClass("UICorner") or Instance.new("UICorner")
            corner.CornerRadius = cornerRadius
            corner.Parent = element

            -- Light shadow (top-left)
            local lightShadow = Instance.new("ImageLabel")
            lightShadow.Name = "LightShadow"
            lightShadow.Size = UDim2.new(1, blur, 1, blur)
            lightShadow.Position = UDim2.new(0, -distance - blur/2, 0, -distance - blur/2)
            lightShadow.BackgroundTransparency = 1
            lightShadow.ImageColor3 = lightColor
            lightShadow.ImageTransparency = 0.7
            lightShadow.Image = "rbxassetid://6015897843"
            lightShadow.ScaleType = Enum.ScaleType.Slice
            lightShadow.SliceCenter = Rect.new(49, 49, 450, 450)
            lightShadow.ZIndex = element.ZIndex - 1
            lightShadow.Parent = element.Parent

            -- Dark shadow (bottom-right)
            local darkShadow = Instance.new("ImageLabel")
            darkShadow.Name = "DarkShadow"
            darkShadow.Size = UDim2.new(1, blur, 1, blur)
            darkShadow.Position = UDim2.new(0, distance - blur/2, 0, distance - blur/2)
            darkShadow.BackgroundTransparency = 1
            darkShadow.ImageColor3 = darkColor
            darkShadow.ImageTransparency = 0.85
            darkShadow.Image = "rbxassetid://6015897843"
            darkShadow.ScaleType = Enum.ScaleType.Slice
            darkShadow.SliceCenter = Rect.new(49, 49, 450, 450)
            darkShadow.ZIndex = element.ZIndex - 1
            darkShadow.Parent = element.Parent

            return {
                Corner = corner,
                LightShadow = lightShadow,
                DarkShadow = darkShadow,

                Remove = function()
                    corner:Destroy()
                    lightShadow:Destroy()
                    darkShadow:Destroy()
                end,
            }
        end

        --// Apply Border Gradient
        function Effects.ApplyBorderGradient(element, config)
            config = config or {}

            local colors = config.Colors or {
                Color3.fromRGB(99, 102, 241),
                Color3.fromRGB(236, 72, 153),
            }
            local thickness = config.Thickness or 2
            local rotation = config.Rotation or 45
            local animated = config.Animated or false

            -- Create stroke
            local stroke = element:FindFirstChild("GradientStroke") or Instance.new("UIStroke")
            stroke.Name = "GradientStroke"
            stroke.Thickness = thickness
            stroke.Parent = element

            -- Add gradient to stroke
            local colorKeypoints = {}
            for i, color in ipairs(colors) do
                local time = (i - 1) / (#colors - 1)
                table.insert(colorKeypoints, ColorSequenceKeypoint.new(time, color))
            end

            local gradient = stroke:FindFirstChild("StrokeGradient") or Instance.new("UIGradient")
            gradient.Name = "StrokeGradient"
            gradient.Color = ColorSequence.new(colorKeypoints)
            gradient.Rotation = rotation
            gradient.Parent = stroke

            local animConnection = nil

            if animated then
                local RunService = game:GetService("RunService")

                animConnection = RunService.Heartbeat:Connect(function(dt)
                    gradient.Rotation = (gradient.Rotation + dt * 60) % 360
                end)
            end

            return {
                Stroke = stroke,
                Gradient = gradient,

                SetColors = function(newColors)
                    local newKeypoints = {}
                    for i, color in ipairs(newColors) do
                        local time = (i - 1) / (#newColors - 1)
                        table.insert(newKeypoints, ColorSequenceKeypoint.new(time, color))
                    end
                    gradient.Color = ColorSequence.new(newKeypoints)
                end,

                Remove = function()
                    if animConnection then
                        animConnection:Disconnect()
                    end
                    stroke:Destroy()
                end,
            }
        end

        --// Apply Shimmer Effect
        function Effects.ApplyShimmer(element, config)
            config = config or {}

            local color = config.Color or Color3.fromRGB(255, 255, 255)
            local speed = config.Speed or 1.5

            -- Create shimmer overlay
            local shimmer = Instance.new("Frame")
            shimmer.Name = "ShimmerEffect"
            shimmer.Size = UDim2.new(0.3, 0, 1, 0)
            shimmer.Position = UDim2.new(-0.3, 0, 0, 0)
            shimmer.BackgroundTransparency = 1
            shimmer.ZIndex = element.ZIndex + 1
            shimmer.ClipsDescendants = false

            -- Shimmer gradient
            local gradient = Instance.new("UIGradient")
            gradient.Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, color),
                ColorSequenceKeypoint.new(0.5, color),
                ColorSequenceKeypoint.new(1, color),
            })
            gradient.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 1),
                NumberSequenceKeypoint.new(0.5, 0.7),
                NumberSequenceKeypoint.new(1, 1),
            })
            gradient.Rotation = 20
            gradient.Parent = shimmer

            shimmer.Parent = element

            -- Animate shimmer
            local TweenService = game:GetService("TweenService")
            local running = true

            local function animateShimmer()
                while running do
                    shimmer.Position = UDim2.new(-0.3, 0, 0, 0)

                    local tween = TweenService:Create(shimmer, TweenInfo.new(speed, Enum.EasingStyle.Linear), {
                        Position = UDim2.new(1, 0, 0, 0),
                    })
                    tween:Play()
                    tween.Completed:Wait()

                    task.wait(1)
                end
            end

            task.spawn(animateShimmer)

            return {
                Shimmer = shimmer,

                Remove = function()
                    running = false
                    shimmer:Destroy()
                end,
            }
        end

        return Effects


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Builder
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Builder"] = function()
        local script = CreateMockScript("NexusUI/Themes/Builder")

        --[[
            NexusUI Theme Builder
            Fluent API for creating custom themes
        ]]

        --// Theme Builder Module
        local Builder = {}
        Builder.__index = Builder
        Builder.ClassName = "ThemeBuilder"

        --// Create new builder
        function Builder.Create(name, baseTheme)
            local self = setmetatable({}, Builder)

            self._name = name or "Custom"
            self._baseTheme = baseTheme
            self._colors = {}
            self._fonts = {}
            self._fontSizes = {}
            self._spacing = {}
            self._cornerRadius = {}
            self._shadows = {}
            self._animation = {}
            self._glass = {}
            self._custom = {}

            return self
        end

        --// Set Name
        function Builder:Name(name)
            self._name = name
            return self
        end

        --// Set Base Theme
        function Builder:Base(baseThemeName)
            self._baseTheme = baseThemeName
            return self
        end

        --// Color Setters
        function Builder:Primary(color, hover, pressed, faded)
            self._colors.Primary = color
            if hover then self._colors.PrimaryHover = hover end
            if pressed then self._colors.PrimaryPressed = pressed end
            if faded then self._colors.PrimaryFaded = faded end
            return self
        end

        function Builder:Secondary(color, hover, pressed)
            self._colors.Secondary = color
            if hover then self._colors.SecondaryHover = hover end
            if pressed then self._colors.SecondaryPressed = pressed end
            return self
        end

        function Builder:Accent(color, hover, pressed)
            self._colors.Accent = color
            if hover then self._colors.AccentHover = hover end
            if pressed then self._colors.AccentPressed = pressed end
            return self
        end

        function Builder:Background(main, alt, elevated, floating)
            self._colors.Background = main
            if alt then self._colors.BackgroundAlt = alt end
            if elevated then self._colors.BackgroundElevated = elevated end
            if floating then self._colors.BackgroundFloating = floating end
            return self
        end

        function Builder:Surface(main, hover, active)
            self._colors.Surface = main
            if hover then self._colors.SurfaceHover = hover end
            if active then self._colors.SurfaceActive = active end
            return self
        end

        function Builder:Border(main, focused, error)
            self._colors.Border = main
            if focused then self._colors.BorderFocused = focused end
            if error then self._colors.BorderError = error end
            return self
        end

        function Builder:Text(main, secondary, muted, inverse)
            self._colors.Text = main
            if secondary then self._colors.TextSecondary = secondary end
            if muted then self._colors.TextMuted = muted end
            if inverse then self._colors.TextInverse = inverse end
            return self
        end

        function Builder:Success(color, hover)
            self._colors.Success = color
            if hover then self._colors.SuccessHover = hover end
            return self
        end

        function Builder:Warning(color, hover)
            self._colors.Warning = color
            if hover then self._colors.WarningHover = hover end
            return self
        end

        function Builder:Error(color, hover)
            self._colors.Error = color
            if hover then self._colors.ErrorHover = hover end
            return self
        end

        function Builder:Info(color, hover)
            self._colors.Info = color
            if hover then self._colors.InfoHover = hover end
            return self
        end

        function Builder:Overlay(color, transparency)
            self._colors.Overlay = color
            if transparency then self._colors.OverlayTransparency = transparency end
            return self
        end

        function Builder:Shadow(color, transparency)
            self._colors.Shadow = color
            if transparency then self._colors.ShadowTransparency = transparency end
            return self
        end

        function Builder:Glow(color, transparency)
            self._colors.Glow = color
            if transparency then self._colors.GlowTransparency = transparency end
            return self
        end

        function Builder:Scrollbar(track, thumb, thumbHover)
            self._colors.ScrollbarTrack = track
            if thumb then self._colors.ScrollbarThumb = thumb end
            if thumbHover then self._colors.ScrollbarThumbHover = thumbHover end
            return self
        end

        function Builder:Color(colorName, value)
            self._colors[colorName] = value
            return self
        end

        --// Font Setters
        function Builder:HeaderFont(font)
            self._fonts.Header = font
            return self
        end

        function Builder:TitleFont(font)
            self._fonts.Title = font
            return self
        end

        function Builder:BodyFont(font)
            self._fonts.Body = font
            return self
        end

        function Builder:LabelFont(font)
            self._fonts.Label = font
            return self
        end

        function Builder:ButtonFont(font)
            self._fonts.Button = font
            return self
        end

        function Builder:MonoFont(font)
            self._fonts.Mono = font
            return self
        end

        function Builder:Font(fontName, font)
            self._fonts[fontName] = font
            return self
        end

        --// Font Size Setters
        function Builder:FontSize(sizeName, size)
            self._fontSizes[sizeName] = size
            return self
        end

        function Builder:FontSizes(sizes)
            for name, size in pairs(sizes) do
                self._fontSizes[name] = size
            end
            return self
        end

        --// Spacing Setters
        function Builder:Spacing(spacingName, value)
            self._spacing[spacingName] = value
            return self
        end

        function Builder:Spacings(spacings)
            for name, value in pairs(spacings) do
                self._spacing[name] = value
            end
            return self
        end

        --// Corner Radius Setters
        function Builder:CornerRadius(radiusName, value)
            self._cornerRadius[radiusName] = value
            return self
        end

        function Builder:CornerRadii(radii)
            for name, value in pairs(radii) do
                self._cornerRadius[name] = value
            end
            return self
        end

        --// Shadow Setters
        function Builder:ShadowPreset(presetName, offset, blur, transparency)
            self._shadows[presetName] = {
                Offset = offset,
                Blur = blur,
                Transparency = transparency,
            }
            return self
        end

        --// Animation Setters
        function Builder:AnimationSpeed(speedName, duration)
            self._animation[speedName] = duration
            return self
        end

        function Builder:DefaultEasing(easingName)
            self._animation.DefaultEasing = easingName
            return self
        end

        --// Glass Effect Setters
        function Builder:Glass(settings)
            for key, value in pairs(settings) do
                self._glass[key] = value
            end
            return self
        end

        function Builder:GlassTransparency(transparency)
            self._glass.BackgroundTransparency = transparency
            return self
        end

        function Builder:GlassBlur(blurSize)
            self._glass.BlurSize = blurSize
            return self
        end

        --// Custom Properties
        function Builder:Custom(key, value)
            self._custom[key] = value
            return self
        end

        --// Build Theme
        function Builder:Build()
            local theme = {
                Name = self._name,
            }

            -- Add colors if any were set
            if next(self._colors) then
                theme.Colors = self._colors
            end

            -- Add fonts if any were set
            if next(self._fonts) then
                theme.Fonts = self._fonts
            end

            -- Add font sizes if any were set
            if next(self._fontSizes) then
                theme.FontSizes = self._fontSizes
            end

            -- Add spacing if any were set
            if next(self._spacing) then
                theme.Spacing = self._spacing
            end

            -- Add corner radius if any were set
            if next(self._cornerRadius) then
                theme.CornerRadius = self._cornerRadius
            end

            -- Add shadows if any were set
            if next(self._shadows) then
                theme.Shadows = self._shadows
            end

            -- Add animation if any were set
            if next(self._animation) then
                theme.Animation = self._animation
            end

            -- Add glass settings if any were set
            if next(self._glass) then
                theme.Glass = self._glass
            end

            -- Add custom properties
            if next(self._custom) then
                for key, value in pairs(self._custom) do
                    theme[key] = value
                end
            end

            return theme
        end

        --// Build and Register
        function Builder:Register()
            local theme = self:Build()

            local Manager = NexusRequire("NexusUI/Manager")
            Manager.RegisterTheme(theme)

            return theme
        end

        --// Clone from existing theme
        function Builder.FromTheme(existingTheme)
            local builder = Builder.Create(existingTheme.Name .. "Clone")

            if existingTheme.Colors then
                for name, color in pairs(existingTheme.Colors) do
                    builder._colors[name] = color
                end
            end

            if existingTheme.Fonts then
                for name, font in pairs(existingTheme.Fonts) do
                    builder._fonts[name] = font
                end
            end

            if existingTheme.FontSizes then
                for name, size in pairs(existingTheme.FontSizes) do
                    builder._fontSizes[name] = size
                end
            end

            if existingTheme.Spacing then
                for name, spacing in pairs(existingTheme.Spacing) do
                    builder._spacing[name] = spacing
                end
            end

            if existingTheme.CornerRadius then
                for name, radius in pairs(existingTheme.CornerRadius) do
                    builder._cornerRadius[name] = radius
                end
            end

            if existingTheme.Shadows then
                for name, shadow in pairs(existingTheme.Shadows) do
                    builder._shadows[name] = shadow
                end
            end

            if existingTheme.Animation then
                for name, value in pairs(existingTheme.Animation) do
                    builder._animation[name] = value
                end
            end

            if existingTheme.Glass then
                for name, value in pairs(existingTheme.Glass) do
                    builder._glass[name] = value
                end
            end

            return builder
        end

        return Builder


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Dark
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Dark"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Dark")

        --[[
            NexusUI Dark Theme
            Modern dark theme with indigo accents
        ]]

        return {
            Name = "Dark",

            Colors = {
                -- Primary
                Primary = Color3.fromRGB(99, 102, 241),
                PrimaryHover = Color3.fromRGB(129, 140, 248),
                PrimaryPressed = Color3.fromRGB(79, 70, 229),
                PrimaryFaded = Color3.fromRGB(99, 102, 241),

                -- Secondary
                Secondary = Color3.fromRGB(100, 116, 139),
                SecondaryHover = Color3.fromRGB(148, 163, 184),
                SecondaryPressed = Color3.fromRGB(71, 85, 105),

                -- Accent
                Accent = Color3.fromRGB(236, 72, 153),
                AccentHover = Color3.fromRGB(244, 114, 182),
                AccentPressed = Color3.fromRGB(219, 39, 119),

                -- Background
                Background = Color3.fromRGB(15, 15, 15),
                BackgroundAlt = Color3.fromRGB(24, 24, 27),
                BackgroundElevated = Color3.fromRGB(32, 32, 38),
                BackgroundFloating = Color3.fromRGB(39, 39, 42),

                -- Surface
                Surface = Color3.fromRGB(24, 24, 27),
                SurfaceHover = Color3.fromRGB(39, 39, 42),
                SurfaceActive = Color3.fromRGB(52, 52, 58),

                -- Border
                Border = Color3.fromRGB(63, 63, 70),
                BorderFocused = Color3.fromRGB(99, 102, 241),
                BorderError = Color3.fromRGB(239, 68, 68),

                -- Text
                Text = Color3.fromRGB(250, 250, 250),
                TextSecondary = Color3.fromRGB(161, 161, 170),
                TextMuted = Color3.fromRGB(113, 113, 122),
                TextInverse = Color3.fromRGB(15, 15, 15),

                -- Status
                Success = Color3.fromRGB(34, 197, 94),
                SuccessHover = Color3.fromRGB(74, 222, 128),
                Warning = Color3.fromRGB(234, 179, 8),
                WarningHover = Color3.fromRGB(250, 204, 21),
                Error = Color3.fromRGB(239, 68, 68),
                ErrorHover = Color3.fromRGB(248, 113, 113),
                Info = Color3.fromRGB(59, 130, 246),
                InfoHover = Color3.fromRGB(96, 165, 250),

                -- Effects
                Overlay = Color3.fromRGB(0, 0, 0),
                OverlayTransparency = 0.5,
                Shadow = Color3.fromRGB(0, 0, 0),
                ShadowTransparency = 0.5,
                Glow = Color3.fromRGB(99, 102, 241),
                GlowTransparency = 0.8,

                -- Scrollbar
                ScrollbarTrack = Color3.fromRGB(39, 39, 42),
                ScrollbarThumb = Color3.fromRGB(82, 82, 91),
                ScrollbarThumbHover = Color3.fromRGB(113, 113, 122),
            },

            Glass = {
                BackgroundTransparency = 0.7,
                BlurSize = 24,
                BorderTransparency = 0.5,
                Saturation = 1.2,
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Light
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Light"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Light")

        --[[
            NexusUI Light Theme
            Clean light theme with vibrant accents
        ]]

        return {
            Name = "Light",

            Colors = {
                -- Primary
                Primary = Color3.fromRGB(79, 70, 229),
                PrimaryHover = Color3.fromRGB(99, 102, 241),
                PrimaryPressed = Color3.fromRGB(67, 56, 202),
                PrimaryFaded = Color3.fromRGB(224, 231, 255),

                -- Secondary
                Secondary = Color3.fromRGB(100, 116, 139),
                SecondaryHover = Color3.fromRGB(71, 85, 105),
                SecondaryPressed = Color3.fromRGB(51, 65, 85),

                -- Accent
                Accent = Color3.fromRGB(219, 39, 119),
                AccentHover = Color3.fromRGB(190, 24, 93),
                AccentPressed = Color3.fromRGB(157, 23, 77),

                -- Background
                Background = Color3.fromRGB(255, 255, 255),
                BackgroundAlt = Color3.fromRGB(249, 250, 251),
                BackgroundElevated = Color3.fromRGB(243, 244, 246),
                BackgroundFloating = Color3.fromRGB(255, 255, 255),

                -- Surface
                Surface = Color3.fromRGB(249, 250, 251),
                SurfaceHover = Color3.fromRGB(243, 244, 246),
                SurfaceActive = Color3.fromRGB(229, 231, 235),

                -- Border
                Border = Color3.fromRGB(209, 213, 219),
                BorderFocused = Color3.fromRGB(79, 70, 229),
                BorderError = Color3.fromRGB(239, 68, 68),

                -- Text
                Text = Color3.fromRGB(17, 24, 39),
                TextSecondary = Color3.fromRGB(75, 85, 99),
                TextMuted = Color3.fromRGB(156, 163, 175),
                TextInverse = Color3.fromRGB(255, 255, 255),

                -- Status
                Success = Color3.fromRGB(22, 163, 74),
                SuccessHover = Color3.fromRGB(21, 128, 61),
                Warning = Color3.fromRGB(202, 138, 4),
                WarningHover = Color3.fromRGB(161, 98, 7),
                Error = Color3.fromRGB(220, 38, 38),
                ErrorHover = Color3.fromRGB(185, 28, 28),
                Info = Color3.fromRGB(37, 99, 235),
                InfoHover = Color3.fromRGB(29, 78, 216),

                -- Effects
                Overlay = Color3.fromRGB(0, 0, 0),
                OverlayTransparency = 0.3,
                Shadow = Color3.fromRGB(0, 0, 0),
                ShadowTransparency = 0.9,
                Glow = Color3.fromRGB(79, 70, 229),
                GlowTransparency = 0.9,

                -- Scrollbar
                ScrollbarTrack = Color3.fromRGB(243, 244, 246),
                ScrollbarThumb = Color3.fromRGB(209, 213, 219),
                ScrollbarThumbHover = Color3.fromRGB(156, 163, 175),
            },

            Glass = {
                BackgroundTransparency = 0.4,
                BlurSize = 16,
                BorderTransparency = 0.7,
                Saturation = 1.0,
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Ocean
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Ocean"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Ocean")

        --[[
            NexusUI Ocean Theme
            Calming ocean-inspired teal theme
        ]]

        return {
            Name = "Ocean",

            Colors = {
                Primary = Color3.fromRGB(20, 184, 166),
                PrimaryHover = Color3.fromRGB(45, 212, 191),
                PrimaryPressed = Color3.fromRGB(13, 148, 136),
                PrimaryFaded = Color3.fromRGB(17, 94, 89),

                Secondary = Color3.fromRGB(71, 85, 105),
                SecondaryHover = Color3.fromRGB(100, 116, 139),
                SecondaryPressed = Color3.fromRGB(51, 65, 85),

                Accent = Color3.fromRGB(6, 182, 212),
                AccentHover = Color3.fromRGB(34, 211, 238),
                AccentPressed = Color3.fromRGB(8, 145, 178),

                Background = Color3.fromRGB(10, 20, 25),
                BackgroundAlt = Color3.fromRGB(15, 30, 38),
                BackgroundElevated = Color3.fromRGB(20, 40, 50),
                BackgroundFloating = Color3.fromRGB(25, 50, 62),

                Surface = Color3.fromRGB(15, 30, 38),
                SurfaceHover = Color3.fromRGB(25, 50, 62),
                SurfaceActive = Color3.fromRGB(35, 65, 80),

                Border = Color3.fromRGB(45, 80, 95),
                BorderFocused = Color3.fromRGB(20, 184, 166),
                BorderError = Color3.fromRGB(239, 68, 68),

                Text = Color3.fromRGB(240, 253, 250),
                TextSecondary = Color3.fromRGB(153, 246, 228),
                TextMuted = Color3.fromRGB(94, 234, 212),
                TextInverse = Color3.fromRGB(10, 20, 25),

                Success = Color3.fromRGB(34, 197, 94),
                SuccessHover = Color3.fromRGB(74, 222, 128),
                Warning = Color3.fromRGB(234, 179, 8),
                WarningHover = Color3.fromRGB(250, 204, 21),
                Error = Color3.fromRGB(239, 68, 68),
                ErrorHover = Color3.fromRGB(248, 113, 113),
                Info = Color3.fromRGB(6, 182, 212),
                InfoHover = Color3.fromRGB(34, 211, 238),

                Overlay = Color3.fromRGB(0, 10, 15),
                OverlayTransparency = 0.5,
                Shadow = Color3.fromRGB(0, 10, 15),
                ShadowTransparency = 0.4,
                Glow = Color3.fromRGB(20, 184, 166),
                GlowTransparency = 0.7,

                ScrollbarTrack = Color3.fromRGB(25, 50, 62),
                ScrollbarThumb = Color3.fromRGB(45, 80, 95),
                ScrollbarThumbHover = Color3.fromRGB(20, 184, 166),
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Forest
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Forest"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Forest")

        --[[
            NexusUI Forest Theme
            Natural forest green theme
        ]]

        return {
            Name = "Forest",

            Colors = {
                Primary = Color3.fromRGB(34, 197, 94),
                PrimaryHover = Color3.fromRGB(74, 222, 128),
                PrimaryPressed = Color3.fromRGB(22, 163, 74),
                PrimaryFaded = Color3.fromRGB(20, 83, 45),

                Secondary = Color3.fromRGB(82, 82, 91),
                SecondaryHover = Color3.fromRGB(113, 113, 122),
                SecondaryPressed = Color3.fromRGB(63, 63, 70),

                Accent = Color3.fromRGB(132, 204, 22),
                AccentHover = Color3.fromRGB(163, 230, 53),
                AccentPressed = Color3.fromRGB(101, 163, 13),

                Background = Color3.fromRGB(12, 18, 12),
                BackgroundAlt = Color3.fromRGB(18, 28, 18),
                BackgroundElevated = Color3.fromRGB(24, 38, 24),
                BackgroundFloating = Color3.fromRGB(30, 48, 30),

                Surface = Color3.fromRGB(18, 28, 18),
                SurfaceHover = Color3.fromRGB(30, 48, 30),
                SurfaceActive = Color3.fromRGB(42, 64, 42),

                Border = Color3.fromRGB(50, 80, 50),
                BorderFocused = Color3.fromRGB(34, 197, 94),
                BorderError = Color3.fromRGB(239, 68, 68),

                Text = Color3.fromRGB(240, 253, 244),
                TextSecondary = Color3.fromRGB(187, 247, 208),
                TextMuted = Color3.fromRGB(134, 239, 172),
                TextInverse = Color3.fromRGB(12, 18, 12),

                Success = Color3.fromRGB(34, 197, 94),
                SuccessHover = Color3.fromRGB(74, 222, 128),
                Warning = Color3.fromRGB(234, 179, 8),
                WarningHover = Color3.fromRGB(250, 204, 21),
                Error = Color3.fromRGB(239, 68, 68),
                ErrorHover = Color3.fromRGB(248, 113, 113),
                Info = Color3.fromRGB(59, 130, 246),
                InfoHover = Color3.fromRGB(96, 165, 250),

                Overlay = Color3.fromRGB(0, 10, 0),
                OverlayTransparency = 0.5,
                Shadow = Color3.fromRGB(0, 10, 0),
                ShadowTransparency = 0.4,
                Glow = Color3.fromRGB(34, 197, 94),
                GlowTransparency = 0.7,

                ScrollbarTrack = Color3.fromRGB(30, 48, 30),
                ScrollbarThumb = Color3.fromRGB(50, 80, 50),
                ScrollbarThumbHover = Color3.fromRGB(34, 197, 94),
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Sunset
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Sunset"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Sunset")

        --[[
            NexusUI Sunset Theme
            Warm sunset orange and pink theme
        ]]

        return {
            Name = "Sunset",

            Colors = {
                Primary = Color3.fromRGB(249, 115, 22),
                PrimaryHover = Color3.fromRGB(251, 146, 60),
                PrimaryPressed = Color3.fromRGB(234, 88, 12),
                PrimaryFaded = Color3.fromRGB(124, 45, 18),

                Secondary = Color3.fromRGB(120, 113, 108),
                SecondaryHover = Color3.fromRGB(168, 162, 158),
                SecondaryPressed = Color3.fromRGB(87, 83, 78),

                Accent = Color3.fromRGB(244, 63, 94),
                AccentHover = Color3.fromRGB(251, 113, 133),
                AccentPressed = Color3.fromRGB(225, 29, 72),

                Background = Color3.fromRGB(20, 12, 10),
                BackgroundAlt = Color3.fromRGB(32, 20, 16),
                BackgroundElevated = Color3.fromRGB(44, 28, 22),
                BackgroundFloating = Color3.fromRGB(56, 36, 28),

                Surface = Color3.fromRGB(32, 20, 16),
                SurfaceHover = Color3.fromRGB(56, 36, 28),
                SurfaceActive = Color3.fromRGB(72, 48, 38),

                Border = Color3.fromRGB(92, 60, 48),
                BorderFocused = Color3.fromRGB(249, 115, 22),
                BorderError = Color3.fromRGB(239, 68, 68),

                Text = Color3.fromRGB(255, 247, 237),
                TextSecondary = Color3.fromRGB(254, 215, 170),
                TextMuted = Color3.fromRGB(253, 186, 116),
                TextInverse = Color3.fromRGB(20, 12, 10),

                Success = Color3.fromRGB(34, 197, 94),
                SuccessHover = Color3.fromRGB(74, 222, 128),
                Warning = Color3.fromRGB(234, 179, 8),
                WarningHover = Color3.fromRGB(250, 204, 21),
                Error = Color3.fromRGB(239, 68, 68),
                ErrorHover = Color3.fromRGB(248, 113, 113),
                Info = Color3.fromRGB(59, 130, 246),
                InfoHover = Color3.fromRGB(96, 165, 250),

                Overlay = Color3.fromRGB(10, 5, 0),
                OverlayTransparency = 0.5,
                Shadow = Color3.fromRGB(10, 5, 0),
                ShadowTransparency = 0.4,
                Glow = Color3.fromRGB(249, 115, 22),
                GlowTransparency = 0.7,

                ScrollbarTrack = Color3.fromRGB(56, 36, 28),
                ScrollbarThumb = Color3.fromRGB(92, 60, 48),
                ScrollbarThumbHover = Color3.fromRGB(249, 115, 22),
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Midnight
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Midnight"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Midnight")

        --[[
            NexusUI Midnight Theme
            Deep midnight blue theme
        ]]

        return {
            Name = "Midnight",

            Colors = {
                Primary = Color3.fromRGB(59, 130, 246),
                PrimaryHover = Color3.fromRGB(96, 165, 250),
                PrimaryPressed = Color3.fromRGB(37, 99, 235),
                PrimaryFaded = Color3.fromRGB(30, 58, 138),

                Secondary = Color3.fromRGB(71, 85, 105),
                SecondaryHover = Color3.fromRGB(100, 116, 139),
                SecondaryPressed = Color3.fromRGB(51, 65, 85),

                Accent = Color3.fromRGB(139, 92, 246),
                AccentHover = Color3.fromRGB(167, 139, 250),
                AccentPressed = Color3.fromRGB(124, 58, 237),

                Background = Color3.fromRGB(8, 12, 21),
                BackgroundAlt = Color3.fromRGB(15, 23, 42),
                BackgroundElevated = Color3.fromRGB(22, 33, 56),
                BackgroundFloating = Color3.fromRGB(30, 41, 59),

                Surface = Color3.fromRGB(15, 23, 42),
                SurfaceHover = Color3.fromRGB(30, 41, 59),
                SurfaceActive = Color3.fromRGB(51, 65, 85),

                Border = Color3.fromRGB(51, 65, 85),
                BorderFocused = Color3.fromRGB(59, 130, 246),
                BorderError = Color3.fromRGB(239, 68, 68),

                Text = Color3.fromRGB(241, 245, 249),
                TextSecondary = Color3.fromRGB(148, 163, 184),
                TextMuted = Color3.fromRGB(100, 116, 139),
                TextInverse = Color3.fromRGB(15, 23, 42),

                Success = Color3.fromRGB(34, 197, 94),
                SuccessHover = Color3.fromRGB(74, 222, 128),
                Warning = Color3.fromRGB(234, 179, 8),
                WarningHover = Color3.fromRGB(250, 204, 21),
                Error = Color3.fromRGB(239, 68, 68),
                ErrorHover = Color3.fromRGB(248, 113, 113),
                Info = Color3.fromRGB(59, 130, 246),
                InfoHover = Color3.fromRGB(96, 165, 250),

                Overlay = Color3.fromRGB(0, 0, 0),
                OverlayTransparency = 0.5,
                Shadow = Color3.fromRGB(0, 0, 0),
                ShadowTransparency = 0.4,
                Glow = Color3.fromRGB(59, 130, 246),
                GlowTransparency = 0.7,

                ScrollbarTrack = Color3.fromRGB(30, 41, 59),
                ScrollbarThumb = Color3.fromRGB(71, 85, 105),
                ScrollbarThumbHover = Color3.fromRGB(100, 116, 139),
            },

            Glass = {
                BackgroundTransparency = 0.75,
                BlurSize = 28,
                BorderTransparency = 0.4,
                Saturation = 1.3,
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Neon
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Neon"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Neon")

        --[[
            NexusUI Neon Theme
            Vibrant neon colors on dark background
        ]]

        return {
            Name = "Neon",

            Colors = {
                Primary = Color3.fromRGB(0, 255, 136),
                PrimaryHover = Color3.fromRGB(102, 255, 178),
                PrimaryPressed = Color3.fromRGB(0, 204, 109),
                PrimaryFaded = Color3.fromRGB(0, 80, 43),

                Secondary = Color3.fromRGB(113, 113, 122),
                SecondaryHover = Color3.fromRGB(161, 161, 170),
                SecondaryPressed = Color3.fromRGB(82, 82, 91),

                Accent = Color3.fromRGB(255, 0, 128),
                AccentHover = Color3.fromRGB(255, 102, 178),
                AccentPressed = Color3.fromRGB(204, 0, 102),

                Background = Color3.fromRGB(5, 5, 10),
                BackgroundAlt = Color3.fromRGB(10, 10, 18),
                BackgroundElevated = Color3.fromRGB(15, 15, 26),
                BackgroundFloating = Color3.fromRGB(20, 20, 34),

                Surface = Color3.fromRGB(10, 10, 18),
                SurfaceHover = Color3.fromRGB(20, 20, 34),
                SurfaceActive = Color3.fromRGB(30, 30, 50),

                Border = Color3.fromRGB(40, 40, 65),
                BorderFocused = Color3.fromRGB(0, 255, 136),
                BorderError = Color3.fromRGB(255, 50, 50),

                Text = Color3.fromRGB(255, 255, 255),
                TextSecondary = Color3.fromRGB(200, 200, 220),
                TextMuted = Color3.fromRGB(140, 140, 170),
                TextInverse = Color3.fromRGB(5, 5, 10),

                Success = Color3.fromRGB(0, 255, 136),
                SuccessHover = Color3.fromRGB(102, 255, 178),
                Warning = Color3.fromRGB(255, 230, 0),
                WarningHover = Color3.fromRGB(255, 240, 102),
                Error = Color3.fromRGB(255, 50, 50),
                ErrorHover = Color3.fromRGB(255, 120, 120),
                Info = Color3.fromRGB(0, 200, 255),
                InfoHover = Color3.fromRGB(102, 220, 255),

                Overlay = Color3.fromRGB(0, 0, 0),
                OverlayTransparency = 0.4,
                Shadow = Color3.fromRGB(0, 255, 136),
                ShadowTransparency = 0.85,
                Glow = Color3.fromRGB(0, 255, 136),
                GlowTransparency = 0.5,

                ScrollbarTrack = Color3.fromRGB(20, 20, 34),
                ScrollbarThumb = Color3.fromRGB(0, 255, 136),
                ScrollbarThumbHover = Color3.fromRGB(102, 255, 178),
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Cyberpunk
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Cyberpunk"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Cyberpunk")

        --[[
            NexusUI Cyberpunk Theme
            Futuristic cyberpunk aesthetic with yellow accents
        ]]

        return {
            Name = "Cyberpunk",

            Colors = {
                Primary = Color3.fromRGB(252, 211, 77),
                PrimaryHover = Color3.fromRGB(253, 224, 71),
                PrimaryPressed = Color3.fromRGB(245, 158, 11),
                PrimaryFaded = Color3.fromRGB(120, 95, 25),

                Secondary = Color3.fromRGB(100, 116, 139),
                SecondaryHover = Color3.fromRGB(148, 163, 184),
                SecondaryPressed = Color3.fromRGB(71, 85, 105),

                Accent = Color3.fromRGB(236, 72, 153),
                AccentHover = Color3.fromRGB(244, 114, 182),
                AccentPressed = Color3.fromRGB(219, 39, 119),

                Background = Color3.fromRGB(8, 8, 15),
                BackgroundAlt = Color3.fromRGB(15, 15, 28),
                BackgroundElevated = Color3.fromRGB(22, 22, 40),
                BackgroundFloating = Color3.fromRGB(30, 30, 55),

                Surface = Color3.fromRGB(15, 15, 28),
                SurfaceHover = Color3.fromRGB(30, 30, 55),
                SurfaceActive = Color3.fromRGB(45, 45, 75),

                Border = Color3.fromRGB(55, 55, 85),
                BorderFocused = Color3.fromRGB(252, 211, 77),
                BorderError = Color3.fromRGB(255, 50, 50),

                Text = Color3.fromRGB(252, 211, 77),
                TextSecondary = Color3.fromRGB(200, 180, 140),
                TextMuted = Color3.fromRGB(140, 130, 110),
                TextInverse = Color3.fromRGB(8, 8, 15),

                Success = Color3.fromRGB(0, 255, 136),
                SuccessHover = Color3.fromRGB(102, 255, 178),
                Warning = Color3.fromRGB(252, 211, 77),
                WarningHover = Color3.fromRGB(253, 224, 71),
                Error = Color3.fromRGB(255, 50, 80),
                ErrorHover = Color3.fromRGB(255, 100, 120),
                Info = Color3.fromRGB(59, 130, 246),
                InfoHover = Color3.fromRGB(96, 165, 250),

                Overlay = Color3.fromRGB(0, 0, 0),
                OverlayTransparency = 0.4,
                Shadow = Color3.fromRGB(252, 211, 77),
                ShadowTransparency = 0.9,
                Glow = Color3.fromRGB(252, 211, 77),
                GlowTransparency = 0.6,

                ScrollbarTrack = Color3.fromRGB(30, 30, 55),
                ScrollbarThumb = Color3.fromRGB(252, 211, 77),
                ScrollbarThumbHover = Color3.fromRGB(253, 224, 71),
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Dracula
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Dracula"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Dracula")

        --[[
            NexusUI Dracula Theme
            Dark theme with vibrant purple and pink
        ]]

        return {
            Name = "Dracula",

            Colors = {
                Primary = Color3.fromRGB(189, 147, 249),
                PrimaryHover = Color3.fromRGB(210, 180, 255),
                PrimaryPressed = Color3.fromRGB(150, 110, 200),
                PrimaryFaded = Color3.fromRGB(100, 75, 130),

                Secondary = Color3.fromRGB(98, 114, 164),
                SecondaryHover = Color3.fromRGB(130, 145, 190),
                SecondaryPressed = Color3.fromRGB(70, 85, 130),

                Accent = Color3.fromRGB(255, 121, 198),
                AccentHover = Color3.fromRGB(255, 160, 215),
                AccentPressed = Color3.fromRGB(200, 90, 150),

                Background = Color3.fromRGB(40, 42, 54),
                BackgroundAlt = Color3.fromRGB(50, 52, 68),
                BackgroundElevated = Color3.fromRGB(60, 62, 80),
                BackgroundFloating = Color3.fromRGB(68, 71, 90),

                Surface = Color3.fromRGB(50, 52, 68),
                SurfaceHover = Color3.fromRGB(68, 71, 90),
                SurfaceActive = Color3.fromRGB(80, 84, 105),

                Border = Color3.fromRGB(68, 71, 90),
                BorderFocused = Color3.fromRGB(189, 147, 249),
                BorderError = Color3.fromRGB(255, 85, 85),

                Text = Color3.fromRGB(248, 248, 242),
                TextSecondary = Color3.fromRGB(189, 147, 249),
                TextMuted = Color3.fromRGB(98, 114, 164),
                TextInverse = Color3.fromRGB(40, 42, 54),

                Success = Color3.fromRGB(80, 250, 123),
                SuccessHover = Color3.fromRGB(130, 255, 165),
                Warning = Color3.fromRGB(241, 250, 140),
                WarningHover = Color3.fromRGB(250, 255, 180),
                Error = Color3.fromRGB(255, 85, 85),
                ErrorHover = Color3.fromRGB(255, 130, 130),
                Info = Color3.fromRGB(139, 233, 253),
                InfoHover = Color3.fromRGB(175, 240, 255),

                Overlay = Color3.fromRGB(30, 32, 42),
                OverlayTransparency = 0.4,
                Shadow = Color3.fromRGB(30, 32, 42),
                ShadowTransparency = 0.5,
                Glow = Color3.fromRGB(189, 147, 249),
                GlowTransparency = 0.6,

                ScrollbarTrack = Color3.fromRGB(60, 62, 80),
                ScrollbarThumb = Color3.fromRGB(189, 147, 249),
                ScrollbarThumbHover = Color3.fromRGB(255, 121, 198),
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Nord
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Nord"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Nord")

        --[[
            NexusUI Nord Theme
            Arctic, north-bluish color palette
        ]]

        return {
            Name = "Nord",

            Colors = {
                Primary = Color3.fromRGB(136, 192, 208),
                PrimaryHover = Color3.fromRGB(163, 209, 222),
                PrimaryPressed = Color3.fromRGB(129, 161, 193),
                PrimaryFaded = Color3.fromRGB(76, 86, 106),

                Secondary = Color3.fromRGB(76, 86, 106),
                SecondaryHover = Color3.fromRGB(94, 129, 172),
                SecondaryPressed = Color3.fromRGB(67, 76, 94),

                Accent = Color3.fromRGB(191, 97, 106),
                AccentHover = Color3.fromRGB(208, 135, 112),
                AccentPressed = Color3.fromRGB(163, 80, 90),

                Background = Color3.fromRGB(46, 52, 64),
                BackgroundAlt = Color3.fromRGB(59, 66, 82),
                BackgroundElevated = Color3.fromRGB(67, 76, 94),
                BackgroundFloating = Color3.fromRGB(76, 86, 106),

                Surface = Color3.fromRGB(59, 66, 82),
                SurfaceHover = Color3.fromRGB(76, 86, 106),
                SurfaceActive = Color3.fromRGB(94, 129, 172),

                Border = Color3.fromRGB(76, 86, 106),
                BorderFocused = Color3.fromRGB(136, 192, 208),
                BorderError = Color3.fromRGB(191, 97, 106),

                Text = Color3.fromRGB(236, 239, 244),
                TextSecondary = Color3.fromRGB(216, 222, 233),
                TextMuted = Color3.fromRGB(129, 161, 193),
                TextInverse = Color3.fromRGB(46, 52, 64),

                Success = Color3.fromRGB(163, 190, 140),
                SuccessHover = Color3.fromRGB(180, 205, 165),
                Warning = Color3.fromRGB(235, 203, 139),
                WarningHover = Color3.fromRGB(245, 215, 165),
                Error = Color3.fromRGB(191, 97, 106),
                ErrorHover = Color3.fromRGB(210, 130, 140),
                Info = Color3.fromRGB(129, 161, 193),
                InfoHover = Color3.fromRGB(136, 192, 208),

                Overlay = Color3.fromRGB(30, 35, 45),
                OverlayTransparency = 0.4,
                Shadow = Color3.fromRGB(30, 35, 45),
                ShadowTransparency = 0.5,
                Glow = Color3.fromRGB(136, 192, 208),
                GlowTransparency = 0.7,

                ScrollbarTrack = Color3.fromRGB(67, 76, 94),
                ScrollbarThumb = Color3.fromRGB(94, 129, 172),
                ScrollbarThumbHover = Color3.fromRGB(136, 192, 208),
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Monokai
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Monokai"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Monokai")

        --[[
            NexusUI Monokai Theme
            Classic code editor theme
        ]]

        return {
            Name = "Monokai",

            Colors = {
                Primary = Color3.fromRGB(166, 226, 46),
                PrimaryHover = Color3.fromRGB(190, 240, 90),
                PrimaryPressed = Color3.fromRGB(130, 180, 30),
                PrimaryFaded = Color3.fromRGB(80, 110, 20),

                Secondary = Color3.fromRGB(117, 113, 94),
                SecondaryHover = Color3.fromRGB(150, 145, 125),
                SecondaryPressed = Color3.fromRGB(90, 87, 70),

                Accent = Color3.fromRGB(249, 38, 114),
                AccentHover = Color3.fromRGB(255, 90, 150),
                AccentPressed = Color3.fromRGB(200, 25, 90),

                Background = Color3.fromRGB(39, 40, 34),
                BackgroundAlt = Color3.fromRGB(52, 53, 46),
                BackgroundElevated = Color3.fromRGB(62, 63, 54),
                BackgroundFloating = Color3.fromRGB(72, 73, 64),

                Surface = Color3.fromRGB(52, 53, 46),
                SurfaceHover = Color3.fromRGB(72, 73, 64),
                SurfaceActive = Color3.fromRGB(90, 91, 80),

                Border = Color3.fromRGB(72, 73, 64),
                BorderFocused = Color3.fromRGB(166, 226, 46),
                BorderError = Color3.fromRGB(249, 38, 114),

                Text = Color3.fromRGB(248, 248, 242),
                TextSecondary = Color3.fromRGB(230, 219, 116),
                TextMuted = Color3.fromRGB(117, 113, 94),
                TextInverse = Color3.fromRGB(39, 40, 34),

                Success = Color3.fromRGB(166, 226, 46),
                SuccessHover = Color3.fromRGB(190, 240, 90),
                Warning = Color3.fromRGB(230, 219, 116),
                WarningHover = Color3.fromRGB(245, 235, 150),
                Error = Color3.fromRGB(249, 38, 114),
                ErrorHover = Color3.fromRGB(255, 90, 150),
                Info = Color3.fromRGB(102, 217, 239),
                InfoHover = Color3.fromRGB(145, 230, 250),

                Overlay = Color3.fromRGB(25, 26, 22),
                OverlayTransparency = 0.4,
                Shadow = Color3.fromRGB(25, 26, 22),
                ShadowTransparency = 0.5,
                Glow = Color3.fromRGB(166, 226, 46),
                GlowTransparency = 0.7,

                ScrollbarTrack = Color3.fromRGB(62, 63, 54),
                ScrollbarThumb = Color3.fromRGB(166, 226, 46),
                ScrollbarThumbHover = Color3.fromRGB(249, 38, 114),
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Synthwave
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Synthwave"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Synthwave")

        --[[
            NexusUI Synthwave Theme
            80s retro synthwave aesthetic
        ]]

        return {
            Name = "Synthwave",

            Colors = {
                Primary = Color3.fromRGB(255, 0, 170),
                PrimaryHover = Color3.fromRGB(255, 80, 200),
                PrimaryPressed = Color3.fromRGB(200, 0, 130),
                PrimaryFaded = Color3.fromRGB(100, 0, 65),

                Secondary = Color3.fromRGB(0, 200, 255),
                SecondaryHover = Color3.fromRGB(80, 220, 255),
                SecondaryPressed = Color3.fromRGB(0, 150, 200),

                Accent = Color3.fromRGB(255, 200, 0),
                AccentHover = Color3.fromRGB(255, 220, 80),
                AccentPressed = Color3.fromRGB(200, 150, 0),

                Background = Color3.fromRGB(18, 5, 30),
                BackgroundAlt = Color3.fromRGB(28, 10, 48),
                BackgroundElevated = Color3.fromRGB(40, 15, 65),
                BackgroundFloating = Color3.fromRGB(55, 20, 85),

                Surface = Color3.fromRGB(28, 10, 48),
                SurfaceHover = Color3.fromRGB(55, 20, 85),
                SurfaceActive = Color3.fromRGB(75, 30, 110),

                Border = Color3.fromRGB(90, 40, 130),
                BorderFocused = Color3.fromRGB(255, 0, 170),
                BorderError = Color3.fromRGB(255, 80, 80),

                Text = Color3.fromRGB(255, 255, 255),
                TextSecondary = Color3.fromRGB(255, 200, 255),
                TextMuted = Color3.fromRGB(200, 150, 200),
                TextInverse = Color3.fromRGB(18, 5, 30),

                Success = Color3.fromRGB(0, 255, 170),
                SuccessHover = Color3.fromRGB(80, 255, 200),
                Warning = Color3.fromRGB(255, 200, 0),
                WarningHover = Color3.fromRGB(255, 220, 80),
                Error = Color3.fromRGB(255, 80, 100),
                ErrorHover = Color3.fromRGB(255, 130, 150),
                Info = Color3.fromRGB(0, 200, 255),
                InfoHover = Color3.fromRGB(80, 220, 255),

                Overlay = Color3.fromRGB(10, 0, 20),
                OverlayTransparency = 0.4,
                Shadow = Color3.fromRGB(255, 0, 170),
                ShadowTransparency = 0.85,
                Glow = Color3.fromRGB(255, 0, 170),
                GlowTransparency = 0.5,

                ScrollbarTrack = Color3.fromRGB(55, 20, 85),
                ScrollbarThumb = Color3.fromRGB(255, 0, 170),
                ScrollbarThumbHover = Color3.fromRGB(255, 80, 200),
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Catppuccin
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Catppuccin"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Catppuccin")

        --[[
            NexusUI Catppuccin Theme
            Soothing pastel theme (Mocha variant)
        ]]

        return {
            Name = "Catppuccin",

            Colors = {
                Primary = Color3.fromRGB(137, 180, 250),
                PrimaryHover = Color3.fromRGB(166, 200, 255),
                PrimaryPressed = Color3.fromRGB(110, 155, 225),
                PrimaryFaded = Color3.fromRGB(70, 95, 140),

                Secondary = Color3.fromRGB(108, 112, 134),
                SecondaryHover = Color3.fromRGB(140, 145, 170),
                SecondaryPressed = Color3.fromRGB(85, 90, 110),

                Accent = Color3.fromRGB(245, 194, 231),
                AccentHover = Color3.fromRGB(255, 220, 245),
                AccentPressed = Color3.fromRGB(215, 165, 200),

                Background = Color3.fromRGB(30, 30, 46),
                BackgroundAlt = Color3.fromRGB(36, 39, 58),
                BackgroundElevated = Color3.fromRGB(49, 50, 68),
                BackgroundFloating = Color3.fromRGB(69, 71, 90),

                Surface = Color3.fromRGB(36, 39, 58),
                SurfaceHover = Color3.fromRGB(69, 71, 90),
                SurfaceActive = Color3.fromRGB(88, 91, 112),

                Border = Color3.fromRGB(69, 71, 90),
                BorderFocused = Color3.fromRGB(137, 180, 250),
                BorderError = Color3.fromRGB(243, 139, 168),

                Text = Color3.fromRGB(205, 214, 244),
                TextSecondary = Color3.fromRGB(186, 194, 222),
                TextMuted = Color3.fromRGB(108, 112, 134),
                TextInverse = Color3.fromRGB(30, 30, 46),

                Success = Color3.fromRGB(166, 227, 161),
                SuccessHover = Color3.fromRGB(195, 240, 195),
                Warning = Color3.fromRGB(249, 226, 175),
                WarningHover = Color3.fromRGB(255, 240, 200),
                Error = Color3.fromRGB(243, 139, 168),
                ErrorHover = Color3.fromRGB(255, 175, 195),
                Info = Color3.fromRGB(116, 199, 236),
                InfoHover = Color3.fromRGB(155, 220, 250),

                Overlay = Color3.fromRGB(20, 20, 32),
                OverlayTransparency = 0.4,
                Shadow = Color3.fromRGB(20, 20, 32),
                ShadowTransparency = 0.5,
                Glow = Color3.fromRGB(137, 180, 250),
                GlowTransparency = 0.7,

                ScrollbarTrack = Color3.fromRGB(49, 50, 68),
                ScrollbarThumb = Color3.fromRGB(137, 180, 250),
                ScrollbarThumbHover = Color3.fromRGB(245, 194, 231),
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Rose
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Rose"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Rose")

        --[[
            NexusUI Rose Theme
            Elegant rose pink theme
        ]]

        return {
            Name = "Rose",

            Colors = {
                Primary = Color3.fromRGB(244, 63, 94),
                PrimaryHover = Color3.fromRGB(251, 113, 133),
                PrimaryPressed = Color3.fromRGB(225, 29, 72),
                PrimaryFaded = Color3.fromRGB(136, 19, 55),

                Secondary = Color3.fromRGB(113, 113, 122),
                SecondaryHover = Color3.fromRGB(161, 161, 170),
                SecondaryPressed = Color3.fromRGB(82, 82, 91),

                Accent = Color3.fromRGB(236, 72, 153),
                AccentHover = Color3.fromRGB(244, 114, 182),
                AccentPressed = Color3.fromRGB(219, 39, 119),

                Background = Color3.fromRGB(20, 12, 16),
                BackgroundAlt = Color3.fromRGB(32, 18, 26),
                BackgroundElevated = Color3.fromRGB(44, 26, 36),
                BackgroundFloating = Color3.fromRGB(58, 35, 47),

                Surface = Color3.fromRGB(32, 18, 26),
                SurfaceHover = Color3.fromRGB(58, 35, 47),
                SurfaceActive = Color3.fromRGB(75, 48, 62),

                Border = Color3.fromRGB(90, 55, 72),
                BorderFocused = Color3.fromRGB(244, 63, 94),
                BorderError = Color3.fromRGB(239, 68, 68),

                Text = Color3.fromRGB(255, 241, 242),
                TextSecondary = Color3.fromRGB(253, 164, 175),
                TextMuted = Color3.fromRGB(190, 120, 140),
                TextInverse = Color3.fromRGB(20, 12, 16),

                Success = Color3.fromRGB(34, 197, 94),
                SuccessHover = Color3.fromRGB(74, 222, 128),
                Warning = Color3.fromRGB(234, 179, 8),
                WarningHover = Color3.fromRGB(250, 204, 21),
                Error = Color3.fromRGB(239, 68, 68),
                ErrorHover = Color3.fromRGB(248, 113, 113),
                Info = Color3.fromRGB(59, 130, 246),
                InfoHover = Color3.fromRGB(96, 165, 250),

                Overlay = Color3.fromRGB(10, 6, 8),
                OverlayTransparency = 0.5,
                Shadow = Color3.fromRGB(10, 6, 8),
                ShadowTransparency = 0.4,
                Glow = Color3.fromRGB(244, 63, 94),
                GlowTransparency = 0.6,

                ScrollbarTrack = Color3.fromRGB(58, 35, 47),
                ScrollbarThumb = Color3.fromRGB(244, 63, 94),
                ScrollbarThumbHover = Color3.fromRGB(251, 113, 133),
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Crimson
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Crimson"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Crimson")

        --[[
            NexusUI Crimson Theme
            Deep crimson red theme
        ]]

        return {
            Name = "Crimson",

            Colors = {
                Primary = Color3.fromRGB(220, 38, 38),
                PrimaryHover = Color3.fromRGB(239, 68, 68),
                PrimaryPressed = Color3.fromRGB(185, 28, 28),
                PrimaryFaded = Color3.fromRGB(127, 29, 29),

                Secondary = Color3.fromRGB(113, 113, 122),
                SecondaryHover = Color3.fromRGB(161, 161, 170),
                SecondaryPressed = Color3.fromRGB(82, 82, 91),

                Accent = Color3.fromRGB(244, 63, 94),
                AccentHover = Color3.fromRGB(251, 113, 133),
                AccentPressed = Color3.fromRGB(225, 29, 72),

                Background = Color3.fromRGB(18, 8, 8),
                BackgroundAlt = Color3.fromRGB(30, 14, 14),
                BackgroundElevated = Color3.fromRGB(42, 20, 20),
                BackgroundFloating = Color3.fromRGB(56, 28, 28),

                Surface = Color3.fromRGB(30, 14, 14),
                SurfaceHover = Color3.fromRGB(56, 28, 28),
                SurfaceActive = Color3.fromRGB(75, 40, 40),

                Border = Color3.fromRGB(95, 50, 50),
                BorderFocused = Color3.fromRGB(220, 38, 38),
                BorderError = Color3.fromRGB(239, 68, 68),

                Text = Color3.fromRGB(254, 242, 242),
                TextSecondary = Color3.fromRGB(254, 202, 202),
                TextMuted = Color3.fromRGB(252, 165, 165),
                TextInverse = Color3.fromRGB(18, 8, 8),

                Success = Color3.fromRGB(34, 197, 94),
                SuccessHover = Color3.fromRGB(74, 222, 128),
                Warning = Color3.fromRGB(234, 179, 8),
                WarningHover = Color3.fromRGB(250, 204, 21),
                Error = Color3.fromRGB(220, 38, 38),
                ErrorHover = Color3.fromRGB(239, 68, 68),
                Info = Color3.fromRGB(59, 130, 246),
                InfoHover = Color3.fromRGB(96, 165, 250),

                Overlay = Color3.fromRGB(9, 4, 4),
                OverlayTransparency = 0.5,
                Shadow = Color3.fromRGB(9, 4, 4),
                ShadowTransparency = 0.4,
                Glow = Color3.fromRGB(220, 38, 38),
                GlowTransparency = 0.5,

                ScrollbarTrack = Color3.fromRGB(56, 28, 28),
                ScrollbarThumb = Color3.fromRGB(220, 38, 38),
                ScrollbarThumbHover = Color3.fromRGB(239, 68, 68),
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Lavender
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Lavender"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Lavender")

        --[[
            NexusUI Lavender Theme
            Soft purple lavender theme
        ]]

        return {
            Name = "Lavender",

            Colors = {
                Primary = Color3.fromRGB(168, 85, 247),
                PrimaryHover = Color3.fromRGB(192, 132, 252),
                PrimaryPressed = Color3.fromRGB(147, 51, 234),
                PrimaryFaded = Color3.fromRGB(88, 28, 135),

                Secondary = Color3.fromRGB(113, 113, 122),
                SecondaryHover = Color3.fromRGB(161, 161, 170),
                SecondaryPressed = Color3.fromRGB(82, 82, 91),

                Accent = Color3.fromRGB(139, 92, 246),
                AccentHover = Color3.fromRGB(167, 139, 250),
                AccentPressed = Color3.fromRGB(124, 58, 237),

                Background = Color3.fromRGB(16, 14, 22),
                BackgroundAlt = Color3.fromRGB(26, 22, 38),
                BackgroundElevated = Color3.fromRGB(36, 30, 52),
                BackgroundFloating = Color3.fromRGB(48, 40, 68),

                Surface = Color3.fromRGB(26, 22, 38),
                SurfaceHover = Color3.fromRGB(48, 40, 68),
                SurfaceActive = Color3.fromRGB(65, 55, 90),

                Border = Color3.fromRGB(75, 60, 105),
                BorderFocused = Color3.fromRGB(168, 85, 247),
                BorderError = Color3.fromRGB(239, 68, 68),

                Text = Color3.fromRGB(250, 245, 255),
                TextSecondary = Color3.fromRGB(216, 180, 254),
                TextMuted = Color3.fromRGB(167, 139, 250),
                TextInverse = Color3.fromRGB(16, 14, 22),

                Success = Color3.fromRGB(34, 197, 94),
                SuccessHover = Color3.fromRGB(74, 222, 128),
                Warning = Color3.fromRGB(234, 179, 8),
                WarningHover = Color3.fromRGB(250, 204, 21),
                Error = Color3.fromRGB(239, 68, 68),
                ErrorHover = Color3.fromRGB(248, 113, 113),
                Info = Color3.fromRGB(59, 130, 246),
                InfoHover = Color3.fromRGB(96, 165, 250),

                Overlay = Color3.fromRGB(8, 7, 12),
                OverlayTransparency = 0.5,
                Shadow = Color3.fromRGB(8, 7, 12),
                ShadowTransparency = 0.4,
                Glow = Color3.fromRGB(168, 85, 247),
                GlowTransparency = 0.6,

                ScrollbarTrack = Color3.fromRGB(48, 40, 68),
                ScrollbarThumb = Color3.fromRGB(168, 85, 247),
                ScrollbarThumbHover = Color3.fromRGB(192, 132, 252),
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Manager
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Manager"] = function()
        local script = CreateMockScript("NexusUI/Themes/Manager")

        --[[
            NexusUI Theme Manager
            Handles theme registration, switching, and application
        ]]

        --// Theme Manager Module
        local Manager = {}
        Manager.ClassName = "ThemeManager"

        --// Theme Registry
        local RegisteredThemes = {}
        local CurrentThemeName = "Dark"
        local CurrentTheme = nil
        local ThemeListeners = {}
        local TrackedElements = {}

        --// Default Theme Structure
        local DefaultThemeStructure = {
            Name = "Default",

            -- Colors
            Colors = {
                -- Primary palette
                Primary = Color3.fromRGB(99, 102, 241),
                PrimaryHover = Color3.fromRGB(129, 140, 248),
                PrimaryPressed = Color3.fromRGB(79, 70, 229),
                PrimaryFaded = Color3.fromRGB(99, 102, 241),

                -- Secondary palette
                Secondary = Color3.fromRGB(100, 116, 139),
                SecondaryHover = Color3.fromRGB(148, 163, 184),
                SecondaryPressed = Color3.fromRGB(71, 85, 105),

                -- Accent
                Accent = Color3.fromRGB(236, 72, 153),
                AccentHover = Color3.fromRGB(244, 114, 182),
                AccentPressed = Color3.fromRGB(219, 39, 119),

                -- Background
                Background = Color3.fromRGB(15, 15, 15),
                BackgroundAlt = Color3.fromRGB(24, 24, 27),
                BackgroundElevated = Color3.fromRGB(32, 32, 38),
                BackgroundFloating = Color3.fromRGB(39, 39, 42),

                -- Surface
                Surface = Color3.fromRGB(24, 24, 27),
                SurfaceHover = Color3.fromRGB(39, 39, 42),
                SurfaceActive = Color3.fromRGB(52, 52, 58),

                -- Border
                Border = Color3.fromRGB(63, 63, 70),
                BorderFocused = Color3.fromRGB(99, 102, 241),
                BorderError = Color3.fromRGB(239, 68, 68),

                -- Text
                Text = Color3.fromRGB(250, 250, 250),
                TextSecondary = Color3.fromRGB(161, 161, 170),
                TextMuted = Color3.fromRGB(113, 113, 122),
                TextInverse = Color3.fromRGB(15, 15, 15),

                -- Status
                Success = Color3.fromRGB(34, 197, 94),
                SuccessHover = Color3.fromRGB(74, 222, 128),
                Warning = Color3.fromRGB(234, 179, 8),
                WarningHover = Color3.fromRGB(250, 204, 21),
                Error = Color3.fromRGB(239, 68, 68),
                ErrorHover = Color3.fromRGB(248, 113, 113),
                Info = Color3.fromRGB(59, 130, 246),
                InfoHover = Color3.fromRGB(96, 165, 250),

                -- Overlay
                Overlay = Color3.fromRGB(0, 0, 0),
                OverlayTransparency = 0.5,

                -- Scrollbar
                ScrollbarTrack = Color3.fromRGB(39, 39, 42),
                ScrollbarThumb = Color3.fromRGB(82, 82, 91),
                ScrollbarThumbHover = Color3.fromRGB(113, 113, 122),

                -- Shadow
                Shadow = Color3.fromRGB(0, 0, 0),
                ShadowTransparency = 0.5,

                -- Glow
                Glow = Color3.fromRGB(99, 102, 241),
                GlowTransparency = 0.8,
            },

            -- Typography
            Fonts = {
                Header = Enum.Font.GothamBold,
                Title = Enum.Font.GothamMedium,
                Body = Enum.Font.Gotham,
                Label = Enum.Font.Gotham,
                Button = Enum.Font.GothamMedium,
                Mono = Enum.Font.RobotoMono,
                Code = Enum.Font.Code,
            },

            -- Font Sizes
            FontSizes = {
                XSmall = 10,
                Small = 12,
                Normal = 14,
                Medium = 16,
                Large = 18,
                XLarge = 24,
                XXLarge = 32,
                Header = 28,
                Title = 20,
            },

            -- Spacing
            Spacing = {
                None = 0,
                XSmall = 4,
                Small = 8,
                Medium = 12,
                Normal = 16,
                Large = 24,
                XLarge = 32,
                XXLarge = 48,
            },

            -- Border Radius
            CornerRadius = {
                None = UDim.new(0, 0),
                Small = UDim.new(0, 4),
                Medium = UDim.new(0, 8),
                Large = UDim.new(0, 12),
                XLarge = UDim.new(0, 16),
                Full = UDim.new(0, 9999),
            },

            -- Shadows
            Shadows = {
                None = { Offset = Vector2.new(0, 0), Blur = 0, Transparency = 1 },
                Small = { Offset = Vector2.new(0, 2), Blur = 4, Transparency = 0.7 },
                Medium = { Offset = Vector2.new(0, 4), Blur = 8, Transparency = 0.6 },
                Large = { Offset = Vector2.new(0, 8), Blur = 16, Transparency = 0.5 },
                XLarge = { Offset = Vector2.new(0, 12), Blur = 24, Transparency = 0.4 },
            },

            -- Animation
            Animation = {
                Fast = 0.15,
                Normal = 0.25,
                Slow = 0.4,
                VerySlow = 0.6,
                DefaultEasing = "QuadOut",
            },

            -- Liquid Glass Effect Settings
            Glass = {
                BackgroundTransparency = 0.7,
                BlurSize = 24,
                BorderTransparency = 0.5,
                Saturation = 1.2,
            },
        }

        --// Deep Copy
        local function DeepCopy(original)
            local copy

            if type(original) == "table" then
                copy = {}
                for key, value in pairs(original) do
                    copy[DeepCopy(key)] = DeepCopy(value)
                end
            else
                copy = original
            end

            return copy
        end

        --// Merge Tables
        local function MergeTables(base, override)
            local result = DeepCopy(base)

            for key, value in pairs(override) do
                if type(value) == "table" and type(result[key]) == "table" then
                    result[key] = MergeTables(result[key], value)
                else
                    result[key] = value
                end
            end

            return result
        end

        --// Validate Theme
        local function ValidateTheme(theme)
            if not theme.Name then
                warn("Theme must have a Name")
                return false
            end

            if not theme.Colors then
                warn("Theme must have Colors")
                return false
            end

            return true
        end

        --// Initialize with default theme
        local function InitializeDefaultTheme()
            CurrentTheme = DeepCopy(DefaultThemeStructure)
            RegisteredThemes["Default"] = CurrentTheme
        end

        --// Register Theme
        function Manager.RegisterTheme(theme)
            if not ValidateTheme(theme) then
                return false
            end

            -- Merge with default structure
            local fullTheme = MergeTables(DefaultThemeStructure, theme)
            fullTheme.Name = theme.Name

            RegisteredThemes[theme.Name] = fullTheme

            return true
        end

        --// Get Theme
        function Manager.GetTheme(themeName)
            return RegisteredThemes[themeName]
        end

        --// Get Current Theme
        function Manager.GetCurrentTheme()
            return CurrentTheme
        end

        --// Get Current Theme Name
        function Manager.GetCurrentThemeName()
            return CurrentThemeName
        end

        --// Set Theme
        function Manager.SetTheme(themeName, animate)
            local theme = RegisteredThemes[themeName]

            if not theme then
                warn("Theme not found:", themeName)
                return false
            end

            local previousTheme = CurrentTheme
            CurrentThemeName = themeName
            CurrentTheme = theme

            -- Notify listeners
            for _, listener in ipairs(ThemeListeners) do
                pcall(listener, theme, previousTheme, animate)
            end

            -- Update tracked elements
            for element, category in pairs(TrackedElements) do
                if element and element.Parent then
                    Manager.ApplyTheme(element, category, animate)
                else
                    TrackedElements[element] = nil
                end
            end

            return true
        end

        --// Get Available Themes
        function Manager.GetAvailableThemes()
            local themes = {}
            for name, _ in pairs(RegisteredThemes) do
                table.insert(themes, name)
            end
            return themes
        end

        --// On Theme Change
        function Manager.OnThemeChange(callback)
            table.insert(ThemeListeners, callback)

            -- Return disconnect function
            return function()
                for i, listener in ipairs(ThemeListeners) do
                    if listener == callback then
                        table.remove(ThemeListeners, i)
                        break
                    end
                end
            end
        end

        --// Get Color
        function Manager.GetColor(colorName)
            if CurrentTheme and CurrentTheme.Colors[colorName] then
                return CurrentTheme.Colors[colorName]
            end
            return DefaultThemeStructure.Colors[colorName]
        end

        --// Get Font
        function Manager.GetFont(fontName)
            if CurrentTheme and CurrentTheme.Fonts[fontName] then
                return CurrentTheme.Fonts[fontName]
            end
            return DefaultThemeStructure.Fonts[fontName]
        end

        --// Get Font Size
        function Manager.GetFontSize(sizeName)
            if CurrentTheme and CurrentTheme.FontSizes[sizeName] then
                return CurrentTheme.FontSizes[sizeName]
            end
            return DefaultThemeStructure.FontSizes[sizeName]
        end

        --// Get Spacing
        function Manager.GetSpacing(spacingName)
            if CurrentTheme and CurrentTheme.Spacing[spacingName] then
                return CurrentTheme.Spacing[spacingName]
            end
            return DefaultThemeStructure.Spacing[spacingName]
        end

        --// Get Corner Radius
        function Manager.GetCornerRadius(radiusName)
            if CurrentTheme and CurrentTheme.CornerRadius[radiusName] then
                return CurrentTheme.CornerRadius[radiusName]
            end
            return DefaultThemeStructure.CornerRadius[radiusName]
        end

        --// Get Shadow
        function Manager.GetShadow(shadowName)
            if CurrentTheme and CurrentTheme.Shadows[shadowName] then
                return CurrentTheme.Shadows[shadowName]
            end
            return DefaultThemeStructure.Shadows[shadowName]
        end

        --// Get Animation Duration
        function Manager.GetAnimationDuration(speedName)
            if CurrentTheme and CurrentTheme.Animation[speedName] then
                return CurrentTheme.Animation[speedName]
            end
            return DefaultThemeStructure.Animation[speedName]
        end

        --// Get Glass Settings
        function Manager.GetGlassSettings()
            if CurrentTheme and CurrentTheme.Glass then
                return CurrentTheme.Glass
            end
            return DefaultThemeStructure.Glass
        end

        --// Apply Theme to Element
        function Manager.ApplyTheme(element, category, animate)
            if not element then return end
            if not CurrentTheme then return end

            category = category or "Surface"

            local colors = CurrentTheme.Colors
            local duration = animate and CurrentTheme.Animation.Normal or 0

            -- Track element for future updates
            TrackedElements[element] = category

            -- Apply based on category
            if category == "Background" then
                if duration > 0 then
                    -- Use TweenService if available
                    local TweenService = game:GetService("TweenService")
                    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                    TweenService:Create(element, tweenInfo, {
                        BackgroundColor3 = colors.Background,
                    }):Play()
                else
                    element.BackgroundColor3 = colors.Background
                end
            elseif category == "Surface" then
                if duration > 0 then
                    local TweenService = game:GetService("TweenService")
                    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                    TweenService:Create(element, tweenInfo, {
                        BackgroundColor3 = colors.Surface,
                    }):Play()
                else
                    element.BackgroundColor3 = colors.Surface
                end
            elseif category == "Primary" then
                if duration > 0 then
                    local TweenService = game:GetService("TweenService")
                    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                    TweenService:Create(element, tweenInfo, {
                        BackgroundColor3 = colors.Primary,
                    }):Play()
                else
                    element.BackgroundColor3 = colors.Primary
                end
            elseif category == "Text" then
                if element:IsA("TextLabel") or element:IsA("TextButton") or element:IsA("TextBox") then
                    if duration > 0 then
                        local TweenService = game:GetService("TweenService")
                        local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                        TweenService:Create(element, tweenInfo, {
                            TextColor3 = colors.Text,
                        }):Play()
                    else
                        element.TextColor3 = colors.Text
                    end
                end
            end
        end

        --// Untrack Element
        function Manager.UntrackElement(element)
            TrackedElements[element] = nil
        end

        --// Clear Tracking
        function Manager.ClearTracking()
            TrackedElements = {}
        end

        --// Export Default Structure
        Manager.DefaultStructure = DefaultThemeStructure

        --// Initialize
        InitializeDefaultTheme()

        return Manager


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/init
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/init"] = function()
        local script = CreateMockScript("NexusUI/Themes/init")

        --[[
            NexusUI Theme System
            Comprehensive theming with 25+ presets

            Features:
            - Dynamic theme switching
            - Custom theme creation
            - Theme inheritance
            - Color palette generation
            - Accent color customization
        ]]

        --// Themes Module
        local Themes = {}

        --// Load sub-modules
        Themes.Manager = NexusRequire("NexusUI/Themes/Manager")
        Themes.Builder = NexusRequire("NexusUI/Themes/Builder")
        Themes.Palette = NexusRequire("NexusUI/Themes/Palette")
        Themes.Presets = NexusRequire("NexusUI/Themes/Presets")
        Themes.Effects = NexusRequire("NexusUI/Themes/Effects")

        --// Quick Access

        -- Get current theme
        function Themes.GetCurrent()
            return Themes.Manager.GetCurrentTheme()
        end

        -- Set theme by name
        function Themes.Set(themeName, animate)
            return Themes.Manager.SetTheme(themeName, animate)
        end

        -- Get theme by name
        function Themes.Get(themeName)
            return Themes.Manager.GetTheme(themeName)
        end

        -- Register custom theme
        function Themes.Register(theme)
            return Themes.Manager.RegisterTheme(theme)
        end

        -- Create new theme
        function Themes.Create(name, baseTheme)
            return Themes.Builder.Create(name, baseTheme)
        end

        -- Generate palette from color
        function Themes.GeneratePalette(baseColor)
            return Themes.Palette.Generate(baseColor)
        end

        -- Get all theme names
        function Themes.GetAvailable()
            return Themes.Manager.GetAvailableThemes()
        end

        -- Apply theme to element
        function Themes.ApplyTo(element, category)
            return Themes.Manager.ApplyTheme(element, category)
        end

        -- Subscribe to theme changes
        function Themes.OnChange(callback)
            return Themes.Manager.OnThemeChange(callback)
        end

        -- Get color from current theme
        function Themes.Color(colorName)
            return Themes.Manager.GetColor(colorName)
        end

        -- Get font from current theme
        function Themes.Font(fontName)
            return Themes.Manager.GetFont(fontName)
        end

        return Themes


    end


    -- ============================================================================
    -- Module: NexusUI/Effects/LiquidGlass
    -- ============================================================================
    NexusUI_Modules["NexusUI/Effects/LiquidGlass"] = function()
        local script = CreateMockScript("NexusUI/Effects/LiquidGlass")

        --[[
            NexusUI Liquid Glass Effect
            Premium liquid glass effect with refraction-like visuals
        ]]

        --// Services
        local RunService = game:GetService("RunService")
        local TweenService = game:GetService("TweenService")

        --// Liquid Glass Module
        local LiquidGlass = {}
        LiquidGlass.ClassName = "LiquidGlassEffect"

        --// Active Effects
        local ActiveEffects = {}
        local EffectIdCounter = 0

        local function GenerateEffectId()
            EffectIdCounter = EffectIdCounter + 1
            return "liquidglass_" .. EffectIdCounter
        end

        --// Default Configuration
        local DefaultConfig = {
            BackgroundTransparency = 0.75,
            TintColor = Color3.fromRGB(40, 42, 54),
            BorderColor = Color3.fromRGB(255, 255, 255),
            BorderTransparency = 0.6,
            BorderThickness = 1,
            CornerRadius = UDim.new(0, 12),
            RefractionStrength = 0.15,
            ChromaticAberration = true,
            ShimmerEnabled = true,
            ShimmerSpeed = 3,
            ShimmerOpacity = 0.1,
            HighlightEnabled = true,
            HighlightAngle = -45,
            AnimateOnHover = true,
            HoverGlow = true,
            GlowColor = Color3.fromRGB(99, 102, 241),
            GlowSize = 8,
            GlowTransparency = 0.8,
        }

        --// Create the liquid glass effect
        function LiquidGlass.Apply(element, config)
            if not element then
                warn("LiquidGlass.Apply: No element provided")
                return nil
            end

            config = config or {}

            -- Merge with defaults
            for key, defaultValue in pairs(DefaultConfig) do
                if config[key] == nil then
                    config[key] = defaultValue
                end
            end

            local effectId = GenerateEffectId()
            local effectData = {
                Id = effectId,
                Element = element,
                Config = config,
                Components = {},
                Connections = {},
                IsHovered = false,
            }

            -- Store original properties
            effectData.OriginalProperties = {
                BackgroundTransparency = element.BackgroundTransparency,
                BackgroundColor3 = element.BackgroundColor3,
                BorderSizePixel = element.BorderSizePixel,
            }

            -- Apply base transparency and color
            element.BackgroundTransparency = config.BackgroundTransparency
            element.BackgroundColor3 = config.TintColor
            element.BorderSizePixel = 0

            -- Add corner radius
            local corner = element:FindFirstChild("LG_Corner") or Instance.new("UICorner")
            corner.Name = "LG_Corner"
            corner.CornerRadius = config.CornerRadius
            corner.Parent = element
            effectData.Components.Corner = corner

            -- Add border stroke
            local stroke = element:FindFirstChild("LG_Stroke") or Instance.new("UIStroke")
            stroke.Name = "LG_Stroke"
            stroke.Color = config.BorderColor
            stroke.Transparency = config.BorderTransparency
            stroke.Thickness = config.BorderThickness
            stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
            stroke.Parent = element
            effectData.Components.Stroke = stroke

            -- Add highlight gradient (top-left light reflection)
            if config.HighlightEnabled then
                local highlightGradient = element:FindFirstChild("LG_Highlight") or Instance.new("UIGradient")
                highlightGradient.Name = "LG_Highlight"
                highlightGradient.Color = ColorSequence.new({
                    ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
                    ColorSequenceKeypoint.new(0.3, Color3.fromRGB(200, 200, 220)),
                    ColorSequenceKeypoint.new(0.7, config.TintColor),
                    ColorSequenceKeypoint.new(1, config.TintColor),
                })
                highlightGradient.Transparency = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 0.85),
                    NumberSequenceKeypoint.new(0.3, 0.92),
                    NumberSequenceKeypoint.new(0.7, 0.98),
                    NumberSequenceKeypoint.new(1, 1),
                })
                highlightGradient.Rotation = config.HighlightAngle
                highlightGradient.Parent = element
                effectData.Components.HighlightGradient = highlightGradient
            end

            -- Add shimmer effect (animated light sweep)
            if config.ShimmerEnabled then
                local shimmerFrame = Instance.new("Frame")
                shimmerFrame.Name = "LG_ShimmerFrame"
                shimmerFrame.Size = UDim2.new(1, 0, 1, 0)
                shimmerFrame.BackgroundTransparency = 1
                shimmerFrame.ClipsDescendants = true
                shimmerFrame.ZIndex = element.ZIndex + 1
                shimmerFrame.Parent = element

                local shimmerCorner = Instance.new("UICorner")
                shimmerCorner.CornerRadius = config.CornerRadius
                shimmerCorner.Parent = shimmerFrame

                local shimmer = Instance.new("Frame")
                shimmer.Name = "LG_Shimmer"
                shimmer.Size = UDim2.new(0.5, 0, 2, 0)
                shimmer.Position = UDim2.new(-0.5, 0, -0.5, 0)
                shimmer.AnchorPoint = Vector2.new(0, 0)
                shimmer.Rotation = 20
                shimmer.BackgroundTransparency = 1
                shimmer.ZIndex = element.ZIndex + 2
                shimmer.Parent = shimmerFrame

                local shimmerGradient = Instance.new("UIGradient")
                shimmerGradient.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
                shimmerGradient.Transparency = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 1),
                    NumberSequenceKeypoint.new(0.4, 1 - config.ShimmerOpacity),
                    NumberSequenceKeypoint.new(0.5, 1 - config.ShimmerOpacity * 1.5),
                    NumberSequenceKeypoint.new(0.6, 1 - config.ShimmerOpacity),
                    NumberSequenceKeypoint.new(1, 1),
                })
                shimmerGradient.Parent = shimmer

                effectData.Components.ShimmerFrame = shimmerFrame
                effectData.Components.Shimmer = shimmer

                -- Animate shimmer
                local function animateShimmer()
                    while effectData.Components.Shimmer and effectData.Components.Shimmer.Parent do
                        shimmer.Position = UDim2.new(-0.5, 0, -0.5, 0)

                        local tween = TweenService:Create(shimmer, TweenInfo.new(config.ShimmerSpeed, Enum.EasingStyle.Linear), {
                            Position = UDim2.new(1.5, 0, -0.5, 0),
                        })
                        tween:Play()
                        tween.Completed:Wait()

                        task.wait(2)
                    end
                end

                task.spawn(animateShimmer)
            end

            -- Add chromatic aberration effect (RGB split)
            if config.ChromaticAberration then
                -- Red channel (slight offset left)
                local chromaticRed = Instance.new("Frame")
                chromaticRed.Name = "LG_ChromaticRed"
                chromaticRed.Size = UDim2.new(1, 2, 1, 0)
                chromaticRed.Position = UDim2.new(0, -1, 0, 0)
                chromaticRed.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
                chromaticRed.BackgroundTransparency = 0.97
                chromaticRed.BorderSizePixel = 0
                chromaticRed.ZIndex = element.ZIndex - 1

                local redCorner = Instance.new("UICorner")
                redCorner.CornerRadius = config.CornerRadius
                redCorner.Parent = chromaticRed

                chromaticRed.Parent = element
                effectData.Components.ChromaticRed = chromaticRed

                -- Blue channel (slight offset right)
                local chromaticBlue = Instance.new("Frame")
                chromaticBlue.Name = "LG_ChromaticBlue"
                chromaticBlue.Size = UDim2.new(1, 2, 1, 0)
                chromaticBlue.Position = UDim2.new(0, 1, 0, 0)
                chromaticBlue.BackgroundColor3 = Color3.fromRGB(100, 100, 255)
                chromaticBlue.BackgroundTransparency = 0.97
                chromaticBlue.BorderSizePixel = 0
                chromaticBlue.ZIndex = element.ZIndex - 1

                local blueCorner = Instance.new("UICorner")
                blueCorner.CornerRadius = config.CornerRadius
                blueCorner.Parent = chromaticBlue

                chromaticBlue.Parent = element
                effectData.Components.ChromaticBlue = chromaticBlue
            end

            -- Add hover effects
            if config.AnimateOnHover then
                local mouseEnter = element.MouseEnter:Connect(function()
                    effectData.IsHovered = true

                    -- Brighten on hover
                    TweenService:Create(element, TweenInfo.new(0.2), {
                        BackgroundTransparency = config.BackgroundTransparency - 0.1,
                    }):Play()

                    TweenService:Create(stroke, TweenInfo.new(0.2), {
                        Transparency = config.BorderTransparency - 0.2,
                    }):Play()

                    if config.HoverGlow then
                        LiquidGlass._showGlow(effectData)
                    end
                end)

                local mouseLeave = element.MouseLeave:Connect(function()
                    effectData.IsHovered = false

                    TweenService:Create(element, TweenInfo.new(0.2), {
                        BackgroundTransparency = config.BackgroundTransparency,
                    }):Play()

                    TweenService:Create(stroke, TweenInfo.new(0.2), {
                        Transparency = config.BorderTransparency,
                    }):Play()

                    if config.HoverGlow then
                        LiquidGlass._hideGlow(effectData)
                    end
                end)

                table.insert(effectData.Connections, mouseEnter)
                table.insert(effectData.Connections, mouseLeave)
            end

            -- Store effect
            ActiveEffects[effectId] = effectData

            -- Return effect handle
            return {
                Id = effectId,

                SetTransparency = function(transparency)
                    config.BackgroundTransparency = transparency
                    if not effectData.IsHovered then
                        element.BackgroundTransparency = transparency
                    end
                end,

                SetTintColor = function(color)
                    config.TintColor = color
                    element.BackgroundColor3 = color
                end,

                SetBorderColor = function(color)
                    config.BorderColor = color
                    stroke.Color = color
                end,

                SetCornerRadius = function(radius)
                    config.CornerRadius = radius
                    corner.CornerRadius = radius
                end,

                ShowGlow = function()
                    LiquidGlass._showGlow(effectData)
                end,

                HideGlow = function()
                    LiquidGlass._hideGlow(effectData)
                end,

                Remove = function()
                    LiquidGlass.Remove(effectId)
                end,
            }
        end

        --// Show glow effect
        function LiquidGlass._showGlow(effectData)
            if effectData.Components.GlowFrame then
                TweenService:Create(effectData.Components.GlowFrame, TweenInfo.new(0.2), {
                    BackgroundTransparency = effectData.Config.GlowTransparency,
                }):Play()
                return
            end

            local element = effectData.Element
            local config = effectData.Config

            local glowFrame = Instance.new("Frame")
            glowFrame.Name = "LG_Glow"
            glowFrame.Size = UDim2.new(1, config.GlowSize * 2, 1, config.GlowSize * 2)
            glowFrame.Position = UDim2.new(0, -config.GlowSize, 0, -config.GlowSize)
            glowFrame.BackgroundColor3 = config.GlowColor
            glowFrame.BackgroundTransparency = 1
            glowFrame.BorderSizePixel = 0
            glowFrame.ZIndex = element.ZIndex - 2

            local glowCorner = Instance.new("UICorner")
            glowCorner.CornerRadius = UDim.new(config.CornerRadius.Scale, config.CornerRadius.Offset + config.GlowSize)
            glowCorner.Parent = glowFrame

            glowFrame.Parent = element.Parent
            effectData.Components.GlowFrame = glowFrame

            -- Position glow behind element
            glowFrame.Position = UDim2.new(
                element.Position.X.Scale,
                element.Position.X.Offset - config.GlowSize,
                element.Position.Y.Scale,
                element.Position.Y.Offset - config.GlowSize
            )
            glowFrame.Size = UDim2.new(
                element.Size.X.Scale,
                element.Size.X.Offset + config.GlowSize * 2,
                element.Size.Y.Scale,
                element.Size.Y.Offset + config.GlowSize * 2
            )

            TweenService:Create(glowFrame, TweenInfo.new(0.2), {
                BackgroundTransparency = config.GlowTransparency,
            }):Play()
        end

        --// Hide glow effect
        function LiquidGlass._hideGlow(effectData)
            if effectData.Components.GlowFrame then
                TweenService:Create(effectData.Components.GlowFrame, TweenInfo.new(0.2), {
                    BackgroundTransparency = 1,
                }):Play()
            end
        end

        --// Remove effect
        function LiquidGlass.Remove(effectId)
            local effectData = ActiveEffects[effectId]
            if not effectData then return end

            -- Disconnect all connections
            for _, connection in ipairs(effectData.Connections) do
                connection:Disconnect()
            end

            -- Destroy all components
            for _, component in pairs(effectData.Components) do
                if component and component.Parent then
                    component:Destroy()
                end
            end

            -- Restore original properties
            if effectData.Element and effectData.OriginalProperties then
                for prop, value in pairs(effectData.OriginalProperties) do
                    pcall(function()
                        effectData.Element[prop] = value
                    end)
                end
            end

            ActiveEffects[effectId] = nil
        end

        --// Remove all effects
        function LiquidGlass.RemoveAll()
            for effectId, _ in pairs(ActiveEffects) do
                LiquidGlass.Remove(effectId)
            end
        end

        --// Get effect count
        function LiquidGlass.GetActiveCount()
            local count = 0
            for _ in pairs(ActiveEffects) do
                count = count + 1
            end
            return count
        end

        return LiquidGlass


    end


    -- ============================================================================
    -- Module: NexusUI/Effects/Glassmorphism
    -- ============================================================================
    NexusUI_Modules["NexusUI/Effects/Glassmorphism"] = function()
        local script = CreateMockScript("NexusUI/Effects/Glassmorphism")

        --[[
            NexusUI Glassmorphism Effect
            Modern frosted glass UI effect
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Glassmorphism Module
        local Glassmorphism = {}
        Glassmorphism.ClassName = "GlassmorphismEffect"

        --// Active Effects
        local ActiveEffects = {}
        local EffectIdCounter = 0

        local function GenerateEffectId()
            EffectIdCounter = EffectIdCounter + 1
            return "glass_" .. EffectIdCounter
        end

        --// Default Configuration
        local DefaultConfig = {
            BackgroundTransparency = 0.6,
            TintColor = Color3.fromRGB(255, 255, 255),
            BlurIntensity = 0.8,
            BorderColor = Color3.fromRGB(255, 255, 255),
            BorderTransparency = 0.7,
            BorderThickness = 1,
            CornerRadius = UDim.new(0, 16),
            NoiseEnabled = true,
            NoiseOpacity = 0.03,
            ShadowEnabled = true,
            ShadowOffset = Vector2.new(0, 8),
            ShadowBlur = 24,
            ShadowTransparency = 0.7,
            InnerGlow = false,
            InnerGlowColor = Color3.fromRGB(255, 255, 255),
            InnerGlowTransparency = 0.95,
        }

        --// Apply glassmorphism effect
        function Glassmorphism.Apply(element, config)
            if not element then
                warn("Glassmorphism.Apply: No element provided")
                return nil
            end

            config = config or {}

            -- Merge with defaults
            for key, defaultValue in pairs(DefaultConfig) do
                if config[key] == nil then
                    config[key] = defaultValue
                end
            end

            local effectId = GenerateEffectId()
            local effectData = {
                Id = effectId,
                Element = element,
                Config = config,
                Components = {},
                Connections = {},
            }

            -- Store original properties
            effectData.OriginalProperties = {
                BackgroundTransparency = element.BackgroundTransparency,
                BackgroundColor3 = element.BackgroundColor3,
                BorderSizePixel = element.BorderSizePixel,
            }

            -- Apply base glass
            element.BackgroundTransparency = config.BackgroundTransparency
            element.BackgroundColor3 = config.TintColor
            element.BorderSizePixel = 0

            -- Add corner radius
            local corner = element:FindFirstChild("GM_Corner") or Instance.new("UICorner")
            corner.Name = "GM_Corner"
            corner.CornerRadius = config.CornerRadius
            corner.Parent = element
            effectData.Components.Corner = corner

            -- Add border
            local stroke = element:FindFirstChild("GM_Stroke") or Instance.new("UIStroke")
            stroke.Name = "GM_Stroke"
            stroke.Color = config.BorderColor
            stroke.Transparency = config.BorderTransparency
            stroke.Thickness = config.BorderThickness
            stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
            stroke.Parent = element
            effectData.Components.Stroke = stroke

            -- Add subtle gradient for depth
            local gradient = element:FindFirstChild("GM_Gradient") or Instance.new("UIGradient")
            gradient.Name = "GM_Gradient"
            gradient.Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
                ColorSequenceKeypoint.new(1, config.TintColor),
            })
            gradient.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 0.9),
                NumberSequenceKeypoint.new(1, 0.95),
            })
            gradient.Rotation = -45
            gradient.Parent = element
            effectData.Components.Gradient = gradient

            -- Add noise texture for frosted effect
            if config.NoiseEnabled then
                local noiseFrame = Instance.new("Frame")
                noiseFrame.Name = "GM_NoiseFrame"
                noiseFrame.Size = UDim2.new(1, 0, 1, 0)
                noiseFrame.BackgroundTransparency = 1
                noiseFrame.ClipsDescendants = true
                noiseFrame.ZIndex = element.ZIndex + 1

                local noiseCorner = Instance.new("UICorner")
                noiseCorner.CornerRadius = config.CornerRadius
                noiseCorner.Parent = noiseFrame

                local noise = Instance.new("ImageLabel")
                noise.Name = "GM_Noise"
                noise.Size = UDim2.new(1, 0, 1, 0)
                noise.BackgroundTransparency = 1
                noise.Image = "rbxassetid://6031094678" -- Noise texture
                noise.ImageTransparency = 1 - config.NoiseOpacity
                noise.ScaleType = Enum.ScaleType.Tile
                noise.TileSize = UDim2.new(0, 256, 0, 256)
                noise.ZIndex = element.ZIndex + 2
                noise.Parent = noiseFrame

                noiseFrame.Parent = element
                effectData.Components.NoiseFrame = noiseFrame
                effectData.Components.Noise = noise
            end

            -- Add shadow
            if config.ShadowEnabled then
                local shadowFrame = Instance.new("ImageLabel")
                shadowFrame.Name = "GM_Shadow"
                shadowFrame.Size = UDim2.new(1, config.ShadowBlur, 1, config.ShadowBlur)
                shadowFrame.Position = UDim2.new(0.5, config.ShadowOffset.X, 0.5, config.ShadowOffset.Y)
                shadowFrame.AnchorPoint = Vector2.new(0.5, 0.5)
                shadowFrame.BackgroundTransparency = 1
                shadowFrame.Image = "rbxassetid://6015897843" -- Shadow image
                shadowFrame.ImageTransparency = config.ShadowTransparency
                shadowFrame.ImageColor3 = Color3.fromRGB(0, 0, 0)
                shadowFrame.ScaleType = Enum.ScaleType.Slice
                shadowFrame.SliceCenter = Rect.new(49, 49, 450, 450)
                shadowFrame.ZIndex = element.ZIndex - 1
                shadowFrame.Parent = element.Parent

                -- Position shadow relative to element
                shadowFrame.Position = UDim2.new(
                    element.Position.X.Scale,
                    element.Position.X.Offset - config.ShadowBlur/2 + config.ShadowOffset.X,
                    element.Position.Y.Scale,
                    element.Position.Y.Offset - config.ShadowBlur/2 + config.ShadowOffset.Y
                )
                shadowFrame.Size = UDim2.new(
                    element.Size.X.Scale,
                    element.Size.X.Offset + config.ShadowBlur,
                    element.Size.Y.Scale,
                    element.Size.Y.Offset + config.ShadowBlur
                )

                effectData.Components.Shadow = shadowFrame
            end

            -- Add inner glow
            if config.InnerGlow then
                local innerGlowStroke = Instance.new("UIStroke")
                innerGlowStroke.Name = "GM_InnerGlow"
                innerGlowStroke.Color = config.InnerGlowColor
                innerGlowStroke.Transparency = config.InnerGlowTransparency
                innerGlowStroke.Thickness = 4
                innerGlowStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
                innerGlowStroke.Parent = element
                effectData.Components.InnerGlow = innerGlowStroke
            end

            -- Store effect
            ActiveEffects[effectId] = effectData

            -- Return effect handle
            return {
                Id = effectId,

                SetTransparency = function(transparency)
                    config.BackgroundTransparency = transparency
                    element.BackgroundTransparency = transparency
                end,

                SetTintColor = function(color)
                    config.TintColor = color
                    element.BackgroundColor3 = color
                end,

                SetBorderColor = function(color)
                    config.BorderColor = color
                    stroke.Color = color
                end,

                SetNoiseOpacity = function(opacity)
                    config.NoiseOpacity = opacity
                    if effectData.Components.Noise then
                        effectData.Components.Noise.ImageTransparency = 1 - opacity
                    end
                end,

                SetShadowOffset = function(offset)
                    config.ShadowOffset = offset
                    if effectData.Components.Shadow then
                        effectData.Components.Shadow.Position = UDim2.new(
                            element.Position.X.Scale,
                            element.Position.X.Offset - config.ShadowBlur/2 + offset.X,
                            element.Position.Y.Scale,
                            element.Position.Y.Offset - config.ShadowBlur/2 + offset.Y
                        )
                    end
                end,

                AnimateIn = function(duration)
                    duration = duration or 0.3

                    element.BackgroundTransparency = 1
                    if stroke then stroke.Transparency = 1 end
                    if effectData.Components.Shadow then effectData.Components.Shadow.ImageTransparency = 1 end

                    TweenService:Create(element, TweenInfo.new(duration), {
                        BackgroundTransparency = config.BackgroundTransparency,
                    }):Play()

                    if stroke then
                        TweenService:Create(stroke, TweenInfo.new(duration), {
                            Transparency = config.BorderTransparency,
                        }):Play()
                    end

                    if effectData.Components.Shadow then
                        TweenService:Create(effectData.Components.Shadow, TweenInfo.new(duration), {
                            ImageTransparency = config.ShadowTransparency,
                        }):Play()
                    end
                end,

                AnimateOut = function(duration)
                    duration = duration or 0.3

                    TweenService:Create(element, TweenInfo.new(duration), {
                        BackgroundTransparency = 1,
                    }):Play()

                    if stroke then
                        TweenService:Create(stroke, TweenInfo.new(duration), {
                            Transparency = 1,
                        }):Play()
                    end

                    if effectData.Components.Shadow then
                        TweenService:Create(effectData.Components.Shadow, TweenInfo.new(duration), {
                            ImageTransparency = 1,
                        }):Play()
                    end
                end,

                Remove = function()
                    Glassmorphism.Remove(effectId)
                end,
            }
        end

        --// Remove effect
        function Glassmorphism.Remove(effectId)
            local effectData = ActiveEffects[effectId]
            if not effectData then return end

            -- Disconnect all connections
            for _, connection in ipairs(effectData.Connections) do
                connection:Disconnect()
            end

            -- Destroy all components
            for _, component in pairs(effectData.Components) do
                if component and component.Parent then
                    component:Destroy()
                end
            end

            -- Restore original properties
            if effectData.Element and effectData.OriginalProperties then
                for prop, value in pairs(effectData.OriginalProperties) do
                    pcall(function()
                        effectData.Element[prop] = value
                    end)
                end
            end

            ActiveEffects[effectId] = nil
        end

        --// Remove all effects
        function Glassmorphism.RemoveAll()
            for effectId, _ in pairs(ActiveEffects) do
                Glassmorphism.Remove(effectId)
            end
        end

        --// Preset configurations
        Glassmorphism.Presets = {
            Light = {
                BackgroundTransparency = 0.5,
                TintColor = Color3.fromRGB(255, 255, 255),
                BorderColor = Color3.fromRGB(255, 255, 255),
                BorderTransparency = 0.6,
                NoiseOpacity = 0.02,
                ShadowTransparency = 0.8,
            },

            Dark = {
                BackgroundTransparency = 0.6,
                TintColor = Color3.fromRGB(30, 30, 35),
                BorderColor = Color3.fromRGB(80, 80, 90),
                BorderTransparency = 0.7,
                NoiseOpacity = 0.05,
                ShadowTransparency = 0.6,
            },

            Colorful = {
                BackgroundTransparency = 0.7,
                TintColor = Color3.fromRGB(99, 102, 241),
                BorderColor = Color3.fromRGB(167, 139, 250),
                BorderTransparency = 0.5,
                NoiseOpacity = 0.03,
                ShadowTransparency = 0.7,
                InnerGlow = true,
                InnerGlowColor = Color3.fromRGB(167, 139, 250),
            },

            Minimal = {
                BackgroundTransparency = 0.8,
                TintColor = Color3.fromRGB(245, 245, 250),
                BorderColor = Color3.fromRGB(200, 200, 210),
                BorderTransparency = 0.8,
                BorderThickness = 0.5,
                NoiseEnabled = false,
                ShadowEnabled = false,
            },
        }

        function Glassmorphism.GetPreset(name)
            return Glassmorphism.Presets[name]
        end

        return Glassmorphism


    end


    -- ============================================================================
    -- Module: NexusUI/Effects/Blur
    -- ============================================================================
    NexusUI_Modules["NexusUI/Effects/Blur"] = function()
        local script = CreateMockScript("NexusUI/Effects/Blur")

        --[[
            NexusUI Blur Effect
            Simulated blur effects for UI elements
        ]]

        --// Blur Module
        local Blur = {}
        Blur.ClassName = "BlurEffect"

        --// Note: Roblox doesn't have true UI blur, so we simulate it with transparency and overlays

        --// Default Configuration
        local DefaultConfig = {
            BlurSize = 10,
            BlurColor = Color3.fromRGB(0, 0, 0),
            BlurTransparency = 0.5,
            Layers = 3,
            Spread = 2,
        }

        --// Apply blur effect (simulated)
        function Blur.Apply(element, config)
            if not element then
                warn("Blur.Apply: No element provided")
                return nil
            end

            config = config or {}

            -- Merge with defaults
            for key, defaultValue in pairs(DefaultConfig) do
                if config[key] == nil then
                    config[key] = defaultValue
                end
            end

            local blurLayers = {}

            -- Create blur layers
            for i = 1, config.Layers do
                local offset = i * config.Spread
                local layerTransparency = config.BlurTransparency + (i / config.Layers) * (1 - config.BlurTransparency)

                local blurLayer = Instance.new("Frame")
                blurLayer.Name = "BlurLayer_" .. i
                blurLayer.Size = UDim2.new(1, offset * 2, 1, offset * 2)
                blurLayer.Position = UDim2.new(0, -offset, 0, -offset)
                blurLayer.BackgroundColor3 = config.BlurColor
                blurLayer.BackgroundTransparency = layerTransparency
                blurLayer.BorderSizePixel = 0
                blurLayer.ZIndex = element.ZIndex - i

                -- Match corner radius
                local elementCorner = element:FindFirstChildOfClass("UICorner")
                if elementCorner then
                    local corner = Instance.new("UICorner")
                    corner.CornerRadius = UDim.new(elementCorner.CornerRadius.Scale, elementCorner.CornerRadius.Offset + offset)
                    corner.Parent = blurLayer
                end

                blurLayer.Parent = element.Parent
                table.insert(blurLayers, blurLayer)
            end

            return {
                Layers = blurLayers,

                SetColor = function(color)
                    for _, layer in ipairs(blurLayers) do
                        layer.BackgroundColor3 = color
                    end
                end,

                SetTransparency = function(transparency)
                    for i, layer in ipairs(blurLayers) do
                        layer.BackgroundTransparency = transparency + (i / #blurLayers) * (1 - transparency)
                    end
                end,

                Remove = function()
                    for _, layer in ipairs(blurLayers) do
                        layer:Destroy()
                    end
                end,
            }
        end

        --// Background blur for entire screen
        function Blur.ApplyBackground(parent, config)
            config = config or {}

            local transparency = config.Transparency or 0.3
            local color = config.Color or Color3.fromRGB(0, 0, 0)

            local blurFrame = Instance.new("Frame")
            blurFrame.Name = "BackgroundBlur"
            blurFrame.Size = UDim2.new(1, 0, 1, 0)
            blurFrame.BackgroundColor3 = color
            blurFrame.BackgroundTransparency = transparency
            blurFrame.BorderSizePixel = 0
            blurFrame.ZIndex = 1
            blurFrame.Parent = parent

            return {
                Frame = blurFrame,

                SetTransparency = function(t)
                    blurFrame.BackgroundTransparency = t
                end,

                SetColor = function(c)
                    blurFrame.BackgroundColor3 = c
                end,

                Remove = function()
                    blurFrame:Destroy()
                end,
            }
        end

        return Blur


    end


    -- ============================================================================
    -- Module: NexusUI/Effects/Glow
    -- ============================================================================
    NexusUI_Modules["NexusUI/Effects/Glow"] = function()
        local script = CreateMockScript("NexusUI/Effects/Glow")

        --[[
            NexusUI Glow Effect
            Glowing effects for UI elements
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")
        local RunService = game:GetService("RunService")

        --// Glow Module
        local Glow = {}
        Glow.ClassName = "GlowEffect"

        --// Active Effects
        local ActiveEffects = {}
        local EffectIdCounter = 0

        local function GenerateEffectId()
            EffectIdCounter = EffectIdCounter + 1
            return "glow_" .. EffectIdCounter
        end

        --// Default Configuration
        local DefaultConfig = {
            Color = Color3.fromRGB(99, 102, 241),
            Size = 10,
            Transparency = 0.6,
            Animated = false,
            PulseSpeed = 1.5,
            PulseRange = { 0.5, 0.8 },
            Layers = 2,
        }

        --// Apply glow effect
        function Glow.Apply(element, config)
            if not element then
                warn("Glow.Apply: No element provided")
                return nil
            end

            config = config or {}

            -- Merge with defaults
            for key, defaultValue in pairs(DefaultConfig) do
                if config[key] == nil then
                    config[key] = defaultValue
                end
            end

            local effectId = GenerateEffectId()
            local effectData = {
                Id = effectId,
                Element = element,
                Config = config,
                GlowLayers = {},
                Connections = {},
            }

            -- Create glow layers
            for i = 1, config.Layers do
                local layerSize = config.Size * (i / config.Layers)
                local layerTransparency = config.Transparency + (1 - config.Transparency) * ((i - 1) / config.Layers)

                local glowLayer = Instance.new("Frame")
                glowLayer.Name = "GlowLayer_" .. i
                glowLayer.Size = UDim2.new(1, layerSize * 2, 1, layerSize * 2)
                glowLayer.Position = UDim2.new(0.5, 0, 0.5, 0)
                glowLayer.AnchorPoint = Vector2.new(0.5, 0.5)
                glowLayer.BackgroundColor3 = config.Color
                glowLayer.BackgroundTransparency = layerTransparency
                glowLayer.BorderSizePixel = 0
                glowLayer.ZIndex = element.ZIndex - 1

                -- Match corner radius
                local elementCorner = element:FindFirstChildOfClass("UICorner")
                if elementCorner then
                    local corner = Instance.new("UICorner")
                    corner.CornerRadius = UDim.new(elementCorner.CornerRadius.Scale, elementCorner.CornerRadius.Offset + layerSize)
                    corner.Parent = glowLayer
                else
                    local corner = Instance.new("UICorner")
                    corner.CornerRadius = UDim.new(0, layerSize)
                    corner.Parent = glowLayer
                end

                glowLayer.Parent = element
                table.insert(effectData.GlowLayers, glowLayer)
            end

            -- Animate if enabled
            if config.Animated then
                local function pulse()
                    while effectData.GlowLayers[1] and effectData.GlowLayers[1].Parent do
                        -- Pulse out
                        for _, layer in ipairs(effectData.GlowLayers) do
                            TweenService:Create(layer, TweenInfo.new(config.PulseSpeed / 2, Enum.EasingStyle.Sine), {
                                BackgroundTransparency = config.PulseRange[2],
                            }):Play()
                        end
                        task.wait(config.PulseSpeed / 2)

                        -- Pulse in
                        for _, layer in ipairs(effectData.GlowLayers) do
                            TweenService:Create(layer, TweenInfo.new(config.PulseSpeed / 2, Enum.EasingStyle.Sine), {
                                BackgroundTransparency = config.PulseRange[1],
                            }):Play()
                        end
                        task.wait(config.PulseSpeed / 2)
                    end
                end

                task.spawn(pulse)
            end

            -- Store effect
            ActiveEffects[effectId] = effectData

            -- Return effect handle
            return {
                Id = effectId,

                SetColor = function(color)
                    config.Color = color
                    for _, layer in ipairs(effectData.GlowLayers) do
                        TweenService:Create(layer, TweenInfo.new(0.2), {
                            BackgroundColor3 = color,
                        }):Play()
                    end
                end,

                SetSize = function(size)
                    config.Size = size
                    for i, layer in ipairs(effectData.GlowLayers) do
                        local layerSize = size * (i / #effectData.GlowLayers)
                        TweenService:Create(layer, TweenInfo.new(0.2), {
                            Size = UDim2.new(1, layerSize * 2, 1, layerSize * 2),
                        }):Play()
                    end
                end,

                SetTransparency = function(transparency)
                    config.Transparency = transparency
                    for i, layer in ipairs(effectData.GlowLayers) do
                        local layerTransparency = transparency + (1 - transparency) * ((i - 1) / #effectData.GlowLayers)
                        layer.BackgroundTransparency = layerTransparency
                    end
                end,

                Show = function(duration)
                    duration = duration or 0.2
                    for i, layer in ipairs(effectData.GlowLayers) do
                        local layerTransparency = config.Transparency + (1 - config.Transparency) * ((i - 1) / #effectData.GlowLayers)
                        layer.BackgroundTransparency = 1
                        TweenService:Create(layer, TweenInfo.new(duration), {
                            BackgroundTransparency = layerTransparency,
                        }):Play()
                    end
                end,

                Hide = function(duration)
                    duration = duration or 0.2
                    for _, layer in ipairs(effectData.GlowLayers) do
                        TweenService:Create(layer, TweenInfo.new(duration), {
                            BackgroundTransparency = 1,
                        }):Play()
                    end
                end,

                Remove = function()
                    Glow.Remove(effectId)
                end,
            }
        end

        --// Remove effect
        function Glow.Remove(effectId)
            local effectData = ActiveEffects[effectId]
            if not effectData then return end

            -- Disconnect connections
            for _, connection in ipairs(effectData.Connections) do
                connection:Disconnect()
            end

            -- Destroy glow layers
            for _, layer in ipairs(effectData.GlowLayers) do
                layer:Destroy()
            end

            ActiveEffects[effectId] = nil
        end

        --// Remove all effects
        function Glow.RemoveAll()
            for effectId, _ in pairs(ActiveEffects) do
                Glow.Remove(effectId)
            end
        end

        --// Quick glow flash
        function Glow.Flash(element, color, duration)
            color = color or Color3.fromRGB(255, 255, 255)
            duration = duration or 0.3

            local glow = Glow.Apply(element, {
                Color = color,
                Size = 15,
                Transparency = 0.3,
                Layers = 3,
            })

            task.delay(duration, function()
                if glow then
                    glow.Remove()
                end
            end)

            return glow
        end

        return Glow


    end


    -- ============================================================================
    -- Module: NexusUI/Effects/Shadow
    -- ============================================================================
    NexusUI_Modules["NexusUI/Effects/Shadow"] = function()
        local script = CreateMockScript("NexusUI/Effects/Shadow")

        --[[
            NexusUI Shadow Effect
            Drop shadows for UI elements
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Shadow Module
        local Shadow = {}
        Shadow.ClassName = "ShadowEffect"

        --// Default Configuration
        local DefaultConfig = {
            Color = Color3.fromRGB(0, 0, 0),
            Offset = Vector2.new(0, 4),
            Size = 16,
            Transparency = 0.6,
            Softness = 0.5,
        }

        --// Presets
        Shadow.Presets = {
            None = { Size = 0, Transparency = 1 },
            Small = { Offset = Vector2.new(0, 2), Size = 8, Transparency = 0.75 },
            Medium = { Offset = Vector2.new(0, 4), Size = 16, Transparency = 0.65 },
            Large = { Offset = Vector2.new(0, 8), Size = 24, Transparency = 0.55 },
            XLarge = { Offset = Vector2.new(0, 12), Size = 32, Transparency = 0.45 },
            Floating = { Offset = Vector2.new(0, 16), Size = 40, Transparency = 0.5 },
            Subtle = { Offset = Vector2.new(0, 2), Size = 4, Transparency = 0.85 },
            Sharp = { Offset = Vector2.new(2, 2), Size = 0, Transparency = 0.3 },
        }

        --// Apply shadow effect
        function Shadow.Apply(element, config)
            if not element then
                warn("Shadow.Apply: No element provided")
                return nil
            end

            -- Handle preset
            if type(config) == "string" then
                config = Shadow.Presets[config] or Shadow.Presets.Medium
            end

            config = config or {}

            -- Merge with defaults
            for key, defaultValue in pairs(DefaultConfig) do
                if config[key] == nil then
                    config[key] = defaultValue
                end
            end

            -- Create shadow image
            local shadow = Instance.new("ImageLabel")
            shadow.Name = "Shadow"
            shadow.BackgroundTransparency = 1
            shadow.ImageColor3 = config.Color
            shadow.ImageTransparency = config.Transparency
            shadow.Image = "rbxassetid://6015897843" -- Shadow asset
            shadow.ScaleType = Enum.ScaleType.Slice
            shadow.SliceCenter = Rect.new(49, 49, 450, 450)
            shadow.ZIndex = element.ZIndex - 1

            -- Calculate size and position
            local halfSize = config.Size / 2

            shadow.Size = UDim2.new(
                element.Size.X.Scale,
                element.Size.X.Offset + config.Size,
                element.Size.Y.Scale,
                element.Size.Y.Offset + config.Size
            )

            shadow.Position = UDim2.new(
                element.Position.X.Scale,
                element.Position.X.Offset - halfSize + config.Offset.X,
                element.Position.Y.Scale,
                element.Position.Y.Offset - halfSize + config.Offset.Y
            )

            shadow.AnchorPoint = element.AnchorPoint

            shadow.Parent = element.Parent

            -- Update function for when element moves/resizes
            local function updateShadow()
                shadow.Size = UDim2.new(
                    element.Size.X.Scale,
                    element.Size.X.Offset + config.Size,
                    element.Size.Y.Scale,
                    element.Size.Y.Offset + config.Size
                )

                shadow.Position = UDim2.new(
                    element.Position.X.Scale,
                    element.Position.X.Offset - halfSize + config.Offset.X,
                    element.Position.Y.Scale,
                    element.Position.Y.Offset - halfSize + config.Offset.Y
                )
            end

            -- Return shadow handle
            return {
                Shadow = shadow,

                SetColor = function(color)
                    config.Color = color
                    shadow.ImageColor3 = color
                end,

                SetOffset = function(offset)
                    config.Offset = offset
                    updateShadow()
                end,

                SetSize = function(size)
                    config.Size = size
                    halfSize = size / 2
                    updateShadow()
                end,

                SetTransparency = function(transparency)
                    config.Transparency = transparency
                    shadow.ImageTransparency = transparency
                end,

                Show = function(duration)
                    duration = duration or 0.2
                    shadow.ImageTransparency = 1
                    TweenService:Create(shadow, TweenInfo.new(duration), {
                        ImageTransparency = config.Transparency,
                    }):Play()
                end,

                Hide = function(duration)
                    duration = duration or 0.2
                    TweenService:Create(shadow, TweenInfo.new(duration), {
                        ImageTransparency = 1,
                    }):Play()
                end,

                Update = updateShadow,

                Remove = function()
                    shadow:Destroy()
                end,
            }
        end

        --// Apply inner shadow
        function Shadow.ApplyInner(element, config)
            config = config or {}

            local color = config.Color or Color3.fromRGB(0, 0, 0)
            local size = config.Size or 8
            local transparency = config.Transparency or 0.8

            -- Create inner shadow using gradient
            local topShadow = Instance.new("Frame")
            topShadow.Name = "InnerShadowTop"
            topShadow.Size = UDim2.new(1, 0, 0, size)
            topShadow.Position = UDim2.new(0, 0, 0, 0)
            topShadow.BackgroundColor3 = color
            topShadow.BorderSizePixel = 0
            topShadow.ZIndex = element.ZIndex + 1

            local topGradient = Instance.new("UIGradient")
            topGradient.Rotation = 90
            topGradient.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, transparency),
                NumberSequenceKeypoint.new(1, 1),
            })
            topGradient.Parent = topShadow

            topShadow.Parent = element

            return {
                TopShadow = topShadow,

                Remove = function()
                    topShadow:Destroy()
                end,
            }
        end

        return Shadow


    end


    -- ============================================================================
    -- Module: NexusUI/Effects/Gradient
    -- ============================================================================
    NexusUI_Modules["NexusUI/Effects/Gradient"] = function()
        local script = CreateMockScript("NexusUI/Effects/Gradient")

        --[[
            NexusUI Gradient Effect
            Dynamic gradient backgrounds and overlays
        ]]

        --// Services
        local RunService = game:GetService("RunService")
        local TweenService = game:GetService("TweenService")

        --// Gradient Module
        local Gradient = {}
        Gradient.ClassName = "GradientEffect"

        --// Default Configuration
        local DefaultConfig = {
            Colors = {
                Color3.fromRGB(99, 102, 241),
                Color3.fromRGB(168, 85, 247),
            },
            Rotation = 45,
            Animated = false,
            AnimationSpeed = 1,
            AnimationType = "Rotate", -- Rotate, Shift, Pulse
            Transparency = 0,
        }

        --// Presets
        Gradient.Presets = {
            Sunset = {
                Colors = {
                    Color3.fromRGB(249, 115, 22),
                    Color3.fromRGB(244, 63, 94),
                    Color3.fromRGB(168, 85, 247),
                },
                Rotation = 135,
            },

            Ocean = {
                Colors = {
                    Color3.fromRGB(6, 182, 212),
                    Color3.fromRGB(59, 130, 246),
                    Color3.fromRGB(99, 102, 241),
                },
                Rotation = 180,
            },

            Forest = {
                Colors = {
                    Color3.fromRGB(16, 185, 129),
                    Color3.fromRGB(34, 197, 94),
                    Color3.fromRGB(132, 204, 22),
                },
                Rotation = 120,
            },

            Fire = {
                Colors = {
                    Color3.fromRGB(239, 68, 68),
                    Color3.fromRGB(249, 115, 22),
                    Color3.fromRGB(234, 179, 8),
                },
                Rotation = 0,
            },

            Night = {
                Colors = {
                    Color3.fromRGB(15, 23, 42),
                    Color3.fromRGB(30, 41, 59),
                    Color3.fromRGB(51, 65, 85),
                },
                Rotation = 180,
            },

            Rainbow = {
                Colors = {
                    Color3.fromRGB(239, 68, 68),
                    Color3.fromRGB(249, 115, 22),
                    Color3.fromRGB(234, 179, 8),
                    Color3.fromRGB(34, 197, 94),
                    Color3.fromRGB(59, 130, 246),
                    Color3.fromRGB(139, 92, 246),
                },
                Rotation = 90,
            },

            Purple = {
                Colors = {
                    Color3.fromRGB(139, 92, 246),
                    Color3.fromRGB(168, 85, 247),
                    Color3.fromRGB(236, 72, 153),
                },
                Rotation = 135,
            },

            Mint = {
                Colors = {
                    Color3.fromRGB(110, 231, 183),
                    Color3.fromRGB(52, 211, 153),
                    Color3.fromRGB(20, 184, 166),
                },
                Rotation = 90,
            },
        }

        --// Apply gradient effect
        function Gradient.Apply(element, config)
            if not element then
                warn("Gradient.Apply: No element provided")
                return nil
            end

            -- Handle preset
            if type(config) == "string" then
                config = Gradient.Presets[config] or Gradient.Presets.Sunset
            end

            config = config or {}

            -- Merge with defaults
            for key, defaultValue in pairs(DefaultConfig) do
                if config[key] == nil then
                    config[key] = defaultValue
                end
            end

            -- Build color sequence
            local colorKeypoints = {}
            for i, color in ipairs(config.Colors) do
                local time = (i - 1) / (#config.Colors - 1)
                table.insert(colorKeypoints, ColorSequenceKeypoint.new(time, color))
            end

            -- Create gradient
            local gradient = element:FindFirstChild("GradientEffect") or Instance.new("UIGradient")
            gradient.Name = "GradientEffect"
            gradient.Color = ColorSequence.new(colorKeypoints)
            gradient.Rotation = config.Rotation

            if config.Transparency > 0 then
                gradient.Transparency = NumberSequence.new(config.Transparency)
            end

            gradient.Parent = element

            -- Animation
            local connection = nil

            if config.Animated then
                if config.AnimationType == "Rotate" then
                    connection = RunService.Heartbeat:Connect(function(dt)
                        gradient.Rotation = (gradient.Rotation + dt * config.AnimationSpeed * 60) % 360
                    end)
                elseif config.AnimationType == "Shift" then
                    local offset = 0
                    connection = RunService.Heartbeat:Connect(function(dt)
                        offset = (offset + dt * config.AnimationSpeed * 0.5) % 2
                        gradient.Offset = Vector2.new(offset - 1, 0)
                    end)
                elseif config.AnimationType == "Pulse" then
                    task.spawn(function()
                        while gradient.Parent do
                            TweenService:Create(gradient, TweenInfo.new(config.AnimationSpeed / 2), {
                                Offset = Vector2.new(0.1, 0.1),
                            }):Play()
                            task.wait(config.AnimationSpeed / 2)

                            TweenService:Create(gradient, TweenInfo.new(config.AnimationSpeed / 2), {
                                Offset = Vector2.new(-0.1, -0.1),
                            }):Play()
                            task.wait(config.AnimationSpeed / 2)
                        end
                    end)
                end
            end

            -- Return gradient handle
            return {
                Gradient = gradient,

                SetColors = function(colors)
                    local newKeypoints = {}
                    for i, color in ipairs(colors) do
                        local time = (i - 1) / (#colors - 1)
                        table.insert(newKeypoints, ColorSequenceKeypoint.new(time, color))
                    end
                    gradient.Color = ColorSequence.new(newKeypoints)
                end,

                SetRotation = function(rotation)
                    gradient.Rotation = rotation
                end,

                SetTransparency = function(transparency)
                    gradient.Transparency = NumberSequence.new(transparency)
                end,

                AnimateTo = function(newColors, duration)
                    duration = duration or 0.5
                    -- Note: Roblox doesn't support tweening ColorSequence directly
                    -- So we do it manually
                    local startColors = {}
                    for _, kp in ipairs(gradient.Color.Keypoints) do
                        table.insert(startColors, kp.Value)
                    end

                    local startTime = os.clock()
                    local tweenConn

                    tweenConn = RunService.Heartbeat:Connect(function()
                        local elapsed = os.clock() - startTime
                        local progress = math.min(elapsed / duration, 1)

                        local interpolatedKeypoints = {}
                        for i, endColor in ipairs(newColors) do
                            local time = (i - 1) / (#newColors - 1)
                            local startColor = startColors[math.min(i, #startColors)] or startColors[#startColors]
                            local interpolated = startColor:Lerp(endColor, progress)
                            table.insert(interpolatedKeypoints, ColorSequenceKeypoint.new(time, interpolated))
                        end

                        gradient.Color = ColorSequence.new(interpolatedKeypoints)

                        if progress >= 1 then
                            tweenConn:Disconnect()
                        end
                    end)
                end,

                StopAnimation = function()
                    if connection then
                        connection:Disconnect()
                        connection = nil
                    end
                end,

                Remove = function()
                    if connection then
                        connection:Disconnect()
                    end
                    gradient:Destroy()
                end,
            }
        end

        --// Create mesh gradient (multiple overlapping gradients)
        function Gradient.ApplyMesh(element, config)
            config = config or {}

            local layers = config.Layers or 3
            local colors = config.Colors or Gradient.Presets.Sunset.Colors
            local gradients = {}

            for i = 1, layers do
                local layerColors = {}
                for j = 1, 2 do
                    local colorIndex = ((i + j - 2) % #colors) + 1
                    table.insert(layerColors, colors[colorIndex])
                end

                local overlay = Instance.new("Frame")
                overlay.Name = "MeshGradientLayer_" .. i
                overlay.Size = UDim2.new(1, 0, 1, 0)
                overlay.BackgroundTransparency = 0.5 + (i / layers) * 0.3
                overlay.BackgroundColor3 = Color3.new(1, 1, 1)
                overlay.BorderSizePixel = 0
                overlay.ZIndex = element.ZIndex + i

                local gradient = Instance.new("UIGradient")
                gradient.Color = ColorSequence.new(layerColors)
                gradient.Rotation = (360 / layers) * (i - 1)
                gradient.Parent = overlay

                -- Match corner
                local elementCorner = element:FindFirstChildOfClass("UICorner")
                if elementCorner then
                    local corner = Instance.new("UICorner")
                    corner.CornerRadius = elementCorner.CornerRadius
                    corner.Parent = overlay
                end

                overlay.Parent = element
                table.insert(gradients, { Frame = overlay, Gradient = gradient })
            end

            return {
                Gradients = gradients,

                Remove = function()
                    for _, g in ipairs(gradients) do
                        g.Frame:Destroy()
                    end
                end,
            }
        end

        return Gradient


    end


    -- ============================================================================
    -- Module: NexusUI/Effects/Particles
    -- ============================================================================
    NexusUI_Modules["NexusUI/Effects/Particles"] = function()
        local script = CreateMockScript("NexusUI/Effects/Particles")

        --[[
            NexusUI Particles Effect
            Particle systems for UI backgrounds
        ]]

        --// Services
        local RunService = game:GetService("RunService")

        --// Particles Module
        local Particles = {}
        Particles.ClassName = "ParticlesEffect"

        --// Active Systems
        local ActiveSystems = {}
        local SystemIdCounter = 0

        local function GenerateSystemId()
            SystemIdCounter = SystemIdCounter + 1
            return "particles_" .. SystemIdCounter
        end

        --// Default Configuration
        local DefaultConfig = {
            ParticleCount = 50,
            ParticleSize = { Min = 2, Max = 6 },
            ParticleColor = Color3.fromRGB(255, 255, 255),
            ParticleTransparency = { Min = 0.6, Max = 0.9 },
            Speed = { Min = 10, Max = 30 },
            Direction = Vector2.new(0, -1), -- Up
            Spread = 45, -- Degrees
            Lifetime = { Min = 3, Max = 8 },
            FadeIn = true,
            FadeOut = true,
            Glow = false,
            GlowColor = Color3.fromRGB(99, 102, 241),
            Shape = "Circle", -- Circle, Square, Star
        }

        --// Presets
        Particles.Presets = {
            Snow = {
                ParticleCount = 80,
                ParticleSize = { Min = 3, Max = 8 },
                ParticleColor = Color3.fromRGB(255, 255, 255),
                Speed = { Min = 20, Max = 50 },
                Direction = Vector2.new(0.2, 1),
                Spread = 20,
                Lifetime = { Min = 5, Max = 10 },
            },

            Stars = {
                ParticleCount = 30,
                ParticleSize = { Min = 2, Max = 5 },
                ParticleColor = Color3.fromRGB(255, 255, 200),
                ParticleTransparency = { Min = 0.3, Max = 0.8 },
                Speed = { Min = 0, Max = 0 },
                Glow = true,
                GlowColor = Color3.fromRGB(255, 255, 150),
            },

            Rain = {
                ParticleCount = 100,
                ParticleSize = { Min = 1, Max = 2 },
                ParticleColor = Color3.fromRGB(150, 200, 255),
                Speed = { Min = 100, Max = 200 },
                Direction = Vector2.new(0.1, 1),
                Spread = 5,
                Lifetime = { Min = 1, Max = 2 },
                Shape = "Square",
            },

            Fireflies = {
                ParticleCount = 20,
                ParticleSize = { Min = 3, Max = 6 },
                ParticleColor = Color3.fromRGB(255, 230, 100),
                Speed = { Min = 5, Max = 15 },
                Direction = Vector2.new(0, 0),
                Spread = 180,
                Lifetime = { Min = 4, Max = 8 },
                Glow = true,
                GlowColor = Color3.fromRGB(255, 200, 50),
            },

            Bubbles = {
                ParticleCount = 25,
                ParticleSize = { Min = 8, Max = 20 },
                ParticleColor = Color3.fromRGB(200, 230, 255),
                ParticleTransparency = { Min = 0.7, Max = 0.9 },
                Speed = { Min = 15, Max = 40 },
                Direction = Vector2.new(0, -1),
                Spread = 30,
                Lifetime = { Min = 4, Max = 7 },
            },

            Confetti = {
                ParticleCount = 60,
                ParticleSize = { Min = 4, Max = 10 },
                Speed = { Min = 30, Max = 80 },
                Direction = Vector2.new(0, 1),
                Spread = 60,
                Lifetime = { Min = 3, Max = 6 },
                Shape = "Square",
            },
        }

        --// Particle class
        local Particle = {}
        Particle.__index = Particle

        function Particle.new(parent, config, containerSize)
            local self = setmetatable({}, Particle)

            -- Random properties
            local size = math.random(config.ParticleSize.Min, config.ParticleSize.Max)
            local transparency = config.ParticleTransparency.Min + math.random() * (config.ParticleTransparency.Max - config.ParticleTransparency.Min)
            local speed = config.Speed.Min + math.random() * (config.Speed.Max - config.Speed.Min)
            local lifetime = config.Lifetime.Min + math.random() * (config.Lifetime.Max - config.Lifetime.Min)

            -- Calculate direction with spread
            local spreadRad = math.rad(config.Spread)
            local baseAngle = math.atan2(config.Direction.Y, config.Direction.X)
            local angle = baseAngle + (math.random() - 0.5) * spreadRad * 2
            local direction = Vector2.new(math.cos(angle), math.sin(angle))

            -- Random start position
            local startX = math.random(0, containerSize.X)
            local startY = math.random(0, containerSize.Y)

            -- Create particle frame
            self.Frame = Instance.new("Frame")
            self.Frame.Name = "Particle"
            self.Frame.Size = UDim2.new(0, size, 0, size)
            self.Frame.Position = UDim2.new(0, startX, 0, startY)
            self.Frame.AnchorPoint = Vector2.new(0.5, 0.5)
            self.Frame.BackgroundColor3 = config.ParticleColor
            self.Frame.BackgroundTransparency = transparency
            self.Frame.BorderSizePixel = 0
            self.Frame.ZIndex = parent.ZIndex + 1

            -- Shape
            if config.Shape == "Circle" then
                local corner = Instance.new("UICorner")
                corner.CornerRadius = UDim.new(1, 0)
                corner.Parent = self.Frame
            elseif config.Shape == "Star" then
                -- Approximate star with rotation
                self.Frame.Rotation = 45
            end

            self.Frame.Parent = parent

            -- Properties
            self.Config = config
            self.ContainerSize = containerSize
            self.Position = Vector2.new(startX, startY)
            self.Direction = direction
            self.Speed = speed
            self.Lifetime = lifetime
            self.Age = 0
            self.TargetTransparency = transparency
            self.Size = size

            return self
        end

        function Particle:Update(dt)
            self.Age = self.Age + dt

            -- Check lifetime
            if self.Age >= self.Lifetime then
                return true -- Should respawn
            end

            -- Move particle
            self.Position = self.Position + self.Direction * self.Speed * dt

            -- Wrap around container
            if self.Position.X < -self.Size then
                self.Position = Vector2.new(self.ContainerSize.X + self.Size, self.Position.Y)
            elseif self.Position.X > self.ContainerSize.X + self.Size then
                self.Position = Vector2.new(-self.Size, self.Position.Y)
            end

            if self.Position.Y < -self.Size then
                self.Position = Vector2.new(self.Position.X, self.ContainerSize.Y + self.Size)
            elseif self.Position.Y > self.ContainerSize.Y + self.Size then
                self.Position = Vector2.new(self.Position.X, -self.Size)
            end

            -- Update visual
            self.Frame.Position = UDim2.new(0, self.Position.X, 0, self.Position.Y)

            -- Fade effect
            local lifeProgress = self.Age / self.Lifetime
            local transparency = self.TargetTransparency

            if self.Config.FadeIn and lifeProgress < 0.1 then
                transparency = 1 - (lifeProgress / 0.1) * (1 - self.TargetTransparency)
            elseif self.Config.FadeOut and lifeProgress > 0.8 then
                local fadeProgress = (lifeProgress - 0.8) / 0.2
                transparency = self.TargetTransparency + fadeProgress * (1 - self.TargetTransparency)
            end

            self.Frame.BackgroundTransparency = transparency

            return false
        end

        function Particle:Respawn()
            self.Age = 0

            -- New random position at edge
            local side = math.random(1, 4)
            if side == 1 then -- Top
                self.Position = Vector2.new(math.random(0, self.ContainerSize.X), -self.Size)
            elseif side == 2 then -- Bottom
                self.Position = Vector2.new(math.random(0, self.ContainerSize.X), self.ContainerSize.Y + self.Size)
            elseif side == 3 then -- Left
                self.Position = Vector2.new(-self.Size, math.random(0, self.ContainerSize.Y))
            else -- Right
                self.Position = Vector2.new(self.ContainerSize.X + self.Size, math.random(0, self.ContainerSize.Y))
            end

            self.Frame.Position = UDim2.new(0, self.Position.X, 0, self.Position.Y)
        end

        function Particle:Destroy()
            self.Frame:Destroy()
        end

        --// Create particle system
        function Particles.Create(parent, config)
            if not parent then
                warn("Particles.Create: No parent provided")
                return nil
            end

            -- Handle preset
            if type(config) == "string" then
                config = Particles.Presets[config] or Particles.Presets.Snow
            end

            config = config or {}

            -- Merge with defaults
            for key, defaultValue in pairs(DefaultConfig) do
                if config[key] == nil then
                    config[key] = defaultValue
                end
            end

            local systemId = GenerateSystemId()

            -- Create container
            local container = Instance.new("Frame")
            container.Name = "ParticleContainer"
            container.Size = UDim2.new(1, 0, 1, 0)
            container.BackgroundTransparency = 1
            container.ClipsDescendants = true
            container.ZIndex = parent.ZIndex
            container.Parent = parent

            -- Create particles
            local particles = {}
            local containerSize = container.AbsoluteSize

            for i = 1, config.ParticleCount do
                local particle = Particle.new(container, config, containerSize)
                table.insert(particles, particle)
            end

            -- Update loop
            local connection = RunService.Heartbeat:Connect(function(dt)
                containerSize = container.AbsoluteSize

                for _, particle in ipairs(particles) do
                    particle.ContainerSize = containerSize
                    local shouldRespawn = particle:Update(dt)

                    if shouldRespawn then
                        particle:Respawn()
                    end
                end
            end)

            -- Store system
            local systemData = {
                Id = systemId,
                Container = container,
                Particles = particles,
                Connection = connection,
                Config = config,
            }

            ActiveSystems[systemId] = systemData

            -- Return system handle
            return {
                Id = systemId,

                SetParticleCount = function(count)
                    -- Add or remove particles
                    while #particles < count do
                        local particle = Particle.new(container, config, containerSize)
                        table.insert(particles, particle)
                    end

                    while #particles > count do
                        local particle = table.remove(particles)
                        particle:Destroy()
                    end
                end,

                SetSpeed = function(min, max)
                    config.Speed = { Min = min, Max = max }
                end,

                SetColor = function(color)
                    config.ParticleColor = color
                    for _, particle in ipairs(particles) do
                        particle.Frame.BackgroundColor3 = color
                    end
                end,

                Pause = function()
                    if connection then
                        connection:Disconnect()
                        connection = nil
                    end
                end,

                Resume = function()
                    if not connection then
                        connection = RunService.Heartbeat:Connect(function(dt)
                            for _, particle in ipairs(particles) do
                                local shouldRespawn = particle:Update(dt)
                                if shouldRespawn then
                                    particle:Respawn()
                                end
                            end
                        end)
                    end
                end,

                Remove = function()
                    Particles.Remove(systemId)
                end,
            }
        end

        --// Remove particle system
        function Particles.Remove(systemId)
            local systemData = ActiveSystems[systemId]
            if not systemData then return end

            if systemData.Connection then
                systemData.Connection:Disconnect()
            end

            for _, particle in ipairs(systemData.Particles) do
                particle:Destroy()
            end

            systemData.Container:Destroy()
            ActiveSystems[systemId] = nil
        end

        --// Remove all systems
        function Particles.RemoveAll()
            for systemId, _ in pairs(ActiveSystems) do
                Particles.Remove(systemId)
            end
        end

        return Particles


    end


    -- ============================================================================
    -- Module: NexusUI/Effects/Ripple
    -- ============================================================================
    NexusUI_Modules["NexusUI/Effects/Ripple"] = function()
        local script = CreateMockScript("NexusUI/Effects/Ripple")

        --[[
            NexusUI Ripple Effect
            Material Design-style ripple effect
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")
        local UserInputService = game:GetService("UserInputService")

        --// Ripple Module
        local Ripple = {}
        Ripple.ClassName = "RippleEffect"

        --// Default Configuration
        local DefaultConfig = {
            Color = Color3.fromRGB(255, 255, 255),
            Transparency = 0.7,
            Duration = 0.6,
            MaxSize = 2, -- Multiplier of container size
            FadeDelay = 0.2,
        }

        --// Create single ripple
        function Ripple.Create(element, origin, config)
            if not element then
                warn("Ripple.Create: No element provided")
                return nil
            end

            config = config or {}

            -- Merge with defaults
            for key, defaultValue in pairs(DefaultConfig) do
                if config[key] == nil then
                    config[key] = defaultValue
                end
            end

            -- Calculate origin position
            local elementPosition = element.AbsolutePosition
            local elementSize = element.AbsoluteSize

            local rippleX, rippleY

            if origin then
                if typeof(origin) == "Vector2" then
                    rippleX = origin.X - elementPosition.X
                    rippleY = origin.Y - elementPosition.Y
                elseif typeof(origin) == "UDim2" then
                    rippleX = elementSize.X * origin.X.Scale + origin.X.Offset
                    rippleY = elementSize.Y * origin.Y.Scale + origin.Y.Offset
                end
            else
                rippleX = elementSize.X / 2
                rippleY = elementSize.Y / 2
            end

            -- Calculate max ripple size (diagonal of element * multiplier)
            local maxSize = math.sqrt(elementSize.X ^ 2 + elementSize.Y ^ 2) * config.MaxSize

            -- Create ripple container
            local container = Instance.new("Frame")
            container.Name = "RippleContainer"
            container.Size = UDim2.new(1, 0, 1, 0)
            container.BackgroundTransparency = 1
            container.ClipsDescendants = true
            container.ZIndex = element.ZIndex + 10

            -- Match corner radius
            local elementCorner = element:FindFirstChildOfClass("UICorner")
            if elementCorner then
                local corner = Instance.new("UICorner")
                corner.CornerRadius = elementCorner.CornerRadius
                corner.Parent = container
            end

            container.Parent = element

            -- Create ripple circle
            local ripple = Instance.new("Frame")
            ripple.Name = "Ripple"
            ripple.Size = UDim2.new(0, 0, 0, 0)
            ripple.Position = UDim2.new(0, rippleX, 0, rippleY)
            ripple.AnchorPoint = Vector2.new(0.5, 0.5)
            ripple.BackgroundColor3 = config.Color
            ripple.BackgroundTransparency = config.Transparency
            ripple.BorderSizePixel = 0
            ripple.ZIndex = container.ZIndex + 1

            local rippleCorner = Instance.new("UICorner")
            rippleCorner.CornerRadius = UDim.new(1, 0)
            rippleCorner.Parent = ripple

            ripple.Parent = container

            -- Animate ripple
            local expandTween = TweenService:Create(ripple, TweenInfo.new(config.Duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                Size = UDim2.new(0, maxSize, 0, maxSize),
            })

            expandTween:Play()

            -- Fade out
            task.delay(config.FadeDelay, function()
                local fadeTween = TweenService:Create(ripple, TweenInfo.new(config.Duration - config.FadeDelay, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                    BackgroundTransparency = 1,
                })

                fadeTween:Play()
                fadeTween.Completed:Connect(function()
                    container:Destroy()
                end)
            end)

            return {
                Container = container,
                Ripple = ripple,

                Cancel = function()
                    container:Destroy()
                end,
            }
        end

        --// Create ripple from mouse position
        function Ripple.CreateFromMouse(element, config)
            local mousePosition = UserInputService:GetMouseLocation()
            return Ripple.Create(element, mousePosition, config)
        end

        --// Add ripple effect to element (auto-triggers on click)
        function Ripple.AddTo(element, config)
            config = config or {}

            local connections = {}

            -- Handle InputBegan
            local inputBegan = element.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    local position = Vector2.new(input.Position.X, input.Position.Y)
                    Ripple.Create(element, position, config)
                end
            end)

            table.insert(connections, inputBegan)

            return {
                Remove = function()
                    for _, connection in ipairs(connections) do
                        connection:Disconnect()
                    end
                end,
            }
        end

        --// Add hover ripple (subtle ripple on hover)
        function Ripple.AddHover(element, config)
            config = config or {
                Color = Color3.fromRGB(255, 255, 255),
                Transparency = 0.9,
                Duration = 0.3,
                MaxSize = 1.2,
            }

            local connections = {}
            local currentRipple = nil

            local mouseEnter = element.MouseEnter:Connect(function()
                -- Cancel previous ripple
                if currentRipple then
                    currentRipple.Cancel()
                end

                currentRipple = Ripple.Create(element, UDim2.new(0.5, 0, 0.5, 0), config)
            end)

            local mouseLeave = element.MouseLeave:Connect(function()
                -- Let the current ripple fade naturally
                currentRipple = nil
            end)

            table.insert(connections, mouseEnter)
            table.insert(connections, mouseLeave)

            return {
                Remove = function()
                    for _, connection in ipairs(connections) do
                        connection:Disconnect()
                    end
                end,
            }
        end

        --// Multiple ripples (burst effect)
        function Ripple.Burst(element, count, config)
            count = count or 3
            config = config or {}

            local ripples = {}

            for i = 1, count do
                task.delay((i - 1) * 0.1, function()
                    local ripple = Ripple.Create(element, UDim2.new(0.5, 0, 0.5, 0), {
                        Color = config.Color or Color3.fromRGB(255, 255, 255),
                        Transparency = (config.Transparency or 0.7) + (i - 1) * 0.1,
                        Duration = (config.Duration or 0.6) + (i - 1) * 0.1,
                        MaxSize = (config.MaxSize or 2) - (i - 1) * 0.3,
                    })
                    table.insert(ripples, ripple)
                end)
            end

            return ripples
        end

        return Ripple


    end


    -- ============================================================================
    -- Module: NexusUI/Effects/init
    -- ============================================================================
    NexusUI_Modules["NexusUI/Effects/init"] = function()
        local script = CreateMockScript("NexusUI/Effects/init")

        --[[
            NexusUI Effects System
            Visual effects including liquid glass, blur, glow
        ]]

        --// Effects Module
        local Effects = {}

        -- Load sub-modules
        Effects.LiquidGlass = NexusRequire("NexusUI/Effects/LiquidGlass")
        Effects.Glassmorphism = NexusRequire("NexusUI/Effects/Glassmorphism")
        Effects.Blur = NexusRequire("NexusUI/Effects/Blur")
        Effects.Glow = NexusRequire("NexusUI/Effects/Glow")
        Effects.Shadow = NexusRequire("NexusUI/Effects/Shadow")
        Effects.Gradient = NexusRequire("NexusUI/Effects/Gradient")
        Effects.Particles = NexusRequire("NexusUI/Effects/Particles")
        Effects.Ripple = NexusRequire("NexusUI/Effects/Ripple")

        -- Quick access functions
        function Effects.ApplyLiquidGlass(element, config)
            return Effects.LiquidGlass.Apply(element, config)
        end

        function Effects.ApplyGlassmorphism(element, config)
            return Effects.Glassmorphism.Apply(element, config)
        end

        function Effects.ApplyBlur(element, config)
            return Effects.Blur.Apply(element, config)
        end

        function Effects.ApplyGlow(element, config)
            return Effects.Glow.Apply(element, config)
        end

        function Effects.ApplyShadow(element, config)
            return Effects.Shadow.Apply(element, config)
        end

        function Effects.ApplyGradient(element, config)
            return Effects.Gradient.Apply(element, config)
        end

        function Effects.CreateParticles(parent, config)
            return Effects.Particles.Create(parent, config)
        end

        function Effects.CreateRipple(element, origin)
            return Effects.Ripple.Create(element, origin)
        end

        return Effects


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Base
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Base"] = function()
        local script = CreateMockScript("NexusUI/Components/Base")

        --[[
            NexusUI Base Component
            Foundation class for all UI components
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Base Component Module
        local Base = {}
        Base.__index = Base
        Base.ClassName = "BaseComponent"

        --// Component ID Counter
        local ComponentIdCounter = 0

        local function GenerateComponentId()
            ComponentIdCounter = ComponentIdCounter + 1
            return "component_" .. ComponentIdCounter
        end

        --// Constructor
        function Base.new(config)
            local self = setmetatable({}, Base)

            config = config or {}

            -- Core properties
            self.Id = GenerateComponentId()
            self.Name = config.Name or self.ClassName
            self.Parent = nil
            self.Instance = nil
            self.Children = {}
            self.Connections = {}
            self.IsDestroyed = false
            self.IsVisible = true
            self.IsEnabled = true

            -- Theme reference
            self.ThemeManager = nil
            self.ThemeConnection = nil

            -- Animation settings
            self.AnimationDuration = config.AnimationDuration or 0.2
            self.AnimationEasing = config.AnimationEasing or Enum.EasingStyle.Quad

            -- Event signals
            self.OnDestroy = nil
            self.OnVisibilityChanged = nil
            self.OnEnabledChanged = nil

            -- Callbacks
            self._callbacks = {}

            return self
        end

        --// Create base frame
        function Base:_createBaseFrame(className, parent)
            className = className or "Frame"

            local frame = Instance.new(className)
            frame.Name = self.Name
            frame.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            frame.BackgroundTransparency = 0
            frame.BorderSizePixel = 0
            frame.Size = UDim2.new(0, 100, 0, 30)
            frame.Position = UDim2.new(0, 0, 0, 0)

            if parent then
                frame.Parent = parent
            end

            self.Instance = frame
            return frame
        end

        --// Apply base properties
        function Base:_applyProperties(config)
            if not self.Instance then return end

            local frame = self.Instance

            -- Size
            if config.Size then
                frame.Size = config.Size
            end

            -- Position
            if config.Position then
                frame.Position = config.Position
            end

            -- Anchor Point
            if config.AnchorPoint then
                frame.AnchorPoint = config.AnchorPoint
            end

            -- Background
            if config.BackgroundColor3 then
                frame.BackgroundColor3 = config.BackgroundColor3
            end

            if config.BackgroundTransparency then
                frame.BackgroundTransparency = config.BackgroundTransparency
            end

            -- ZIndex
            if config.ZIndex then
                frame.ZIndex = config.ZIndex
            end

            -- Visible
            if config.Visible ~= nil then
                frame.Visible = config.Visible
                self.IsVisible = config.Visible
            end

            -- Layout Order
            if config.LayoutOrder then
                frame.LayoutOrder = config.LayoutOrder
            end

            -- Corner Radius
            if config.CornerRadius then
                local corner = frame:FindFirstChildOfClass("UICorner") or Instance.new("UICorner")
                corner.CornerRadius = config.CornerRadius
                corner.Parent = frame
            end

            -- Padding
            if config.Padding then
                local padding = frame:FindFirstChildOfClass("UIPadding") or Instance.new("UIPadding")
                if typeof(config.Padding) == "UDim" then
                    padding.PaddingTop = config.Padding
                    padding.PaddingBottom = config.Padding
                    padding.PaddingLeft = config.Padding
                    padding.PaddingRight = config.Padding
                elseif typeof(config.Padding) == "table" then
                    padding.PaddingTop = config.Padding.Top or UDim.new(0, 0)
                    padding.PaddingBottom = config.Padding.Bottom or UDim.new(0, 0)
                    padding.PaddingLeft = config.Padding.Left or UDim.new(0, 0)
                    padding.PaddingRight = config.Padding.Right or UDim.new(0, 0)
                end
                padding.Parent = frame
            end
        end

        --// Setup theme connection
        function Base:_setupTheme(themeManager)
            if not themeManager then return end

            self.ThemeManager = themeManager

            -- Subscribe to theme changes
            self.ThemeConnection = themeManager.OnThemeChange(function(theme, previousTheme, animate)
                self:_applyTheme(theme, animate)
            end)

            -- Apply current theme
            local currentTheme = themeManager.GetCurrentTheme()
            if currentTheme then
                self:_applyTheme(currentTheme, false)
            end
        end

        --// Apply theme (override in subclasses)
        function Base:_applyTheme(theme, animate)
            -- Override in subclasses
        end

        --// Connect event
        function Base:_connect(signal, callback)
            local connection = signal:Connect(callback)
            table.insert(self.Connections, connection)
            return connection
        end

        --// Disconnect all
        function Base:_disconnectAll()
            for _, connection in ipairs(self.Connections) do
                if connection.Connected then
                    connection:Disconnect()
                end
            end
            self.Connections = {}

            if self.ThemeConnection then
                self.ThemeConnection()
                self.ThemeConnection = nil
            end
        end

        --// Add child component
        function Base:AddChild(child)
            if child.Instance and self.Instance then
                child.Instance.Parent = self.Instance
                child.Parent = self
                table.insert(self.Children, child)
            end
            return child
        end

        --// Remove child component
        function Base:RemoveChild(child)
            for i, c in ipairs(self.Children) do
                if c == child then
                    table.remove(self.Children, i)
                    child.Parent = nil
                    break
                end
            end
            return child
        end

        --// Get child by name
        function Base:GetChild(name)
            for _, child in ipairs(self.Children) do
                if child.Name == name then
                    return child
                end
            end
            return nil
        end

        --// Get all children
        function Base:GetChildren()
            return self.Children
        end

        --// Set parent
        function Base:SetParent(parent)
            if self.Instance then
                if parent then
                    if parent.Instance then
                        self.Instance.Parent = parent.Instance
                    else
                        self.Instance.Parent = parent
                    end
                else
                    self.Instance.Parent = nil
                end
            end
            self.Parent = parent
            return self
        end

        --// Get parent
        function Base:GetParent()
            return self.Parent
        end

        --// Set visibility
        function Base:SetVisible(visible, animate)
            if self.IsVisible == visible then return self end

            self.IsVisible = visible

            if self.Instance then
                if animate then
                    local targetTransparency = visible and 0 or 1
                    TweenService:Create(self.Instance, TweenInfo.new(self.AnimationDuration), {
                        BackgroundTransparency = targetTransparency,
                    }):Play()

                    if not visible then
                        task.delay(self.AnimationDuration, function()
                            if not self.IsDestroyed then
                                self.Instance.Visible = false
                            end
                        end)
                    else
                        self.Instance.Visible = true
                    end
                else
                    self.Instance.Visible = visible
                end
            end

            if self.OnVisibilityChanged then
                self.OnVisibilityChanged(visible)
            end

            return self
        end

        --// Get visibility
        function Base:IsVisibleState()
            return self.IsVisible
        end

        --// Show
        function Base:Show(animate)
            return self:SetVisible(true, animate)
        end

        --// Hide
        function Base:Hide(animate)
            return self:SetVisible(false, animate)
        end

        --// Toggle visibility
        function Base:ToggleVisibility(animate)
            return self:SetVisible(not self.IsVisible, animate)
        end

        --// Set enabled
        function Base:SetEnabled(enabled)
            if self.IsEnabled == enabled then return self end

            self.IsEnabled = enabled

            -- Override in subclasses to change appearance

            if self.OnEnabledChanged then
                self.OnEnabledChanged(enabled)
            end

            return self
        end

        --// Get enabled
        function Base:IsEnabledState()
            return self.IsEnabled
        end

        --// Set position
        function Base:SetPosition(position, animate)
            if not self.Instance then return self end

            if animate then
                TweenService:Create(self.Instance, TweenInfo.new(self.AnimationDuration, self.AnimationEasing), {
                    Position = position,
                }):Play()
            else
                self.Instance.Position = position
            end

            return self
        end

        --// Get position
        function Base:GetPosition()
            if self.Instance then
                return self.Instance.Position
            end
            return UDim2.new(0, 0, 0, 0)
        end

        --// Set size
        function Base:SetSize(size, animate)
            if not self.Instance then return self end

            if animate then
                TweenService:Create(self.Instance, TweenInfo.new(self.AnimationDuration, self.AnimationEasing), {
                    Size = size,
                }):Play()
            else
                self.Instance.Size = size
            end

            return self
        end

        --// Get size
        function Base:GetSize()
            if self.Instance then
                return self.Instance.Size
            end
            return UDim2.new(0, 0, 0, 0)
        end

        --// Get absolute size
        function Base:GetAbsoluteSize()
            if self.Instance then
                return self.Instance.AbsoluteSize
            end
            return Vector2.new(0, 0)
        end

        --// Get absolute position
        function Base:GetAbsolutePosition()
            if self.Instance then
                return self.Instance.AbsolutePosition
            end
            return Vector2.new(0, 0)
        end

        --// Set ZIndex
        function Base:SetZIndex(zIndex)
            if self.Instance then
                self.Instance.ZIndex = zIndex
            end
            return self
        end

        --// Set layout order
        function Base:SetLayoutOrder(order)
            if self.Instance then
                self.Instance.LayoutOrder = order
            end
            return self
        end

        --// On callback
        function Base:On(eventName, callback)
            if not self._callbacks[eventName] then
                self._callbacks[eventName] = {}
            end
            table.insert(self._callbacks[eventName], callback)
            return self
        end

        --// Fire callback
        function Base:_fire(eventName, ...)
            if self._callbacks[eventName] then
                for _, callback in ipairs(self._callbacks[eventName]) do
                    pcall(callback, ...)
                end
            end
        end

        --// Get instance
        function Base:GetInstance()
            return self.Instance
        end

        --// Destroy
        function Base:Destroy()
            if self.IsDestroyed then return end

            self.IsDestroyed = true

            -- Fire destroy callback
            if self.OnDestroy then
                pcall(self.OnDestroy, self)
            end

            self:_fire("Destroy", self)

            -- Destroy children
            for _, child in ipairs(self.Children) do
                child:Destroy()
            end
            self.Children = {}

            -- Disconnect all
            self:_disconnectAll()

            -- Destroy instance
            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end

            -- Clear callbacks
            self._callbacks = {}

            -- Remove from parent
            if self.Parent and self.Parent.RemoveChild then
                self.Parent:RemoveChild(self)
            end
            self.Parent = nil
        end

        --// Clone (creates a new component with same properties)
        function Base:Clone()
            -- Override in subclasses
            warn("Clone not implemented for " .. self.ClassName)
            return nil
        end

        return Base


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Container
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Container"] = function()
        local script = CreateMockScript("NexusUI/Components/Container")

        --[[
            NexusUI Container Component
            Base class for components that can hold children
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Container Component Module
        local Container = setmetatable({}, { __index = Base })
        Container.__index = Container
        Container.ClassName = "Container"

        --// Constructor
        function Container.new(config)
            local self = setmetatable(Base.new(config), Container)

            config = config or {}

            -- Container-specific properties
            self.Layout = config.Layout or "None" -- None, List, Grid, Flex
            self.LayoutConfig = config.LayoutConfig or {}
            self.Scrollable = config.Scrollable or false
            self.AutoSize = config.AutoSize or false
            self.ContentPadding = config.ContentPadding or UDim.new(0, 8)
            self.ItemSpacing = config.ItemSpacing or UDim.new(0, 4)

            -- Layout instance
            self._layoutInstance = nil

            return self
        end

        --// Create container
        function Container:Create(parent)
            local frame = self:_createBaseFrame("Frame", parent)
            frame.ClipsDescendants = true

            -- Apply properties from config
            if self.Scrollable then
                -- Create scroll frame
                local scrollFrame = Instance.new("ScrollingFrame")
                scrollFrame.Name = "ScrollContent"
                scrollFrame.Size = UDim2.new(1, 0, 1, 0)
                scrollFrame.BackgroundTransparency = 1
                scrollFrame.BorderSizePixel = 0
                scrollFrame.ScrollBarThickness = 4
                scrollFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 110)
                scrollFrame.ScrollBarImageTransparency = 0.5
                scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
                scrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
                scrollFrame.Parent = frame

                self._contentFrame = scrollFrame
            else
                self._contentFrame = frame
            end

            -- Setup layout
            self:_setupLayout()

            return self
        end

        --// Setup layout
        function Container:_setupLayout()
            if not self._contentFrame then return end

            -- Remove existing layout
            if self._layoutInstance then
                self._layoutInstance:Destroy()
                self._layoutInstance = nil
            end

            if self.Layout == "List" then
                local list = Instance.new("UIListLayout")
                list.SortOrder = Enum.SortOrder.LayoutOrder
                list.Padding = self.ItemSpacing
                list.FillDirection = self.LayoutConfig.Direction or Enum.FillDirection.Vertical
                list.HorizontalAlignment = self.LayoutConfig.HorizontalAlignment or Enum.HorizontalAlignment.Left
                list.VerticalAlignment = self.LayoutConfig.VerticalAlignment or Enum.VerticalAlignment.Top
                list.Parent = self._contentFrame
                self._layoutInstance = list

                -- Auto size handling
                if self.AutoSize then
                    self:_connect(list:GetPropertyChangedSignal("AbsoluteContentSize"), function()
                        self:_updateAutoSize()
                    end)
                end

            elseif self.Layout == "Grid" then
                local grid = Instance.new("UIGridLayout")
                grid.SortOrder = Enum.SortOrder.LayoutOrder
                grid.CellSize = self.LayoutConfig.CellSize or UDim2.new(0, 100, 0, 100)
                grid.CellPadding = UDim2.new(self.ItemSpacing.Scale, self.ItemSpacing.Offset, self.ItemSpacing.Scale, self.ItemSpacing.Offset)
                grid.FillDirection = self.LayoutConfig.Direction or Enum.FillDirection.Horizontal
                grid.FillDirectionMaxCells = self.LayoutConfig.MaxCells or 0
                grid.HorizontalAlignment = self.LayoutConfig.HorizontalAlignment or Enum.HorizontalAlignment.Left
                grid.VerticalAlignment = self.LayoutConfig.VerticalAlignment or Enum.VerticalAlignment.Top
                grid.Parent = self._contentFrame
                self._layoutInstance = grid

                if self.AutoSize then
                    self:_connect(grid:GetPropertyChangedSignal("AbsoluteContentSize"), function()
                        self:_updateAutoSize()
                    end)
                end

            elseif self.Layout == "Flex" then
                -- Flex is implemented as a special list layout with flex grow
                local list = Instance.new("UIListLayout")
                list.SortOrder = Enum.SortOrder.LayoutOrder
                list.Padding = self.ItemSpacing
                list.FillDirection = self.LayoutConfig.Direction or Enum.FillDirection.Horizontal
                list.HorizontalAlignment = self.LayoutConfig.HorizontalAlignment or Enum.HorizontalAlignment.Left
                list.VerticalAlignment = self.LayoutConfig.VerticalAlignment or Enum.VerticalAlignment.Top
                list.Parent = self._contentFrame
                self._layoutInstance = list
            end

            -- Add padding
            if self.ContentPadding then
                local padding = self._contentFrame:FindFirstChildOfClass("UIPadding") or Instance.new("UIPadding")
                padding.PaddingTop = self.ContentPadding
                padding.PaddingBottom = self.ContentPadding
                padding.PaddingLeft = self.ContentPadding
                padding.PaddingRight = self.ContentPadding
                padding.Parent = self._contentFrame
            end
        end

        --// Update auto size
        function Container:_updateAutoSize()
            if not self._layoutInstance or not self.Instance then return end

            local contentSize = self._layoutInstance.AbsoluteContentSize

            if self.Scrollable and self._contentFrame:IsA("ScrollingFrame") then
                self._contentFrame.CanvasSize = UDim2.new(0, contentSize.X, 0, contentSize.Y)
            elseif self.AutoSize then
                -- Update container size
                local paddingOffset = 0
                local padding = self._contentFrame:FindFirstChildOfClass("UIPadding")
                if padding then
                    paddingOffset = padding.PaddingTop.Offset + padding.PaddingBottom.Offset
                end

                self.Instance.Size = UDim2.new(
                    self.Instance.Size.X.Scale,
                    self.Instance.Size.X.Offset,
                    0,
                    contentSize.Y + paddingOffset
                )
            end
        end

        --// Set layout
        function Container:SetLayout(layoutType, config)
            self.Layout = layoutType
            self.LayoutConfig = config or {}
            self:_setupLayout()
            return self
        end

        --// Set scrollable
        function Container:SetScrollable(scrollable)
            if self.Scrollable == scrollable then return self end

            self.Scrollable = scrollable

            -- Rebuild content frame
            if self.Instance then
                local children = {}

                -- Store children
                for _, child in ipairs(self._contentFrame:GetChildren()) do
                    if child:IsA("GuiObject") then
                        table.insert(children, child)
                    end
                end

                -- Destroy old content frame (if it's a scroll frame)
                if self._contentFrame ~= self.Instance then
                    self._contentFrame:Destroy()
                end

                -- Create new content frame
                if scrollable then
                    local scrollFrame = Instance.new("ScrollingFrame")
                    scrollFrame.Name = "ScrollContent"
                    scrollFrame.Size = UDim2.new(1, 0, 1, 0)
                    scrollFrame.BackgroundTransparency = 1
                    scrollFrame.BorderSizePixel = 0
                    scrollFrame.ScrollBarThickness = 4
                    scrollFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 110)
                    scrollFrame.ScrollBarImageTransparency = 0.5
                    scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
                    scrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
                    scrollFrame.Parent = self.Instance

                    self._contentFrame = scrollFrame
                else
                    self._contentFrame = self.Instance
                end

                -- Re-parent children
                for _, child in ipairs(children) do
                    child.Parent = self._contentFrame
                end

                -- Re-setup layout
                self:_setupLayout()
            end

            return self
        end

        --// Set item spacing
        function Container:SetItemSpacing(spacing)
            self.ItemSpacing = spacing

            if self._layoutInstance then
                if self._layoutInstance:IsA("UIListLayout") then
                    self._layoutInstance.Padding = spacing
                elseif self._layoutInstance:IsA("UIGridLayout") then
                    self._layoutInstance.CellPadding = UDim2.new(spacing.Scale, spacing.Offset, spacing.Scale, spacing.Offset)
                end
            end

            return self
        end

        --// Set content padding
        function Container:SetContentPadding(padding)
            self.ContentPadding = padding

            if self._contentFrame then
                local uiPadding = self._contentFrame:FindFirstChildOfClass("UIPadding")
                if uiPadding then
                    uiPadding.PaddingTop = padding
                    uiPadding.PaddingBottom = padding
                    uiPadding.PaddingLeft = padding
                    uiPadding.PaddingRight = padding
                end
            end

            return self
        end

        --// Add child (override to use content frame)
        function Container:AddChild(child)
            if child.Instance and self._contentFrame then
                child.Instance.Parent = self._contentFrame
                child.Parent = self
                table.insert(self.Children, child)
            end

            self:_updateAutoSize()

            return child
        end

        --// Clear all children
        function Container:ClearChildren()
            for i = #self.Children, 1, -1 do
                local child = self.Children[i]
                child:Destroy()
                table.remove(self.Children, i)
            end

            return self
        end

        --// Scroll to child
        function Container:ScrollToChild(child, animate)
            if not self.Scrollable or not self._contentFrame:IsA("ScrollingFrame") then return self end

            if child.Instance then
                local childPosition = child.Instance.AbsolutePosition
                local containerPosition = self._contentFrame.AbsolutePosition
                local offset = childPosition - containerPosition

                local targetScroll = Vector2.new(
                    self._contentFrame.CanvasPosition.X,
                    offset.Y
                )

                if animate then
                    -- Animate scroll
                    local startScroll = self._contentFrame.CanvasPosition
                    local startTime = tick()
                    local duration = 0.3

                    local connection
                    connection = game:GetService("RunService").Heartbeat:Connect(function()
                        local progress = math.min((tick() - startTime) / duration, 1)
                        local eased = 1 - (1 - progress) ^ 3 -- Ease out cubic

                        self._contentFrame.CanvasPosition = startScroll:Lerp(targetScroll, eased)

                        if progress >= 1 then
                            connection:Disconnect()
                        end
                    end)
                else
                    self._contentFrame.CanvasPosition = targetScroll
                end
            end

            return self
        end

        --// Scroll to top
        function Container:ScrollToTop(animate)
            if not self.Scrollable or not self._contentFrame:IsA("ScrollingFrame") then return self end

            if animate then
                local startScroll = self._contentFrame.CanvasPosition
                local targetScroll = Vector2.new(startScroll.X, 0)
                local startTime = tick()
                local duration = 0.3

                local connection
                connection = game:GetService("RunService").Heartbeat:Connect(function()
                    local progress = math.min((tick() - startTime) / duration, 1)
                    local eased = 1 - (1 - progress) ^ 3

                    self._contentFrame.CanvasPosition = startScroll:Lerp(targetScroll, eased)

                    if progress >= 1 then
                        connection:Disconnect()
                    end
                end)
            else
                self._contentFrame.CanvasPosition = Vector2.new(self._contentFrame.CanvasPosition.X, 0)
            end

            return self
        end

        --// Scroll to bottom
        function Container:ScrollToBottom(animate)
            if not self.Scrollable or not self._contentFrame:IsA("ScrollingFrame") then return self end

            local maxScroll = self._contentFrame.CanvasSize.Y.Offset - self._contentFrame.AbsoluteSize.Y

            if animate then
                local startScroll = self._contentFrame.CanvasPosition
                local targetScroll = Vector2.new(startScroll.X, maxScroll)
                local startTime = tick()
                local duration = 0.3

                local connection
                connection = game:GetService("RunService").Heartbeat:Connect(function()
                    local progress = math.min((tick() - startTime) / duration, 1)
                    local eased = 1 - (1 - progress) ^ 3

                    self._contentFrame.CanvasPosition = startScroll:Lerp(targetScroll, eased)

                    if progress >= 1 then
                        connection:Disconnect()
                    end
                end)
            else
                self._contentFrame.CanvasPosition = Vector2.new(self._contentFrame.CanvasPosition.X, maxScroll)
            end

            return self
        end

        --// Get content frame
        function Container:GetContentFrame()
            return self._contentFrame
        end

        --// Get content size
        function Container:GetContentSize()
            if self._layoutInstance then
                return self._layoutInstance.AbsoluteContentSize
            end
            return Vector2.new(0, 0)
        end

        return Container


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Button
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Button"] = function()
        local script = CreateMockScript("NexusUI/Components/Button")

        --[[
            NexusUI Button Component
            Interactive button with hover, press states, and ripple effect
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")
        local UserInputService = game:GetService("UserInputService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Button Component Module
        local Button = setmetatable({}, { __index = Base })
        Button.__index = Button
        Button.ClassName = "Button"

        --// Button Variants
        Button.Variant = {
            Primary = "Primary",
            Secondary = "Secondary",
            Accent = "Accent",
            Ghost = "Ghost",
            Outline = "Outline",
            Danger = "Danger",
            Success = "Success",
        }

        --// Button Sizes
        Button.Size = {
            Small = "Small",
            Medium = "Medium",
            Large = "Large",
        }

        --// Constructor
        function Button.new(config)
            local self = setmetatable(Base.new(config), Button)

            config = config or {}

            -- Button-specific properties
            self.Text = config.Text or "Button"
            self.Variant = config.Variant or Button.Variant.Primary
            self.ButtonSize = config.Size or Button.Size.Medium
            self.Icon = config.Icon -- Left icon
            self.IconRight = config.IconRight -- Right icon
            self.RippleEnabled = config.RippleEnabled ~= false
            self.Loading = false
            self.LoadingText = config.LoadingText or "Loading..."

            -- State
            self._isHovered = false
            self._isPressed = false

            -- Callbacks
            self.OnClick = config.OnClick
            self.OnHover = config.OnHover
            self.OnLeave = config.OnLeave

            return self
        end

        --// Get size dimensions
        function Button:_getSizeDimensions()
            if self.ButtonSize == Button.Size.Small then
                return { Height = 28, FontSize = 12, Padding = 8, IconSize = 14 }
            elseif self.ButtonSize == Button.Size.Large then
                return { Height = 44, FontSize = 16, Padding = 16, IconSize = 20 }
            else -- Medium
                return { Height = 36, FontSize = 14, Padding = 12, IconSize = 16 }
            end
        end

        --// Get variant colors
        function Button:_getVariantColors()
            local colors = {
                Primary = {
                    Background = Color3.fromRGB(99, 102, 241),
                    BackgroundHover = Color3.fromRGB(129, 140, 248),
                    BackgroundPressed = Color3.fromRGB(79, 70, 229),
                    Text = Color3.fromRGB(255, 255, 255),
                    Border = nil,
                },
                Secondary = {
                    Background = Color3.fromRGB(63, 63, 70),
                    BackgroundHover = Color3.fromRGB(82, 82, 91),
                    BackgroundPressed = Color3.fromRGB(52, 52, 58),
                    Text = Color3.fromRGB(255, 255, 255),
                    Border = nil,
                },
                Accent = {
                    Background = Color3.fromRGB(236, 72, 153),
                    BackgroundHover = Color3.fromRGB(244, 114, 182),
                    BackgroundPressed = Color3.fromRGB(219, 39, 119),
                    Text = Color3.fromRGB(255, 255, 255),
                    Border = nil,
                },
                Ghost = {
                    Background = Color3.fromRGB(0, 0, 0),
                    BackgroundTransparency = 1,
                    BackgroundHover = Color3.fromRGB(63, 63, 70),
                    BackgroundHoverTransparency = 0.8,
                    BackgroundPressed = Color3.fromRGB(52, 52, 58),
                    BackgroundPressedTransparency = 0.7,
                    Text = Color3.fromRGB(255, 255, 255),
                    Border = nil,
                },
                Outline = {
                    Background = Color3.fromRGB(0, 0, 0),
                    BackgroundTransparency = 1,
                    BackgroundHover = Color3.fromRGB(99, 102, 241),
                    BackgroundHoverTransparency = 0.9,
                    BackgroundPressed = Color3.fromRGB(99, 102, 241),
                    BackgroundPressedTransparency = 0.8,
                    Text = Color3.fromRGB(99, 102, 241),
                    Border = Color3.fromRGB(99, 102, 241),
                },
                Danger = {
                    Background = Color3.fromRGB(220, 38, 38),
                    BackgroundHover = Color3.fromRGB(239, 68, 68),
                    BackgroundPressed = Color3.fromRGB(185, 28, 28),
                    Text = Color3.fromRGB(255, 255, 255),
                    Border = nil,
                },
                Success = {
                    Background = Color3.fromRGB(22, 163, 74),
                    BackgroundHover = Color3.fromRGB(34, 197, 94),
                    BackgroundPressed = Color3.fromRGB(21, 128, 61),
                    Text = Color3.fromRGB(255, 255, 255),
                    Border = nil,
                },
            }

            return colors[self.Variant] or colors.Primary
        end

        --// Create button
        function Button:Create(parent)
            local dimensions = self:_getSizeDimensions()
            local colors = self:_getVariantColors()

            -- Create button frame
            local button = Instance.new("TextButton")
            button.Name = self.Name
            button.Size = UDim2.new(0, 0, 0, dimensions.Height)
            button.AutomaticSize = Enum.AutomaticSize.X
            button.BackgroundColor3 = colors.Background
            button.BackgroundTransparency = colors.BackgroundTransparency or 0
            button.BorderSizePixel = 0
            button.Text = ""
            button.AutoButtonColor = false

            if parent then
                button.Parent = parent
            end

            self.Instance = button

            -- Corner radius
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = button

            -- Border (for outline variant)
            if colors.Border then
                local stroke = Instance.new("UIStroke")
                stroke.Color = colors.Border
                stroke.Thickness = 1
                stroke.Parent = button
                self._stroke = stroke
            end

            -- Padding
            local padding = Instance.new("UIPadding")
            padding.PaddingLeft = UDim.new(0, dimensions.Padding)
            padding.PaddingRight = UDim.new(0, dimensions.Padding)
            padding.Parent = button

            -- Content layout
            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Horizontal
            layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.Padding = UDim.new(0, 6)
            layout.SortOrder = Enum.SortOrder.LayoutOrder
            layout.Parent = button

            -- Left icon (if any)
            if self.Icon then
                local iconLabel = Instance.new("ImageLabel")
                iconLabel.Name = "IconLeft"
                iconLabel.Size = UDim2.new(0, dimensions.IconSize, 0, dimensions.IconSize)
                iconLabel.BackgroundTransparency = 1
                iconLabel.Image = self.Icon
                iconLabel.ImageColor3 = colors.Text
                iconLabel.LayoutOrder = 1
                iconLabel.Parent = button
                self._iconLeft = iconLabel
            end

            -- Text label
            local textLabel = Instance.new("TextLabel")
            textLabel.Name = "Text"
            textLabel.Size = UDim2.new(0, 0, 1, 0)
            textLabel.AutomaticSize = Enum.AutomaticSize.X
            textLabel.BackgroundTransparency = 1
            textLabel.Font = Enum.Font.GothamMedium
            textLabel.Text = self.Text
            textLabel.TextColor3 = colors.Text
            textLabel.TextSize = dimensions.FontSize
            textLabel.LayoutOrder = 2
            textLabel.Parent = button
            self._textLabel = textLabel

            -- Right icon (if any)
            if self.IconRight then
                local iconLabel = Instance.new("ImageLabel")
                iconLabel.Name = "IconRight"
                iconLabel.Size = UDim2.new(0, dimensions.IconSize, 0, dimensions.IconSize)
                iconLabel.BackgroundTransparency = 1
                iconLabel.Image = self.IconRight
                iconLabel.ImageColor3 = colors.Text
                iconLabel.LayoutOrder = 3
                iconLabel.Parent = button
                self._iconRight = iconLabel
            end

            -- Loading spinner (hidden by default)
            local spinner = Instance.new("ImageLabel")
            spinner.Name = "Spinner"
            spinner.Size = UDim2.new(0, dimensions.IconSize, 0, dimensions.IconSize)
            spinner.BackgroundTransparency = 1
            spinner.Image = "rbxassetid://6031094667" -- Circular spinner
            spinner.ImageColor3 = colors.Text
            spinner.Visible = false
            spinner.LayoutOrder = 0
            spinner.Parent = button
            self._spinner = spinner

            -- Setup interactions
            self:_setupInteractions(colors)

            return self
        end

        --// Setup interactions
        function Button:_setupInteractions(colors)
            local button = self.Instance

            -- Hover
            self:_connect(button.MouseEnter, function()
                if not self.IsEnabled or self.Loading then return end

                self._isHovered = true

                TweenService:Create(button, TweenInfo.new(0.15), {
                    BackgroundColor3 = colors.BackgroundHover,
                    BackgroundTransparency = colors.BackgroundHoverTransparency or 0,
                }):Play()

                if self.OnHover then
                    self.OnHover()
                end

                self:_fire("Hover")
            end)

            -- Leave
            self:_connect(button.MouseLeave, function()
                if not self.IsEnabled or self.Loading then return end

                self._isHovered = false
                self._isPressed = false

                TweenService:Create(button, TweenInfo.new(0.15), {
                    BackgroundColor3 = colors.Background,
                    BackgroundTransparency = colors.BackgroundTransparency or 0,
                }):Play()

                if self.OnLeave then
                    self.OnLeave()
                end

                self:_fire("Leave")
            end)

            -- Press
            self:_connect(button.MouseButton1Down, function()
                if not self.IsEnabled or self.Loading then return end

                self._isPressed = true

                TweenService:Create(button, TweenInfo.new(0.1), {
                    BackgroundColor3 = colors.BackgroundPressed,
                    BackgroundTransparency = colors.BackgroundPressedTransparency or 0,
                }):Play()

                -- Scale effect
                TweenService:Create(button, TweenInfo.new(0.1), {
                    Size = UDim2.new(button.Size.X.Scale, button.Size.X.Offset, 0, self:_getSizeDimensions().Height - 2),
                }):Play()
            end)

            -- Release
            self:_connect(button.MouseButton1Up, function()
                if not self.IsEnabled or self.Loading then return end

                self._isPressed = false

                -- Reset scale
                TweenService:Create(button, TweenInfo.new(0.15), {
                    Size = UDim2.new(button.Size.X.Scale, button.Size.X.Offset, 0, self:_getSizeDimensions().Height),
                }):Play()

                if self._isHovered then
                    TweenService:Create(button, TweenInfo.new(0.15), {
                        BackgroundColor3 = colors.BackgroundHover,
                    }):Play()
                end
            end)

            -- Click
            self:_connect(button.MouseButton1Click, function()
                if not self.IsEnabled or self.Loading then return end

                -- Ripple effect
                if self.RippleEnabled then
                    self:_createRipple()
                end

                if self.OnClick then
                    self.OnClick()
                end

                self:_fire("Click")
            end)
        end

        --// Create ripple effect
        function Button:_createRipple()
            local button = self.Instance
            local mousePosition = UserInputService:GetMouseLocation()
            local buttonPosition = button.AbsolutePosition

            local rippleX = mousePosition.X - buttonPosition.X
            local rippleY = mousePosition.Y - buttonPosition.Y - 36 -- Account for topbar

            local maxSize = math.max(button.AbsoluteSize.X, button.AbsoluteSize.Y) * 2

            local ripple = Instance.new("Frame")
            ripple.Name = "Ripple"
            ripple.AnchorPoint = Vector2.new(0.5, 0.5)
            ripple.Position = UDim2.new(0, rippleX, 0, rippleY)
            ripple.Size = UDim2.new(0, 0, 0, 0)
            ripple.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            ripple.BackgroundTransparency = 0.7
            ripple.BorderSizePixel = 0
            ripple.ZIndex = button.ZIndex + 10

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(1, 0)
            corner.Parent = ripple

            ripple.Parent = button

            TweenService:Create(ripple, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                Size = UDim2.new(0, maxSize, 0, maxSize),
                BackgroundTransparency = 1,
            }):Play()

            task.delay(0.5, function()
                ripple:Destroy()
            end)
        end

        --// Set text
        function Button:SetText(text)
            self.Text = text
            if self._textLabel then
                self._textLabel.Text = text
            end
            return self
        end

        --// Get text
        function Button:GetText()
            return self.Text
        end

        --// Set loading state
        function Button:SetLoading(loading)
            self.Loading = loading

            if self._spinner then
                self._spinner.Visible = loading

                if loading then
                    -- Start spinning animation
                    local startTime = os.clock()
                    local spinConnection

                    spinConnection = game:GetService("RunService").Heartbeat:Connect(function()
                        if not self._spinner or not self._spinner.Parent or not self.Loading then
                            spinConnection:Disconnect()
                            return
                        end

                        self._spinner.Rotation = (os.clock() - startTime) * 360
                    end)
                end
            end

            if self._textLabel then
                self._textLabel.Text = loading and self.LoadingText or self.Text
            end

            return self
        end

        --// Set enabled (override)
        function Button:SetEnabled(enabled)
            Base.SetEnabled(self, enabled)

            if self.Instance then
                self.Instance.BackgroundTransparency = enabled and 0 or 0.5
            end

            if self._textLabel then
                self._textLabel.TextTransparency = enabled and 0 or 0.5
            end

            return self
        end

        --// Set variant
        function Button:SetVariant(variant)
            self.Variant = variant
            -- Note: Would need to recreate button or update colors
            return self
        end

        return Button


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Label
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Label"] = function()
        local script = CreateMockScript("NexusUI/Components/Label")

        --[[
            NexusUI Label Component
            Text display with various styles
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Label Component Module
        local Label = setmetatable({}, { __index = Base })
        Label.__index = Label
        Label.ClassName = "Label"

        --// Label Variants
        Label.Variant = {
            Default = "Default",
            Header = "Header",
            Title = "Title",
            Body = "Body",
            Caption = "Caption",
            Code = "Code",
            Muted = "Muted",
        }

        --// Constructor
        function Label.new(config)
            local self = setmetatable(Base.new(config), Label)

            config = config or {}

            self.Text = config.Text or "Label"
            self.Variant = config.Variant or Label.Variant.Body
            self.TextColor = config.TextColor
            self.TextSize = config.TextSize
            self.Font = config.Font
            self.TextXAlignment = config.TextXAlignment or Enum.TextXAlignment.Left
            self.TextYAlignment = config.TextYAlignment or Enum.TextYAlignment.Center
            self.TextWrapped = config.TextWrapped or false
            self.RichText = config.RichText or false
            self.MaxVisibleGraphemes = config.MaxVisibleGraphemes or -1

            return self
        end

        --// Get variant properties
        function Label:_getVariantProperties()
            local variants = {
                Default = {
                    Font = Enum.Font.Gotham,
                    TextSize = 14,
                    TextColor3 = Color3.fromRGB(250, 250, 250),
                },
                Header = {
                    Font = Enum.Font.GothamBold,
                    TextSize = 28,
                    TextColor3 = Color3.fromRGB(250, 250, 250),
                },
                Title = {
                    Font = Enum.Font.GothamMedium,
                    TextSize = 20,
                    TextColor3 = Color3.fromRGB(250, 250, 250),
                },
                Body = {
                    Font = Enum.Font.Gotham,
                    TextSize = 14,
                    TextColor3 = Color3.fromRGB(250, 250, 250),
                },
                Caption = {
                    Font = Enum.Font.Gotham,
                    TextSize = 12,
                    TextColor3 = Color3.fromRGB(161, 161, 170),
                },
                Code = {
                    Font = Enum.Font.RobotoMono,
                    TextSize = 13,
                    TextColor3 = Color3.fromRGB(167, 139, 250),
                },
                Muted = {
                    Font = Enum.Font.Gotham,
                    TextSize = 14,
                    TextColor3 = Color3.fromRGB(113, 113, 122),
                },
            }

            return variants[self.Variant] or variants.Body
        end

        --// Create label
        function Label:Create(parent)
            local props = self:_getVariantProperties()

            local label = Instance.new("TextLabel")
            label.Name = self.Name
            label.Size = UDim2.new(0, 0, 0, 0)
            label.AutomaticSize = Enum.AutomaticSize.XY
            label.BackgroundTransparency = 1
            label.Font = self.Font or props.Font
            label.Text = self.Text
            label.TextColor3 = self.TextColor or props.TextColor3
            label.TextSize = self.TextSize or props.TextSize
            label.TextXAlignment = self.TextXAlignment
            label.TextYAlignment = self.TextYAlignment
            label.TextWrapped = self.TextWrapped
            label.RichText = self.RichText
            label.MaxVisibleGraphemes = self.MaxVisibleGraphemes

            if parent then
                label.Parent = parent
            end

            self.Instance = label
            return self
        end

        --// Set text
        function Label:SetText(text, animate)
            self.Text = text

            if self.Instance then
                if animate then
                    -- Typewriter effect
                    self.Instance.MaxVisibleGraphemes = 0
                    self.Instance.Text = text

                    local length = utf8.len(text) or #text
                    for i = 1, length do
                        self.Instance.MaxVisibleGraphemes = i
                        task.wait(0.02)
                    end
                else
                    self.Instance.Text = text
                end
            end

            return self
        end

        --// Get text
        function Label:GetText()
            return self.Text
        end

        --// Set text color
        function Label:SetTextColor(color, animate)
            self.TextColor = color

            if self.Instance then
                if animate then
                    TweenService:Create(self.Instance, TweenInfo.new(0.2), {
                        TextColor3 = color,
                    }):Play()
                else
                    self.Instance.TextColor3 = color
                end
            end

            return self
        end

        --// Set variant
        function Label:SetVariant(variant)
            self.Variant = variant

            if self.Instance then
                local props = self:_getVariantProperties()
                self.Instance.Font = self.Font or props.Font
                self.Instance.TextSize = self.TextSize or props.TextSize
                self.Instance.TextColor3 = self.TextColor or props.TextColor3
            end

            return self
        end

        return Label


    end


    -- ============================================================================
    -- Module: NexusUI/Components/TextInput
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/TextInput"] = function()
        local script = CreateMockScript("NexusUI/Components/TextInput")

        --[[
            NexusUI TextInput Component
            Text input field with validation and styling
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")
        local UserInputService = game:GetService("UserInputService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// TextInput Component Module
        local TextInput = setmetatable({}, { __index = Base })
        TextInput.__index = TextInput
        TextInput.ClassName = "TextInput"

        --// Input Types
        TextInput.Type = {
            Text = "Text",
            Password = "Password",
            Number = "Number",
            Email = "Email",
            Search = "Search",
        }

        --// Constructor
        function TextInput.new(config)
            local self = setmetatable(Base.new(config), TextInput)

            config = config or {}

            self.Text = config.Text or ""
            self.Placeholder = config.Placeholder or "Enter text..."
            self.InputType = config.InputType or TextInput.Type.Text
            self.MaxLength = config.MaxLength or -1
            self.ClearTextOnFocus = config.ClearTextOnFocus or false
            self.MultiLine = config.MultiLine or false
            self.ReadOnly = config.ReadOnly or false
            self.Icon = config.Icon
            self.ClearButton = config.ClearButton ~= false

            -- Validation
            self.Validator = config.Validator
            self.ValidationMessage = config.ValidationMessage or ""
            self.IsValid = true

            -- Callbacks
            self.OnTextChanged = config.OnTextChanged
            self.OnFocus = config.OnFocus
            self.OnFocusLost = config.OnFocusLost
            self.OnSubmit = config.OnSubmit

            -- State
            self._isFocused = false

            return self
        end

        --// Create input
        function TextInput:Create(parent)
            -- Main container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(1, 0, 0, 40)
            container.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            container.BorderSizePixel = 0

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Corner
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = container

            -- Border stroke
            local stroke = Instance.new("UIStroke")
            stroke.Name = "BorderStroke"
            stroke.Color = Color3.fromRGB(63, 63, 70)
            stroke.Thickness = 1
            stroke.Parent = container
            self._stroke = stroke

            -- Padding
            local padding = Instance.new("UIPadding")
            padding.PaddingLeft = UDim.new(0, 12)
            padding.PaddingRight = UDim.new(0, 12)
            padding.Parent = container

            -- Layout
            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Horizontal
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.Padding = UDim.new(0, 8)
            layout.Parent = container

            -- Icon (if any)
            if self.Icon then
                local icon = Instance.new("ImageLabel")
                icon.Name = "Icon"
                icon.Size = UDim2.new(0, 16, 0, 16)
                icon.BackgroundTransparency = 1
                icon.Image = self.Icon
                icon.ImageColor3 = Color3.fromRGB(113, 113, 122)
                icon.LayoutOrder = 1
                icon.Parent = container
                self._icon = icon
            end

            -- Text box
            local textBox = Instance.new("TextBox")
            textBox.Name = "Input"
            textBox.Size = UDim2.new(1, -50, 1, 0)
            textBox.BackgroundTransparency = 1
            textBox.Font = Enum.Font.Gotham
            textBox.Text = self.Text
            textBox.PlaceholderText = self.Placeholder
            textBox.PlaceholderColor3 = Color3.fromRGB(113, 113, 122)
            textBox.TextColor3 = Color3.fromRGB(250, 250, 250)
            textBox.TextSize = 14
            textBox.TextXAlignment = Enum.TextXAlignment.Left
            textBox.ClearTextOnFocus = self.ClearTextOnFocus
            textBox.MultiLine = self.MultiLine
            textBox.TextEditable = not self.ReadOnly
            textBox.LayoutOrder = 2
            textBox.Parent = container
            self._textBox = textBox

            -- Clear button
            if self.ClearButton then
                local clearBtn = Instance.new("ImageButton")
                clearBtn.Name = "ClearButton"
                clearBtn.Size = UDim2.new(0, 16, 0, 16)
                clearBtn.BackgroundTransparency = 1
                clearBtn.Image = "rbxassetid://6031094678" -- X icon
                clearBtn.ImageColor3 = Color3.fromRGB(113, 113, 122)
                clearBtn.Visible = #self.Text > 0
                clearBtn.LayoutOrder = 3
                clearBtn.Parent = container
                self._clearButton = clearBtn

                self:_connect(clearBtn.MouseButton1Click, function()
                    self:SetText("")
                    textBox:CaptureFocus()
                end)

                self:_connect(clearBtn.MouseEnter, function()
                    TweenService:Create(clearBtn, TweenInfo.new(0.1), {
                        ImageColor3 = Color3.fromRGB(250, 250, 250),
                    }):Play()
                end)

                self:_connect(clearBtn.MouseLeave, function()
                    TweenService:Create(clearBtn, TweenInfo.new(0.1), {
                        ImageColor3 = Color3.fromRGB(113, 113, 122),
                    }):Play()
                end)
            end

            -- Password mask
            if self.InputType == TextInput.Type.Password then
                textBox.Text = string.rep("●", #self.Text)
            end

            -- Setup interactions
            self:_setupInteractions()

            return self
        end

        --// Setup interactions
        function TextInput:_setupInteractions()
            local textBox = self._textBox
            local stroke = self._stroke

            -- Focus
            self:_connect(textBox.Focused, function()
                self._isFocused = true

                TweenService:Create(stroke, TweenInfo.new(0.15), {
                    Color = Color3.fromRGB(99, 102, 241),
                }):Play()

                TweenService:Create(self.Instance, TweenInfo.new(0.15), {
                    BackgroundColor3 = Color3.fromRGB(35, 35, 42),
                }):Play()

                if self.OnFocus then
                    self.OnFocus()
                end

                self:_fire("Focus")
            end)

            -- Focus lost
            self:_connect(textBox.FocusLost, function(enterPressed)
                self._isFocused = false

                local borderColor = self.IsValid and Color3.fromRGB(63, 63, 70) or Color3.fromRGB(239, 68, 68)

                TweenService:Create(stroke, TweenInfo.new(0.15), {
                    Color = borderColor,
                }):Play()

                TweenService:Create(self.Instance, TweenInfo.new(0.15), {
                    BackgroundColor3 = Color3.fromRGB(30, 30, 35),
                }):Play()

                if self.OnFocusLost then
                    self.OnFocusLost(enterPressed)
                end

                if enterPressed and self.OnSubmit then
                    self.OnSubmit(self.Text)
                end

                self:_fire("FocusLost", enterPressed)
            end)

            -- Text changed
            self:_connect(textBox:GetPropertyChangedSignal("Text"), function()
                local text = textBox.Text

                -- Handle password type
                if self.InputType == TextInput.Type.Password then
                    local realText = self.Text
                    local newLen = #text
                    local oldLen = #realText

                    if newLen > oldLen then
                        -- Characters added
                        local addedChars = string.sub(text, oldLen + 1)
                        addedChars = string.gsub(addedChars, "●", "")
                        realText = realText .. addedChars
                    elseif newLen < oldLen then
                        -- Characters removed
                        realText = string.sub(realText, 1, newLen)
                    end

                    self.Text = realText
                    textBox.Text = string.rep("●", #realText)
                else
                    -- Max length
                    if self.MaxLength > 0 and #text > self.MaxLength then
                        textBox.Text = string.sub(text, 1, self.MaxLength)
                        return
                    end

                    -- Number type
                    if self.InputType == TextInput.Type.Number then
                        local filtered = string.gsub(text, "[^%d%.%-]", "")
                        if filtered ~= text then
                            textBox.Text = filtered
                            return
                        end
                    end

                    self.Text = text
                end

                -- Validate
                self:_validate()

                -- Update clear button visibility
                if self._clearButton then
                    self._clearButton.Visible = #self.Text > 0
                end

                if self.OnTextChanged then
                    self.OnTextChanged(self.Text)
                end

                self:_fire("TextChanged", self.Text)
            end)

            -- Hover effects
            self:_connect(self.Instance.MouseEnter, function()
                if not self._isFocused then
                    TweenService:Create(stroke, TweenInfo.new(0.15), {
                        Color = Color3.fromRGB(82, 82, 91),
                    }):Play()
                end
            end)

            self:_connect(self.Instance.MouseLeave, function()
                if not self._isFocused then
                    local borderColor = self.IsValid and Color3.fromRGB(63, 63, 70) or Color3.fromRGB(239, 68, 68)
                    TweenService:Create(stroke, TweenInfo.new(0.15), {
                        Color = borderColor,
                    }):Play()
                end
            end)
        end

        --// Validate
        function TextInput:_validate()
            if self.Validator then
                local isValid, message = self.Validator(self.Text)
                self.IsValid = isValid
                self.ValidationMessage = message or ""

                if self._stroke and not self._isFocused then
                    self._stroke.Color = isValid and Color3.fromRGB(63, 63, 70) or Color3.fromRGB(239, 68, 68)
                end

                return isValid
            end

            self.IsValid = true
            return true
        end

        --// Set text
        function TextInput:SetText(text)
            self.Text = text

            if self._textBox then
                if self.InputType == TextInput.Type.Password then
                    self._textBox.Text = string.rep("●", #text)
                else
                    self._textBox.Text = text
                end
            end

            return self
        end

        --// Get text
        function TextInput:GetText()
            return self.Text
        end

        --// Set placeholder
        function TextInput:SetPlaceholder(placeholder)
            self.Placeholder = placeholder

            if self._textBox then
                self._textBox.PlaceholderText = placeholder
            end

            return self
        end

        --// Focus
        function TextInput:Focus()
            if self._textBox then
                self._textBox:CaptureFocus()
            end
            return self
        end

        --// Clear focus
        function TextInput:ClearFocus()
            if self._textBox then
                self._textBox:ReleaseFocus()
            end
            return self
        end

        --// Set read only
        function TextInput:SetReadOnly(readOnly)
            self.ReadOnly = readOnly

            if self._textBox then
                self._textBox.TextEditable = not readOnly
            end

            return self
        end

        --// Set validator
        function TextInput:SetValidator(validator)
            self.Validator = validator
            self:_validate()
            return self
        end

        --// Select all
        function TextInput:SelectAll()
            if self._textBox then
                self._textBox.SelectionStart = 1
                self._textBox.CursorPosition = #self.Text + 1
            end
            return self
        end

        return TextInput


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Toggle
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Toggle"] = function()
        local script = CreateMockScript("NexusUI/Components/Toggle")

        --[[
            NexusUI Toggle Component
            On/Off switch with smooth animations
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Toggle Component Module
        local Toggle = setmetatable({}, { __index = Base })
        Toggle.__index = Toggle
        Toggle.ClassName = "Toggle"

        --// Constructor
        function Toggle.new(config)
            local self = setmetatable(Base.new(config), Toggle)

            config = config or {}

            self.Value = config.Value or false
            self.Label = config.Label
            self.LabelPosition = config.LabelPosition or "Left" -- Left, Right
            self.Size = config.Size or "Medium" -- Small, Medium, Large
            self.ColorOn = config.ColorOn or Color3.fromRGB(99, 102, 241)
            self.ColorOff = config.ColorOff or Color3.fromRGB(63, 63, 70)

            -- Callbacks
            self.OnToggle = config.OnToggle
            self.OnOn = config.OnOn
            self.OnOff = config.OnOff

            return self
        end

        --// Get size dimensions
        function Toggle:_getSizeDimensions()
            if self.Size == "Small" then
                return { Width = 36, Height = 20, KnobSize = 14, KnobPadding = 3 }
            elseif self.Size == "Large" then
                return { Width = 56, Height = 30, KnobSize = 24, KnobPadding = 3 }
            else -- Medium
                return { Width = 44, Height = 24, KnobSize = 18, KnobPadding = 3 }
            end
        end

        --// Create toggle
        function Toggle:Create(parent)
            local dims = self:_getSizeDimensions()

            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(0, 0, 0, dims.Height)
            container.AutomaticSize = Enum.AutomaticSize.X
            container.BackgroundTransparency = 1

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Layout
            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Horizontal
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.Padding = UDim.new(0, 10)
            layout.SortOrder = Enum.SortOrder.LayoutOrder
            layout.Parent = container

            -- Label (if provided and position is left)
            if self.Label and self.LabelPosition == "Left" then
                local label = Instance.new("TextLabel")
                label.Name = "Label"
                label.Size = UDim2.new(0, 0, 0, dims.Height)
                label.AutomaticSize = Enum.AutomaticSize.X
                label.BackgroundTransparency = 1
                label.Font = Enum.Font.Gotham
                label.Text = self.Label
                label.TextColor3 = Color3.fromRGB(250, 250, 250)
                label.TextSize = 14
                label.TextXAlignment = Enum.TextXAlignment.Left
                label.LayoutOrder = 1
                label.Parent = container
                self._label = label
            end

            -- Toggle track
            local track = Instance.new("TextButton")
            track.Name = "Track"
            track.Size = UDim2.new(0, dims.Width, 0, dims.Height)
            track.BackgroundColor3 = self.Value and self.ColorOn or self.ColorOff
            track.BorderSizePixel = 0
            track.Text = ""
            track.AutoButtonColor = false
            track.LayoutOrder = 2
            track.Parent = container
            self._track = track

            -- Track corner
            local trackCorner = Instance.new("UICorner")
            trackCorner.CornerRadius = UDim.new(1, 0)
            trackCorner.Parent = track

            -- Knob
            local knobPosition = self.Value and 
                UDim2.new(1, -dims.KnobPadding - dims.KnobSize, 0.5, 0) or 
                UDim2.new(0, dims.KnobPadding, 0.5, 0)

            local knob = Instance.new("Frame")
            knob.Name = "Knob"
            knob.Size = UDim2.new(0, dims.KnobSize, 0, dims.KnobSize)
            knob.Position = knobPosition
            knob.AnchorPoint = Vector2.new(0, 0.5)
            knob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            knob.BorderSizePixel = 0
            knob.Parent = track
            self._knob = knob

            -- Knob corner
            local knobCorner = Instance.new("UICorner")
            knobCorner.CornerRadius = UDim.new(1, 0)
            knobCorner.Parent = knob

            -- Knob shadow
            local knobShadow = Instance.new("ImageLabel")
            knobShadow.Name = "Shadow"
            knobShadow.Size = UDim2.new(1, 8, 1, 8)
            knobShadow.Position = UDim2.new(0.5, 0, 0.5, 2)
            knobShadow.AnchorPoint = Vector2.new(0.5, 0.5)
            knobShadow.BackgroundTransparency = 1
            knobShadow.Image = "rbxassetid://6015897843"
            knobShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
            knobShadow.ImageTransparency = 0.7
            knobShadow.ScaleType = Enum.ScaleType.Slice
            knobShadow.SliceCenter = Rect.new(49, 49, 450, 450)
            knobShadow.ZIndex = knob.ZIndex - 1
            knobShadow.Parent = knob

            -- Label (if provided and position is right)
            if self.Label and self.LabelPosition == "Right" then
                local label = Instance.new("TextLabel")
                label.Name = "Label"
                label.Size = UDim2.new(0, 0, 0, dims.Height)
                label.AutomaticSize = Enum.AutomaticSize.X
                label.BackgroundTransparency = 1
                label.Font = Enum.Font.Gotham
                label.Text = self.Label
                label.TextColor3 = Color3.fromRGB(250, 250, 250)
                label.TextSize = 14
                label.TextXAlignment = Enum.TextXAlignment.Left
                label.LayoutOrder = 3
                label.Parent = container
                self._label = label
            end

            -- Setup interactions
            self:_setupInteractions()

            return self
        end

        --// Setup interactions
        function Toggle:_setupInteractions()
            local track = self._track
            local dims = self:_getSizeDimensions()

            -- Click
            self:_connect(track.MouseButton1Click, function()
                if not self.IsEnabled then return end
                self:Toggle()
            end)

            -- Hover
            self:_connect(track.MouseEnter, function()
                if not self.IsEnabled then return end

                TweenService:Create(self._knob, TweenInfo.new(0.15), {
                    Size = UDim2.new(0, dims.KnobSize + 2, 0, dims.KnobSize + 2),
                }):Play()
            end)

            self:_connect(track.MouseLeave, function()
                TweenService:Create(self._knob, TweenInfo.new(0.15), {
                    Size = UDim2.new(0, dims.KnobSize, 0, dims.KnobSize),
                }):Play()
            end)
        end

        --// Toggle
        function Toggle:Toggle(animate)
            self:SetValue(not self.Value, animate)
            return self
        end

        --// Set value
        function Toggle:SetValue(value, animate)
            if self.Value == value then return self end

            local oldValue = self.Value
            self.Value = value
            animate = animate ~= false

            local dims = self:_getSizeDimensions()
            local targetPosition = value and 
                UDim2.new(1, -dims.KnobPadding - dims.KnobSize, 0.5, 0) or 
                UDim2.new(0, dims.KnobPadding, 0.5, 0)
            local targetColor = value and self.ColorOn or self.ColorOff

            if animate then
                TweenService:Create(self._knob, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                    Position = targetPosition,
                }):Play()

                TweenService:Create(self._track, TweenInfo.new(0.15), {
                    BackgroundColor3 = targetColor,
                }):Play()
            else
                self._knob.Position = targetPosition
                self._track.BackgroundColor3 = targetColor
            end

            -- Callbacks
            if self.OnToggle then
                self.OnToggle(value, oldValue)
            end

            if value and self.OnOn then
                self.OnOn()
            elseif not value and self.OnOff then
                self.OnOff()
            end

            self:_fire("Toggle", value, oldValue)

            return self
        end

        --// Get value
        function Toggle:GetValue()
            return self.Value
        end

        --// Set label
        function Toggle:SetLabel(label)
            self.Label = label

            if self._label then
                self._label.Text = label
            end

            return self
        end

        --// Set colors
        function Toggle:SetColors(colorOn, colorOff)
            self.ColorOn = colorOn or self.ColorOn
            self.ColorOff = colorOff or self.ColorOff

            if self._track then
                self._track.BackgroundColor3 = self.Value and self.ColorOn or self.ColorOff
            end

            return self
        end

        --// Set enabled (override)
        function Toggle:SetEnabled(enabled)
            Base.SetEnabled(self, enabled)

            if self._track then
                self._track.BackgroundTransparency = enabled and 0 or 0.5
            end

            if self._knob then
                self._knob.BackgroundTransparency = enabled and 0 or 0.3
            end

            if self._label then
                self._label.TextTransparency = enabled and 0 or 0.5
            end

            return self
        end

        return Toggle


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Checkbox
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Checkbox"] = function()
        local script = CreateMockScript("NexusUI/Components/Checkbox")

        --[[
            NexusUI Checkbox Component
            Checkable box with optional label
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Checkbox Component Module
        local Checkbox = setmetatable({}, { __index = Base })
        Checkbox.__index = Checkbox
        Checkbox.ClassName = "Checkbox"

        --// Constructor
        function Checkbox.new(config)
            local self = setmetatable(Base.new(config), Checkbox)

            config = config or {}

            self.Checked = config.Checked or false
            self.Label = config.Label
            self.LabelPosition = config.LabelPosition or "Right"
            self.Size = config.Size or 20
            self.ColorChecked = config.ColorChecked or Color3.fromRGB(99, 102, 241)
            self.ColorUnchecked = config.ColorUnchecked or Color3.fromRGB(63, 63, 70)
            self.Indeterminate = config.Indeterminate or false

            -- Callbacks
            self.OnChange = config.OnChange
            self.OnChecked = config.OnChecked
            self.OnUnchecked = config.OnUnchecked

            return self
        end

        --// Create checkbox
        function Checkbox:Create(parent)
            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(0, 0, 0, self.Size)
            container.AutomaticSize = Enum.AutomaticSize.X
            container.BackgroundTransparency = 1

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Layout
            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Horizontal
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.Padding = UDim.new(0, 8)
            layout.SortOrder = Enum.SortOrder.LayoutOrder
            layout.Parent = container

            -- Label (left)
            if self.Label and self.LabelPosition == "Left" then
                local label = Instance.new("TextLabel")
                label.Name = "Label"
                label.Size = UDim2.new(0, 0, 0, self.Size)
                label.AutomaticSize = Enum.AutomaticSize.X
                label.BackgroundTransparency = 1
                label.Font = Enum.Font.Gotham
                label.Text = self.Label
                label.TextColor3 = Color3.fromRGB(250, 250, 250)
                label.TextSize = 14
                label.LayoutOrder = 1
                label.Parent = container
                self._label = label
            end

            -- Checkbox button
            local box = Instance.new("TextButton")
            box.Name = "Box"
            box.Size = UDim2.new(0, self.Size, 0, self.Size)
            box.BackgroundColor3 = self.Checked and self.ColorChecked or self.ColorUnchecked
            box.BorderSizePixel = 0
            box.Text = ""
            box.AutoButtonColor = false
            box.LayoutOrder = 2
            box.Parent = container
            self._box = box

            -- Corner
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 4)
            corner.Parent = box

            -- Border
            local stroke = Instance.new("UIStroke")
            stroke.Color = self.Checked and self.ColorChecked or Color3.fromRGB(82, 82, 91)
            stroke.Thickness = 2
            stroke.Parent = box
            self._stroke = stroke

            -- Checkmark
            local checkmark = Instance.new("ImageLabel")
            checkmark.Name = "Checkmark"
            checkmark.Size = UDim2.new(0.7, 0, 0.7, 0)
            checkmark.Position = UDim2.new(0.5, 0, 0.5, 0)
            checkmark.AnchorPoint = Vector2.new(0.5, 0.5)
            checkmark.BackgroundTransparency = 1
            checkmark.Image = "rbxassetid://6031094667" -- Checkmark
            checkmark.ImageColor3 = Color3.fromRGB(255, 255, 255)
            checkmark.ImageTransparency = self.Checked and 0 or 1
            checkmark.ScaleType = Enum.ScaleType.Fit
            checkmark.Parent = box
            self._checkmark = checkmark

            -- Indeterminate line
            local indeterminate = Instance.new("Frame")
            indeterminate.Name = "Indeterminate"
            indeterminate.Size = UDim2.new(0.6, 0, 0, 2)
            indeterminate.Position = UDim2.new(0.5, 0, 0.5, 0)
            indeterminate.AnchorPoint = Vector2.new(0.5, 0.5)
            indeterminate.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            indeterminate.BorderSizePixel = 0
            indeterminate.Visible = self.Indeterminate
            indeterminate.Parent = box
            self._indeterminate = indeterminate

            -- Label (right)
            if self.Label and self.LabelPosition == "Right" then
                local label = Instance.new("TextLabel")
                label.Name = "Label"
                label.Size = UDim2.new(0, 0, 0, self.Size)
                label.AutomaticSize = Enum.AutomaticSize.X
                label.BackgroundTransparency = 1
                label.Font = Enum.Font.Gotham
                label.Text = self.Label
                label.TextColor3 = Color3.fromRGB(250, 250, 250)
                label.TextSize = 14
                label.LayoutOrder = 3
                label.Parent = container
                self._label = label
            end

            -- Setup interactions
            self:_setupInteractions()

            return self
        end

        --// Setup interactions
        function Checkbox:_setupInteractions()
            local box = self._box

            -- Click
            self:_connect(box.MouseButton1Click, function()
                if not self.IsEnabled then return end
                self:Toggle()
            end)

            -- Hover
            self:_connect(box.MouseEnter, function()
                if not self.IsEnabled then return end

                if not self.Checked then
                    TweenService:Create(self._stroke, TweenInfo.new(0.15), {
                        Color = Color3.fromRGB(113, 113, 122),
                    }):Play()
                end

                TweenService:Create(box, TweenInfo.new(0.15), {
                    Size = UDim2.new(0, self.Size + 2, 0, self.Size + 2),
                }):Play()
            end)

            self:_connect(box.MouseLeave, function()
                if not self.Checked then
                    TweenService:Create(self._stroke, TweenInfo.new(0.15), {
                        Color = Color3.fromRGB(82, 82, 91),
                    }):Play()
                end

                TweenService:Create(box, TweenInfo.new(0.15), {
                    Size = UDim2.new(0, self.Size, 0, self.Size),
                }):Play()
            end)
        end

        --// Toggle
        function Checkbox:Toggle()
            self:SetChecked(not self.Checked)
            return self
        end

        --// Set checked
        function Checkbox:SetChecked(checked, animate)
            if self.Checked == checked then return self end

            local oldValue = self.Checked
            self.Checked = checked
            self.Indeterminate = false
            animate = animate ~= false

            local duration = animate and 0.15 or 0

            -- Update visuals
            TweenService:Create(self._box, TweenInfo.new(duration), {
                BackgroundColor3 = checked and self.ColorChecked or self.ColorUnchecked,
            }):Play()

            TweenService:Create(self._stroke, TweenInfo.new(duration), {
                Color = checked and self.ColorChecked or Color3.fromRGB(82, 82, 91),
            }):Play()

            TweenService:Create(self._checkmark, TweenInfo.new(duration), {
                ImageTransparency = checked and 0 or 1,
            }):Play()

            self._indeterminate.Visible = false

            -- Scale animation for check
            if checked and animate then
                self._checkmark.Size = UDim2.new(0.3, 0, 0.3, 0)
                TweenService:Create(self._checkmark, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                    Size = UDim2.new(0.7, 0, 0.7, 0),
                }):Play()
            end

            -- Callbacks
            if self.OnChange then
                self.OnChange(checked, oldValue)
            end

            if checked and self.OnChecked then
                self.OnChecked()
            elseif not checked and self.OnUnchecked then
                self.OnUnchecked()
            end

            self:_fire("Change", checked, oldValue)

            return self
        end

        --// Get checked
        function Checkbox:GetChecked()
            return self.Checked
        end

        --// Set indeterminate
        function Checkbox:SetIndeterminate(indeterminate)
            self.Indeterminate = indeterminate

            if indeterminate then
                self._checkmark.ImageTransparency = 1
                self._indeterminate.Visible = true
                self._box.BackgroundColor3 = self.ColorChecked
                self._stroke.Color = self.ColorChecked
            else
                self._indeterminate.Visible = false
            end

            return self
        end

        --// Set label
        function Checkbox:SetLabel(label)
            self.Label = label

            if self._label then
                self._label.Text = label
            end

            return self
        end

        return Checkbox


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Slider
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Slider"] = function()
        local script = CreateMockScript("NexusUI/Components/Slider")

        --[[
            NexusUI Slider Component
            Range slider with value display
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")
        local UserInputService = game:GetService("UserInputService")
        local RunService = game:GetService("RunService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Slider Component Module
        local Slider = setmetatable({}, { __index = Base })
        Slider.__index = Slider
        Slider.ClassName = "Slider"

        --// Constructor
        function Slider.new(config)
            local self = setmetatable(Base.new(config), Slider)

            config = config or {}

            self.Value = config.Value or 50
            self.Min = config.Min or 0
            self.Max = config.Max or 100
            self.Step = config.Step or 1
            self.Label = config.Label
            self.ShowValue = config.ShowValue ~= false
            self.ValueFormat = config.ValueFormat or "%.0f"
            self.ValueSuffix = config.ValueSuffix or ""
            self.TrackColor = config.TrackColor or Color3.fromRGB(63, 63, 70)
            self.FillColor = config.FillColor or Color3.fromRGB(99, 102, 241)
            self.KnobColor = config.KnobColor or Color3.fromRGB(255, 255, 255)

            -- Callbacks
            self.OnValueChanged = config.OnValueChanged
            self.OnDragStart = config.OnDragStart
            self.OnDragEnd = config.OnDragEnd

            -- State
            self._isDragging = false

            return self
        end

        --// Create slider
        function Slider:Create(parent)
            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(1, 0, 0, 50)
            container.BackgroundTransparency = 1

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Header row (label + value)
            if self.Label or self.ShowValue then
                local header = Instance.new("Frame")
                header.Name = "Header"
                header.Size = UDim2.new(1, 0, 0, 20)
                header.BackgroundTransparency = 1
                header.Parent = container

                if self.Label then
                    local label = Instance.new("TextLabel")
                    label.Name = "Label"
                    label.Size = UDim2.new(0.5, 0, 1, 0)
                    label.BackgroundTransparency = 1
                    label.Font = Enum.Font.Gotham
                    label.Text = self.Label
                    label.TextColor3 = Color3.fromRGB(250, 250, 250)
                    label.TextSize = 14
                    label.TextXAlignment = Enum.TextXAlignment.Left
                    label.Parent = header
                    self._label = label
                end

                if self.ShowValue then
                    local valueLabel = Instance.new("TextLabel")
                    valueLabel.Name = "Value"
                    valueLabel.Size = UDim2.new(0.5, 0, 1, 0)
                    valueLabel.Position = UDim2.new(0.5, 0, 0, 0)
                    valueLabel.BackgroundTransparency = 1
                    valueLabel.Font = Enum.Font.GothamMedium
                    valueLabel.Text = self:_formatValue(self.Value)
                    valueLabel.TextColor3 = Color3.fromRGB(161, 161, 170)
                    valueLabel.TextSize = 14
                    valueLabel.TextXAlignment = Enum.TextXAlignment.Right
                    valueLabel.Parent = header
                    self._valueLabel = valueLabel
                end
            end

            -- Track container
            local trackContainer = Instance.new("Frame")
            trackContainer.Name = "TrackContainer"
            trackContainer.Size = UDim2.new(1, 0, 0, 20)
            trackContainer.Position = UDim2.new(0, 0, 1, -20)
            trackContainer.BackgroundTransparency = 1
            trackContainer.Parent = container

            -- Track
            local track = Instance.new("Frame")
            track.Name = "Track"
            track.Size = UDim2.new(1, 0, 0, 6)
            track.Position = UDim2.new(0, 0, 0.5, 0)
            track.AnchorPoint = Vector2.new(0, 0.5)
            track.BackgroundColor3 = self.TrackColor
            track.BorderSizePixel = 0
            track.Parent = trackContainer
            self._track = track

            local trackCorner = Instance.new("UICorner")
            trackCorner.CornerRadius = UDim.new(1, 0)
            trackCorner.Parent = track

            -- Fill
            local fill = Instance.new("Frame")
            fill.Name = "Fill"
            fill.Size = UDim2.new(self:_getProgress(), 0, 1, 0)
            fill.BackgroundColor3 = self.FillColor
            fill.BorderSizePixel = 0
            fill.Parent = track
            self._fill = fill

            local fillCorner = Instance.new("UICorner")
            fillCorner.CornerRadius = UDim.new(1, 0)
            fillCorner.Parent = fill

            -- Knob
            local knob = Instance.new("Frame")
            knob.Name = "Knob"
            knob.Size = UDim2.new(0, 18, 0, 18)
            knob.Position = UDim2.new(self:_getProgress(), 0, 0.5, 0)
            knob.AnchorPoint = Vector2.new(0.5, 0.5)
            knob.BackgroundColor3 = self.KnobColor
            knob.BorderSizePixel = 0
            knob.ZIndex = 2
            knob.Parent = trackContainer
            self._knob = knob

            local knobCorner = Instance.new("UICorner")
            knobCorner.CornerRadius = UDim.new(1, 0)
            knobCorner.Parent = knob

            -- Knob shadow
            local knobShadow = Instance.new("ImageLabel")
            knobShadow.Name = "Shadow"
            knobShadow.Size = UDim2.new(1, 12, 1, 12)
            knobShadow.Position = UDim2.new(0.5, 0, 0.5, 2)
            knobShadow.AnchorPoint = Vector2.new(0.5, 0.5)
            knobShadow.BackgroundTransparency = 1
            knobShadow.Image = "rbxassetid://6015897843"
            knobShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
            knobShadow.ImageTransparency = 0.6
            knobShadow.ScaleType = Enum.ScaleType.Slice
            knobShadow.SliceCenter = Rect.new(49, 49, 450, 450)
            knobShadow.ZIndex = 1
            knobShadow.Parent = knob

            -- Click area (invisible button for easier interaction)
            local clickArea = Instance.new("TextButton")
            clickArea.Name = "ClickArea"
            clickArea.Size = UDim2.new(1, 0, 1, 0)
            clickArea.BackgroundTransparency = 1
            clickArea.Text = ""
            clickArea.ZIndex = 3
            clickArea.Parent = trackContainer
            self._clickArea = clickArea

            -- Setup interactions
            self:_setupInteractions()

            return self
        end

        --// Format value
        function Slider:_formatValue(value)
            return string.format(self.ValueFormat, value) .. self.ValueSuffix
        end

        --// Get progress (0-1)
        function Slider:_getProgress()
            return (self.Value - self.Min) / (self.Max - self.Min)
        end

        --// Value from progress
        function Slider:_valueFromProgress(progress)
            local rawValue = self.Min + (self.Max - self.Min) * progress

            -- Apply step
            if self.Step > 0 then
                rawValue = math.floor(rawValue / self.Step + 0.5) * self.Step
            end

            return math.clamp(rawValue, self.Min, self.Max)
        end

        --// Setup interactions
        function Slider:_setupInteractions()
            local clickArea = self._clickArea
            local track = self._track

            -- Update from mouse position
            local function updateFromMouse()
                local mousePos = UserInputService:GetMouseLocation()
                local trackPos = track.AbsolutePosition
                local trackSize = track.AbsoluteSize

                local relativeX = mousePos.X - trackPos.X
                local progress = math.clamp(relativeX / trackSize.X, 0, 1)
                local newValue = self:_valueFromProgress(progress)

                self:SetValue(newValue, false)
            end

            -- Mouse down
            self:_connect(clickArea.MouseButton1Down, function()
                if not self.IsEnabled then return end

                self._isDragging = true

                TweenService:Create(self._knob, TweenInfo.new(0.1), {
                    Size = UDim2.new(0, 22, 0, 22),
                }):Play()

                if self.OnDragStart then
                    self.OnDragStart(self.Value)
                end

                self:_fire("DragStart", self.Value)

                updateFromMouse()
            end)

            -- Mouse move (while dragging)
            local moveConnection
            self:_connect(clickArea.MouseButton1Down, function()
                if moveConnection then
                    moveConnection:Disconnect()
                end

                moveConnection = RunService.Heartbeat:Connect(function()
                    if self._isDragging then
                        updateFromMouse()
                    end
                end)
            end)

            -- Mouse up
            self:_connect(UserInputService.InputEnded, function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 and self._isDragging then
                    self._isDragging = false

                    if moveConnection then
                        moveConnection:Disconnect()
                        moveConnection = nil
                    end

                    TweenService:Create(self._knob, TweenInfo.new(0.1), {
                        Size = UDim2.new(0, 18, 0, 18),
                    }):Play()

                    if self.OnDragEnd then
                        self.OnDragEnd(self.Value)
                    end

                    self:_fire("DragEnd", self.Value)
                end
            end)

            -- Hover
            self:_connect(clickArea.MouseEnter, function()
                if not self.IsEnabled then return end

                if not self._isDragging then
                    TweenService:Create(self._knob, TweenInfo.new(0.1), {
                        Size = UDim2.new(0, 20, 0, 20),
                    }):Play()
                end
            end)

            self:_connect(clickArea.MouseLeave, function()
                if not self._isDragging then
                    TweenService:Create(self._knob, TweenInfo.new(0.1), {
                        Size = UDim2.new(0, 18, 0, 18),
                    }):Play()
                end
            end)
        end

        --// Set value
        function Slider:SetValue(value, animate)
            value = math.clamp(value, self.Min, self.Max)

            -- Apply step
            if self.Step > 0 then
                value = math.floor(value / self.Step + 0.5) * self.Step
            end

            if math.abs(self.Value - value) < 0.001 then return self end

            local oldValue = self.Value
            self.Value = value
            animate = animate ~= false and not self._isDragging

            local progress = self:_getProgress()
            local duration = animate and 0.15 or 0

            -- Update visuals
            TweenService:Create(self._fill, TweenInfo.new(duration), {
                Size = UDim2.new(progress, 0, 1, 0),
            }):Play()

            TweenService:Create(self._knob, TweenInfo.new(duration), {
                Position = UDim2.new(progress, 0, 0.5, 0),
            }):Play()

            -- Update value label
            if self._valueLabel then
                self._valueLabel.Text = self:_formatValue(value)
            end

            -- Callback
            if self.OnValueChanged then
                self.OnValueChanged(value, oldValue)
            end

            self:_fire("ValueChanged", value, oldValue)

            return self
        end

        --// Get value
        function Slider:GetValue()
            return self.Value
        end

        --// Set range
        function Slider:SetRange(min, max)
            self.Min = min
            self.Max = max
            self:SetValue(math.clamp(self.Value, min, max))
            return self
        end

        --// Set step
        function Slider:SetStep(step)
            self.Step = step
            return self
        end

        --// Set colors
        function Slider:SetColors(trackColor, fillColor, knobColor)
            if trackColor then
                self.TrackColor = trackColor
                self._track.BackgroundColor3 = trackColor
            end

            if fillColor then
                self.FillColor = fillColor
                self._fill.BackgroundColor3 = fillColor
            end

            if knobColor then
                self.KnobColor = knobColor
                self._knob.BackgroundColor3 = knobColor
            end

            return self
        end

        return Slider


    end


    -- ============================================================================
    -- Module: NexusUI/Components/ProgressBar
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/ProgressBar"] = function()
        local script = CreateMockScript("NexusUI/Components/ProgressBar")

        --[[
            NexusUI ProgressBar Component
            Progress indicator with various styles
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")
        local RunService = game:GetService("RunService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// ProgressBar Component Module
        local ProgressBar = setmetatable({}, { __index = Base })
        ProgressBar.__index = ProgressBar
        ProgressBar.ClassName = "ProgressBar"

        --// Style variants
        ProgressBar.Style = {
            Default = "Default",
            Striped = "Striped",
            Animated = "Animated",
            Gradient = "Gradient",
        }

        --// Constructor
        function ProgressBar.new(config)
            local self = setmetatable(Base.new(config), ProgressBar)

            config = config or {}

            self.Value = config.Value or 0
            self.Max = config.Max or 100
            self.Style = config.Style or ProgressBar.Style.Default
            self.ShowLabel = config.ShowLabel or false
            self.LabelFormat = config.LabelFormat or "%.0f%%"
            self.Height = config.Height or 8
            self.TrackColor = config.TrackColor or Color3.fromRGB(39, 39, 42)
            self.FillColor = config.FillColor or Color3.fromRGB(99, 102, 241)
            self.FillColorSecondary = config.FillColorSecondary or Color3.fromRGB(139, 92, 246)
            self.Indeterminate = config.Indeterminate or false
            self.AnimationSpeed = config.AnimationSpeed or 1

            -- State
            self._animationConnection = nil

            return self
        end

        --// Create progress bar
        function ProgressBar:Create(parent)
            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(1, 0, 0, self.Height)
            container.BackgroundTransparency = 1

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Track
            local track = Instance.new("Frame")
            track.Name = "Track"
            track.Size = UDim2.new(1, 0, 1, 0)
            track.BackgroundColor3 = self.TrackColor
            track.BorderSizePixel = 0
            track.ClipsDescendants = true
            track.Parent = container
            self._track = track

            local trackCorner = Instance.new("UICorner")
            trackCorner.CornerRadius = UDim.new(1, 0)
            trackCorner.Parent = track

            -- Fill
            local fill = Instance.new("Frame")
            fill.Name = "Fill"
            fill.Size = UDim2.new(self:_getProgress(), 0, 1, 0)
            fill.BackgroundColor3 = self.FillColor
            fill.BorderSizePixel = 0
            fill.Parent = track
            self._fill = fill

            local fillCorner = Instance.new("UICorner")
            fillCorner.CornerRadius = UDim.new(1, 0)
            fillCorner.Parent = fill

            -- Apply style
            self:_applyStyle()

            -- Start animations if needed
            if self.Indeterminate then
                self:_startIndeterminateAnimation()
            elseif self.Style == ProgressBar.Style.Animated then
                self:_startStripedAnimation()
            end

            return self
        end

        --// Get progress (0-1)
        function ProgressBar:_getProgress()
            return math.clamp(self.Value / self.Max, 0, 1)
        end

        --// Apply style
        function ProgressBar:_applyStyle()
            -- Clear existing gradients/patterns
            for _, child in ipairs(self._fill:GetChildren()) do
                if child:IsA("UIGradient") or child.Name == "Stripes" then
                    child:Destroy()
                end
            end

            if self.Style == ProgressBar.Style.Gradient then
                local gradient = Instance.new("UIGradient")
                gradient.Color = ColorSequence.new({
                    ColorSequenceKeypoint.new(0, self.FillColor),
                    ColorSequenceKeypoint.new(1, self.FillColorSecondary),
                })
                gradient.Rotation = 90
                gradient.Parent = self._fill

            elseif self.Style == ProgressBar.Style.Striped or self.Style == ProgressBar.Style.Animated then
                -- Create stripes with image
                local stripes = Instance.new("ImageLabel")
                stripes.Name = "Stripes"
                stripes.Size = UDim2.new(2, 0, 1, 0)
                stripes.Position = UDim2.new(0, 0, 0, 0)
                stripes.BackgroundTransparency = 1
                stripes.Image = "rbxassetid://6034818372" -- Diagonal stripes pattern
                stripes.ImageColor3 = Color3.fromRGB(255, 255, 255)
                stripes.ImageTransparency = 0.85
                stripes.ScaleType = Enum.ScaleType.Tile
                stripes.TileSize = UDim2.new(0, 30, 0, 30)
                stripes.Parent = self._fill
                self._stripes = stripes
            end
        end

        --// Start indeterminate animation
        function ProgressBar:_startIndeterminateAnimation()
            self:_stopAnimations()

            self._fill.Size = UDim2.new(0.3, 0, 1, 0)

            self._animationConnection = RunService.Heartbeat:Connect(function(dt)
                local currentX = self._fill.Position.X.Scale
                local newX = currentX + dt * self.AnimationSpeed

                if newX > 1 then
                    newX = -0.3
                end

                self._fill.Position = UDim2.new(newX, 0, 0, 0)
            end)
        end

        --// Start striped animation
        function ProgressBar:_startStripedAnimation()
            self:_stopAnimations()

            if not self._stripes then return end

            self._animationConnection = RunService.Heartbeat:Connect(function(dt)
                local currentX = self._stripes.Position.X.Offset
                local newX = currentX - dt * 50 * self.AnimationSpeed

                if newX < -30 then
                    newX = 0
                end

                self._stripes.Position = UDim2.new(0, newX, 0, 0)
            end)
        end

        --// Stop animations
        function ProgressBar:_stopAnimations()
            if self._animationConnection then
                self._animationConnection:Disconnect()
                self._animationConnection = nil
            end
        end

        --// Set value
        function ProgressBar:SetValue(value, animate)
            value = math.clamp(value, 0, self.Max)

            if self.Indeterminate then return self end

            local oldValue = self.Value
            self.Value = value
            animate = animate ~= false

            local progress = self:_getProgress()
            local duration = animate and 0.3 or 0

            TweenService:Create(self._fill, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                Size = UDim2.new(progress, 0, 1, 0),
            }):Play()

            self:_fire("ValueChanged", value, oldValue)

            return self
        end

        --// Get value
        function ProgressBar:GetValue()
            return self.Value
        end

        --// Increment
        function ProgressBar:Increment(amount)
            return self:SetValue(self.Value + (amount or 1))
        end

        --// Decrement
        function ProgressBar:Decrement(amount)
            return self:SetValue(self.Value - (amount or 1))
        end

        --// Set indeterminate
        function ProgressBar:SetIndeterminate(indeterminate)
            self.Indeterminate = indeterminate

            if indeterminate then
                self:_startIndeterminateAnimation()
            else
                self:_stopAnimations()
                self._fill.Position = UDim2.new(0, 0, 0, 0)
                self:SetValue(self.Value, false)
            end

            return self
        end

        --// Set style
        function ProgressBar:SetStyle(style)
            self.Style = style
            self:_applyStyle()

            if style == ProgressBar.Style.Animated and not self.Indeterminate then
                self:_startStripedAnimation()
            elseif not self.Indeterminate then
                self:_stopAnimations()
            end

            return self
        end

        --// Set colors
        function ProgressBar:SetColors(fillColor, fillColorSecondary, trackColor)
            if fillColor then
                self.FillColor = fillColor
                self._fill.BackgroundColor3 = fillColor
            end

            if fillColorSecondary then
                self.FillColorSecondary = fillColorSecondary
            end

            if trackColor then
                self.TrackColor = trackColor
                self._track.BackgroundColor3 = trackColor
            end

            -- Re-apply style for gradient
            if self.Style == ProgressBar.Style.Gradient then
                self:_applyStyle()
            end

            return self
        end

        --// Destroy override
        function ProgressBar:Destroy()
            self:_stopAnimations()
            Base.Destroy(self)
        end

        return ProgressBar


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Divider
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Divider"] = function()
        local script = CreateMockScript("NexusUI/Components/Divider")

        --[[
            NexusUI Divider Component
            Visual separator between content
        ]]

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Divider Component Module
        local Divider = setmetatable({}, { __index = Base })
        Divider.__index = Divider
        Divider.ClassName = "Divider"

        --// Divider Orientation
        Divider.Orientation = {
            Horizontal = "Horizontal",
            Vertical = "Vertical",
        }

        --// Constructor
        function Divider.new(config)
            local self = setmetatable(Base.new(config), Divider)

            config = config or {}

            self.Orientation = config.Orientation or Divider.Orientation.Horizontal
            self.Thickness = config.Thickness or 1
            self.Color = config.Color or Color3.fromRGB(63, 63, 70)
            self.Text = config.Text
            self.TextPosition = config.TextPosition or "Center" -- Left, Center, Right
            self.Margin = config.Margin or 0

            return self
        end

        --// Create divider
        function Divider:Create(parent)
            local isHorizontal = self.Orientation == Divider.Orientation.Horizontal

            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.BackgroundTransparency = 1

            if isHorizontal then
                container.Size = UDim2.new(1, 0, 0, self.Text and 20 or self.Thickness)
            else
                container.Size = UDim2.new(0, self.Thickness, 1, 0)
            end

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            if self.Text and isHorizontal then
                -- Divider with text
                local layout = Instance.new("UIListLayout")
                layout.FillDirection = Enum.FillDirection.Horizontal
                layout.VerticalAlignment = Enum.VerticalAlignment.Center
                layout.Padding = UDim.new(0, 12)
                layout.Parent = container

                -- Left line
                local leftLine = Instance.new("Frame")
                leftLine.Name = "LeftLine"
                leftLine.BackgroundColor3 = self.Color
                leftLine.BorderSizePixel = 0
                leftLine.LayoutOrder = 1
                leftLine.Parent = container
                self._leftLine = leftLine

                -- Text
                local text = Instance.new("TextLabel")
                text.Name = "Text"
                text.Size = UDim2.new(0, 0, 0, 0)
                text.AutomaticSize = Enum.AutomaticSize.XY
                text.BackgroundTransparency = 1
                text.Font = Enum.Font.Gotham
                text.Text = self.Text
                text.TextColor3 = Color3.fromRGB(113, 113, 122)
                text.TextSize = 12
                text.LayoutOrder = 2
                text.Parent = container
                self._text = text

                -- Right line
                local rightLine = Instance.new("Frame")
                rightLine.Name = "RightLine"
                rightLine.BackgroundColor3 = self.Color
                rightLine.BorderSizePixel = 0
                rightLine.LayoutOrder = 3
                rightLine.Parent = container
                self._rightLine = rightLine

                -- Calculate line sizes based on text position
                self:_updateLinePositions()

            else
                -- Simple line
                local line = Instance.new("Frame")
                line.Name = "Line"
                line.Size = UDim2.new(1, 0, 1, 0)
                line.BackgroundColor3 = self.Color
                line.BorderSizePixel = 0
                line.Parent = container
                self._line = line
            end

            return self
        end

        --// Update line positions based on text position
        function Divider:_updateLinePositions()
            if not self._leftLine or not self._rightLine then return end

            if self.TextPosition == "Left" then
                self._leftLine.Size = UDim2.new(0, 20, 0, self.Thickness)
                self._rightLine.Size = UDim2.new(1, -100, 0, self.Thickness)
            elseif self.TextPosition == "Right" then
                self._leftLine.Size = UDim2.new(1, -100, 0, self.Thickness)
                self._rightLine.Size = UDim2.new(0, 20, 0, self.Thickness)
            else -- Center
                self._leftLine.Size = UDim2.new(0.5, -40, 0, self.Thickness)
                self._rightLine.Size = UDim2.new(0.5, -40, 0, self.Thickness)
            end
        end

        --// Set color
        function Divider:SetColor(color)
            self.Color = color

            if self._line then
                self._line.BackgroundColor3 = color
            end

            if self._leftLine then
                self._leftLine.BackgroundColor3 = color
            end

            if self._rightLine then
                self._rightLine.BackgroundColor3 = color
            end

            return self
        end

        --// Set text
        function Divider:SetText(text)
            self.Text = text

            if self._text then
                self._text.Text = text
            end

            return self
        end

        return Divider


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Spacer
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Spacer"] = function()
        local script = CreateMockScript("NexusUI/Components/Spacer")

        --[[
            NexusUI Spacer Component
            Flexible space between components
        ]]

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Spacer Component Module
        local Spacer = setmetatable({}, { __index = Base })
        Spacer.__index = Spacer
        Spacer.ClassName = "Spacer"

        --// Constructor
        function Spacer.new(config)
            local self = setmetatable(Base.new(config), Spacer)

            config = config or {}

            self.Width = config.Width or 0
            self.Height = config.Height or 0
            self.Flex = config.Flex or 0 -- For flexible spacing in layouts

            return self
        end

        --// Create spacer
        function Spacer:Create(parent)
            local spacer = Instance.new("Frame")
            spacer.Name = self.Name
            spacer.BackgroundTransparency = 1
            spacer.BorderSizePixel = 0

            if self.Flex > 0 then
                -- Flexible spacer (grows to fill space)
                spacer.Size = UDim2.new(self.Flex, 0, self.Flex, 0)
            else
                -- Fixed spacer
                spacer.Size = UDim2.new(0, self.Width, 0, self.Height)
            end

            if parent then
                spacer.Parent = parent
            end

            self.Instance = spacer

            return self
        end

        --// Set size
        function Spacer:SetSize(width, height)
            self.Width = width or self.Width
            self.Height = height or self.Height

            if self.Instance and self.Flex == 0 then
                self.Instance.Size = UDim2.new(0, self.Width, 0, self.Height)
            end

            return self
        end

        --// Set flex
        function Spacer:SetFlex(flex)
            self.Flex = flex

            if self.Instance then
                if flex > 0 then
                    self.Instance.Size = UDim2.new(flex, 0, flex, 0)
                else
                    self.Instance.Size = UDim2.new(0, self.Width, 0, self.Height)
                end
            end

            return self
        end

        return Spacer


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Icon
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Icon"] = function()
        local script = CreateMockScript("NexusUI/Components/Icon")

        --[[
            NexusUI Icon Component
            Roblox icon display with easy customization
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Icon Component Module
        local Icon = setmetatable({}, { __index = Base })
        Icon.__index = Icon
        Icon.ClassName = "Icon"

        --// Built-in icon library (Roblox asset IDs)
        Icon.Library = {
            -- Navigation
            Home = "rbxassetid://7733964719",
            Menu = "rbxassetid://7733960805",
            Close = "rbxassetid://7072725342",
            Back = "rbxassetid://7072706620",
            Forward = "rbxassetid://7072706796",
            Up = "rbxassetid://7072725612",
            Down = "rbxassetid://7072706223",

            -- Actions
            Search = "rbxassetid://7072718929",
            Settings = "rbxassetid://7059346373",
            Edit = "rbxassetid://7072706435",
            Delete = "rbxassetid://7072706189",
            Add = "rbxassetid://7072706044",
            Remove = "rbxassetid://7072718651",
            Refresh = "rbxassetid://7072718464",
            Copy = "rbxassetid://7072706104",

            -- Status
            Check = "rbxassetid://7072706016",
            Warning = "rbxassetid://7072725760",
            Error = "rbxassetid://7072706350",
            Info = "rbxassetid://7072718185",

            -- Media
            Play = "rbxassetid://7072718281",
            Pause = "rbxassetid://7072718165",
            Stop = "rbxassetid://7072725252",
            Volume = "rbxassetid://7072725693",
            Mute = "rbxassetid://7072718013",

            -- User
            User = "rbxassetid://7072725516",
            Users = "rbxassetid://7072725573",

            -- Files
            File = "rbxassetid://7072706527",
            Folder = "rbxassetid://7072706609",
            Image = "rbxassetid://7072718089",
            Download = "rbxassetid://7072706290",
            Upload = "rbxassetid://7072725470",

            -- Communication
            Chat = "rbxassetid://7072705970",
            Mail = "rbxassetid://7072717874",
            Send = "rbxassetid://7072718820",

            -- Misc
            Star = "rbxassetid://7072725131",
            Heart = "rbxassetid://7072717960",
            Lock = "rbxassetid://7072717802",
            Unlock = "rbxassetid://7072725399",
            Eye = "rbxassetid://7072706494",
            EyeOff = "rbxassetid://7072706461",
            Link = "rbxassetid://7072717730",
            Maximize = "rbxassetid://7072717952",
            Minimize = "rbxassetid://7072717970",

            -- Gaming
            Gamepad = "rbxassetid://7072706686",
            Sword = "rbxassetid://7072725310",
            Shield = "rbxassetid://7072718985",
            Coin = "rbxassetid://7072706072",
            Trophy = "rbxassetid://7072725363",
        }

        --// Constructor
        function Icon.new(config)
            local self = setmetatable(Base.new(config), Icon)

            config = config or {}

            self.IconName = config.Icon -- Name from library
            self.IconId = config.IconId -- Direct asset ID
            self.IconSize = config.Size or 24
            self.Color = config.Color or Color3.fromRGB(250, 250, 250)
            self.Clickable = config.Clickable or false
            self.HoverColor = config.HoverColor or Color3.fromRGB(99, 102, 241)

            -- Callbacks
            self.OnClick = config.OnClick

            return self
        end

        --// Create icon
        function Icon:Create(parent)
            local iconId = self.IconId or Icon.Library[self.IconName] or Icon.Library.Info

            -- Icon container
            local container

            if self.Clickable then
                container = Instance.new("ImageButton")
                container.AutoButtonColor = false
            else
                container = Instance.new("ImageLabel")
            end

            container.Name = self.Name
            container.Size = UDim2.new(0, self.IconSize, 0, self.IconSize)
            container.BackgroundTransparency = 1
            container.Image = iconId
            container.ImageColor3 = self.Color
            container.ScaleType = Enum.ScaleType.Fit

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Setup interactions
            if self.Clickable then
                self:_setupInteractions()
            end

            return self
        end

        --// Setup interactions
        function Icon:_setupInteractions()
            local container = self.Instance

            -- Hover
            self:_connect(container.MouseEnter, function()
                TweenService:Create(container, TweenInfo.new(0.15), {
                    ImageColor3 = self.HoverColor,
                }):Play()
            end)

            self:_connect(container.MouseLeave, function()
                TweenService:Create(container, TweenInfo.new(0.15), {
                    ImageColor3 = self.Color,
                }):Play()
            end)

            -- Click
            self:_connect(container.MouseButton1Click, function()
                if self.OnClick then
                    self.OnClick()
                end

                self:_fire("Click")
            end)

            -- Press effect
            self:_connect(container.MouseButton1Down, function()
                TweenService:Create(container, TweenInfo.new(0.05), {
                    Size = UDim2.new(0, self.IconSize * 0.9, 0, self.IconSize * 0.9),
                }):Play()
            end)

            self:_connect(container.MouseButton1Up, function()
                TweenService:Create(container, TweenInfo.new(0.1, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                    Size = UDim2.new(0, self.IconSize, 0, self.IconSize),
                }):Play()
            end)
        end

        --// Set icon by name
        function Icon:SetIcon(iconName)
            self.IconName = iconName
            local iconId = Icon.Library[iconName]

            if iconId and self.Instance then
                self.Instance.Image = iconId
            end

            return self
        end

        --// Set icon by ID
        function Icon:SetIconId(iconId)
            self.IconId = iconId

            if self.Instance then
                self.Instance.Image = iconId
            end

            return self
        end

        --// Set color
        function Icon:SetColor(color)
            self.Color = color

            if self.Instance then
                self.Instance.ImageColor3 = color
            end

            return self
        end

        --// Set size
        function Icon:SetSize(size)
            self.IconSize = size

            if self.Instance then
                self.Instance.Size = UDim2.new(0, size, 0, size)
            end

            return self
        end

        --// Animate rotation
        function Icon:Spin(duration, loops)
            if not self.Instance then return self end

            duration = duration or 1
            loops = loops or math.huge

            task.spawn(function()
                for i = 1, loops do
                    TweenService:Create(self.Instance, TweenInfo.new(duration, Enum.EasingStyle.Linear), {
                        Rotation = self.Instance.Rotation + 360,
                    }):Play()
                    task.wait(duration)
                end
            end)

            return self
        end

        --// Pulse animation
        function Icon:Pulse()
            if not self.Instance then return self end

            local originalSize = self.IconSize

            TweenService:Create(self.Instance, TweenInfo.new(0.15), {
                Size = UDim2.new(0, originalSize * 1.2, 0, originalSize * 1.2),
            }):Play()

            task.delay(0.15, function()
                TweenService:Create(self.Instance, TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                    Size = UDim2.new(0, originalSize, 0, originalSize),
                }):Play()
            end)

            return self
        end

        return Icon


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Avatar
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Avatar"] = function()
        local script = CreateMockScript("NexusUI/Components/Avatar")

        --[[
            NexusUI Avatar Component
            User avatar display with various shapes
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")
        local Players = game:GetService("Players")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Avatar Component Module
        local Avatar = setmetatable({}, { __index = Base })
        Avatar.__index = Avatar
        Avatar.ClassName = "Avatar"

        --// Avatar Shapes
        Avatar.Shape = {
            Circle = "Circle",
            Square = "Square",
            Rounded = "Rounded",
        }

        --// Avatar Sizes
        Avatar.Size = {
            XS = 24,
            SM = 32,
            MD = 40,
            LG = 56,
            XL = 80,
        }

        --// Constructor
        function Avatar.new(config)
            local self = setmetatable(Base.new(config), Avatar)

            config = config or {}

            self.Image = config.Image
            self.UserId = config.UserId
            self.Initials = config.Initials
            self.AvatarSize = config.Size or Avatar.Size.MD
            self.Shape = config.Shape or Avatar.Shape.Circle
            self.BorderColor = config.BorderColor
            self.BorderWidth = config.BorderWidth or 0
            self.StatusIndicator = config.StatusIndicator -- "online", "offline", "away", "busy"
            self.FallbackColor = config.FallbackColor or Color3.fromRGB(99, 102, 241)

            return self
        end

        --// Get status color
        function Avatar:_getStatusColor()
            local colors = {
                online = Color3.fromRGB(34, 197, 94),
                offline = Color3.fromRGB(113, 113, 122),
                away = Color3.fromRGB(245, 158, 11),
                busy = Color3.fromRGB(239, 68, 68),
            }

            return colors[self.StatusIndicator] or Color3.fromRGB(113, 113, 122)
        end

        --// Get corner radius
        function Avatar:_getCornerRadius()
            if self.Shape == Avatar.Shape.Circle then
                return UDim.new(1, 0)
            elseif self.Shape == Avatar.Shape.Square then
                return UDim.new(0, 0)
            else -- Rounded
                return UDim.new(0, 8)
            end
        end

        --// Create avatar
        function Avatar:Create(parent)
            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(0, self.AvatarSize, 0, self.AvatarSize)
            container.BackgroundTransparency = 1

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Avatar frame
            local avatar = Instance.new("Frame")
            avatar.Name = "Avatar"
            avatar.Size = UDim2.new(1, 0, 1, 0)
            avatar.BackgroundColor3 = self.FallbackColor
            avatar.BorderSizePixel = 0
            avatar.ClipsDescendants = true
            avatar.Parent = container
            self._avatar = avatar

            -- Corner
            local corner = Instance.new("UICorner")
            corner.CornerRadius = self:_getCornerRadius()
            corner.Parent = avatar

            -- Border
            if self.BorderWidth > 0 then
                local stroke = Instance.new("UIStroke")
                stroke.Color = self.BorderColor or Color3.fromRGB(255, 255, 255)
                stroke.Thickness = self.BorderWidth
                stroke.Parent = avatar
                self._stroke = stroke
            end

            -- Image
            local image = Instance.new("ImageLabel")
            image.Name = "Image"
            image.Size = UDim2.new(1, 0, 1, 0)
            image.BackgroundTransparency = 1
            image.ImageTransparency = 1
            image.ScaleType = Enum.ScaleType.Crop
            image.Parent = avatar
            self._image = image

            local imageCorner = Instance.new("UICorner")
            imageCorner.CornerRadius = self:_getCornerRadius()
            imageCorner.Parent = image

            -- Initials (fallback)
            local initials = Instance.new("TextLabel")
            initials.Name = "Initials"
            initials.Size = UDim2.new(1, 0, 1, 0)
            initials.BackgroundTransparency = 1
            initials.Font = Enum.Font.GothamBold
            initials.Text = self.Initials or ""
            initials.TextColor3 = Color3.fromRGB(255, 255, 255)
            initials.TextSize = self.AvatarSize * 0.4
            initials.Parent = avatar
            self._initials = initials

            -- Status indicator
            if self.StatusIndicator then
                local statusSize = math.max(self.AvatarSize * 0.25, 8)

                local status = Instance.new("Frame")
                status.Name = "Status"
                status.Size = UDim2.new(0, statusSize, 0, statusSize)
                status.Position = UDim2.new(1, -statusSize * 0.3, 1, -statusSize * 0.3)
                status.AnchorPoint = Vector2.new(1, 1)
                status.BackgroundColor3 = self:_getStatusColor()
                status.BorderSizePixel = 0
                status.ZIndex = 2
                status.Parent = container
                self._status = status

                local statusCorner = Instance.new("UICorner")
                statusCorner.CornerRadius = UDim.new(1, 0)
                statusCorner.Parent = status

                -- Status border
                local statusBorder = Instance.new("UIStroke")
                statusBorder.Color = Color3.fromRGB(30, 30, 35)
                statusBorder.Thickness = 2
                statusBorder.Parent = status
            end

            -- Load image
            self:_loadImage()

            return self
        end

        --// Load image
        function Avatar:_loadImage()
            local imageUrl = self.Image

            -- If UserId provided, get thumbnail
            if self.UserId and not self.Image then
                imageUrl = Players:GetUserThumbnailAsync(
                    self.UserId,
                    Enum.ThumbnailType.HeadShot,
                    Enum.ThumbnailSize.Size100x100
                )
            end

            if imageUrl then
                self._image.Image = imageUrl

                -- Fade in when loaded
                TweenService:Create(self._image, TweenInfo.new(0.2), {
                    ImageTransparency = 0,
                }):Play()

                -- Hide initials
                self._initials.Visible = false
            else
                -- Show initials as fallback
                self._initials.Visible = true
                self._image.Visible = false
            end
        end

        --// Set image
        function Avatar:SetImage(image)
            self.Image = image
            self:_loadImage()
            return self
        end

        --// Set user ID
        function Avatar:SetUserId(userId)
            self.UserId = userId
            self.Image = nil
            self:_loadImage()
            return self
        end

        --// Set initials
        function Avatar:SetInitials(initials)
            self.Initials = initials

            if self._initials then
                self._initials.Text = initials
            end

            return self
        end

        --// Set status
        function Avatar:SetStatus(status)
            self.StatusIndicator = status

            if self._status then
                TweenService:Create(self._status, TweenInfo.new(0.2), {
                    BackgroundColor3 = self:_getStatusColor(),
                }):Play()
            end

            return self
        end

        --// Set shape
        function Avatar:SetShape(shape)
            self.Shape = shape
            local radius = self:_getCornerRadius()

            if self._avatar then
                for _, child in ipairs(self._avatar:GetChildren()) do
                    if child:IsA("UICorner") then
                        child.CornerRadius = radius
                    end
                end
            end

            return self
        end

        --// Show online pulse
        function Avatar:ShowOnlinePulse()
            if not self._status then return self end

            local ring = Instance.new("Frame")
            ring.Name = "PulseRing"
            ring.Size = UDim2.new(1, 0, 1, 0)
            ring.Position = UDim2.new(0.5, 0, 0.5, 0)
            ring.AnchorPoint = Vector2.new(0.5, 0.5)
            ring.BackgroundColor3 = self:_getStatusColor()
            ring.BackgroundTransparency = 0.5
            ring.BorderSizePixel = 0
            ring.ZIndex = self._status.ZIndex - 1
            ring.Parent = self._status

            local ringCorner = Instance.new("UICorner")
            ringCorner.CornerRadius = UDim.new(1, 0)
            ringCorner.Parent = ring

            -- Pulse animation
            local function pulse()
                ring.Size = UDim2.new(1, 0, 1, 0)
                ring.BackgroundTransparency = 0.5

                TweenService:Create(ring, TweenInfo.new(1.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                    Size = UDim2.new(2.5, 0, 2.5, 0),
                    BackgroundTransparency = 1,
                }):Play()
            end

            pulse()
            task.spawn(function()
                while ring and ring.Parent do
                    task.wait(1.5)
                    if ring and ring.Parent then
                        pulse()
                    end
                end
            end)

            return self
        end

        return Avatar


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Badge
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Badge"] = function()
        local script = CreateMockScript("NexusUI/Components/Badge")

        --[[
            NexusUI Badge Component
            Small status indicator or label
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Badge Component Module
        local Badge = setmetatable({}, { __index = Base })
        Badge.__index = Badge
        Badge.ClassName = "Badge"

        --// Badge Variants
        Badge.Variant = {
            Default = "Default",
            Primary = "Primary",
            Secondary = "Secondary",
            Success = "Success",
            Warning = "Warning",
            Danger = "Danger",
            Info = "Info",
            Outline = "Outline",
            Dot = "Dot",
        }

        --// Constructor
        function Badge.new(config)
            local self = setmetatable(Base.new(config), Badge)

            config = config or {}

            self.Text = config.Text or "Badge"
            self.Variant = config.Variant or Badge.Variant.Primary
            self.Icon = config.Icon
            self.Pulse = config.Pulse or false
            self.Count = config.Count
            self.MaxCount = config.MaxCount or 99

            return self
        end

        --// Get variant colors
        function Badge:_getVariantColors()
            local variants = {
                Default = {
                    Background = Color3.fromRGB(63, 63, 70),
                    Text = Color3.fromRGB(250, 250, 250),
                },
                Primary = {
                    Background = Color3.fromRGB(99, 102, 241),
                    Text = Color3.fromRGB(255, 255, 255),
                },
                Secondary = {
                    Background = Color3.fromRGB(82, 82, 91),
                    Text = Color3.fromRGB(250, 250, 250),
                },
                Success = {
                    Background = Color3.fromRGB(34, 197, 94),
                    Text = Color3.fromRGB(255, 255, 255),
                },
                Warning = {
                    Background = Color3.fromRGB(245, 158, 11),
                    Text = Color3.fromRGB(0, 0, 0),
                },
                Danger = {
                    Background = Color3.fromRGB(239, 68, 68),
                    Text = Color3.fromRGB(255, 255, 255),
                },
                Info = {
                    Background = Color3.fromRGB(59, 130, 246),
                    Text = Color3.fromRGB(255, 255, 255),
                },
                Outline = {
                    Background = Color3.fromRGB(0, 0, 0),
                    BackgroundTransparency = 1,
                    Text = Color3.fromRGB(250, 250, 250),
                    BorderColor = Color3.fromRGB(82, 82, 91),
                },
                Dot = {
                    Background = Color3.fromRGB(239, 68, 68),
                    Text = Color3.fromRGB(255, 255, 255),
                },
            }

            return variants[self.Variant] or variants.Default
        end

        --// Create badge
        function Badge:Create(parent)
            local colors = self:_getVariantColors()
            local isDot = self.Variant == Badge.Variant.Dot

            -- Badge container
            local badge = Instance.new("Frame")
            badge.Name = self.Name
            badge.BackgroundColor3 = colors.Background
            badge.BackgroundTransparency = colors.BackgroundTransparency or 0
            badge.BorderSizePixel = 0

            if isDot then
                badge.Size = UDim2.new(0, 8, 0, 8)
            else
                badge.Size = UDim2.new(0, 0, 0, 22)
                badge.AutomaticSize = Enum.AutomaticSize.X
            end

            if parent then
                badge.Parent = parent
            end

            self.Instance = badge

            -- Corner
            local corner = Instance.new("UICorner")
            corner.CornerRadius = isDot and UDim.new(1, 0) or UDim.new(0, 11)
            corner.Parent = badge

            -- Padding
            if not isDot then
                local padding = Instance.new("UIPadding")
                padding.PaddingLeft = UDim.new(0, 8)
                padding.PaddingRight = UDim.new(0, 8)
                padding.Parent = badge

                -- Layout
                local layout = Instance.new("UIListLayout")
                layout.FillDirection = Enum.FillDirection.Horizontal
                layout.VerticalAlignment = Enum.VerticalAlignment.Center
                layout.Padding = UDim.new(0, 4)
                layout.Parent = badge

                -- Icon
                if self.Icon then
                    local icon = Instance.new("ImageLabel")
                    icon.Name = "Icon"
                    icon.Size = UDim2.new(0, 12, 0, 12)
                    icon.BackgroundTransparency = 1
                    icon.Image = self.Icon
                    icon.ImageColor3 = colors.Text
                    icon.LayoutOrder = 1
                    icon.Parent = badge
                    self._icon = icon
                end

                -- Text
                local displayText = self.Text
                if self.Count then
                    displayText = self.Count > self.MaxCount and (tostring(self.MaxCount) .. "+") or tostring(self.Count)
                end

                local text = Instance.new("TextLabel")
                text.Name = "Text"
                text.Size = UDim2.new(0, 0, 1, 0)
                text.AutomaticSize = Enum.AutomaticSize.X
                text.BackgroundTransparency = 1
                text.Font = Enum.Font.GothamMedium
                text.Text = displayText
                text.TextColor3 = colors.Text
                text.TextSize = 12
                text.LayoutOrder = 2
                text.Parent = badge
                self._text = text
            end

            -- Border for outline
            if self.Variant == Badge.Variant.Outline then
                local stroke = Instance.new("UIStroke")
                stroke.Color = colors.BorderColor
                stroke.Thickness = 1
                stroke.Parent = badge
            end

            -- Pulse animation
            if self.Pulse then
                self:_startPulse()
            end

            return self
        end

        --// Start pulse animation
        function Badge:_startPulse()
            -- Pulse ring
            local ring = Instance.new("Frame")
            ring.Name = "PulseRing"
            ring.Size = UDim2.new(1, 0, 1, 0)
            ring.Position = UDim2.new(0.5, 0, 0.5, 0)
            ring.AnchorPoint = Vector2.new(0.5, 0.5)
            ring.BackgroundColor3 = self.Instance.BackgroundColor3
            ring.BackgroundTransparency = 0.5
            ring.BorderSizePixel = 0
            ring.ZIndex = self.Instance.ZIndex - 1
            ring.Parent = self.Instance
            self._pulseRing = ring

            local ringCorner = Instance.new("UICorner")
            ringCorner.CornerRadius = UDim.new(1, 0)
            ringCorner.Parent = ring

            -- Pulse animation loop
            local function pulse()
                ring.Size = UDim2.new(1, 0, 1, 0)
                ring.BackgroundTransparency = 0.5

                TweenService:Create(ring, TweenInfo.new(1.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                    Size = UDim2.new(2.5, 0, 2.5, 0),
                    BackgroundTransparency = 1,
                }):Play()
            end

            pulse()
            self._pulseConnection = task.spawn(function()
                while self.Instance and self.Instance.Parent do
                    task.wait(1.5)
                    pulse()
                end
            end)
        end

        --// Stop pulse
        function Badge:_stopPulse()
            if self._pulseConnection then
                task.cancel(self._pulseConnection)
                self._pulseConnection = nil
            end

            if self._pulseRing then
                self._pulseRing:Destroy()
                self._pulseRing = nil
            end
        end

        --// Set text
        function Badge:SetText(text)
            self.Text = text

            if self._text then
                self._text.Text = text
            end

            return self
        end

        --// Set count
        function Badge:SetCount(count)
            self.Count = count

            if self._text then
                local displayText = count > self.MaxCount and (tostring(self.MaxCount) .. "+") or tostring(count)
                self._text.Text = displayText
            end

            return self
        end

        --// Set variant
        function Badge:SetVariant(variant)
            self.Variant = variant
            local colors = self:_getVariantColors()

            self.Instance.BackgroundColor3 = colors.Background
            self.Instance.BackgroundTransparency = colors.BackgroundTransparency or 0

            if self._text then
                self._text.TextColor3 = colors.Text
            end

            if self._icon then
                self._icon.ImageColor3 = colors.Text
            end

            return self
        end

        --// Set pulse
        function Badge:SetPulse(pulse)
            self.Pulse = pulse

            if pulse then
                self:_startPulse()
            else
                self:_stopPulse()
            end

            return self
        end

        --// Destroy override
        function Badge:Destroy()
            self:_stopPulse()
            Base.Destroy(self)
        end

        return Badge


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Tooltip
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Tooltip"] = function()
        local script = CreateMockScript("NexusUI/Components/Tooltip")

        --[[
            NexusUI Tooltip Component
            Contextual information on hover
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")
        local RunService = game:GetService("RunService")
        local UserInputService = game:GetService("UserInputService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Tooltip Component Module
        local Tooltip = setmetatable({}, { __index = Base })
        Tooltip.__index = Tooltip
        Tooltip.ClassName = "Tooltip"

        --// Tooltip Positions
        Tooltip.Position = {
            Top = "Top",
            Bottom = "Bottom",
            Left = "Left",
            Right = "Right",
            Cursor = "Cursor",
        }

        --// Constructor
        function Tooltip.new(config)
            local self = setmetatable(Base.new(config), Tooltip)

            config = config or {}

            self.Text = config.Text or "Tooltip"
            self.TargetInstance = config.Target
            self.TooltipPosition = config.Position or Tooltip.Position.Top
            self.Delay = config.Delay or 0.5
            self.MaxWidth = config.MaxWidth or 200
            self.ShowArrow = config.ShowArrow ~= false
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
            self.TextColor = config.TextColor or Color3.fromRGB(250, 250, 250)

            -- State
            self._visible = false
            self._delayThread = nil
            self._followConnection = nil

            return self
        end

        --// Create tooltip
        function Tooltip:Create(parent)
            -- Get screen gui
            local screenGui = parent
            while screenGui and not screenGui:IsA("ScreenGui") do
                screenGui = screenGui.Parent
            end

            if not screenGui then
                screenGui = Instance.new("ScreenGui")
                screenGui.Parent = game:GetService("CoreGui")
            end

            -- Tooltip container
            local tooltip = Instance.new("Frame")
            tooltip.Name = self.Name
            tooltip.Size = UDim2.new(0, 0, 0, 0)
            tooltip.AutomaticSize = Enum.AutomaticSize.XY
            tooltip.BackgroundColor3 = self.BackgroundColor
            tooltip.BorderSizePixel = 0
            tooltip.Visible = false
            tooltip.ZIndex = 9999
            tooltip.Parent = screenGui
            self.Instance = tooltip

            -- Corner
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 6)
            corner.Parent = tooltip

            -- Shadow
            local shadow = Instance.new("ImageLabel")
            shadow.Name = "Shadow"
            shadow.Size = UDim2.new(1, 16, 1, 16)
            shadow.Position = UDim2.new(0.5, 0, 0.5, 4)
            shadow.AnchorPoint = Vector2.new(0.5, 0.5)
            shadow.BackgroundTransparency = 1
            shadow.Image = "rbxassetid://6015897843"
            shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
            shadow.ImageTransparency = 0.5
            shadow.ScaleType = Enum.ScaleType.Slice
            shadow.SliceCenter = Rect.new(49, 49, 450, 450)
            shadow.ZIndex = tooltip.ZIndex - 1
            shadow.Parent = tooltip

            -- Padding
            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, 8)
            padding.PaddingBottom = UDim.new(0, 8)
            padding.PaddingLeft = UDim.new(0, 12)
            padding.PaddingRight = UDim.new(0, 12)
            padding.Parent = tooltip

            -- Size constraint
            local constraint = Instance.new("UISizeConstraint")
            constraint.MaxSize = Vector2.new(self.MaxWidth, math.huge)
            constraint.Parent = tooltip

            -- Text
            local text = Instance.new("TextLabel")
            text.Name = "Text"
            text.Size = UDim2.new(0, 0, 0, 0)
            text.AutomaticSize = Enum.AutomaticSize.XY
            text.BackgroundTransparency = 1
            text.Font = Enum.Font.Gotham
            text.Text = self.Text
            text.TextColor3 = self.TextColor
            text.TextSize = 12
            text.TextWrapped = true
            text.TextXAlignment = Enum.TextXAlignment.Center
            text.ZIndex = tooltip.ZIndex
            text.Parent = tooltip
            self._text = text

            -- Arrow (if enabled)
            if self.ShowArrow then
                local arrow = Instance.new("ImageLabel")
                arrow.Name = "Arrow"
                arrow.Size = UDim2.new(0, 12, 0, 6)
                arrow.BackgroundTransparency = 1
                arrow.Image = "rbxassetid://4292963604" -- Triangle
                arrow.ImageColor3 = self.BackgroundColor
                arrow.ZIndex = tooltip.ZIndex
                arrow.Parent = tooltip
                self._arrow = arrow
            end

            -- Bind to target
            if self.TargetInstance then
                self:BindTo(self.TargetInstance)
            end

            return self
        end

        --// Update position
        function Tooltip:_updatePosition()
            if not self.TargetInstance or not self.Instance then return end

            local targetPos = self.TargetInstance.AbsolutePosition
            local targetSize = self.TargetInstance.AbsoluteSize
            local tooltipSize = self.Instance.AbsoluteSize

            local x, y = 0, 0
            local arrowRotation = 0
            local arrowX, arrowY = 0.5, 0

            if self.TooltipPosition == Tooltip.Position.Top then
                x = targetPos.X + targetSize.X / 2 - tooltipSize.X / 2
                y = targetPos.Y - tooltipSize.Y - 8
                arrowRotation = 180
                arrowX, arrowY = 0.5, 1

            elseif self.TooltipPosition == Tooltip.Position.Bottom then
                x = targetPos.X + targetSize.X / 2 - tooltipSize.X / 2
                y = targetPos.Y + targetSize.Y + 8
                arrowRotation = 0
                arrowX, arrowY = 0.5, -0.5

            elseif self.TooltipPosition == Tooltip.Position.Left then
                x = targetPos.X - tooltipSize.X - 8
                y = targetPos.Y + targetSize.Y / 2 - tooltipSize.Y / 2
                arrowRotation = 90
                arrowX, arrowY = 1, 0.5

            elseif self.TooltipPosition == Tooltip.Position.Right then
                x = targetPos.X + targetSize.X + 8
                y = targetPos.Y + targetSize.Y / 2 - tooltipSize.Y / 2
                arrowRotation = -90
                arrowX, arrowY = -0.5, 0.5

            elseif self.TooltipPosition == Tooltip.Position.Cursor then
                local mouse = UserInputService:GetMouseLocation()
                x = mouse.X + 12
                y = mouse.Y + 12
            end

            -- Keep on screen
            local viewportSize = workspace.CurrentCamera.ViewportSize
            x = math.clamp(x, 4, viewportSize.X - tooltipSize.X - 4)
            y = math.clamp(y, 4, viewportSize.Y - tooltipSize.Y - 4)

            self.Instance.Position = UDim2.new(0, x, 0, y)

            -- Update arrow
            if self._arrow and self.TooltipPosition ~= Tooltip.Position.Cursor then
                self._arrow.Rotation = arrowRotation
                self._arrow.AnchorPoint = Vector2.new(arrowX, arrowY)

                if self.TooltipPosition == Tooltip.Position.Top then
                    self._arrow.Position = UDim2.new(0.5, 0, 1, 0)
                elseif self.TooltipPosition == Tooltip.Position.Bottom then
                    self._arrow.Position = UDim2.new(0.5, 0, 0, 0)
                elseif self.TooltipPosition == Tooltip.Position.Left then
                    self._arrow.Position = UDim2.new(1, 0, 0.5, 0)
                elseif self.TooltipPosition == Tooltip.Position.Right then
                    self._arrow.Position = UDim2.new(0, 0, 0.5, 0)
                end
            end
        end

        --// Show
        function Tooltip:Show(animate)
            if self._visible then return self end

            self._visible = true
            animate = animate ~= false

            self:_updatePosition()
            self.Instance.Visible = true

            if animate then
                self.Instance.BackgroundTransparency = 1
                if self._text then self._text.TextTransparency = 1 end

                TweenService:Create(self.Instance, TweenInfo.new(0.15), {
                    BackgroundTransparency = 0,
                }):Play()

                if self._text then
                    TweenService:Create(self._text, TweenInfo.new(0.15), {
                        TextTransparency = 0,
                    }):Play()
                end
            end

            -- Start following if cursor mode
            if self.TooltipPosition == Tooltip.Position.Cursor then
                self._followConnection = RunService.Heartbeat:Connect(function()
                    self:_updatePosition()
                end)
            end

            self:_fire("Show")
            return self
        end

        --// Hide
        function Tooltip:Hide(animate)
            if not self._visible then return self end

            self._visible = false
            animate = animate ~= false

            -- Stop following
            if self._followConnection then
                self._followConnection:Disconnect()
                self._followConnection = nil
            end

            if animate then
                TweenService:Create(self.Instance, TweenInfo.new(0.1), {
                    BackgroundTransparency = 1,
                }):Play()

                if self._text then
                    TweenService:Create(self._text, TweenInfo.new(0.1), {
                        TextTransparency = 1,
                    }):Play()
                end

                task.delay(0.1, function()
                    if not self._visible then
                        self.Instance.Visible = false
                    end
                end)
            else
                self.Instance.Visible = false
            end

            self:_fire("Hide")
            return self
        end

        --// Bind to instance
        function Tooltip:BindTo(instance)
            self.TargetInstance = instance

            -- Mouse enter
            self:_connect(instance.MouseEnter, function()
                -- Cancel existing delay
                if self._delayThread then
                    task.cancel(self._delayThread)
                end

                -- Start delay
                self._delayThread = task.delay(self.Delay, function()
                    self:Show()
                end)
            end)

            -- Mouse leave
            self:_connect(instance.MouseLeave, function()
                -- Cancel delay
                if self._delayThread then
                    task.cancel(self._delayThread)
                    self._delayThread = nil
                end

                self:Hide()
            end)

            return self
        end

        --// Set text
        function Tooltip:SetText(text)
            self.Text = text

            if self._text then
                self._text.Text = text
            end

            return self
        end

        --// Set position
        function Tooltip:SetPosition(position)
            self.TooltipPosition = position
            self:_updatePosition()
            return self
        end

        --// Destroy override
        function Tooltip:Destroy()
            if self._delayThread then
                task.cancel(self._delayThread)
            end

            if self._followConnection then
                self._followConnection:Disconnect()
            end

            Base.Destroy(self)
        end

        return Tooltip


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Image
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Image"] = function()
        local script = CreateMockScript("NexusUI/Components/Image")

        --[[
            NexusUI Image Component
            Image display with loading states
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")
        local ContentProvider = game:GetService("ContentProvider")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Image Component Module
        local Image = setmetatable({}, { __index = Base })
        Image.__index = Image
        Image.ClassName = "Image"

        --// Image Fit Modes
        Image.Fit = {
            Cover = "Cover",
            Contain = "Contain",
            Fill = "Fill",
            None = "None",
        }

        --// Constructor
        function Image.new(config)
            local self = setmetatable(Base.new(config), Image)

            config = config or {}

            self.Source = config.Source or ""
            self.FitMode = config.FitMode or Image.Fit.Cover
            self.CornerRadius = config.CornerRadius or 0
            self.FallbackImage = config.FallbackImage
            self.FallbackColor = config.FallbackColor or Color3.fromRGB(39, 39, 42)
            self.ShowLoading = config.ShowLoading or false
            self.Tint = config.Tint or Color3.fromRGB(255, 255, 255)
            self.AspectRatio = config.AspectRatio -- e.g., 16/9

            -- State
            self._isLoaded = false
            self._hasError = false

            return self
        end

        --// Create image
        function Image:Create(parent)
            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(1, 0, 0, 200)
            container.BackgroundColor3 = self.FallbackColor
            container.BorderSizePixel = 0
            container.ClipsDescendants = true

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Corner radius
            if self.CornerRadius > 0 then
                local corner = Instance.new("UICorner")
                corner.CornerRadius = UDim.new(0, self.CornerRadius)
                corner.Parent = container
            end

            -- Aspect ratio constraint
            if self.AspectRatio then
                local ratio = Instance.new("UIAspectRatioConstraint")
                ratio.AspectRatio = self.AspectRatio
                ratio.Parent = container
            end

            -- Image
            local image = Instance.new("ImageLabel")
            image.Name = "Image"
            image.BackgroundTransparency = 1
            image.ImageColor3 = self.Tint
            image.ImageTransparency = 1
            image.Parent = container
            self._image = image

            -- Apply fit mode
            self:_applyFitMode()

            -- Corner for image
            if self.CornerRadius > 0 then
                local corner = Instance.new("UICorner")
                corner.CornerRadius = UDim.new(0, self.CornerRadius)
                corner.Parent = image
            end

            -- Loading indicator
            if self.ShowLoading then
                local loading = Instance.new("Frame")
                loading.Name = "Loading"
                loading.Size = UDim2.new(0, 30, 0, 30)
                loading.Position = UDim2.new(0.5, 0, 0.5, 0)
                loading.AnchorPoint = Vector2.new(0.5, 0.5)
                loading.BackgroundTransparency = 1
                loading.Parent = container
                self._loading = loading

                -- Spinner
                local spinner = Instance.new("ImageLabel")
                spinner.Name = "Spinner"
                spinner.Size = UDim2.new(1, 0, 1, 0)
                spinner.BackgroundTransparency = 1
                spinner.Image = "rbxassetid://6034818372" -- Spinner icon
                spinner.ImageColor3 = Color3.fromRGB(161, 161, 170)
                spinner.Parent = loading
                self._spinner = spinner

                -- Start spinning
                self:_startSpinner()
            end

            -- Load image
            if self.Source ~= "" then
                self:SetSource(self.Source)
            end

            return self
        end

        --// Apply fit mode
        function Image:_applyFitMode()
            if not self._image then return end

            if self.FitMode == Image.Fit.Cover then
                self._image.Size = UDim2.new(1, 0, 1, 0)
                self._image.Position = UDim2.new(0, 0, 0, 0)
                self._image.ScaleType = Enum.ScaleType.Crop

            elseif self.FitMode == Image.Fit.Contain then
                self._image.Size = UDim2.new(1, 0, 1, 0)
                self._image.Position = UDim2.new(0, 0, 0, 0)
                self._image.ScaleType = Enum.ScaleType.Fit

            elseif self.FitMode == Image.Fit.Fill then
                self._image.Size = UDim2.new(1, 0, 1, 0)
                self._image.Position = UDim2.new(0, 0, 0, 0)
                self._image.ScaleType = Enum.ScaleType.Stretch

            elseif self.FitMode == Image.Fit.None then
                self._image.Position = UDim2.new(0.5, 0, 0.5, 0)
                self._image.AnchorPoint = Vector2.new(0.5, 0.5)
                self._image.ScaleType = Enum.ScaleType.Fit
                self._image.AutomaticSize = Enum.AutomaticSize.XY
            end
        end

        --// Start spinner animation
        function Image:_startSpinner()
            if not self._spinner then return end

            task.spawn(function()
                while self._spinner and self._spinner.Parent and not self._isLoaded do
                    self._spinner.Rotation = self._spinner.Rotation + 5
                    task.wait(0.02)
                end
            end)
        end

        --// Stop spinner
        function Image:_stopSpinner()
            if self._loading then
                TweenService:Create(self._loading, TweenInfo.new(0.2), {
                    -- Can't tween Visible, so we tween transparency
                }):Play()

                task.delay(0.2, function()
                    if self._loading then
                        self._loading.Visible = false
                    end
                end)
            end
        end

        --// Set source
        function Image:SetSource(source)
            self.Source = source
            self._isLoaded = false
            self._hasError = false

            if self._image then
                self._image.ImageTransparency = 1

                -- Show loading
                if self._loading then
                    self._loading.Visible = true
                    self:_startSpinner()
                end

                -- Preload image
                task.spawn(function()
                    local success = pcall(function()
                        ContentProvider:PreloadAsync({source})
                    end)

                    if success then
                        self._image.Image = source
                        self._isLoaded = true

                        -- Fade in
                        TweenService:Create(self._image, TweenInfo.new(0.3), {
                            ImageTransparency = 0,
                        }):Play()

                        self:_stopSpinner()
                        self:_fire("Loaded")

                    else
                        self._hasError = true

                        -- Show fallback
                        if self.FallbackImage then
                            self._image.Image = self.FallbackImage
                            TweenService:Create(self._image, TweenInfo.new(0.3), {
                                ImageTransparency = 0,
                            }):Play()
                        end

                        self:_stopSpinner()
                        self:_fire("Error")
                    end
                end)
            end

            return self
        end

        --// Set tint
        function Image:SetTint(color)
            self.Tint = color

            if self._image then
                self._image.ImageColor3 = color
            end

            return self
        end

        --// Set fit mode
        function Image:SetFitMode(mode)
            self.FitMode = mode
            self:_applyFitMode()
            return self
        end

        --// Set corner radius
        function Image:SetCornerRadius(radius)
            self.CornerRadius = radius

            local containers = {self.Instance, self._image}
            for _, container in ipairs(containers) do
                if container then
                    local corner = container:FindFirstChildOfClass("UICorner")
                    if corner then
                        corner.CornerRadius = UDim.new(0, radius)
                    elseif radius > 0 then
                        corner = Instance.new("UICorner")
                        corner.CornerRadius = UDim.new(0, radius)
                        corner.Parent = container
                    end
                end
            end

            return self
        end

        --// Is loaded
        function Image:IsLoaded()
            return self._isLoaded
        end

        --// Has error
        function Image:HasError()
            return self._hasError
        end

        return Image


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Dropdown
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Dropdown"] = function()
        local script = CreateMockScript("NexusUI/Components/Dropdown")

        --[[
            NexusUI Dropdown Component
            Selectable dropdown menu
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Dropdown Component Module
        local Dropdown = setmetatable({}, { __index = Base })
        Dropdown.__index = Dropdown
        Dropdown.ClassName = "Dropdown"

        --// Constructor
        function Dropdown.new(config)
            local self = setmetatable(Base.new(config), Dropdown)

            config = config or {}

            self.Options = config.Options or {} -- Array of {Text, Value, Icon, Disabled}
            self.SelectedIndex = config.SelectedIndex or 0
            self.Placeholder = config.Placeholder or "Select..."
            self.Label = config.Label
            self.Searchable = config.Searchable or false
            self.MaxVisibleItems = config.MaxVisibleItems or 6
            self.DropdownWidth = config.DropdownWidth -- nil = same as button

            -- Callbacks
            self.OnSelect = config.OnSelect
            self.OnOpen = config.OnOpen
            self.OnClose = config.OnClose

            -- State
            self._isOpen = false
            self._filteredOptions = {}
            self._optionButtons = {}

            return self
        end

        --// Create dropdown
        function Dropdown:Create(parent)
            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(1, 0, 0, 40)
            container.BackgroundTransparency = 1
            container.ClipsDescendants = false

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Button
            local button = Instance.new("TextButton")
            button.Name = "Button"
            button.Size = UDim2.new(1, 0, 1, 0)
            button.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            button.BorderSizePixel = 0
            button.Text = ""
            button.AutoButtonColor = false
            button.Parent = container
            self._button = button

            local buttonCorner = Instance.new("UICorner")
            buttonCorner.CornerRadius = UDim.new(0, 8)
            buttonCorner.Parent = button

            local buttonStroke = Instance.new("UIStroke")
            buttonStroke.Color = Color3.fromRGB(63, 63, 70)
            buttonStroke.Thickness = 1
            buttonStroke.Parent = button
            self._buttonStroke = buttonStroke

            local buttonPadding = Instance.new("UIPadding")
            buttonPadding.PaddingLeft = UDim.new(0, 12)
            buttonPadding.PaddingRight = UDim.new(0, 12)
            buttonPadding.Parent = button

            local buttonLayout = Instance.new("UIListLayout")
            buttonLayout.FillDirection = Enum.FillDirection.Horizontal
            buttonLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            buttonLayout.HorizontalAlignment = Enum.HorizontalAlignment.SpaceBetween
            buttonLayout.Parent = button

            -- Selected text
            local selectedText = Instance.new("TextLabel")
            selectedText.Name = "SelectedText"
            selectedText.Size = UDim2.new(1, -20, 1, 0)
            selectedText.BackgroundTransparency = 1
            selectedText.Font = Enum.Font.Gotham
            selectedText.TextColor3 = self.SelectedIndex > 0 and Color3.fromRGB(250, 250, 250) or Color3.fromRGB(113, 113, 122)
            selectedText.TextSize = 14
            selectedText.TextXAlignment = Enum.TextXAlignment.Left
            selectedText.TextTruncate = Enum.TextTruncate.AtEnd
            selectedText.LayoutOrder = 1
            selectedText.Parent = button
            self._selectedText = selectedText

            -- Update selected text
            self:_updateSelectedText()

            -- Arrow icon
            local arrow = Instance.new("ImageLabel")
            arrow.Name = "Arrow"
            arrow.Size = UDim2.new(0, 14, 0, 14)
            arrow.BackgroundTransparency = 1
            arrow.Image = "rbxassetid://7072706223"
            arrow.ImageColor3 = Color3.fromRGB(161, 161, 170)
            arrow.LayoutOrder = 2
            arrow.Parent = button
            self._arrow = arrow

            -- Dropdown panel
            local panel = Instance.new("Frame")
            panel.Name = "Panel"
            panel.Size = UDim2.new(self.DropdownWidth and 0 or 1, self.DropdownWidth or 0, 0, 0)
            panel.Position = UDim2.new(0, 0, 1, 4)
            panel.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            panel.BorderSizePixel = 0
            panel.Visible = false
            panel.ZIndex = 100
            panel.ClipsDescendants = true
            panel.Parent = container
            self._panel = panel

            local panelCorner = Instance.new("UICorner")
            panelCorner.CornerRadius = UDim.new(0, 8)
            panelCorner.Parent = panel

            local panelStroke = Instance.new("UIStroke")
            panelStroke.Color = Color3.fromRGB(63, 63, 70)
            panelStroke.Thickness = 1
            panelStroke.Parent = panel

            -- Shadow
            local shadow = Instance.new("ImageLabel")
            shadow.Name = "Shadow"
            shadow.Size = UDim2.new(1, 16, 1, 16)
            shadow.Position = UDim2.new(0.5, 0, 0.5, 4)
            shadow.AnchorPoint = Vector2.new(0.5, 0.5)
            shadow.BackgroundTransparency = 1
            shadow.Image = "rbxassetid://6015897843"
            shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
            shadow.ImageTransparency = 0.5
            shadow.ScaleType = Enum.ScaleType.Slice
            shadow.SliceCenter = Rect.new(49, 49, 450, 450)
            shadow.ZIndex = panel.ZIndex - 1
            shadow.Parent = panel

            -- Search input (if searchable)
            if self.Searchable then
                local searchContainer = Instance.new("Frame")
                searchContainer.Name = "SearchContainer"
                searchContainer.Size = UDim2.new(1, 0, 0, 36)
                searchContainer.BackgroundTransparency = 1
                searchContainer.Parent = panel

                local searchPadding = Instance.new("UIPadding")
                searchPadding.PaddingTop = UDim.new(0, 6)
                searchPadding.PaddingLeft = UDim.new(0, 6)
                searchPadding.PaddingRight = UDim.new(0, 6)
                searchPadding.Parent = searchContainer

                local searchBox = Instance.new("TextBox")
                searchBox.Name = "SearchBox"
                searchBox.Size = UDim2.new(1, 0, 0, 30)
                searchBox.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
                searchBox.BorderSizePixel = 0
                searchBox.Font = Enum.Font.Gotham
                searchBox.Text = ""
                searchBox.PlaceholderText = "Search..."
                searchBox.PlaceholderColor3 = Color3.fromRGB(113, 113, 122)
                searchBox.TextColor3 = Color3.fromRGB(250, 250, 250)
                searchBox.TextSize = 13
                searchBox.ClearTextOnFocus = false
                searchBox.Parent = searchContainer
                self._searchBox = searchBox

                local searchCorner = Instance.new("UICorner")
                searchCorner.CornerRadius = UDim.new(0, 6)
                searchCorner.Parent = searchBox

                local searchBoxPadding = Instance.new("UIPadding")
                searchBoxPadding.PaddingLeft = UDim.new(0, 8)
                searchBoxPadding.Parent = searchBox

                -- Search text changed
                self:_connect(searchBox:GetPropertyChangedSignal("Text"), function()
                    self:_filterOptions(searchBox.Text)
                end)
            end

            -- Options scroll frame
            local optionsFrame = Instance.new("ScrollingFrame")
            optionsFrame.Name = "Options"
            optionsFrame.Size = UDim2.new(1, 0, 1, self.Searchable and -42 or -6)
            optionsFrame.Position = UDim2.new(0, 0, 0, self.Searchable and 42 or 3)
            optionsFrame.BackgroundTransparency = 1
            optionsFrame.BorderSizePixel = 0
            optionsFrame.ScrollBarThickness = 4
            optionsFrame.ScrollBarImageColor3 = Color3.fromRGB(82, 82, 91)
            optionsFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
            optionsFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
            optionsFrame.ZIndex = panel.ZIndex
            optionsFrame.Parent = panel
            self._optionsFrame = optionsFrame

            local optionsPadding = Instance.new("UIPadding")
            optionsPadding.PaddingTop = UDim.new(0, 3)
            optionsPadding.PaddingBottom = UDim.new(0, 3)
            optionsPadding.PaddingLeft = UDim.new(0, 6)
            optionsPadding.PaddingRight = UDim.new(0, 6)
            optionsPadding.Parent = optionsFrame

            local optionsLayout = Instance.new("UIListLayout")
            optionsLayout.Padding = UDim.new(0, 2)
            optionsLayout.SortOrder = Enum.SortOrder.LayoutOrder
            optionsLayout.Parent = optionsFrame

            -- Create option buttons
            self:_createOptions()

            -- Setup interactions
            self:_setupInteractions()

            return self
        end

        --// Update selected text
        function Dropdown:_updateSelectedText()
            if self.SelectedIndex > 0 and self.Options[self.SelectedIndex] then
                local option = self.Options[self.SelectedIndex]
                self._selectedText.Text = option.Text or option
                self._selectedText.TextColor3 = Color3.fromRGB(250, 250, 250)
            else
                self._selectedText.Text = self.Placeholder
                self._selectedText.TextColor3 = Color3.fromRGB(113, 113, 122)
            end
        end

        --// Create option buttons
        function Dropdown:_createOptions()
            -- Clear existing
            for _, btn in ipairs(self._optionButtons) do
                btn:Destroy()
            end
            self._optionButtons = {}

            local options = #self._filteredOptions > 0 and self._filteredOptions or self.Options

            for i, option in ipairs(options) do
                local optionData = type(option) == "table" and option or { Text = option, Value = option }
                local isSelected = self:_getOptionIndex(optionData) == self.SelectedIndex

                local btn = Instance.new("TextButton")
                btn.Name = "Option" .. i
                btn.Size = UDim2.new(1, 0, 0, 32)
                btn.BackgroundColor3 = isSelected and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(39, 39, 42)
                btn.BackgroundTransparency = isSelected and 0 or 1
                btn.BorderSizePixel = 0
                btn.AutoButtonColor = false
                btn.LayoutOrder = i
                btn.ZIndex = self._panel.ZIndex
                btn.Parent = self._optionsFrame

                local btnCorner = Instance.new("UICorner")
                btnCorner.CornerRadius = UDim.new(0, 6)
                btnCorner.Parent = btn

                local btnPadding = Instance.new("UIPadding")
                btnPadding.PaddingLeft = UDim.new(0, 8)
                btnPadding.PaddingRight = UDim.new(0, 8)
                btnPadding.Parent = btn

                local btnLayout = Instance.new("UIListLayout")
                btnLayout.FillDirection = Enum.FillDirection.Horizontal
                btnLayout.VerticalAlignment = Enum.VerticalAlignment.Center
                btnLayout.Padding = UDim.new(0, 8)
                btnLayout.Parent = btn

                -- Icon (if provided)
                if optionData.Icon then
                    local icon = Instance.new("ImageLabel")
                    icon.Size = UDim2.new(0, 14, 0, 14)
                    icon.BackgroundTransparency = 1
                    icon.Image = optionData.Icon
                    icon.ImageColor3 = isSelected and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(161, 161, 170)
                    icon.ZIndex = btn.ZIndex
                    icon.LayoutOrder = 1
                    icon.Parent = btn
                end

                -- Text
                local text = Instance.new("TextLabel")
                text.Size = UDim2.new(1, optionData.Icon and -22 or 0, 1, 0)
                text.BackgroundTransparency = 1
                text.Font = Enum.Font.Gotham
                text.Text = optionData.Text
                text.TextColor3 = isSelected and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(250, 250, 250)
                text.TextSize = 13
                text.TextXAlignment = Enum.TextXAlignment.Left
                text.TextTruncate = Enum.TextTruncate.AtEnd
                text.ZIndex = btn.ZIndex
                text.LayoutOrder = 2
                text.Parent = btn

                -- Check mark (if selected)
                if isSelected then
                    local check = Instance.new("ImageLabel")
                    check.Size = UDim2.new(0, 14, 0, 14)
                    check.Position = UDim2.new(1, -22, 0.5, 0)
                    check.AnchorPoint = Vector2.new(0, 0.5)
                    check.BackgroundTransparency = 1
                    check.Image = "rbxassetid://6031094667"
                    check.ImageColor3 = Color3.fromRGB(255, 255, 255)
                    check.ZIndex = btn.ZIndex
                    check.Parent = btn
                end

                -- Click handler
                self:_connect(btn.MouseButton1Click, function()
                    if optionData.Disabled then return end

                    local realIndex = self:_getOptionIndex(optionData)
                    self:SetSelectedIndex(realIndex)
                    self:Close()
                end)

                -- Hover
                self:_connect(btn.MouseEnter, function()
                    if not isSelected then
                        TweenService:Create(btn, TweenInfo.new(0.1), {
                            BackgroundTransparency = 0,
                        }):Play()
                    end
                end)

                self:_connect(btn.MouseLeave, function()
                    if not isSelected then
                        TweenService:Create(btn, TweenInfo.new(0.1), {
                            BackgroundTransparency = 1,
                        }):Play()
                    end
                end)

                table.insert(self._optionButtons, btn)
            end
        end

        --// Get option index in original array
        function Dropdown:_getOptionIndex(optionData)
            for i, opt in ipairs(self.Options) do
                local data = type(opt) == "table" and opt or { Text = opt, Value = opt }
                if data.Text == optionData.Text and data.Value == optionData.Value then
                    return i
                end
            end
            return 0
        end

        --// Filter options
        function Dropdown:_filterOptions(query)
            self._filteredOptions = {}
            query = string.lower(query)

            if query == "" then
                self:_createOptions()
                return
            end

            for _, option in ipairs(self.Options) do
                local text = type(option) == "table" and option.Text or option
                if string.find(string.lower(text), query, 1, true) then
                    table.insert(self._filteredOptions, option)
                end
            end

            self:_createOptions()
        end

        --// Setup interactions
        function Dropdown:_setupInteractions()
            -- Toggle on button click
            self:_connect(self._button.MouseButton1Click, function()
                if self._isOpen then
                    self:Close()
                else
                    self:Open()
                end
            end)

            -- Hover
            self:_connect(self._button.MouseEnter, function()
                if not self._isOpen then
                    TweenService:Create(self._buttonStroke, TweenInfo.new(0.15), {
                        Color = Color3.fromRGB(82, 82, 91),
                    }):Play()
                end
            end)

            self:_connect(self._button.MouseLeave, function()
                if not self._isOpen then
                    TweenService:Create(self._buttonStroke, TweenInfo.new(0.15), {
                        Color = Color3.fromRGB(63, 63, 70),
                    }):Play()
                end
            end)
        end

        --// Open dropdown
        function Dropdown:Open()
            if self._isOpen then return self end

            self._isOpen = true
            self._panel.Visible = true

            -- Calculate height
            local itemHeight = 32
            local padding = self.Searchable and 48 or 6
            local maxHeight = self.MaxVisibleItems * itemHeight + padding
            local contentHeight = #self.Options * itemHeight + padding
            local panelHeight = math.min(contentHeight, maxHeight)

            -- Animate open
            self._panel.Size = UDim2.new(self.DropdownWidth and 0 or 1, self.DropdownWidth or 0, 0, 0)
            TweenService:Create(self._panel, TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                Size = UDim2.new(self.DropdownWidth and 0 or 1, self.DropdownWidth or 0, 0, panelHeight),
            }):Play()

            -- Rotate arrow
            TweenService:Create(self._arrow, TweenInfo.new(0.15), {
                Rotation = 180,
            }):Play()

            TweenService:Create(self._buttonStroke, TweenInfo.new(0.15), {
                Color = Color3.fromRGB(99, 102, 241),
            }):Play()

            -- Focus search if searchable
            if self.Searchable and self._searchBox then
                self._searchBox:CaptureFocus()
            end

            if self.OnOpen then
                self.OnOpen()
            end

            self:_fire("Open")

            return self
        end

        --// Close dropdown
        function Dropdown:Close()
            if not self._isOpen then return self end

            self._isOpen = false

            -- Animate close
            TweenService:Create(self._panel, TweenInfo.new(0.1), {
                Size = UDim2.new(self.DropdownWidth and 0 or 1, self.DropdownWidth or 0, 0, 0),
            }):Play()

            task.delay(0.1, function()
                if not self._isOpen then
                    self._panel.Visible = false
                end
            end)

            -- Rotate arrow back
            TweenService:Create(self._arrow, TweenInfo.new(0.15), {
                Rotation = 0,
            }):Play()

            TweenService:Create(self._buttonStroke, TweenInfo.new(0.15), {
                Color = Color3.fromRGB(63, 63, 70),
            }):Play()

            -- Clear search
            if self.Searchable and self._searchBox then
                self._searchBox.Text = ""
                self._filteredOptions = {}
            end

            if self.OnClose then
                self.OnClose()
            end

            self:_fire("Close")

            return self
        end

        --// Set selected index
        function Dropdown:SetSelectedIndex(index)
            if index == self.SelectedIndex then return self end

            local oldIndex = self.SelectedIndex
            self.SelectedIndex = index

            self:_updateSelectedText()
            self:_createOptions()

            local option = self.Options[index]
            local value = type(option) == "table" and (option.Value or option.Text) or option

            if self.OnSelect then
                self.OnSelect(index, value, oldIndex)
            end

            self:_fire("Select", index, value, oldIndex)

            return self
        end

        --// Set selected value
        function Dropdown:SetSelectedValue(value)
            for i, option in ipairs(self.Options) do
                local optValue = type(option) == "table" and (option.Value or option.Text) or option
                if optValue == value then
                    return self:SetSelectedIndex(i)
                end
            end
            return self
        end

        --// Get selected value
        function Dropdown:GetSelectedValue()
            if self.SelectedIndex > 0 and self.Options[self.SelectedIndex] then
                local option = self.Options[self.SelectedIndex]
                return type(option) == "table" and (option.Value or option.Text) or option
            end
            return nil
        end

        --// Set options
        function Dropdown:SetOptions(options)
            self.Options = options
            self.SelectedIndex = 0
            self._filteredOptions = {}

            self:_updateSelectedText()
            self:_createOptions()

            return self
        end

        return Dropdown


    end


    -- ============================================================================
    -- Module: NexusUI/Components/MultiSelect
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/MultiSelect"] = function()
        local script = CreateMockScript("NexusUI/Components/MultiSelect")

        --[[
            NexusUI MultiSelect Component
            Multi-selection dropdown
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// MultiSelect Component Module
        local MultiSelect = setmetatable({}, { __index = Base })
        MultiSelect.__index = MultiSelect
        MultiSelect.ClassName = "MultiSelect"

        --// Constructor
        function MultiSelect.new(config)
            local self = setmetatable(Base.new(config), MultiSelect)

            config = config or {}

            self.Options = config.Options or {}
            self.SelectedIndices = config.SelectedIndices or {}
            self.Placeholder = config.Placeholder or "Select items..."
            self.MaxSelections = config.MaxSelections or -1
            self.ShowTags = config.ShowTags ~= false
            self.MaxVisibleItems = config.MaxVisibleItems or 6

            -- Callbacks
            self.OnChange = config.OnChange

            -- State
            self._isOpen = false
            self._optionButtons = {}

            return self
        end

        --// Create multi-select
        function MultiSelect:Create(parent)
            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(1, 0, 0, 40)
            container.BackgroundTransparency = 1
            container.ClipsDescendants = false

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Button
            local button = Instance.new("TextButton")
            button.Name = "Button"
            button.Size = UDim2.new(1, 0, 1, 0)
            button.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            button.BorderSizePixel = 0
            button.Text = ""
            button.AutoButtonColor = false
            button.Parent = container
            self._button = button

            local buttonCorner = Instance.new("UICorner")
            buttonCorner.CornerRadius = UDim.new(0, 8)
            buttonCorner.Parent = button

            local buttonStroke = Instance.new("UIStroke")
            buttonStroke.Color = Color3.fromRGB(63, 63, 70)
            buttonStroke.Thickness = 1
            buttonStroke.Parent = button
            self._buttonStroke = buttonStroke

            local buttonPadding = Instance.new("UIPadding")
            buttonPadding.PaddingLeft = UDim.new(0, 12)
            buttonPadding.PaddingRight = UDim.new(0, 12)
            buttonPadding.Parent = button

            -- Tags container
            local tagsContainer = Instance.new("Frame")
            tagsContainer.Name = "Tags"
            tagsContainer.Size = UDim2.new(1, -30, 1, 0)
            tagsContainer.BackgroundTransparency = 1
            tagsContainer.ClipsDescendants = true
            tagsContainer.Parent = button
            self._tagsContainer = tagsContainer

            local tagsLayout = Instance.new("UIListLayout")
            tagsLayout.FillDirection = Enum.FillDirection.Horizontal
            tagsLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            tagsLayout.Padding = UDim.new(0, 4)
            tagsLayout.Parent = tagsContainer

            -- Placeholder
            local placeholder = Instance.new("TextLabel")
            placeholder.Name = "Placeholder"
            placeholder.Size = UDim2.new(1, 0, 1, 0)
            placeholder.BackgroundTransparency = 1
            placeholder.Font = Enum.Font.Gotham
            placeholder.Text = self.Placeholder
            placeholder.TextColor3 = Color3.fromRGB(113, 113, 122)
            placeholder.TextSize = 14
            placeholder.TextXAlignment = Enum.TextXAlignment.Left
            placeholder.Parent = tagsContainer
            self._placeholder = placeholder

            -- Arrow
            local arrow = Instance.new("ImageLabel")
            arrow.Name = "Arrow"
            arrow.Size = UDim2.new(0, 14, 0, 14)
            arrow.Position = UDim2.new(1, -14, 0.5, 0)
            arrow.AnchorPoint = Vector2.new(1, 0.5)
            arrow.BackgroundTransparency = 1
            arrow.Image = "rbxassetid://7072706223"
            arrow.ImageColor3 = Color3.fromRGB(161, 161, 170)
            arrow.Parent = button
            self._arrow = arrow

            -- Panel
            local panel = Instance.new("Frame")
            panel.Name = "Panel"
            panel.Size = UDim2.new(1, 0, 0, 0)
            panel.Position = UDim2.new(0, 0, 1, 4)
            panel.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            panel.BorderSizePixel = 0
            panel.Visible = false
            panel.ZIndex = 100
            panel.ClipsDescendants = true
            panel.Parent = container
            self._panel = panel

            local panelCorner = Instance.new("UICorner")
            panelCorner.CornerRadius = UDim.new(0, 8)
            panelCorner.Parent = panel

            local panelStroke = Instance.new("UIStroke")
            panelStroke.Color = Color3.fromRGB(63, 63, 70)
            panelStroke.Thickness = 1
            panelStroke.Parent = panel

            -- Options scroll frame
            local optionsFrame = Instance.new("ScrollingFrame")
            optionsFrame.Name = "Options"
            optionsFrame.Size = UDim2.new(1, 0, 1, -6)
            optionsFrame.Position = UDim2.new(0, 0, 0, 3)
            optionsFrame.BackgroundTransparency = 1
            optionsFrame.BorderSizePixel = 0
            optionsFrame.ScrollBarThickness = 4
            optionsFrame.ScrollBarImageColor3 = Color3.fromRGB(82, 82, 91)
            optionsFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
            optionsFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
            optionsFrame.ZIndex = panel.ZIndex
            optionsFrame.Parent = panel
            self._optionsFrame = optionsFrame

            local optionsPadding = Instance.new("UIPadding")
            optionsPadding.PaddingTop = UDim.new(0, 3)
            optionsPadding.PaddingBottom = UDim.new(0, 3)
            optionsPadding.PaddingLeft = UDim.new(0, 6)
            optionsPadding.PaddingRight = UDim.new(0, 6)
            optionsPadding.Parent = optionsFrame

            local optionsLayout = Instance.new("UIListLayout")
            optionsLayout.Padding = UDim.new(0, 2)
            optionsLayout.Parent = optionsFrame

            -- Create options
            self:_createOptions()
            self:_updateTags()

            -- Setup interactions
            self:_setupInteractions()

            return self
        end

        --// Create option buttons
        function MultiSelect:_createOptions()
            for _, btn in ipairs(self._optionButtons) do
                btn:Destroy()
            end
            self._optionButtons = {}

            for i, option in ipairs(self.Options) do
                local optionData = type(option) == "table" and option or { Text = option, Value = option }
                local isSelected = table.find(self.SelectedIndices, i) ~= nil

                local btn = Instance.new("TextButton")
                btn.Name = "Option" .. i
                btn.Size = UDim2.new(1, 0, 0, 32)
                btn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
                btn.BackgroundTransparency = isSelected and 0 or 1
                btn.BorderSizePixel = 0
                btn.Text = ""
                btn.AutoButtonColor = false
                btn.ZIndex = self._panel.ZIndex
                btn.Parent = self._optionsFrame

                local btnCorner = Instance.new("UICorner")
                btnCorner.CornerRadius = UDim.new(0, 6)
                btnCorner.Parent = btn

                local btnPadding = Instance.new("UIPadding")
                btnPadding.PaddingLeft = UDim.new(0, 8)
                btnPadding.PaddingRight = UDim.new(0, 8)
                btnPadding.Parent = btn

                local btnLayout = Instance.new("UIListLayout")
                btnLayout.FillDirection = Enum.FillDirection.Horizontal
                btnLayout.VerticalAlignment = Enum.VerticalAlignment.Center
                btnLayout.Padding = UDim.new(0, 8)
                btnLayout.Parent = btn

                -- Checkbox
                local checkbox = Instance.new("Frame")
                checkbox.Name = "Checkbox"
                checkbox.Size = UDim2.new(0, 16, 0, 16)
                checkbox.BackgroundColor3 = isSelected and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(63, 63, 70)
                checkbox.BorderSizePixel = 0
                checkbox.ZIndex = btn.ZIndex
                checkbox.LayoutOrder = 1
                checkbox.Parent = btn

                local checkboxCorner = Instance.new("UICorner")
                checkboxCorner.CornerRadius = UDim.new(0, 4)
                checkboxCorner.Parent = checkbox

                -- Checkmark
                local checkmark = Instance.new("ImageLabel")
                checkmark.Size = UDim2.new(0.7, 0, 0.7, 0)
                checkmark.Position = UDim2.new(0.5, 0, 0.5, 0)
                checkmark.AnchorPoint = Vector2.new(0.5, 0.5)
                checkmark.BackgroundTransparency = 1
                checkmark.Image = "rbxassetid://6031094667"
                checkmark.ImageColor3 = Color3.fromRGB(255, 255, 255)
                checkmark.ImageTransparency = isSelected and 0 or 1
                checkmark.ZIndex = btn.ZIndex
                checkmark.Parent = checkbox

                -- Text
                local text = Instance.new("TextLabel")
                text.Size = UDim2.new(1, -24, 1, 0)
                text.BackgroundTransparency = 1
                text.Font = Enum.Font.Gotham
                text.Text = optionData.Text
                text.TextColor3 = Color3.fromRGB(250, 250, 250)
                text.TextSize = 13
                text.TextXAlignment = Enum.TextXAlignment.Left
                text.ZIndex = btn.ZIndex
                text.LayoutOrder = 2
                text.Parent = btn

                -- Click handler
                self:_connect(btn.MouseButton1Click, function()
                    self:_toggleOption(i)
                end)

                -- Hover
                self:_connect(btn.MouseEnter, function()
                    if not isSelected then
                        TweenService:Create(btn, TweenInfo.new(0.1), {
                            BackgroundTransparency = 0.5,
                        }):Play()
                    end
                end)

                self:_connect(btn.MouseLeave, function()
                    if not isSelected then
                        TweenService:Create(btn, TweenInfo.new(0.1), {
                            BackgroundTransparency = 1,
                        }):Play()
                    end
                end)

                table.insert(self._optionButtons, btn)
            end
        end

        --// Toggle option
        function MultiSelect:_toggleOption(index)
            local existingPos = table.find(self.SelectedIndices, index)

            if existingPos then
                -- Deselect
                table.remove(self.SelectedIndices, existingPos)
            else
                -- Check max selections
                if self.MaxSelections > 0 and #self.SelectedIndices >= self.MaxSelections then
                    return
                end

                table.insert(self.SelectedIndices, index)
            end

            self:_createOptions()
            self:_updateTags()

            if self.OnChange then
                self.OnChange(self.SelectedIndices, self:GetSelectedValues())
            end

            self:_fire("Change", self.SelectedIndices, self:GetSelectedValues())
        end

        --// Update tags
        function MultiSelect:_updateTags()
            -- Clear existing tags
            for _, child in ipairs(self._tagsContainer:GetChildren()) do
                if child:IsA("Frame") then
                    child:Destroy()
                end
            end

            if #self.SelectedIndices == 0 then
                self._placeholder.Visible = true
                return
            end

            self._placeholder.Visible = false

            if self.ShowTags then
                for i, index in ipairs(self.SelectedIndices) do
                    if i > 3 then
                        -- Show "+X more" tag
                        local moreTag = Instance.new("Frame")
                        moreTag.Name = "MoreTag"
                        moreTag.Size = UDim2.new(0, 0, 0, 24)
                        moreTag.AutomaticSize = Enum.AutomaticSize.X
                        moreTag.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
                        moreTag.BorderSizePixel = 0
                        moreTag.Parent = self._tagsContainer

                        local tagCorner = Instance.new("UICorner")
                        tagCorner.CornerRadius = UDim.new(0, 4)
                        tagCorner.Parent = moreTag

                        local tagPadding = Instance.new("UIPadding")
                        tagPadding.PaddingLeft = UDim.new(0, 6)
                        tagPadding.PaddingRight = UDim.new(0, 6)
                        tagPadding.Parent = moreTag

                        local tagText = Instance.new("TextLabel")
                        tagText.Size = UDim2.new(0, 0, 1, 0)
                        tagText.AutomaticSize = Enum.AutomaticSize.X
                        tagText.BackgroundTransparency = 1
                        tagText.Font = Enum.Font.GothamMedium
                        tagText.Text = "+" .. (#self.SelectedIndices - 3) .. " more"
                        tagText.TextColor3 = Color3.fromRGB(250, 250, 250)
                        tagText.TextSize = 11
                        tagText.Parent = moreTag
                        break
                    end

                    local option = self.Options[index]
                    local text = type(option) == "table" and option.Text or option

                    local tag = Instance.new("Frame")
                    tag.Name = "Tag" .. i
                    tag.Size = UDim2.new(0, 0, 0, 24)
                    tag.AutomaticSize = Enum.AutomaticSize.X
                    tag.BackgroundColor3 = Color3.fromRGB(99, 102, 241)
                    tag.BorderSizePixel = 0
                    tag.Parent = self._tagsContainer

                    local tagCorner = Instance.new("UICorner")
                    tagCorner.CornerRadius = UDim.new(0, 4)
                    tagCorner.Parent = tag

                    local tagPadding = Instance.new("UIPadding")
                    tagPadding.PaddingLeft = UDim.new(0, 6)
                    tagPadding.PaddingRight = UDim.new(0, 6)
                    tagPadding.Parent = tag

                    local tagText = Instance.new("TextLabel")
                    tagText.Size = UDim2.new(0, 0, 1, 0)
                    tagText.AutomaticSize = Enum.AutomaticSize.X
                    tagText.BackgroundTransparency = 1
                    tagText.Font = Enum.Font.GothamMedium
                    tagText.Text = text
                    tagText.TextColor3 = Color3.fromRGB(255, 255, 255)
                    tagText.TextSize = 11
                    tagText.Parent = tag
                end
            else
                -- Just show count
                self._placeholder.Text = #self.SelectedIndices .. " selected"
                self._placeholder.TextColor3 = Color3.fromRGB(250, 250, 250)
                self._placeholder.Visible = true
            end
        end

        --// Setup interactions
        function MultiSelect:_setupInteractions()
            self:_connect(self._button.MouseButton1Click, function()
                if self._isOpen then
                    self:Close()
                else
                    self:Open()
                end
            end)

            self:_connect(self._button.MouseEnter, function()
                if not self._isOpen then
                    TweenService:Create(self._buttonStroke, TweenInfo.new(0.15), {
                        Color = Color3.fromRGB(82, 82, 91),
                    }):Play()
                end
            end)

            self:_connect(self._button.MouseLeave, function()
                if not self._isOpen then
                    TweenService:Create(self._buttonStroke, TweenInfo.new(0.15), {
                        Color = Color3.fromRGB(63, 63, 70),
                    }):Play()
                end
            end)
        end

        --// Open
        function MultiSelect:Open()
            if self._isOpen then return self end

            self._isOpen = true
            self._panel.Visible = true

            local itemHeight = 32
            local maxHeight = self.MaxVisibleItems * itemHeight + 12
            local contentHeight = #self.Options * itemHeight + 12
            local panelHeight = math.min(contentHeight, maxHeight)

            TweenService:Create(self._panel, TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                Size = UDim2.new(1, 0, 0, panelHeight),
            }):Play()

            TweenService:Create(self._arrow, TweenInfo.new(0.15), {
                Rotation = 180,
            }):Play()

            TweenService:Create(self._buttonStroke, TweenInfo.new(0.15), {
                Color = Color3.fromRGB(99, 102, 241),
            }):Play()

            return self
        end

        --// Close
        function MultiSelect:Close()
            if not self._isOpen then return self end

            self._isOpen = false

            TweenService:Create(self._panel, TweenInfo.new(0.1), {
                Size = UDim2.new(1, 0, 0, 0),
            }):Play()

            task.delay(0.1, function()
                if not self._isOpen then
                    self._panel.Visible = false
                end
            end)

            TweenService:Create(self._arrow, TweenInfo.new(0.15), {
                Rotation = 0,
            }):Play()

            TweenService:Create(self._buttonStroke, TweenInfo.new(0.15), {
                Color = Color3.fromRGB(63, 63, 70),
            }):Play()

            return self
        end

        --// Get selected values
        function MultiSelect:GetSelectedValues()
            local values = {}
            for _, index in ipairs(self.SelectedIndices) do
                local option = self.Options[index]
                local value = type(option) == "table" and (option.Value or option.Text) or option
                table.insert(values, value)
            end
            return values
        end

        --// Set selected indices
        function MultiSelect:SetSelectedIndices(indices)
            self.SelectedIndices = indices or {}
            self:_createOptions()
            self:_updateTags()
            return self
        end

        --// Select all
        function MultiSelect:SelectAll()
            self.SelectedIndices = {}
            for i = 1, #self.Options do
                if self.MaxSelections < 0 or i <= self.MaxSelections then
                    table.insert(self.SelectedIndices, i)
                end
            end
            self:_createOptions()
            self:_updateTags()
            return self
        end

        --// Clear selection
        function MultiSelect:ClearSelection()
            self.SelectedIndices = {}
            self:_createOptions()
            self:_updateTags()
            return self
        end

        return MultiSelect


    end


    -- ============================================================================
    -- Module: NexusUI/Components/ColorPicker
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/ColorPicker"] = function()
        local script = CreateMockScript("NexusUI/Components/ColorPicker")

        --[[
            NexusUI ColorPicker Component
            Interactive color selection
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")
        local UserInputService = game:GetService("UserInputService")
        local RunService = game:GetService("RunService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// ColorPicker Component Module
        local ColorPicker = setmetatable({}, { __index = Base })
        ColorPicker.__index = ColorPicker
        ColorPicker.ClassName = "ColorPicker"

        --// Constructor
        function ColorPicker.new(config)
            local self = setmetatable(Base.new(config), ColorPicker)

            config = config or {}

            self.Color = config.Color or Color3.fromRGB(255, 255, 255)
            self.Label = config.Label
            self.ShowAlpha = config.ShowAlpha or false
            self.Alpha = config.Alpha or 1
            self.ShowPresets = config.ShowPresets ~= false
            self.Presets = config.Presets or {
                Color3.fromRGB(239, 68, 68),   -- Red
                Color3.fromRGB(249, 115, 22),  -- Orange
                Color3.fromRGB(245, 158, 11),  -- Amber
                Color3.fromRGB(234, 179, 8),   -- Yellow
                Color3.fromRGB(132, 204, 22),  -- Lime
                Color3.fromRGB(34, 197, 94),   -- Green
                Color3.fromRGB(20, 184, 166),  -- Teal
                Color3.fromRGB(6, 182, 212),   -- Cyan
                Color3.fromRGB(59, 130, 246),  -- Blue
                Color3.fromRGB(99, 102, 241),  -- Indigo
                Color3.fromRGB(139, 92, 246),  -- Violet
                Color3.fromRGB(168, 85, 247),  -- Purple
                Color3.fromRGB(236, 72, 153),  -- Pink
                Color3.fromRGB(244, 63, 94),   -- Rose
                Color3.fromRGB(255, 255, 255), -- White
                Color3.fromRGB(0, 0, 0),       -- Black
            }

            -- Callbacks
            self.OnColorChanged = config.OnColorChanged

            -- State
            self._isExpanded = false
            self._hue = 0
            self._saturation = 1
            self._value = 1
            self._draggingPicker = false
            self._draggingHue = false

            -- Initialize HSV from color
            self:_updateHSVFromColor()

            return self
        end

        --// Update HSV from color
        function ColorPicker:_updateHSVFromColor()
            local h, s, v = Color3.toHSV(self.Color)
            self._hue = h
            self._saturation = s
            self._value = v
        end

        --// Update color from HSV
        function ColorPicker:_updateColorFromHSV()
            self.Color = Color3.fromHSV(self._hue, self._saturation, self._value)
        end

        --// Create color picker
        function ColorPicker:Create(parent)
            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(1, 0, 0, 36)
            container.BackgroundTransparency = 1
            container.ClipsDescendants = false

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Header
            local header = Instance.new("Frame")
            header.Name = "Header"
            header.Size = UDim2.new(1, 0, 0, 36)
            header.BackgroundTransparency = 1
            header.Parent = container

            local headerLayout = Instance.new("UIListLayout")
            headerLayout.FillDirection = Enum.FillDirection.Horizontal
            headerLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            headerLayout.HorizontalAlignment = Enum.HorizontalAlignment.SpaceBetween
            headerLayout.Parent = header

            -- Label
            if self.Label then
                local label = Instance.new("TextLabel")
                label.Name = "Label"
                label.Size = UDim2.new(0.5, 0, 1, 0)
                label.BackgroundTransparency = 1
                label.Font = Enum.Font.Gotham
                label.Text = self.Label
                label.TextColor3 = Color3.fromRGB(250, 250, 250)
                label.TextSize = 14
                label.TextXAlignment = Enum.TextXAlignment.Left
                label.LayoutOrder = 1
                label.Parent = header
            end

            -- Color preview button
            local previewButton = Instance.new("TextButton")
            previewButton.Name = "Preview"
            previewButton.Size = UDim2.new(0, 60, 0, 28)
            previewButton.BackgroundColor3 = self.Color
            previewButton.BorderSizePixel = 0
            previewButton.Text = ""
            previewButton.AutoButtonColor = false
            previewButton.LayoutOrder = 2
            previewButton.Parent = header
            self._previewButton = previewButton

            local previewCorner = Instance.new("UICorner")
            previewCorner.CornerRadius = UDim.new(0, 6)
            previewCorner.Parent = previewButton

            local previewStroke = Instance.new("UIStroke")
            previewStroke.Color = Color3.fromRGB(63, 63, 70)
            previewStroke.Thickness = 1
            previewStroke.Parent = previewButton

            -- Expanded panel
            local panel = Instance.new("Frame")
            panel.Name = "Panel"
            panel.Size = UDim2.new(1, 0, 0, 200)
            panel.Position = UDim2.new(0, 0, 0, 40)
            panel.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            panel.BorderSizePixel = 0
            panel.Visible = false
            panel.ZIndex = 100
            panel.Parent = container
            self._panel = panel

            local panelCorner = Instance.new("UICorner")
            panelCorner.CornerRadius = UDim.new(0, 8)
            panelCorner.Parent = panel

            local panelStroke = Instance.new("UIStroke")
            panelStroke.Color = Color3.fromRGB(63, 63, 70)
            panelStroke.Thickness = 1
            panelStroke.Parent = panel

            local panelPadding = Instance.new("UIPadding")
            panelPadding.PaddingTop = UDim.new(0, 12)
            panelPadding.PaddingBottom = UDim.new(0, 12)
            panelPadding.PaddingLeft = UDim.new(0, 12)
            panelPadding.PaddingRight = UDim.new(0, 12)
            panelPadding.Parent = panel

            -- Saturation/Value picker
            local picker = Instance.new("Frame")
            picker.Name = "Picker"
            picker.Size = UDim2.new(1, -30, 0, 120)
            picker.BackgroundColor3 = Color3.fromHSV(self._hue, 1, 1)
            picker.BorderSizePixel = 0
            picker.Parent = panel
            self._picker = picker

            local pickerCorner = Instance.new("UICorner")
            pickerCorner.CornerRadius = UDim.new(0, 6)
            pickerCorner.Parent = picker

            -- White gradient (saturation)
            local whiteGradient = Instance.new("UIGradient")
            whiteGradient.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255), Color3.fromRGB(255, 255, 255))
            whiteGradient.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 0),
                NumberSequenceKeypoint.new(1, 1),
            })
            whiteGradient.Parent = picker

            -- Black gradient overlay (value)
            local blackOverlay = Instance.new("Frame")
            blackOverlay.Size = UDim2.new(1, 0, 1, 0)
            blackOverlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            blackOverlay.BackgroundTransparency = 0
            blackOverlay.BorderSizePixel = 0
            blackOverlay.Parent = picker

            local blackOverlayCorner = Instance.new("UICorner")
            blackOverlayCorner.CornerRadius = UDim.new(0, 6)
            blackOverlayCorner.Parent = blackOverlay

            local blackGradient = Instance.new("UIGradient")
            blackGradient.Color = ColorSequence.new(Color3.fromRGB(0, 0, 0), Color3.fromRGB(0, 0, 0))
            blackGradient.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 1),
                NumberSequenceKeypoint.new(1, 0),
            })
            blackGradient.Rotation = 90
            blackGradient.Parent = blackOverlay

            -- Picker cursor
            local pickerCursor = Instance.new("Frame")
            pickerCursor.Name = "Cursor"
            pickerCursor.Size = UDim2.new(0, 14, 0, 14)
            pickerCursor.Position = UDim2.new(self._saturation, 0, 1 - self._value, 0)
            pickerCursor.AnchorPoint = Vector2.new(0.5, 0.5)
            pickerCursor.BackgroundColor3 = self.Color
            pickerCursor.BorderSizePixel = 0
            pickerCursor.ZIndex = 10
            pickerCursor.Parent = picker
            self._pickerCursor = pickerCursor

            local cursorCorner = Instance.new("UICorner")
            cursorCorner.CornerRadius = UDim.new(1, 0)
            cursorCorner.Parent = pickerCursor

            local cursorStroke = Instance.new("UIStroke")
            cursorStroke.Color = Color3.fromRGB(255, 255, 255)
            cursorStroke.Thickness = 2
            cursorStroke.Parent = pickerCursor

            -- Hue slider
            local hueSlider = Instance.new("Frame")
            hueSlider.Name = "HueSlider"
            hueSlider.Size = UDim2.new(0, 16, 0, 120)
            hueSlider.Position = UDim2.new(1, -16, 0, 0)
            hueSlider.BorderSizePixel = 0
            hueSlider.Parent = panel
            self._hueSlider = hueSlider

            local hueCorner = Instance.new("UICorner")
            hueCorner.CornerRadius = UDim.new(0, 8)
            hueCorner.Parent = hueSlider

            -- Hue gradient
            local hueGradient = Instance.new("UIGradient")
            hueGradient.Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.fromHSV(0, 1, 1)),
                ColorSequenceKeypoint.new(0.167, Color3.fromHSV(0.167, 1, 1)),
                ColorSequenceKeypoint.new(0.333, Color3.fromHSV(0.333, 1, 1)),
                ColorSequenceKeypoint.new(0.5, Color3.fromHSV(0.5, 1, 1)),
                ColorSequenceKeypoint.new(0.667, Color3.fromHSV(0.667, 1, 1)),
                ColorSequenceKeypoint.new(0.833, Color3.fromHSV(0.833, 1, 1)),
                ColorSequenceKeypoint.new(1, Color3.fromHSV(1, 1, 1)),
            })
            hueGradient.Rotation = 90
            hueGradient.Parent = hueSlider

            -- Hue cursor
            local hueCursor = Instance.new("Frame")
            hueCursor.Name = "HueCursor"
            hueCursor.Size = UDim2.new(1, 4, 0, 6)
            hueCursor.Position = UDim2.new(0.5, 0, self._hue, 0)
            hueCursor.AnchorPoint = Vector2.new(0.5, 0.5)
            hueCursor.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            hueCursor.BorderSizePixel = 0
            hueCursor.ZIndex = 10
            hueCursor.Parent = hueSlider
            self._hueCursor = hueCursor

            local hueCursorCorner = Instance.new("UICorner")
            hueCursorCorner.CornerRadius = UDim.new(0, 3)
            hueCursorCorner.Parent = hueCursor

            -- Presets
            if self.ShowPresets then
                local presetsContainer = Instance.new("Frame")
                presetsContainer.Name = "Presets"
                presetsContainer.Size = UDim2.new(1, 0, 0, 24)
                presetsContainer.Position = UDim2.new(0, 0, 0, 130)
                presetsContainer.BackgroundTransparency = 1
                presetsContainer.Parent = panel

                local presetsLayout = Instance.new("UIListLayout")
                presetsLayout.FillDirection = Enum.FillDirection.Horizontal
                presetsLayout.Padding = UDim.new(0, 4)
                presetsLayout.Parent = presetsContainer

                for i, presetColor in ipairs(self.Presets) do
                    local preset = Instance.new("TextButton")
                    preset.Size = UDim2.new(0, 16, 0, 16)
                    preset.BackgroundColor3 = presetColor
                    preset.BorderSizePixel = 0
                    preset.Text = ""
                    preset.Parent = presetsContainer

                    local presetCorner = Instance.new("UICorner")
                    presetCorner.CornerRadius = UDim.new(0, 4)
                    presetCorner.Parent = preset

                    self:_connect(preset.MouseButton1Click, function()
                        self:SetColor(presetColor)
                    end)
                end
            end

            -- Setup interactions
            self:_setupInteractions()

            return self
        end

        --// Setup interactions
        function ColorPicker:_setupInteractions()
            -- Toggle panel
            self:_connect(self._previewButton.MouseButton1Click, function()
                self:_togglePanel()
            end)

            -- Picker interactions
            local picker = self._picker

            local function updatePickerFromMouse()
                local mousePos = UserInputService:GetMouseLocation()
                local pickerPos = picker.AbsolutePosition
                local pickerSize = picker.AbsoluteSize

                local relX = math.clamp((mousePos.X - pickerPos.X) / pickerSize.X, 0, 1)
                local relY = math.clamp((mousePos.Y - pickerPos.Y) / pickerSize.Y, 0, 1)

                self._saturation = relX
                self._value = 1 - relY

                self:_updateColorFromHSV()
                self:_updateVisuals()
            end

            self:_connect(picker.InputBegan, function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    self._draggingPicker = true
                    updatePickerFromMouse()
                end
            end)

            -- Hue slider interactions
            local hueSlider = self._hueSlider

            local function updateHueFromMouse()
                local mousePos = UserInputService:GetMouseLocation()
                local sliderPos = hueSlider.AbsolutePosition
                local sliderSize = hueSlider.AbsoluteSize

                local relY = math.clamp((mousePos.Y - sliderPos.Y) / sliderSize.Y, 0, 1)

                self._hue = relY

                self:_updateColorFromHSV()
                self:_updateVisuals()
            end

            self:_connect(hueSlider.InputBegan, function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    self._draggingHue = true
                    updateHueFromMouse()
                end
            end)

            -- Global mouse move/up
            self:_connect(UserInputService.InputChanged, function(input)
                if input.UserInputType == Enum.UserInputType.MouseMovement then
                    if self._draggingPicker then
                        updatePickerFromMouse()
                    elseif self._draggingHue then
                        updateHueFromMouse()
                    end
                end
            end)

            self:_connect(UserInputService.InputEnded, function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    self._draggingPicker = false
                    self._draggingHue = false
                end
            end)
        end

        --// Toggle panel
        function ColorPicker:_togglePanel()
            self._isExpanded = not self._isExpanded
            self._panel.Visible = self._isExpanded

            if self._isExpanded then
                self.Instance.Size = UDim2.new(1, 0, 0, 250)
            else
                self.Instance.Size = UDim2.new(1, 0, 0, 36)
            end
        end

        --// Update visuals
        function ColorPicker:_updateVisuals()
            -- Update preview
            self._previewButton.BackgroundColor3 = self.Color

            -- Update picker background
            self._picker.BackgroundColor3 = Color3.fromHSV(self._hue, 1, 1)

            -- Update cursors
            self._pickerCursor.Position = UDim2.new(self._saturation, 0, 1 - self._value, 0)
            self._pickerCursor.BackgroundColor3 = self.Color

            self._hueCursor.Position = UDim2.new(0.5, 0, self._hue, 0)

            -- Fire callback
            if self.OnColorChanged then
                self.OnColorChanged(self.Color)
            end

            self:_fire("ColorChanged", self.Color)
        end

        --// Set color
        function ColorPicker:SetColor(color)
            self.Color = color
            self:_updateHSVFromColor()
            self:_updateVisuals()
            return self
        end

        --// Get color
        function ColorPicker:GetColor()
            return self.Color
        end

        --// Get color with alpha
        function ColorPicker:GetColorWithAlpha()
            return self.Color, self.Alpha
        end

        return ColorPicker


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Table
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Table"] = function()
        local script = CreateMockScript("NexusUI/Components/Table")

        --[[
            NexusUI Table Component
            Data table with sorting and selection
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Table Component Module
        local Table = setmetatable({}, { __index = Base })
        Table.__index = Table
        Table.ClassName = "Table"

        --// Constructor
        function Table.new(config)
            local self = setmetatable(Base.new(config), Table)

            config = config or {}

            self.Columns = config.Columns or {} -- Array of {Key, Header, Width, Sortable, Render}
            self.Data = config.Data or {}
            self.Selectable = config.Selectable or false
            self.MultiSelect = config.MultiSelect or false
            self.Striped = config.Striped or false
            self.Bordered = config.Bordered or false
            self.RowHeight = config.RowHeight or 40
            self.HeaderHeight = config.HeaderHeight or 44

            -- Callbacks
            self.OnRowClick = config.OnRowClick
            self.OnSelectionChange = config.OnSelectionChange
            self.OnSort = config.OnSort

            -- State
            self._selectedRows = {}
            self._sortColumn = nil
            self._sortDirection = "asc"
            self._rows = {}

            return self
        end

        --// Create table
        function Table:Create(parent)
            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(1, 0, 0, 300)
            container.BackgroundColor3 = Color3.fromRGB(24, 24, 27)
            container.BorderSizePixel = 0
            container.ClipsDescendants = true

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = container

            if self.Bordered then
                local stroke = Instance.new("UIStroke")
                stroke.Color = Color3.fromRGB(63, 63, 70)
                stroke.Thickness = 1
                stroke.Parent = container
            end

            -- Header
            local header = Instance.new("Frame")
            header.Name = "Header"
            header.Size = UDim2.new(1, 0, 0, self.HeaderHeight)
            header.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            header.BorderSizePixel = 0
            header.Parent = container
            self._header = header

            local headerCorner = Instance.new("UICorner")
            headerCorner.CornerRadius = UDim.new(0, 8)
            headerCorner.Parent = header

            -- Fix bottom corners of header
            local headerFix = Instance.new("Frame")
            headerFix.Size = UDim2.new(1, 0, 0.5, 0)
            headerFix.Position = UDim2.new(0, 0, 0.5, 0)
            headerFix.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            headerFix.BorderSizePixel = 0
            headerFix.ZIndex = header.ZIndex - 1
            headerFix.Parent = header

            local headerLayout = Instance.new("UIListLayout")
            headerLayout.FillDirection = Enum.FillDirection.Horizontal
            headerLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            headerLayout.Parent = header

            -- Create header cells
            self:_createHeaderCells()

            -- Body scroll frame
            local body = Instance.new("ScrollingFrame")
            body.Name = "Body"
            body.Size = UDim2.new(1, 0, 1, -self.HeaderHeight)
            body.Position = UDim2.new(0, 0, 0, self.HeaderHeight)
            body.BackgroundTransparency = 1
            body.BorderSizePixel = 0
            body.ScrollBarThickness = 6
            body.ScrollBarImageColor3 = Color3.fromRGB(82, 82, 91)
            body.CanvasSize = UDim2.new(0, 0, 0, 0)
            body.AutomaticCanvasSize = Enum.AutomaticSize.Y
            body.Parent = container
            self._body = body

            local bodyLayout = Instance.new("UIListLayout")
            bodyLayout.SortOrder = Enum.SortOrder.LayoutOrder
            bodyLayout.Parent = body

            -- Create rows
            self:_createRows()

            return self
        end

        --// Create header cells
        function Table:_createHeaderCells()
            for _, child in ipairs(self._header:GetChildren()) do
                if child:IsA("TextButton") or child:IsA("Frame") then
                    child:Destroy()
                end
            end

            for i, column in ipairs(self.Columns) do
                local cell

                if column.Sortable then
                    cell = Instance.new("TextButton")
                    cell.AutoButtonColor = false
                    cell.Text = ""
                else
                    cell = Instance.new("Frame")
                end

                cell.Name = "HeaderCell" .. i
                cell.Size = column.Width and UDim2.new(0, column.Width, 1, 0) or UDim2.new(1 / #self.Columns, 0, 1, 0)
                cell.BackgroundTransparency = 1
                cell.LayoutOrder = i
                cell.Parent = self._header

                local padding = Instance.new("UIPadding")
                padding.PaddingLeft = UDim.new(0, 12)
                padding.PaddingRight = UDim.new(0, 12)
                padding.Parent = cell

                local layout = Instance.new("UIListLayout")
                layout.FillDirection = Enum.FillDirection.Horizontal
                layout.VerticalAlignment = Enum.VerticalAlignment.Center
                layout.Padding = UDim.new(0, 6)
                layout.Parent = cell

                local text = Instance.new("TextLabel")
                text.Name = "Text"
                text.Size = UDim2.new(1, column.Sortable and -20 or 0, 1, 0)
                text.BackgroundTransparency = 1
                text.Font = Enum.Font.GothamMedium
                text.Text = column.Header or column.Key
                text.TextColor3 = Color3.fromRGB(161, 161, 170)
                text.TextSize = 12
                text.TextXAlignment = Enum.TextXAlignment.Left
                text.LayoutOrder = 1
                text.Parent = cell

                if column.Sortable then
                    local sortIcon = Instance.new("ImageLabel")
                    sortIcon.Name = "SortIcon"
                    sortIcon.Size = UDim2.new(0, 12, 0, 12)
                    sortIcon.BackgroundTransparency = 1
                    sortIcon.Image = "rbxassetid://7072706223"
                    sortIcon.ImageColor3 = Color3.fromRGB(113, 113, 122)
                    sortIcon.ImageTransparency = self._sortColumn == column.Key and 0 or 0.5
                    sortIcon.Rotation = self._sortDirection == "desc" and 180 or 0
                    sortIcon.LayoutOrder = 2
                    sortIcon.Parent = cell

                    self:_connect(cell.MouseButton1Click, function()
                        self:_toggleSort(column.Key)
                    end)

                    self:_connect(cell.MouseEnter, function()
                        TweenService:Create(sortIcon, TweenInfo.new(0.1), {
                            ImageTransparency = 0,
                        }):Play()
                    end)

                    self:_connect(cell.MouseLeave, function()
                        if self._sortColumn ~= column.Key then
                            TweenService:Create(sortIcon, TweenInfo.new(0.1), {
                                ImageTransparency = 0.5,
                            }):Play()
                        end
                    end)
                end
            end
        end

        --// Toggle sort
        function Table:_toggleSort(columnKey)
            if self._sortColumn == columnKey then
                self._sortDirection = self._sortDirection == "asc" and "desc" or "asc"
            else
                self._sortColumn = columnKey
                self._sortDirection = "asc"
            end

            self:_createHeaderCells()
            self:_sortData()
            self:_createRows()

            if self.OnSort then
                self.OnSort(columnKey, self._sortDirection)
            end
        end

        --// Sort data
        function Table:_sortData()
            if not self._sortColumn then return end

            table.sort(self.Data, function(a, b)
                local valA = a[self._sortColumn]
                local valB = b[self._sortColumn]

                if type(valA) == "string" and type(valB) == "string" then
                    if self._sortDirection == "asc" then
                        return valA:lower() < valB:lower()
                    else
                        return valA:lower() > valB:lower()
                    end
                else
                    if self._sortDirection == "asc" then
                        return valA < valB
                    else
                        return valA > valB
                    end
                end
            end)
        end

        --// Create rows
        function Table:_createRows()
            for _, row in ipairs(self._rows) do
                row:Destroy()
            end
            self._rows = {}

            for i, rowData in ipairs(self.Data) do
                local isSelected = table.find(self._selectedRows, i) ~= nil

                local row = Instance.new("TextButton")
                row.Name = "Row" .. i
                row.Size = UDim2.new(1, 0, 0, self.RowHeight)
                row.BackgroundColor3 = self.Striped and i % 2 == 0 and Color3.fromRGB(27, 27, 30) or Color3.fromRGB(24, 24, 27)
                row.BackgroundTransparency = isSelected and 0.8 or 0
                row.BorderSizePixel = 0
                row.Text = ""
                row.AutoButtonColor = false
                row.LayoutOrder = i
                row.Parent = self._body

                if isSelected then
                    row.BackgroundColor3 = Color3.fromRGB(99, 102, 241)
                end

                local rowLayout = Instance.new("UIListLayout")
                rowLayout.FillDirection = Enum.FillDirection.Horizontal
                rowLayout.VerticalAlignment = Enum.VerticalAlignment.Center
                rowLayout.Parent = row

                -- Hover indicator
                local hover = Instance.new("Frame")
                hover.Name = "Hover"
                hover.Size = UDim2.new(1, 0, 1, 0)
                hover.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                hover.BackgroundTransparency = 1
                hover.BorderSizePixel = 0
                hover.ZIndex = row.ZIndex - 1
                hover.Parent = row

                -- Create cells
                for j, column in ipairs(self.Columns) do
                    local cell = Instance.new("Frame")
                    cell.Name = "Cell" .. j
                    cell.Size = column.Width and UDim2.new(0, column.Width, 1, 0) or UDim2.new(1 / #self.Columns, 0, 1, 0)
                    cell.BackgroundTransparency = 1
                    cell.LayoutOrder = j
                    cell.Parent = row

                    local padding = Instance.new("UIPadding")
                    padding.PaddingLeft = UDim.new(0, 12)
                    padding.PaddingRight = UDim.new(0, 12)
                    padding.Parent = cell

                    local value = rowData[column.Key]

                    if column.Render then
                        -- Custom render function
                        column.Render(cell, value, rowData, i)
                    else
                        local text = Instance.new("TextLabel")
                        text.Size = UDim2.new(1, 0, 1, 0)
                        text.BackgroundTransparency = 1
                        text.Font = Enum.Font.Gotham
                        text.Text = tostring(value or "")
                        text.TextColor3 = Color3.fromRGB(250, 250, 250)
                        text.TextSize = 13
                        text.TextXAlignment = Enum.TextXAlignment.Left
                        text.TextTruncate = Enum.TextTruncate.AtEnd
                        text.Parent = cell
                    end
                end

                -- Interactions
                if self.Selectable then
                    self:_connect(row.MouseButton1Click, function()
                        self:_toggleRowSelection(i)
                    end)
                end

                self:_connect(row.MouseEnter, function()
                    if not isSelected then
                        TweenService:Create(hover, TweenInfo.new(0.1), {
                            BackgroundTransparency = 0.95,
                        }):Play()
                    end
                end)

                self:_connect(row.MouseLeave, function()
                    TweenService:Create(hover, TweenInfo.new(0.1), {
                        BackgroundTransparency = 1,
                    }):Play()
                end)

                if self.OnRowClick then
                    self:_connect(row.MouseButton1Click, function()
                        self.OnRowClick(i, rowData)
                    end)
                end

                table.insert(self._rows, row)
            end
        end

        --// Toggle row selection
        function Table:_toggleRowSelection(index)
            local existingPos = table.find(self._selectedRows, index)

            if existingPos then
                table.remove(self._selectedRows, existingPos)
            else
                if self.MultiSelect then
                    table.insert(self._selectedRows, index)
                else
                    self._selectedRows = { index }
                end
            end

            self:_createRows()

            if self.OnSelectionChange then
                self.OnSelectionChange(self._selectedRows, self:GetSelectedData())
            end
        end

        --// Get selected data
        function Table:GetSelectedData()
            local data = {}
            for _, index in ipairs(self._selectedRows) do
                table.insert(data, self.Data[index])
            end
            return data
        end

        --// Set data
        function Table:SetData(data)
            self.Data = data
            self._selectedRows = {}

            if self._sortColumn then
                self:_sortData()
            end

            self:_createRows()
            return self
        end

        --// Add row
        function Table:AddRow(rowData)
            table.insert(self.Data, rowData)

            if self._sortColumn then
                self:_sortData()
            end

            self:_createRows()
            return self
        end

        --// Remove row
        function Table:RemoveRow(index)
            table.remove(self.Data, index)

            -- Update selection
            for i, selectedIndex in ipairs(self._selectedRows) do
                if selectedIndex == index then
                    table.remove(self._selectedRows, i)
                elseif selectedIndex > index then
                    self._selectedRows[i] = selectedIndex - 1
                end
            end

            self:_createRows()
            return self
        end

        --// Clear selection
        function Table:ClearSelection()
            self._selectedRows = {}
            self:_createRows()
            return self
        end

        --// Select all
        function Table:SelectAll()
            if not self.MultiSelect then return self end

            self._selectedRows = {}
            for i = 1, #self.Data do
                table.insert(self._selectedRows, i)
            end

            self:_createRows()
            return self
        end

        return Table


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Pagination
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Pagination"] = function()
        local script = CreateMockScript("NexusUI/Components/Pagination")

        --[[
            NexusUI Pagination Component
            Page navigation controls
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Pagination Component Module
        local Pagination = setmetatable({}, { __index = Base })
        Pagination.__index = Pagination
        Pagination.ClassName = "Pagination"

        --// Constructor
        function Pagination.new(config)
            local self = setmetatable(Base.new(config), Pagination)

            config = config or {}

            self.CurrentPage = config.CurrentPage or 1
            self.TotalPages = config.TotalPages or 1
            self.VisiblePages = config.VisiblePages or 5
            self.ShowFirstLast = config.ShowFirstLast ~= false
            self.ShowPrevNext = config.ShowPrevNext ~= false

            -- Callbacks
            self.OnPageChange = config.OnPageChange

            -- State
            self._pageButtons = {}

            return self
        end

        --// Create pagination
        function Pagination:Create(parent)
            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(0, 0, 0, 36)
            container.AutomaticSize = Enum.AutomaticSize.X
            container.BackgroundTransparency = 1

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Horizontal
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.Padding = UDim.new(0, 4)
            layout.Parent = container

            -- Build pagination
            self:_buildPagination()

            return self
        end

        --// Build pagination
        function Pagination:_buildPagination()
            -- Clear existing
            for _, btn in ipairs(self._pageButtons) do
                btn:Destroy()
            end
            self._pageButtons = {}

            local layoutOrder = 0

            -- First page button
            if self.ShowFirstLast then
                layoutOrder = layoutOrder + 1
                self:_createNavButton("First", "⟪", layoutOrder, function()
                    self:GoToPage(1)
                end, self.CurrentPage == 1)
            end

            -- Previous button
            if self.ShowPrevNext then
                layoutOrder = layoutOrder + 1
                self:_createNavButton("Prev", "←", layoutOrder, function()
                    self:PrevPage()
                end, self.CurrentPage == 1)
            end

            -- Page numbers
            local startPage, endPage = self:_getPageRange()

            -- Ellipsis before
            if startPage > 1 then
                layoutOrder = layoutOrder + 1
                self:_createEllipsis(layoutOrder)
            end

            -- Page buttons
            for page = startPage, endPage do
                layoutOrder = layoutOrder + 1
                self:_createPageButton(page, layoutOrder)
            end

            -- Ellipsis after
            if endPage < self.TotalPages then
                layoutOrder = layoutOrder + 1
                self:_createEllipsis(layoutOrder)
            end

            -- Next button
            if self.ShowPrevNext then
                layoutOrder = layoutOrder + 1
                self:_createNavButton("Next", "→", layoutOrder, function()
                    self:NextPage()
                end, self.CurrentPage == self.TotalPages)
            end

            -- Last page button
            if self.ShowFirstLast then
                layoutOrder = layoutOrder + 1
                self:_createNavButton("Last", "⟫", layoutOrder, function()
                    self:GoToPage(self.TotalPages)
                end, self.CurrentPage == self.TotalPages)
            end
        end

        --// Get page range
        function Pagination:_getPageRange()
            local half = math.floor(self.VisiblePages / 2)
            local startPage = math.max(1, self.CurrentPage - half)
            local endPage = math.min(self.TotalPages, startPage + self.VisiblePages - 1)

            -- Adjust start if we're near the end
            if endPage - startPage + 1 < self.VisiblePages then
                startPage = math.max(1, endPage - self.VisiblePages + 1)
            end

            return startPage, endPage
        end

        --// Create page button
        function Pagination:_createPageButton(page, layoutOrder)
            local isSelected = page == self.CurrentPage

            local btn = Instance.new("TextButton")
            btn.Name = "Page" .. page
            btn.Size = UDim2.new(0, 36, 0, 36)
            btn.BackgroundColor3 = isSelected and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(39, 39, 42)
            btn.BackgroundTransparency = isSelected and 0 or 1
            btn.BorderSizePixel = 0
            btn.Font = Enum.Font.GothamMedium
            btn.Text = tostring(page)
            btn.TextColor3 = isSelected and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(250, 250, 250)
            btn.TextSize = 13
            btn.AutoButtonColor = false
            btn.LayoutOrder = layoutOrder
            btn.Parent = self.Instance

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 6)
            corner.Parent = btn

            if not isSelected then
                self:_connect(btn.MouseButton1Click, function()
                    self:GoToPage(page)
                end)

                self:_connect(btn.MouseEnter, function()
                    TweenService:Create(btn, TweenInfo.new(0.1), {
                        BackgroundTransparency = 0.5,
                    }):Play()
                end)

                self:_connect(btn.MouseLeave, function()
                    TweenService:Create(btn, TweenInfo.new(0.1), {
                        BackgroundTransparency = 1,
                    }):Play()
                end)
            end

            table.insert(self._pageButtons, btn)
        end

        --// Create nav button
        function Pagination:_createNavButton(name, text, layoutOrder, callback, disabled)
            local btn = Instance.new("TextButton")
            btn.Name = name
            btn.Size = UDim2.new(0, 36, 0, 36)
            btn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
            btn.BackgroundTransparency = 1
            btn.BorderSizePixel = 0
            btn.Font = Enum.Font.GothamBold
            btn.Text = text
            btn.TextColor3 = disabled and Color3.fromRGB(82, 82, 91) or Color3.fromRGB(250, 250, 250)
            btn.TextSize = 14
            btn.AutoButtonColor = false
            btn.LayoutOrder = layoutOrder
            btn.Parent = self.Instance

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 6)
            corner.Parent = btn

            if not disabled then
                self:_connect(btn.MouseButton1Click, callback)

                self:_connect(btn.MouseEnter, function()
                    TweenService:Create(btn, TweenInfo.new(0.1), {
                        BackgroundTransparency = 0.5,
                    }):Play()
                end)

                self:_connect(btn.MouseLeave, function()
                    TweenService:Create(btn, TweenInfo.new(0.1), {
                        BackgroundTransparency = 1,
                    }):Play()
                end)
            end

            table.insert(self._pageButtons, btn)
        end

        --// Create ellipsis
        function Pagination:_createEllipsis(layoutOrder)
            local ellipsis = Instance.new("TextLabel")
            ellipsis.Name = "Ellipsis"
            ellipsis.Size = UDim2.new(0, 20, 0, 36)
            ellipsis.BackgroundTransparency = 1
            ellipsis.Font = Enum.Font.GothamBold
            ellipsis.Text = "..."
            ellipsis.TextColor3 = Color3.fromRGB(113, 113, 122)
            ellipsis.TextSize = 14
            ellipsis.LayoutOrder = layoutOrder
            ellipsis.Parent = self.Instance

            table.insert(self._pageButtons, ellipsis)
        end

        --// Go to page
        function Pagination:GoToPage(page)
            page = math.clamp(page, 1, self.TotalPages)

            if page == self.CurrentPage then return self end

            local oldPage = self.CurrentPage
            self.CurrentPage = page

            self:_buildPagination()

            if self.OnPageChange then
                self.OnPageChange(page, oldPage)
            end

            self:_fire("PageChange", page, oldPage)

            return self
        end

        --// Next page
        function Pagination:NextPage()
            return self:GoToPage(self.CurrentPage + 1)
        end

        --// Previous page
        function Pagination:PrevPage()
            return self:GoToPage(self.CurrentPage - 1)
        end

        --// Set total pages
        function Pagination:SetTotalPages(totalPages)
            self.TotalPages = math.max(1, totalPages)

            if self.CurrentPage > self.TotalPages then
                self.CurrentPage = self.TotalPages
            end

            self:_buildPagination()
            return self
        end

        --// Get current page
        function Pagination:GetCurrentPage()
            return self.CurrentPage
        end

        return Pagination


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Window
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Window"] = function()
        local script = CreateMockScript("NexusUI/Components/Window")

        --[[
            NexusUI Window Component
            Draggable, resizable window container
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")
        local UserInputService = game:GetService("UserInputService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Window Component Module
        local Window = setmetatable({}, { __index = Base })
        Window.__index = Window
        Window.ClassName = "Window"

        --// Constructor
        function Window.new(config)
            local self = setmetatable(Base.new(config), Window)

            config = config or {}

            self.Title = config.Title or "Window"
            self.Icon = config.Icon
            self.Width = config.Width or 400
            self.Height = config.Height or 300
            self.MinWidth = config.MinWidth or 200
            self.MinHeight = config.MinHeight or 150
            self.Draggable = config.Draggable ~= false
            self.Resizable = config.Resizable or false
            self.Closable = config.Closable ~= false
            self.Minimizable = config.Minimizable or false
            self.Maximizable = config.Maximizable or false
            self.ShowHeader = config.ShowHeader ~= false
            self.StartPosition = config.StartPosition or "Center" -- Center, TopLeft, Custom
            self.CustomPosition = config.CustomPosition -- UDim2 for custom position

            -- Callbacks
            self.OnClose = config.OnClose
            self.OnMinimize = config.OnMinimize
            self.OnMaximize = config.OnMaximize
            self.OnRestore = config.OnRestore
            self.OnDrag = config.OnDrag
            self.OnResize = config.OnResize

            -- State
            self._isMinimized = false
            self._isMaximized = false
            self._isDragging = false
            self._isResizing = false
            self._dragOffset = Vector2.new(0, 0)
            self._originalSize = nil
            self._originalPosition = nil

            return self
        end

        --// Create window
        function Window:Create(parent)
            -- Main frame
            local window = Instance.new("Frame")
            window.Name = self.Name
            window.Size = UDim2.new(0, self.Width, 0, self.Height)
            window.BackgroundColor3 = Color3.fromRGB(24, 24, 27)
            window.BorderSizePixel = 0
            window.ClipsDescendants = true

            if parent then
                window.Parent = parent
            end

            self.Instance = window

            -- Position window
            self:_positionWindow()

            -- Corner
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 10)
            corner.Parent = window

            -- Shadow
            local shadow = Instance.new("ImageLabel")
            shadow.Name = "Shadow"
            shadow.Size = UDim2.new(1, 30, 1, 30)
            shadow.Position = UDim2.new(0.5, 0, 0.5, 8)
            shadow.AnchorPoint = Vector2.new(0.5, 0.5)
            shadow.BackgroundTransparency = 1
            shadow.Image = "rbxassetid://6015897843"
            shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
            shadow.ImageTransparency = 0.4
            shadow.ScaleType = Enum.ScaleType.Slice
            shadow.SliceCenter = Rect.new(49, 49, 450, 450)
            shadow.ZIndex = window.ZIndex - 1
            shadow.Parent = window

            -- Border
            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(63, 63, 70)
            stroke.Thickness = 1
            stroke.Parent = window

            -- Header
            if self.ShowHeader then
                local header = Instance.new("Frame")
                header.Name = "Header"
                header.Size = UDim2.new(1, 0, 0, 44)
                header.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
                header.BorderSizePixel = 0
                header.Parent = window
                self._header = header

                local headerCorner = Instance.new("UICorner")
                headerCorner.CornerRadius = UDim.new(0, 10)
                headerCorner.Parent = header

                -- Fix bottom corners
                local headerFix = Instance.new("Frame")
                headerFix.Size = UDim2.new(1, 0, 0.5, 0)
                headerFix.Position = UDim2.new(0, 0, 0.5, 0)
                headerFix.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
                headerFix.BorderSizePixel = 0
                headerFix.ZIndex = header.ZIndex - 1
                headerFix.Parent = header

                local headerPadding = Instance.new("UIPadding")
                headerPadding.PaddingLeft = UDim.new(0, 16)
                headerPadding.PaddingRight = UDim.new(0, 12)
                headerPadding.Parent = header

                local headerLayout = Instance.new("UIListLayout")
                headerLayout.FillDirection = Enum.FillDirection.Horizontal
                headerLayout.VerticalAlignment = Enum.VerticalAlignment.Center
                headerLayout.HorizontalAlignment = Enum.HorizontalAlignment.SpaceBetween
                headerLayout.Parent = header

                -- Left content
                local leftContent = Instance.new("Frame")
                leftContent.Size = UDim2.new(1, -100, 1, 0)
                leftContent.BackgroundTransparency = 1
                leftContent.LayoutOrder = 1
                leftContent.Parent = header

                local leftLayout = Instance.new("UIListLayout")
                leftLayout.FillDirection = Enum.FillDirection.Horizontal
                leftLayout.VerticalAlignment = Enum.VerticalAlignment.Center
                leftLayout.Padding = UDim.new(0, 10)
                leftLayout.Parent = leftContent

                -- Icon
                if self.Icon then
                    local icon = Instance.new("ImageLabel")
                    icon.Size = UDim2.new(0, 18, 0, 18)
                    icon.BackgroundTransparency = 1
                    icon.Image = self.Icon
                    icon.ImageColor3 = Color3.fromRGB(161, 161, 170)
                    icon.LayoutOrder = 1
                    icon.Parent = leftContent
                end

                -- Title
                local title = Instance.new("TextLabel")
                title.Name = "Title"
                title.Size = UDim2.new(1, self.Icon and -28 or 0, 1, 0)
                title.BackgroundTransparency = 1
                title.Font = Enum.Font.GothamMedium
                title.Text = self.Title
                title.TextColor3 = Color3.fromRGB(250, 250, 250)
                title.TextSize = 14
                title.TextXAlignment = Enum.TextXAlignment.Left
                title.TextTruncate = Enum.TextTruncate.AtEnd
                title.LayoutOrder = 2
                title.Parent = leftContent
                self._title = title

                -- Buttons container
                local buttons = Instance.new("Frame")
                buttons.Size = UDim2.new(0, 0, 0, 28)
                buttons.AutomaticSize = Enum.AutomaticSize.X
                buttons.BackgroundTransparency = 1
                buttons.LayoutOrder = 2
                buttons.Parent = header

                local buttonsLayout = Instance.new("UIListLayout")
                buttonsLayout.FillDirection = Enum.FillDirection.Horizontal
                buttonsLayout.VerticalAlignment = Enum.VerticalAlignment.Center
                buttonsLayout.Padding = UDim.new(0, 4)
                buttonsLayout.Parent = buttons

                -- Minimize button
                if self.Minimizable then
                    local minimizeBtn = self:_createHeaderButton("Minimize", "_", buttons, 1)
                    self:_connect(minimizeBtn.MouseButton1Click, function()
                        self:ToggleMinimize()
                    end)
                end

                -- Maximize button
                if self.Maximizable then
                    local maximizeBtn = self:_createHeaderButton("Maximize", "□", buttons, 2)
                    self._maximizeBtn = maximizeBtn
                    self:_connect(maximizeBtn.MouseButton1Click, function()
                        self:ToggleMaximize()
                    end)
                end

                -- Close button
                if self.Closable then
                    local closeBtn = self:_createHeaderButton("Close", "×", buttons, 3, true)
                    self:_connect(closeBtn.MouseButton1Click, function()
                        self:Close()
                    end)
                end

                -- Drag handler
                if self.Draggable then
                    self:_setupDragging()
                end
            end

            -- Content
            local content = Instance.new("Frame")
            content.Name = "Content"
            content.Size = UDim2.new(1, 0, 1, self.ShowHeader and -44 or 0)
            content.Position = UDim2.new(0, 0, 0, self.ShowHeader and 44 or 0)
            content.BackgroundTransparency = 1
            content.Parent = window
            self._content = content

            -- Resize handle
            if self.Resizable then
                self:_createResizeHandle()
            end

            return self
        end

        --// Position window
        function Window:_positionWindow()
            if self.StartPosition == "Center" then
                self.Instance.Position = UDim2.new(0.5, -self.Width/2, 0.5, -self.Height/2)
            elseif self.StartPosition == "TopLeft" then
                self.Instance.Position = UDim2.new(0, 20, 0, 20)
            elseif self.StartPosition == "Custom" and self.CustomPosition then
                self.Instance.Position = self.CustomPosition
            end
        end

        --// Create header button
        function Window:_createHeaderButton(name, text, parent, order, isClose)
            local btn = Instance.new("TextButton")
            btn.Name = name
            btn.Size = UDim2.new(0, 28, 0, 28)
            btn.BackgroundColor3 = isClose and Color3.fromRGB(239, 68, 68) or Color3.fromRGB(63, 63, 70)
            btn.BackgroundTransparency = 1
            btn.BorderSizePixel = 0
            btn.Font = Enum.Font.GothamBold
            btn.Text = text
            btn.TextColor3 = Color3.fromRGB(161, 161, 170)
            btn.TextSize = text == "×" and 22 or 16
            btn.AutoButtonColor = false
            btn.LayoutOrder = order
            btn.Parent = parent

            local btnCorner = Instance.new("UICorner")
            btnCorner.CornerRadius = UDim.new(0, 6)
            btnCorner.Parent = btn

            self:_connect(btn.MouseEnter, function()
                TweenService:Create(btn, TweenInfo.new(0.1), {
                    BackgroundTransparency = 0,
                    TextColor3 = Color3.fromRGB(255, 255, 255),
                }):Play()
            end)

            self:_connect(btn.MouseLeave, function()
                TweenService:Create(btn, TweenInfo.new(0.1), {
                    BackgroundTransparency = 1,
                    TextColor3 = Color3.fromRGB(161, 161, 170),
                }):Play()
            end)

            return btn
        end

        --// Setup dragging
        function Window:_setupDragging()
            local header = self._header

            self:_connect(header.InputBegan, function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    self._isDragging = true
                    local mousePos = UserInputService:GetMouseLocation()
                    local windowPos = self.Instance.AbsolutePosition
                    self._dragOffset = mousePos - windowPos

                    -- Bring to front
                    self.Instance.ZIndex = 100
                end
            end)

            self:_connect(UserInputService.InputChanged, function(input)
                if input.UserInputType == Enum.UserInputType.MouseMovement and self._isDragging then
                    local mousePos = UserInputService:GetMouseLocation()
                    local newPos = mousePos - self._dragOffset

                    self.Instance.Position = UDim2.new(0, newPos.X, 0, newPos.Y)

                    if self.OnDrag then
                        self.OnDrag(newPos)
                    end
                end
            end)

            self:_connect(UserInputService.InputEnded, function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    self._isDragging = false
                end
            end)
        end

        --// Create resize handle
        function Window:_createResizeHandle()
            local handle = Instance.new("TextButton")
            handle.Name = "ResizeHandle"
            handle.Size = UDim2.new(0, 16, 0, 16)
            handle.Position = UDim2.new(1, -16, 1, -16)
            handle.BackgroundTransparency = 1
            handle.Text = ""
            handle.Parent = self.Instance

            -- Resize indicator
            local indicator = Instance.new("ImageLabel")
            indicator.Size = UDim2.new(0, 12, 0, 12)
            indicator.Position = UDim2.new(0.5, 0, 0.5, 0)
            indicator.AnchorPoint = Vector2.new(0.5, 0.5)
            indicator.BackgroundTransparency = 1
            indicator.Image = "rbxassetid://6034818372" -- Resize grip
            indicator.ImageColor3 = Color3.fromRGB(82, 82, 91)
            indicator.Rotation = 45
            indicator.Parent = handle

            self:_connect(handle.InputBegan, function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    self._isResizing = true
                    self._resizeStartPos = UserInputService:GetMouseLocation()
                    self._resizeStartSize = self.Instance.AbsoluteSize
                end
            end)

            self:_connect(UserInputService.InputChanged, function(input)
                if input.UserInputType == Enum.UserInputType.MouseMovement and self._isResizing then
                    local mousePos = UserInputService:GetMouseLocation()
                    local delta = mousePos - self._resizeStartPos

                    local newWidth = math.max(self.MinWidth, self._resizeStartSize.X + delta.X)
                    local newHeight = math.max(self.MinHeight, self._resizeStartSize.Y + delta.Y)

                    self.Instance.Size = UDim2.new(0, newWidth, 0, newHeight)

                    if self.OnResize then
                        self.OnResize(newWidth, newHeight)
                    end
                end
            end)

            self:_connect(UserInputService.InputEnded, function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    self._isResizing = false
                end
            end)
        end

        --// Close
        function Window:Close(animate)
            animate = animate ~= false

            if self.OnClose then
                local shouldClose = self.OnClose()
                if shouldClose == false then return self end
            end

            if animate then
                TweenService:Create(self.Instance, TweenInfo.new(0.15), {
                    Size = UDim2.new(0, self.Width * 0.9, 0, self.Height * 0.9),
                    BackgroundTransparency = 1,
                }):Play()

                task.delay(0.15, function()
                    self.Instance.Visible = false
                end)
            else
                self.Instance.Visible = false
            end

            self:_fire("Close")
            return self
        end

        --// Show
        function Window:Show(animate)
            animate = animate ~= false

            self.Instance.Visible = true

            if animate then
                self.Instance.Size = UDim2.new(0, self.Width * 0.9, 0, self.Height * 0.9)
                self.Instance.BackgroundTransparency = 1

                TweenService:Create(self.Instance, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                    Size = UDim2.new(0, self.Width, 0, self.Height),
                    BackgroundTransparency = 0,
                }):Play()
            end

            self:_fire("Show")
            return self
        end

        --// Toggle minimize
        function Window:ToggleMinimize()
            self._isMinimized = not self._isMinimized

            if self._isMinimized then
                self._originalSize = self.Instance.Size
                TweenService:Create(self.Instance, TweenInfo.new(0.2), {
                    Size = UDim2.new(0, self.Width, 0, 44),
                }):Play()

                if self.OnMinimize then self.OnMinimize() end
            else
                TweenService:Create(self.Instance, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                    Size = self._originalSize or UDim2.new(0, self.Width, 0, self.Height),
                }):Play()

                if self.OnRestore then self.OnRestore() end
            end

            return self
        end

        --// Toggle maximize
        function Window:ToggleMaximize()
            self._isMaximized = not self._isMaximized

            if self._isMaximized then
                self._originalSize = self.Instance.Size
                self._originalPosition = self.Instance.Position

                TweenService:Create(self.Instance, TweenInfo.new(0.2), {
                    Size = UDim2.new(1, -20, 1, -20),
                    Position = UDim2.new(0, 10, 0, 10),
                }):Play()

                if self._maximizeBtn then
                    self._maximizeBtn.Text = "❐"
                end

                if self.OnMaximize then self.OnMaximize() end
            else
                TweenService:Create(self.Instance, TweenInfo.new(0.2), {
                    Size = self._originalSize,
                    Position = self._originalPosition,
                }):Play()

                if self._maximizeBtn then
                    self._maximizeBtn.Text = "□"
                end

                if self.OnRestore then self.OnRestore() end
            end

            return self
        end

        --// Set title
        function Window:SetTitle(title)
            self.Title = title
            if self._title then
                self._title.Text = title
            end
            return self
        end

        --// Get content frame
        function Window:GetContent()
            return self._content
        end

        return Window


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Modal
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Modal"] = function()
        local script = CreateMockScript("NexusUI/Components/Modal")

        --[[
            NexusUI Modal Component
            Modal dialog with overlay
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Modal Component Module
        local Modal = setmetatable({}, { __index = Base })
        Modal.__index = Modal
        Modal.ClassName = "Modal"

        --// Constructor
        function Modal.new(config)
            local self = setmetatable(Base.new(config), Modal)

            config = config or {}

            self.Title = config.Title or "Modal"
            self.Width = config.Width or 400
            self.Height = config.Height or "auto"
            self.CloseOnOverlayClick = config.CloseOnOverlayClick ~= false
            self.ShowCloseButton = config.ShowCloseButton ~= false
            self.OverlayColor = config.OverlayColor or Color3.fromRGB(0, 0, 0)
            self.OverlayTransparency = config.OverlayTransparency or 0.5

            -- Callbacks
            self.OnOpen = config.OnOpen
            self.OnClose = config.OnClose

            -- State
            self._isOpen = false

            return self
        end

        --// Create modal
        function Modal:Create(parent)
            -- Get screen gui
            local screenGui = parent
            while screenGui and not screenGui:IsA("ScreenGui") do
                screenGui = screenGui.Parent
            end

            if not screenGui then
                screenGui = Instance.new("ScreenGui")
                screenGui.Parent = game:GetService("CoreGui")
            end

            -- Overlay
            local overlay = Instance.new("TextButton")
            overlay.Name = self.Name .. "_Overlay"
            overlay.Size = UDim2.new(1, 0, 1, 0)
            overlay.BackgroundColor3 = self.OverlayColor
            overlay.BackgroundTransparency = 1
            overlay.BorderSizePixel = 0
            overlay.Text = ""
            overlay.AutoButtonColor = false
            overlay.Visible = false
            overlay.ZIndex = 1000
            overlay.Parent = screenGui
            self._overlay = overlay

            if self.CloseOnOverlayClick then
                self:_connect(overlay.MouseButton1Click, function()
                    self:Close()
                end)
            end

            -- Modal container
            local modal = Instance.new("Frame")
            modal.Name = self.Name
            modal.Size = self.Height == "auto" and UDim2.new(0, self.Width, 0, 0) or UDim2.new(0, self.Width, 0, self.Height)
            modal.AutomaticSize = self.Height == "auto" and Enum.AutomaticSize.Y or Enum.AutomaticSize.None
            modal.Position = UDim2.new(0.5, 0, 0.5, 0)
            modal.AnchorPoint = Vector2.new(0.5, 0.5)
            modal.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            modal.BorderSizePixel = 0
            modal.Visible = false
            modal.ZIndex = 1001
            modal.Parent = screenGui
            self.Instance = modal

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 12)
            corner.Parent = modal

            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(63, 63, 70)
            stroke.Thickness = 1
            stroke.Parent = modal

            -- Shadow
            local shadow = Instance.new("ImageLabel")
            shadow.Name = "Shadow"
            shadow.Size = UDim2.new(1, 40, 1, 40)
            shadow.Position = UDim2.new(0.5, 0, 0.5, 10)
            shadow.AnchorPoint = Vector2.new(0.5, 0.5)
            shadow.BackgroundTransparency = 1
            shadow.Image = "rbxassetid://6015897843"
            shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
            shadow.ImageTransparency = 0.3
            shadow.ScaleType = Enum.ScaleType.Slice
            shadow.SliceCenter = Rect.new(49, 49, 450, 450)
            shadow.ZIndex = modal.ZIndex - 1
            shadow.Parent = modal

            -- Header
            local header = Instance.new("Frame")
            header.Name = "Header"
            header.Size = UDim2.new(1, 0, 0, 56)
            header.BackgroundTransparency = 1
            header.Parent = modal

            local headerPadding = Instance.new("UIPadding")
            headerPadding.PaddingLeft = UDim.new(0, 20)
            headerPadding.PaddingRight = UDim.new(0, 16)
            headerPadding.Parent = header

            local headerLayout = Instance.new("UIListLayout")
            headerLayout.FillDirection = Enum.FillDirection.Horizontal
            headerLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            headerLayout.HorizontalAlignment = Enum.HorizontalAlignment.SpaceBetween
            headerLayout.Parent = header

            -- Title
            local title = Instance.new("TextLabel")
            title.Name = "Title"
            title.Size = UDim2.new(1, -40, 1, 0)
            title.BackgroundTransparency = 1
            title.Font = Enum.Font.GothamBold
            title.Text = self.Title
            title.TextColor3 = Color3.fromRGB(250, 250, 250)
            title.TextSize = 18
            title.TextXAlignment = Enum.TextXAlignment.Left
            title.LayoutOrder = 1
            title.Parent = header
            self._title = title

            -- Close button
            if self.ShowCloseButton then
                local closeBtn = Instance.new("TextButton")
                closeBtn.Name = "CloseBtn"
                closeBtn.Size = UDim2.new(0, 32, 0, 32)
                closeBtn.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
                closeBtn.BackgroundTransparency = 1
                closeBtn.BorderSizePixel = 0
                closeBtn.Font = Enum.Font.GothamBold
                closeBtn.Text = "×"
                closeBtn.TextColor3 = Color3.fromRGB(161, 161, 170)
                closeBtn.TextSize = 24
                closeBtn.AutoButtonColor = false
                closeBtn.LayoutOrder = 2
                closeBtn.ZIndex = modal.ZIndex
                closeBtn.Parent = header

                local closeBtnCorner = Instance.new("UICorner")
                closeBtnCorner.CornerRadius = UDim.new(0, 8)
                closeBtnCorner.Parent = closeBtn

                self:_connect(closeBtn.MouseButton1Click, function()
                    self:Close()
                end)

                self:_connect(closeBtn.MouseEnter, function()
                    TweenService:Create(closeBtn, TweenInfo.new(0.1), {
                        BackgroundTransparency = 0,
                        TextColor3 = Color3.fromRGB(255, 255, 255),
                    }):Play()
                end)

                self:_connect(closeBtn.MouseLeave, function()
                    TweenService:Create(closeBtn, TweenInfo.new(0.1), {
                        BackgroundTransparency = 1,
                        TextColor3 = Color3.fromRGB(161, 161, 170),
                    }):Play()
                end)
            end

            -- Content
            local content = Instance.new("Frame")
            content.Name = "Content"
            content.Size = UDim2.new(1, 0, 0, 0)
            content.AutomaticSize = Enum.AutomaticSize.Y
            content.Position = UDim2.new(0, 0, 0, 56)
            content.BackgroundTransparency = 1
            content.Parent = modal
            self._content = content

            local contentPadding = Instance.new("UIPadding")
            contentPadding.PaddingLeft = UDim.new(0, 20)
            contentPadding.PaddingRight = UDim.new(0, 20)
            contentPadding.PaddingBottom = UDim.new(0, 20)
            contentPadding.Parent = content

            return self
        end

        --// Open
        function Modal:Open(animate)
            if self._isOpen then return self end

            self._isOpen = true
            animate = animate ~= false

            self._overlay.Visible = true
            self.Instance.Visible = true

            if animate then
                -- Fade in overlay
                TweenService:Create(self._overlay, TweenInfo.new(0.2), {
                    BackgroundTransparency = self.OverlayTransparency,
                }):Play()

                -- Scale in modal
                self.Instance.Size = self.Height == "auto" and UDim2.new(0, self.Width * 0.9, 0, 0) or UDim2.new(0, self.Width * 0.9, 0, self.Height * 0.9)
                self.Instance.BackgroundTransparency = 1

                TweenService:Create(self.Instance, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                    Size = self.Height == "auto" and UDim2.new(0, self.Width, 0, 0) or UDim2.new(0, self.Width, 0, self.Height),
                    BackgroundTransparency = 0,
                }):Play()
            else
                self._overlay.BackgroundTransparency = self.OverlayTransparency
            end

            if self.OnOpen then
                self.OnOpen()
            end

            self:_fire("Open")

            return self
        end

        --// Close
        function Modal:Close(animate)
            if not self._isOpen then return self end

            self._isOpen = false
            animate = animate ~= false

            if self.OnClose then
                local shouldClose = self.OnClose()
                if shouldClose == false then
                    self._isOpen = true
                    return self
                end
            end

            if animate then
                TweenService:Create(self._overlay, TweenInfo.new(0.15), {
                    BackgroundTransparency = 1,
                }):Play()

                TweenService:Create(self.Instance, TweenInfo.new(0.15), {
                    Size = self.Height == "auto" and UDim2.new(0, self.Width * 0.9, 0, 0) or UDim2.new(0, self.Width * 0.9, 0, self.Height * 0.9),
                    BackgroundTransparency = 1,
                }):Play()

                task.delay(0.15, function()
                    if not self._isOpen then
                        self._overlay.Visible = false
                        self.Instance.Visible = false
                    end
                end)
            else
                self._overlay.Visible = false
                self.Instance.Visible = false
            end

            self:_fire("Close")

            return self
        end

        --// Toggle
        function Modal:Toggle()
            if self._isOpen then
                self:Close()
            else
                self:Open()
            end
            return self
        end

        --// Is open
        function Modal:IsOpen()
            return self._isOpen
        end

        --// Set title
        function Modal:SetTitle(title)
            self.Title = title
            if self._title then
                self._title.Text = title
            end
            return self
        end

        --// Get content frame
        function Modal:GetContent()
            return self._content
        end

        --// Destroy override
        function Modal:Destroy()
            if self._overlay then
                self._overlay:Destroy()
            end
            Base.Destroy(self)
        end

        return Modal


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Dialog
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Dialog"] = function()
        local script = CreateMockScript("NexusUI/Components/Dialog")

        --[[
            NexusUI Dialog Component
            Confirmation/alert dialog
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Dialog Component Module
        local Dialog = setmetatable({}, { __index = Base })
        Dialog.__index = Dialog
        Dialog.ClassName = "Dialog"

        --// Dialog Types
        Dialog.Type = {
            Info = "Info",
            Success = "Success",
            Warning = "Warning",
            Error = "Error",
            Confirm = "Confirm",
        }

        --// Constructor
        function Dialog.new(config)
            local self = setmetatable(Base.new(config), Dialog)

            config = config or {}

            self.Title = config.Title or "Dialog"
            self.Message = config.Message or ""
            self.DialogType = config.Type or Dialog.Type.Info
            self.Buttons = config.Buttons or {} -- Array of {Text, Variant, OnClick}
            self.ShowIcon = config.ShowIcon ~= false
            self.Width = config.Width or 360

            -- Callbacks
            self.OnClose = config.OnClose

            -- State
            self._isOpen = false

            return self
        end

        --// Get type icon and color
        function Dialog:_getTypeStyle()
            local styles = {
                Info = {
                    Icon = "rbxassetid://7072718185",
                    Color = Color3.fromRGB(59, 130, 246),
                },
                Success = {
                    Icon = "rbxassetid://7072706016",
                    Color = Color3.fromRGB(34, 197, 94),
                },
                Warning = {
                    Icon = "rbxassetid://7072725760",
                    Color = Color3.fromRGB(245, 158, 11),
                },
                Error = {
                    Icon = "rbxassetid://7072706350",
                    Color = Color3.fromRGB(239, 68, 68),
                },
                Confirm = {
                    Icon = "rbxassetid://7072718185",
                    Color = Color3.fromRGB(99, 102, 241),
                },
            }

            return styles[self.DialogType] or styles.Info
        end

        --// Create dialog
        function Dialog:Create(parent)
            -- Get screen gui
            local screenGui = parent
            while screenGui and not screenGui:IsA("ScreenGui") do
                screenGui = screenGui.Parent
            end

            if not screenGui then
                screenGui = Instance.new("ScreenGui")
                screenGui.Parent = game:GetService("CoreGui")
            end

            -- Overlay
            local overlay = Instance.new("TextButton")
            overlay.Name = self.Name .. "_Overlay"
            overlay.Size = UDim2.new(1, 0, 1, 0)
            overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            overlay.BackgroundTransparency = 1
            overlay.BorderSizePixel = 0
            overlay.Text = ""
            overlay.AutoButtonColor = false
            overlay.Visible = false
            overlay.ZIndex = 2000
            overlay.Parent = screenGui
            self._overlay = overlay

            local style = self:_getTypeStyle()

            -- Dialog container
            local dialog = Instance.new("Frame")
            dialog.Name = self.Name
            dialog.Size = UDim2.new(0, self.Width, 0, 0)
            dialog.AutomaticSize = Enum.AutomaticSize.Y
            dialog.Position = UDim2.new(0.5, 0, 0.5, 0)
            dialog.AnchorPoint = Vector2.new(0.5, 0.5)
            dialog.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            dialog.BorderSizePixel = 0
            dialog.Visible = false
            dialog.ZIndex = 2001
            dialog.Parent = screenGui
            self.Instance = dialog

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 12)
            corner.Parent = dialog

            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(63, 63, 70)
            stroke.Thickness = 1
            stroke.Parent = dialog

            -- Shadow
            local shadow = Instance.new("ImageLabel")
            shadow.Name = "Shadow"
            shadow.Size = UDim2.new(1, 40, 1, 40)
            shadow.Position = UDim2.new(0.5, 0, 0.5, 10)
            shadow.AnchorPoint = Vector2.new(0.5, 0.5)
            shadow.BackgroundTransparency = 1
            shadow.Image = "rbxassetid://6015897843"
            shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
            shadow.ImageTransparency = 0.3
            shadow.ScaleType = Enum.ScaleType.Slice
            shadow.SliceCenter = Rect.new(49, 49, 450, 450)
            shadow.ZIndex = dialog.ZIndex - 1
            shadow.Parent = dialog

            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, 24)
            padding.PaddingBottom = UDim.new(0, 20)
            padding.PaddingLeft = UDim.new(0, 24)
            padding.PaddingRight = UDim.new(0, 24)
            padding.Parent = dialog

            local layout = Instance.new("UIListLayout")
            layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            layout.Padding = UDim.new(0, 16)
            layout.Parent = dialog

            -- Icon
            if self.ShowIcon then
                local iconContainer = Instance.new("Frame")
                iconContainer.Size = UDim2.new(0, 48, 0, 48)
                iconContainer.BackgroundColor3 = style.Color
                iconContainer.BackgroundTransparency = 0.9
                iconContainer.BorderSizePixel = 0
                iconContainer.LayoutOrder = 1
                iconContainer.Parent = dialog

                local iconCorner = Instance.new("UICorner")
                iconCorner.CornerRadius = UDim.new(1, 0)
                iconCorner.Parent = iconContainer

                local icon = Instance.new("ImageLabel")
                icon.Size = UDim2.new(0, 24, 0, 24)
                icon.Position = UDim2.new(0.5, 0, 0.5, 0)
                icon.AnchorPoint = Vector2.new(0.5, 0.5)
                icon.BackgroundTransparency = 1
                icon.Image = style.Icon
                icon.ImageColor3 = style.Color
                icon.Parent = iconContainer
            end

            -- Title
            local title = Instance.new("TextLabel")
            title.Size = UDim2.new(1, 0, 0, 0)
            title.AutomaticSize = Enum.AutomaticSize.Y
            title.BackgroundTransparency = 1
            title.Font = Enum.Font.GothamBold
            title.Text = self.Title
            title.TextColor3 = Color3.fromRGB(250, 250, 250)
            title.TextSize = 18
            title.TextWrapped = true
            title.LayoutOrder = 2
            title.Parent = dialog
            self._title = title

            -- Message
            local message = Instance.new("TextLabel")
            message.Size = UDim2.new(1, 0, 0, 0)
            message.AutomaticSize = Enum.AutomaticSize.Y
            message.BackgroundTransparency = 1
            message.Font = Enum.Font.Gotham
            message.Text = self.Message
            message.TextColor3 = Color3.fromRGB(161, 161, 170)
            message.TextSize = 14
            message.TextWrapped = true
            message.LayoutOrder = 3
            message.Parent = dialog
            self._message = message

            -- Buttons
            if #self.Buttons > 0 then
                local buttonsContainer = Instance.new("Frame")
                buttonsContainer.Size = UDim2.new(1, 0, 0, 40)
                buttonsContainer.BackgroundTransparency = 1
                buttonsContainer.LayoutOrder = 4
                buttonsContainer.Parent = dialog

                local buttonsLayout = Instance.new("UIListLayout")
                buttonsLayout.FillDirection = Enum.FillDirection.Horizontal
                buttonsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
                buttonsLayout.Padding = UDim.new(0, 8)
                buttonsLayout.Parent = buttonsContainer

                for i, buttonConfig in ipairs(self.Buttons) do
                    local btn = Instance.new("TextButton")
                    btn.Size = UDim2.new(0, 100, 0, 40)
                    btn.AutomaticSize = Enum.AutomaticSize.X
                    btn.BorderSizePixel = 0
                    btn.Font = Enum.Font.GothamMedium
                    btn.Text = buttonConfig.Text or "Button"
                    btn.TextSize = 14
                    btn.AutoButtonColor = false
                    btn.LayoutOrder = i
                    btn.ZIndex = dialog.ZIndex
                    btn.Parent = buttonsContainer

                    local btnCorner = Instance.new("UICorner")
                    btnCorner.CornerRadius = UDim.new(0, 8)
                    btnCorner.Parent = btn

                    local btnPadding = Instance.new("UIPadding")
                    btnPadding.PaddingLeft = UDim.new(0, 20)
                    btnPadding.PaddingRight = UDim.new(0, 20)
                    btnPadding.Parent = btn

                    -- Apply variant
                    if buttonConfig.Variant == "Primary" or (i == #self.Buttons and not buttonConfig.Variant) then
                        btn.BackgroundColor3 = Color3.fromRGB(99, 102, 241)
                        btn.TextColor3 = Color3.fromRGB(255, 255, 255)
                    elseif buttonConfig.Variant == "Danger" then
                        btn.BackgroundColor3 = Color3.fromRGB(239, 68, 68)
                        btn.TextColor3 = Color3.fromRGB(255, 255, 255)
                    else -- Secondary/Default
                        btn.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
                        btn.TextColor3 = Color3.fromRGB(250, 250, 250)
                    end

                    self:_connect(btn.MouseButton1Click, function()
                        if buttonConfig.OnClick then
                            buttonConfig.OnClick()
                        end
                        self:Close()
                    end)

                    self:_connect(btn.MouseEnter, function()
                        TweenService:Create(btn, TweenInfo.new(0.1), {
                            BackgroundTransparency = 0.2,
                        }):Play()
                    end)

                    self:_connect(btn.MouseLeave, function()
                        TweenService:Create(btn, TweenInfo.new(0.1), {
                            BackgroundTransparency = 0,
                        }):Play()
                    end)
                end
            end

            return self
        end

        --// Show
        function Dialog:Show()
            if self._isOpen then return self end

            self._isOpen = true
            self._overlay.Visible = true
            self.Instance.Visible = true

            TweenService:Create(self._overlay, TweenInfo.new(0.2), {
                BackgroundTransparency = 0.5,
            }):Play()

            self.Instance.Position = UDim2.new(0.5, 0, 0.5, 20)
            self.Instance.BackgroundTransparency = 1

            TweenService:Create(self.Instance, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                Position = UDim2.new(0.5, 0, 0.5, 0),
                BackgroundTransparency = 0,
            }):Play()

            return self
        end

        --// Close
        function Dialog:Close()
            if not self._isOpen then return self end

            self._isOpen = false

            TweenService:Create(self._overlay, TweenInfo.new(0.15), {
                BackgroundTransparency = 1,
            }):Play()

            TweenService:Create(self.Instance, TweenInfo.new(0.15), {
                Position = UDim2.new(0.5, 0, 0.5, 20),
                BackgroundTransparency = 1,
            }):Play()

            task.delay(0.15, function()
                if not self._isOpen then
                    self._overlay.Visible = false
                    self.Instance.Visible = false
                end
            end)

            if self.OnClose then
                self.OnClose()
            end

            return self
        end

        --// Static helpers
        function Dialog.Alert(title, message, onClose)
            local dialog = Dialog.new({
                Title = title,
                Message = message,
                Type = Dialog.Type.Info,
                Buttons = {{ Text = "OK", Variant = "Primary" }},
                OnClose = onClose,
            })
            dialog:Create()
            dialog:Show()
            return dialog
        end

        function Dialog.Confirm(title, message, onConfirm, onCancel)
            local dialog = Dialog.new({
                Title = title,
                Message = message,
                Type = Dialog.Type.Confirm,
                Buttons = {
                    { Text = "Cancel", Variant = "Secondary", OnClick = onCancel },
                    { Text = "Confirm", Variant = "Primary", OnClick = onConfirm },
                },
            })
            dialog:Create()
            dialog:Show()
            return dialog
        end

        function Dialog.Error(title, message, onClose)
            local dialog = Dialog.new({
                Title = title,
                Message = message,
                Type = Dialog.Type.Error,
                Buttons = {{ Text = "OK", Variant = "Primary" }},
                OnClose = onClose,
            })
            dialog:Create()
            dialog:Show()
            return dialog
        end

        --// Destroy override
        function Dialog:Destroy()
            if self._overlay then
                self._overlay:Destroy()
            end
            Base.Destroy(self)
        end

        return Dialog


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Drawer
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Drawer"] = function()
        local script = CreateMockScript("NexusUI/Components/Drawer")

        --[[
            NexusUI Drawer Component
            Slide-out panel from edge
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")
        local UserInputService = game:GetService("UserInputService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Drawer Component Module
        local Drawer = setmetatable({}, { __index = Base })
        Drawer.__index = Drawer
        Drawer.ClassName = "Drawer"

        --// Drawer Positions
        Drawer.Position = {
            Left = "Left",
            Right = "Right",
            Top = "Top",
            Bottom = "Bottom",
        }

        --// Constructor
        function Drawer.new(config)
            local self = setmetatable(Base.new(config), Drawer)

            config = config or {}

            self.DrawerPosition = config.Position or Drawer.Position.Left
            self.Width = config.Width or 300
            self.Height = config.Height or 300
            self.ShowOverlay = config.ShowOverlay ~= false
            self.CloseOnOverlayClick = config.CloseOnOverlayClick ~= false
            self.OverlayTransparency = config.OverlayTransparency or 0.5

            -- Callbacks
            self.OnOpen = config.OnOpen
            self.OnClose = config.OnClose

            -- State
            self._isOpen = false

            return self
        end

        --// Create drawer
        function Drawer:Create(parent)
            -- Get screen gui
            local screenGui = parent
            while screenGui and not screenGui:IsA("ScreenGui") do
                screenGui = screenGui.Parent
            end

            if not screenGui then
                screenGui = Instance.new("ScreenGui")
                screenGui.Parent = game:GetService("CoreGui")
            end

            -- Overlay
            if self.ShowOverlay then
                local overlay = Instance.new("TextButton")
                overlay.Name = self.Name .. "_Overlay"
                overlay.Size = UDim2.new(1, 0, 1, 0)
                overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                overlay.BackgroundTransparency = 1
                overlay.BorderSizePixel = 0
                overlay.Text = ""
                overlay.AutoButtonColor = false
                overlay.Visible = false
                overlay.ZIndex = 900
                overlay.Parent = screenGui
                self._overlay = overlay

                if self.CloseOnOverlayClick then
                    self:_connect(overlay.MouseButton1Click, function()
                        self:Close()
                    end)
                end
            end

            -- Drawer
            local drawer = Instance.new("Frame")
            drawer.Name = self.Name
            drawer.BackgroundColor3 = Color3.fromRGB(24, 24, 27)
            drawer.BorderSizePixel = 0
            drawer.Visible = false
            drawer.ZIndex = 901
            drawer.Parent = screenGui
            self.Instance = drawer

            -- Position and size based on drawer position
            self:_applyPosition()

            -- Border
            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(63, 63, 70)
            stroke.Thickness = 1
            stroke.Parent = drawer

            -- Content
            local content = Instance.new("Frame")
            content.Name = "Content"
            content.Size = UDim2.new(1, 0, 1, 0)
            content.BackgroundTransparency = 1
            content.Parent = drawer
            self._content = content

            local contentPadding = Instance.new("UIPadding")
            contentPadding.PaddingTop = UDim.new(0, 16)
            contentPadding.PaddingBottom = UDim.new(0, 16)
            contentPadding.PaddingLeft = UDim.new(0, 16)
            contentPadding.PaddingRight = UDim.new(0, 16)
            contentPadding.Parent = content

            return self
        end

        --// Apply position
        function Drawer:_applyPosition()
            local drawer = self.Instance

            if self.DrawerPosition == Drawer.Position.Left then
                drawer.Size = UDim2.new(0, self.Width, 1, 0)
                drawer.Position = UDim2.new(0, -self.Width, 0, 0)
                self._openPosition = UDim2.new(0, 0, 0, 0)
                self._closedPosition = UDim2.new(0, -self.Width, 0, 0)

            elseif self.DrawerPosition == Drawer.Position.Right then
                drawer.Size = UDim2.new(0, self.Width, 1, 0)
                drawer.Position = UDim2.new(1, 0, 0, 0)
                self._openPosition = UDim2.new(1, -self.Width, 0, 0)
                self._closedPosition = UDim2.new(1, 0, 0, 0)

            elseif self.DrawerPosition == Drawer.Position.Top then
                drawer.Size = UDim2.new(1, 0, 0, self.Height)
                drawer.Position = UDim2.new(0, 0, 0, -self.Height)
                self._openPosition = UDim2.new(0, 0, 0, 0)
                self._closedPosition = UDim2.new(0, 0, 0, -self.Height)

            elseif self.DrawerPosition == Drawer.Position.Bottom then
                drawer.Size = UDim2.new(1, 0, 0, self.Height)
                drawer.Position = UDim2.new(0, 0, 1, 0)
                self._openPosition = UDim2.new(0, 0, 1, -self.Height)
                self._closedPosition = UDim2.new(0, 0, 1, 0)
            end
        end

        --// Open
        function Drawer:Open(animate)
            if self._isOpen then return self end

            self._isOpen = true
            animate = animate ~= false

            if self._overlay then
                self._overlay.Visible = true
            end
            self.Instance.Visible = true

            if animate then
                if self._overlay then
                    TweenService:Create(self._overlay, TweenInfo.new(0.25), {
                        BackgroundTransparency = self.OverlayTransparency,
                    }):Play()
                end

                TweenService:Create(self.Instance, TweenInfo.new(0.25, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {
                    Position = self._openPosition,
                }):Play()
            else
                if self._overlay then
                    self._overlay.BackgroundTransparency = self.OverlayTransparency
                end
                self.Instance.Position = self._openPosition
            end

            if self.OnOpen then
                self.OnOpen()
            end

            self:_fire("Open")

            return self
        end

        --// Close
        function Drawer:Close(animate)
            if not self._isOpen then return self end

            self._isOpen = false
            animate = animate ~= false

            if animate then
                if self._overlay then
                    TweenService:Create(self._overlay, TweenInfo.new(0.2), {
                        BackgroundTransparency = 1,
                    }):Play()
                end

                TweenService:Create(self.Instance, TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {
                    Position = self._closedPosition,
                }):Play()

                task.delay(0.2, function()
                    if not self._isOpen then
                        if self._overlay then
                            self._overlay.Visible = false
                        end
                        self.Instance.Visible = false
                    end
                end)
            else
                if self._overlay then
                    self._overlay.Visible = false
                end
                self.Instance.Visible = false
                self.Instance.Position = self._closedPosition
            end

            if self.OnClose then
                self.OnClose()
            end

            self:_fire("Close")

            return self
        end

        --// Toggle
        function Drawer:Toggle()
            if self._isOpen then
                self:Close()
            else
                self:Open()
            end
            return self
        end

        --// Is open
        function Drawer:IsOpen()
            return self._isOpen
        end

        --// Get content
        function Drawer:GetContent()
            return self._content
        end

        --// Destroy override
        function Drawer:Destroy()
            if self._overlay then
                self._overlay:Destroy()
            end
            Base.Destroy(self)
        end

        return Drawer


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Panel
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Panel"] = function()
        local script = CreateMockScript("NexusUI/Components/Panel")

        --[[
            NexusUI Panel Component
            Simple container panel
        ]]

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Panel Component Module
        local Panel = setmetatable({}, { __index = Base })
        Panel.__index = Panel
        Panel.ClassName = "Panel"

        --// Constructor
        function Panel.new(config)
            local self = setmetatable(Base.new(config), Panel)

            config = config or {}

            self.Padding = config.Padding or 16
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(30, 30, 35)
            self.CornerRadius = config.CornerRadius or 8
            self.Border = config.Border or false
            self.BorderColor = config.BorderColor or Color3.fromRGB(63, 63, 70)
            self.Shadow = config.Shadow or false
            self.AutoSize = config.AutoSize or false

            return self
        end

        --// Create panel
        function Panel:Create(parent)
            -- Panel container
            local panel = Instance.new("Frame")
            panel.Name = self.Name
            panel.Size = self.AutoSize and UDim2.new(0, 0, 0, 0) or UDim2.new(1, 0, 0, 200)
            panel.AutomaticSize = self.AutoSize and Enum.AutomaticSize.XY or Enum.AutomaticSize.None
            panel.BackgroundColor3 = self.BackgroundColor
            panel.BorderSizePixel = 0

            if parent then
                panel.Parent = parent
            end

            self.Instance = panel

            -- Corner
            if self.CornerRadius > 0 then
                local corner = Instance.new("UICorner")
                corner.CornerRadius = UDim.new(0, self.CornerRadius)
                corner.Parent = panel
            end

            -- Border
            if self.Border then
                local stroke = Instance.new("UIStroke")
                stroke.Color = self.BorderColor
                stroke.Thickness = 1
                stroke.Parent = panel
                self._stroke = stroke
            end

            -- Shadow
            if self.Shadow then
                local shadow = Instance.new("ImageLabel")
                shadow.Name = "Shadow"
                shadow.Size = UDim2.new(1, 20, 1, 20)
                shadow.Position = UDim2.new(0.5, 0, 0.5, 6)
                shadow.AnchorPoint = Vector2.new(0.5, 0.5)
                shadow.BackgroundTransparency = 1
                shadow.Image = "rbxassetid://6015897843"
                shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
                shadow.ImageTransparency = 0.6
                shadow.ScaleType = Enum.ScaleType.Slice
                shadow.SliceCenter = Rect.new(49, 49, 450, 450)
                shadow.ZIndex = panel.ZIndex - 1
                shadow.Parent = panel
            end

            -- Padding
            if self.Padding > 0 then
                local padding = Instance.new("UIPadding")
                padding.PaddingTop = UDim.new(0, self.Padding)
                padding.PaddingBottom = UDim.new(0, self.Padding)
                padding.PaddingLeft = UDim.new(0, self.Padding)
                padding.PaddingRight = UDim.new(0, self.Padding)
                padding.Parent = panel
                self._padding = padding
            end

            return self
        end

        --// Set background color
        function Panel:SetBackgroundColor(color)
            self.BackgroundColor = color
            if self.Instance then
                self.Instance.BackgroundColor3 = color
            end
            return self
        end

        --// Set padding
        function Panel:SetPadding(padding)
            self.Padding = padding

            if self._padding then
                self._padding.PaddingTop = UDim.new(0, padding)
                self._padding.PaddingBottom = UDim.new(0, padding)
                self._padding.PaddingLeft = UDim.new(0, padding)
                self._padding.PaddingRight = UDim.new(0, padding)
            end

            return self
        end

        --// Set border
        function Panel:SetBorder(enabled, color)
            self.Border = enabled
            if color then self.BorderColor = color end

            if self._stroke then
                self._stroke.Color = self.BorderColor
                self._stroke.Thickness = enabled and 1 or 0
            elseif enabled then
                local stroke = Instance.new("UIStroke")
                stroke.Color = self.BorderColor
                stroke.Thickness = 1
                stroke.Parent = self.Instance
                self._stroke = stroke
            end

            return self
        end

        return Panel


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Card
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Card"] = function()
        local script = CreateMockScript("NexusUI/Components/Card")

        --[[
            NexusUI Card Component
            Content card container
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Card Component Module
        local Card = setmetatable({}, { __index = Base })
        Card.__index = Card
        Card.ClassName = "Card"

        --// Card Variants
        Card.Variant = {
            Default = "Default",
            Elevated = "Elevated",
            Outlined = "Outlined",
            Filled = "Filled",
        }

        --// Constructor
        function Card.new(config)
            local self = setmetatable(Base.new(config), Card)

            config = config or {}

            self.Title = config.Title
            self.Subtitle = config.Subtitle
            self.HeaderImage = config.HeaderImage
            self.HeaderHeight = config.HeaderHeight or 150
            self.Variant = config.Variant or Card.Variant.Default
            self.Clickable = config.Clickable or false
            self.Width = config.Width -- nil = fill parent
            self.Padding = config.Padding or 16

            -- Callbacks
            self.OnClick = config.OnClick

            return self
        end

        --// Create card
        function Card:Create(parent)
            -- Card container
            local card

            if self.Clickable then
                card = Instance.new("TextButton")
                card.Text = ""
                card.AutoButtonColor = false
            else
                card = Instance.new("Frame")
            end

            card.Name = self.Name
            card.Size = self.Width and UDim2.new(0, self.Width, 0, 0) or UDim2.new(1, 0, 0, 0)
            card.AutomaticSize = Enum.AutomaticSize.Y
            card.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            card.BorderSizePixel = 0

            if parent then
                card.Parent = parent
            end

            self.Instance = card

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 12)
            corner.Parent = card

            -- Apply variant styles
            self:_applyVariant()

            -- Header image
            if self.HeaderImage then
                local headerImage = Instance.new("ImageLabel")
                headerImage.Name = "HeaderImage"
                headerImage.Size = UDim2.new(1, 0, 0, self.HeaderHeight)
                headerImage.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
                headerImage.BorderSizePixel = 0
                headerImage.Image = self.HeaderImage
                headerImage.ScaleType = Enum.ScaleType.Crop
                headerImage.Parent = card
                self._headerImage = headerImage

                local headerCorner = Instance.new("UICorner")
                headerCorner.CornerRadius = UDim.new(0, 12)
                headerCorner.Parent = headerImage

                -- Fix bottom corners
                local headerFix = Instance.new("Frame")
                headerFix.Size = UDim2.new(1, 0, 0, 12)
                headerFix.Position = UDim2.new(0, 0, 1, -12)
                headerFix.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
                headerFix.BorderSizePixel = 0
                headerFix.ZIndex = headerImage.ZIndex - 1
                headerFix.Parent = headerImage
            end

            -- Body
            local body = Instance.new("Frame")
            body.Name = "Body"
            body.Size = UDim2.new(1, 0, 0, 0)
            body.AutomaticSize = Enum.AutomaticSize.Y
            body.Position = self.HeaderImage and UDim2.new(0, 0, 0, self.HeaderHeight) or UDim2.new(0, 0, 0, 0)
            body.BackgroundTransparency = 1
            body.Parent = card
            self._body = body

            local bodyPadding = Instance.new("UIPadding")
            bodyPadding.PaddingTop = UDim.new(0, self.Padding)
            bodyPadding.PaddingBottom = UDim.new(0, self.Padding)
            bodyPadding.PaddingLeft = UDim.new(0, self.Padding)
            bodyPadding.PaddingRight = UDim.new(0, self.Padding)
            bodyPadding.Parent = body

            local bodyLayout = Instance.new("UIListLayout")
            bodyLayout.Padding = UDim.new(0, 8)
            bodyLayout.Parent = body

            -- Title
            if self.Title then
                local title = Instance.new("TextLabel")
                title.Name = "Title"
                title.Size = UDim2.new(1, 0, 0, 0)
                title.AutomaticSize = Enum.AutomaticSize.Y
                title.BackgroundTransparency = 1
                title.Font = Enum.Font.GothamBold
                title.Text = self.Title
                title.TextColor3 = Color3.fromRGB(250, 250, 250)
                title.TextSize = 16
                title.TextXAlignment = Enum.TextXAlignment.Left
                title.TextWrapped = true
                title.LayoutOrder = 1
                title.Parent = body
                self._title = title
            end

            -- Subtitle
            if self.Subtitle then
                local subtitle = Instance.new("TextLabel")
                subtitle.Name = "Subtitle"
                subtitle.Size = UDim2.new(1, 0, 0, 0)
                subtitle.AutomaticSize = Enum.AutomaticSize.Y
                subtitle.BackgroundTransparency = 1
                subtitle.Font = Enum.Font.Gotham
                subtitle.Text = self.Subtitle
                subtitle.TextColor3 = Color3.fromRGB(113, 113, 122)
                subtitle.TextSize = 13
                subtitle.TextXAlignment = Enum.TextXAlignment.Left
                subtitle.TextWrapped = true
                subtitle.LayoutOrder = 2
                subtitle.Parent = body
                self._subtitle = subtitle
            end

            -- Content container
            local content = Instance.new("Frame")
            content.Name = "Content"
            content.Size = UDim2.new(1, 0, 0, 0)
            content.AutomaticSize = Enum.AutomaticSize.Y
            content.BackgroundTransparency = 1
            content.LayoutOrder = 3
            content.Parent = body
            self._content = content

            -- Clickable interactions
            if self.Clickable then
                self:_setupClickable()
            end

            return self
        end

        --// Apply variant
        function Card:_applyVariant()
            local card = self.Instance

            if self.Variant == Card.Variant.Elevated then
                -- Shadow
                local shadow = Instance.new("ImageLabel")
                shadow.Name = "Shadow"
                shadow.Size = UDim2.new(1, 20, 1, 20)
                shadow.Position = UDim2.new(0.5, 0, 0.5, 6)
                shadow.AnchorPoint = Vector2.new(0.5, 0.5)
                shadow.BackgroundTransparency = 1
                shadow.Image = "rbxassetid://6015897843"
                shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
                shadow.ImageTransparency = 0.6
                shadow.ScaleType = Enum.ScaleType.Slice
                shadow.SliceCenter = Rect.new(49, 49, 450, 450)
                shadow.ZIndex = card.ZIndex - 1
                shadow.Parent = card
                self._shadow = shadow

            elseif self.Variant == Card.Variant.Outlined then
                card.BackgroundTransparency = 1

                local stroke = Instance.new("UIStroke")
                stroke.Color = Color3.fromRGB(63, 63, 70)
                stroke.Thickness = 1
                stroke.Parent = card

            elseif self.Variant == Card.Variant.Filled then
                card.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
            end
        end

        --// Setup clickable
        function Card:_setupClickable()
            local card = self.Instance

            self:_connect(card.MouseButton1Click, function()
                if self.OnClick then
                    self.OnClick()
                end
                self:_fire("Click")
            end)

            self:_connect(card.MouseEnter, function()
                if self.Variant == Card.Variant.Elevated and self._shadow then
                    TweenService:Create(self._shadow, TweenInfo.new(0.15), {
                        ImageTransparency = 0.4,
                        Position = UDim2.new(0.5, 0, 0.5, 10),
                    }):Play()
                end

                TweenService:Create(card, TweenInfo.new(0.15), {
                    BackgroundColor3 = Color3.fromRGB(35, 35, 40),
                }):Play()
            end)

            self:_connect(card.MouseLeave, function()
                if self.Variant == Card.Variant.Elevated and self._shadow then
                    TweenService:Create(self._shadow, TweenInfo.new(0.15), {
                        ImageTransparency = 0.6,
                        Position = UDim2.new(0.5, 0, 0.5, 6),
                    }):Play()
                end

                TweenService:Create(card, TweenInfo.new(0.15), {
                    BackgroundColor3 = Color3.fromRGB(30, 30, 35),
                }):Play()
            end)
        end

        --// Set title
        function Card:SetTitle(title)
            self.Title = title
            if self._title then
                self._title.Text = title
            end
            return self
        end

        --// Set subtitle
        function Card:SetSubtitle(subtitle)
            self.Subtitle = subtitle
            if self._subtitle then
                self._subtitle.Text = subtitle
            end
            return self
        end

        --// Set header image
        function Card:SetHeaderImage(image)
            self.HeaderImage = image
            if self._headerImage then
                self._headerImage.Image = image
            end
            return self
        end

        --// Get content frame
        function Card:GetContent()
            return self._content
        end

        --// Get body frame
        function Card:GetBody()
            return self._body
        end

        return Card


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Accordion
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Accordion"] = function()
        local script = CreateMockScript("NexusUI/Components/Accordion")

        --[[
            NexusUI Accordion Component
            Collapsible content sections
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Accordion Component Module
        local Accordion = setmetatable({}, { __index = Base })
        Accordion.__index = Accordion
        Accordion.ClassName = "Accordion"

        --// Constructor
        function Accordion.new(config)
            local self = setmetatable(Base.new(config), Accordion)

            config = config or {}

            self.Items = config.Items or {} -- Array of {Title, Content, Icon, DefaultExpanded}
            self.AllowMultiple = config.AllowMultiple or false
            self.Bordered = config.Bordered ~= false

            -- Callbacks
            self.OnExpand = config.OnExpand
            self.OnCollapse = config.OnCollapse

            -- State
            self._expandedItems = {}
            self._itemElements = {}

            return self
        end

        --// Create accordion
        function Accordion:Create(parent)
            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(1, 0, 0, 0)
            container.AutomaticSize = Enum.AutomaticSize.Y
            container.BackgroundTransparency = 1

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            local layout = Instance.new("UIListLayout")
            layout.SortOrder = Enum.SortOrder.LayoutOrder
            layout.Padding = UDim.new(0, 2)
            layout.Parent = container

            -- Build items
            self:_buildItems()

            return self
        end

        --// Build items
        function Accordion:_buildItems()
            -- Clear existing
            for _, element in pairs(self._itemElements) do
                if element.Instance then
                    element.Instance:Destroy()
                end
            end
            self._itemElements = {}

            for i, item in ipairs(self.Items) do
                local isExpanded = self._expandedItems[i] or (item.DefaultExpanded and self._expandedItems[i] == nil)

                if item.DefaultExpanded and self._expandedItems[i] == nil then
                    self._expandedItems[i] = true
                end

                local itemFrame = Instance.new("Frame")
                itemFrame.Name = "Item" .. i
                itemFrame.Size = UDim2.new(1, 0, 0, 0)
                itemFrame.AutomaticSize = Enum.AutomaticSize.Y
                itemFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
                itemFrame.BorderSizePixel = 0
                itemFrame.LayoutOrder = i
                itemFrame.Parent = self.Instance

                local itemCorner = Instance.new("UICorner")
                itemCorner.CornerRadius = UDim.new(0, 8)
                itemCorner.Parent = itemFrame

                if self.Bordered then
                    local itemStroke = Instance.new("UIStroke")
                    itemStroke.Color = Color3.fromRGB(63, 63, 70)
                    itemStroke.Thickness = 1
                    itemStroke.Parent = itemFrame
                end

                -- Header
                local header = Instance.new("TextButton")
                header.Name = "Header"
                header.Size = UDim2.new(1, 0, 0, 48)
                header.BackgroundTransparency = 1
                header.Text = ""
                header.AutoButtonColor = false
                header.Parent = itemFrame

                local headerPadding = Instance.new("UIPadding")
                headerPadding.PaddingLeft = UDim.new(0, 16)
                headerPadding.PaddingRight = UDim.new(0, 16)
                headerPadding.Parent = header

                local headerLayout = Instance.new("UIListLayout")
                headerLayout.FillDirection = Enum.FillDirection.Horizontal
                headerLayout.VerticalAlignment = Enum.VerticalAlignment.Center
                headerLayout.HorizontalAlignment = Enum.HorizontalAlignment.SpaceBetween
                headerLayout.Parent = header

                -- Left content
                local leftContent = Instance.new("Frame")
                leftContent.Size = UDim2.new(1, -30, 1, 0)
                leftContent.BackgroundTransparency = 1
                leftContent.LayoutOrder = 1
                leftContent.Parent = header

                local leftLayout = Instance.new("UIListLayout")
                leftLayout.FillDirection = Enum.FillDirection.Horizontal
                leftLayout.VerticalAlignment = Enum.VerticalAlignment.Center
                leftLayout.Padding = UDim.new(0, 10)
                leftLayout.Parent = leftContent

                if item.Icon then
                    local icon = Instance.new("ImageLabel")
                    icon.Size = UDim2.new(0, 18, 0, 18)
                    icon.BackgroundTransparency = 1
                    icon.Image = item.Icon
                    icon.ImageColor3 = Color3.fromRGB(161, 161, 170)
                    icon.LayoutOrder = 1
                    icon.Parent = leftContent
                end

                local title = Instance.new("TextLabel")
                title.Size = UDim2.new(1, item.Icon and -28 or 0, 1, 0)
                title.BackgroundTransparency = 1
                title.Font = Enum.Font.GothamMedium
                title.Text = item.Title
                title.TextColor3 = Color3.fromRGB(250, 250, 250)
                title.TextSize = 14
                title.TextXAlignment = Enum.TextXAlignment.Left
                title.LayoutOrder = 2
                title.Parent = leftContent

                -- Arrow
                local arrow = Instance.new("ImageLabel")
                arrow.Name = "Arrow"
                arrow.Size = UDim2.new(0, 16, 0, 16)
                arrow.BackgroundTransparency = 1
                arrow.Image = "rbxassetid://7072706223"
                arrow.ImageColor3 = Color3.fromRGB(161, 161, 170)
                arrow.Rotation = isExpanded and 180 or 0
                arrow.LayoutOrder = 2
                arrow.Parent = header

                -- Content
                local content = Instance.new("Frame")
                content.Name = "Content"
                content.Size = UDim2.new(1, 0, 0, 0)
                content.AutomaticSize = isExpanded and Enum.AutomaticSize.Y or Enum.AutomaticSize.None
                content.BackgroundTransparency = 1
                content.ClipsDescendants = true
                content.Parent = itemFrame

                local contentPadding = Instance.new("UIPadding")
                contentPadding.PaddingLeft = UDim.new(0, 16)
                contentPadding.PaddingRight = UDim.new(0, 16)
                contentPadding.PaddingBottom = isExpanded and UDim.new(0, 16) or UDim.new(0, 0)
                contentPadding.Parent = content

                -- Content text or custom content
                if type(item.Content) == "string" then
                    local contentText = Instance.new("TextLabel")
                    contentText.Size = UDim2.new(1, 0, 0, 0)
                    contentText.AutomaticSize = Enum.AutomaticSize.Y
                    contentText.BackgroundTransparency = 1
                    contentText.Font = Enum.Font.Gotham
                    contentText.Text = item.Content
                    contentText.TextColor3 = Color3.fromRGB(161, 161, 170)
                    contentText.TextSize = 13
                    contentText.TextXAlignment = Enum.TextXAlignment.Left
                    contentText.TextWrapped = true
                    contentText.Parent = content
                end

                -- Interactions
                self:_connect(header.MouseButton1Click, function()
                    self:_toggleItem(i)
                end)

                self:_connect(header.MouseEnter, function()
                    TweenService:Create(arrow, TweenInfo.new(0.15), {
                        ImageColor3 = Color3.fromRGB(250, 250, 250),
                    }):Play()
                end)

                self:_connect(header.MouseLeave, function()
                    TweenService:Create(arrow, TweenInfo.new(0.15), {
                        ImageColor3 = Color3.fromRGB(161, 161, 170),
                    }):Play()
                end)

                self._itemElements[i] = {
                    Instance = itemFrame,
                    Header = header,
                    Content = content,
                    ContentPadding = contentPadding,
                    Arrow = arrow,
                    Item = item,
                }
            end
        end

        --// Toggle item
        function Accordion:_toggleItem(index)
            local element = self._itemElements[index]
            if not element then return end

            local isExpanded = self._expandedItems[index]

            if isExpanded then
                -- Collapse
                self._expandedItems[index] = false

                TweenService:Create(element.Arrow, TweenInfo.new(0.2), {
                    Rotation = 0,
                }):Play()

                element.Content.AutomaticSize = Enum.AutomaticSize.None
                TweenService:Create(element.Content, TweenInfo.new(0.2), {
                    Size = UDim2.new(1, 0, 0, 0),
                }):Play()

                element.ContentPadding.PaddingBottom = UDim.new(0, 0)

                if self.OnCollapse then
                    self.OnCollapse(index, element.Item)
                end

                self:_fire("Collapse", index, element.Item)
            else
                -- Expand (collapse others if not AllowMultiple)
                if not self.AllowMultiple then
                    for i, _ in pairs(self._expandedItems) do
                        if self._expandedItems[i] then
                            self:_toggleItem(i)
                        end
                    end
                end

                self._expandedItems[index] = true

                TweenService:Create(element.Arrow, TweenInfo.new(0.2), {
                    Rotation = 180,
                }):Play()

                element.ContentPadding.PaddingBottom = UDim.new(0, 16)
                element.Content.AutomaticSize = Enum.AutomaticSize.Y

                if self.OnExpand then
                    self.OnExpand(index, element.Item)
                end

                self:_fire("Expand", index, element.Item)
            end
        end

        --// Expand item
        function Accordion:ExpandItem(index)
            if not self._expandedItems[index] then
                self:_toggleItem(index)
            end
            return self
        end

        --// Collapse item
        function Accordion:CollapseItem(index)
            if self._expandedItems[index] then
                self:_toggleItem(index)
            end
            return self
        end

        --// Expand all
        function Accordion:ExpandAll()
            for i = 1, #self.Items do
                self:ExpandItem(i)
            end
            return self
        end

        --// Collapse all
        function Accordion:CollapseAll()
            for i = 1, #self.Items do
                self:CollapseItem(i)
            end
            return self
        end

        --// Set items
        function Accordion:SetItems(items)
            self.Items = items
            self._expandedItems = {}
            self:_buildItems()
            return self
        end

        --// Get content frame (for custom content)
        function Accordion:GetContentFrame(index)
            local element = self._itemElements[index]
            return element and element.Content
        end

        return Accordion


    end


    -- ============================================================================
    -- Module: NexusUI/Components/init
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/init"] = function()
        local script = CreateMockScript("NexusUI/Components/init")

        --[[
            NexusUI Components Module
            All UI components
        ]]

        --// Components Module
        local Components = {}

        -- Base classes
        Components.Base = NexusRequire("NexusUI/Components/Base")
        Components.Container = NexusRequire("NexusUI/Components/Container")

        -- Basic components
        Components.Label = NexusRequire("NexusUI/Components/Label")
        Components.Button = NexusRequire("NexusUI/Components/Button")
        Components.TextInput = NexusRequire("NexusUI/Components/TextInput")
        Components.TextArea = NexusRequire("NexusUI/Components/TextArea")
        Components.NumberInput = NexusRequire("NexusUI/Components/NumberInput")
        Components.SearchInput = NexusRequire("NexusUI/Components/SearchInput")
        Components.Toggle = NexusRequire("NexusUI/Components/Toggle")
        Components.Switch = NexusRequire("NexusUI/Components/Switch")
        Components.Checkbox = NexusRequire("NexusUI/Components/Checkbox")
        Components.RadioButton = NexusRequire("NexusUI/Components/RadioButton")
        Components.Slider = NexusRequire("NexusUI/Components/Slider")
        Components.RangeSlider = NexusRequire("NexusUI/Components/RangeSlider")
        Components.ProgressBar = NexusRequire("NexusUI/Components/ProgressBar")
        Components.Badge = NexusRequire("NexusUI/Components/Badge")
        Components.Avatar = NexusRequire("NexusUI/Components/Avatar")
        Components.Tooltip = NexusRequire("NexusUI/Components/Tooltip")
        Components.Divider = NexusRequire("NexusUI/Components/Divider")
        Components.Spacer = NexusRequire("NexusUI/Components/Spacer")
        Components.Image = NexusRequire("NexusUI/Components/Image")
        Components.Icon = NexusRequire("NexusUI/Components/Icon")
        Components.Keybind = NexusRequire("NexusUI/Components/Keybind")
        Components.ColorPicker = NexusRequire("NexusUI/Components/ColorPicker")
        Components.SegmentedControl = NexusRequire("NexusUI/Components/SegmentedControl")

        -- Advanced components
        Components.Dropdown = NexusRequire("NexusUI/Components/Dropdown")
        Components.MultiSelect = NexusRequire("NexusUI/Components/MultiSelect")
        Components.Table = NexusRequire("NexusUI/Components/Table")
        Components.TreeView = NexusRequire("NexusUI/Components/TreeView")
        Components.Accordion = NexusRequire("NexusUI/Components/Accordion")
        Components.Tabs = NexusRequire("NexusUI/Components/Tabs")
        Components.List = NexusRequire("NexusUI/Components/List")
        Components.VirtualList = NexusRequire("NexusUI/Components/VirtualList")
        Components.Pagination = NexusRequire("NexusUI/Components/Pagination")
        Components.ContextMenu = NexusRequire("NexusUI/Components/ContextMenu")
        Components.Calendar = NexusRequire("NexusUI/Components/Calendar")

        -- Container components
        Components.Window = NexusRequire("NexusUI/Components/Window")
        Components.Modal = NexusRequire("NexusUI/Components/Modal")
        Components.Dialog = NexusRequire("NexusUI/Components/Dialog")
        Components.Card = NexusRequire("NexusUI/Components/Card")
        Components.Panel = NexusRequire("NexusUI/Components/Panel")
        Components.ScrollView = NexusRequire("NexusUI/Components/ScrollView")
        Components.Drawer = NexusRequire("NexusUI/Components/Drawer")
        Components.Sidebar = NexusRequire("NexusUI/Components/Sidebar")
        Components.TopBar = NexusRequire("NexusUI/Components/TopBar")
        Components.Section = NexusRequire("NexusUI/Components/Section")

        return Components


    end


    -- ============================================================================
    -- Module: NexusUI/Notifications/Toast
    -- ============================================================================
    NexusUI_Modules["NexusUI/Notifications/Toast"] = function()
        local script = CreateMockScript("NexusUI/Notifications/Toast")

        --[[
            NexusUI Toast Component
            Lightweight notification toast
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Toast Component Module
        local Toast = {}
        Toast.__index = Toast
        Toast.ClassName = "Toast"

        --// Toast Types
        Toast.Type = {
            Default = "Default",
            Success = "Success",
            Error = "Error",
            Warning = "Warning",
            Info = "Info",
            Loading = "Loading",
        }

        --// Constructor
        function Toast.new(config)
            local self = setmetatable({}, Toast)

            config = config or {}

            self.Message = config.Message or "Toast message"
            self.ToastType = config.Type or Toast.Type.Default
            self.Duration = config.Duration or 3
            self.Position = config.Position or "TopRight" -- TopRight, TopLeft, TopCenter, BottomRight, BottomLeft, BottomCenter
            self.ShowIcon = config.ShowIcon ~= false
            self.Closable = config.Closable ~= false
            self.Action = config.Action -- {Text, OnClick}

            -- Callbacks
            self.OnClose = config.OnClose

            -- State
            self._isVisible = false
            self._connections = {}

            return self
        end

        --// Get type style
        function Toast:_getTypeStyle()
            local styles = {
                Default = {
                    Background = Color3.fromRGB(39, 39, 42),
                    Border = Color3.fromRGB(63, 63, 70),
                    Text = Color3.fromRGB(250, 250, 250),
                    Icon = nil,
                    IconColor = nil,
                },
                Success = {
                    Background = Color3.fromRGB(20, 83, 45),
                    Border = Color3.fromRGB(34, 197, 94),
                    Text = Color3.fromRGB(187, 247, 208),
                    Icon = "rbxassetid://7072706016",
                    IconColor = Color3.fromRGB(34, 197, 94),
                },
                Error = {
                    Background = Color3.fromRGB(127, 29, 29),
                    Border = Color3.fromRGB(239, 68, 68),
                    Text = Color3.fromRGB(254, 202, 202),
                    Icon = "rbxassetid://7072706350",
                    IconColor = Color3.fromRGB(239, 68, 68),
                },
                Warning = {
                    Background = Color3.fromRGB(120, 53, 15),
                    Border = Color3.fromRGB(245, 158, 11),
                    Text = Color3.fromRGB(254, 243, 199),
                    Icon = "rbxassetid://7072725760",
                    IconColor = Color3.fromRGB(245, 158, 11),
                },
                Info = {
                    Background = Color3.fromRGB(30, 58, 138),
                    Border = Color3.fromRGB(59, 130, 246),
                    Text = Color3.fromRGB(191, 219, 254),
                    Icon = "rbxassetid://7072718185",
                    IconColor = Color3.fromRGB(59, 130, 246),
                },
                Loading = {
                    Background = Color3.fromRGB(39, 39, 42),
                    Border = Color3.fromRGB(99, 102, 241),
                    Text = Color3.fromRGB(250, 250, 250),
                    Icon = "rbxassetid://6034818372",
                    IconColor = Color3.fromRGB(99, 102, 241),
                },
            }

            return styles[self.ToastType] or styles.Default
        end

        --// Create toast
        function Toast:Create(parent)
            local style = self:_getTypeStyle()

            -- Toast container
            local toast = Instance.new("Frame")
            toast.Name = "Toast"
            toast.Size = UDim2.new(0, 0, 0, 44)
            toast.AutomaticSize = Enum.AutomaticSize.X
            toast.BackgroundColor3 = style.Background
            toast.BorderSizePixel = 0
            toast.Visible = false

            if parent then
                toast.Parent = parent
            end

            self.Instance = toast

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 10)
            corner.Parent = toast

            local stroke = Instance.new("UIStroke")
            stroke.Color = style.Border
            stroke.Thickness = 1
            stroke.Transparency = 0.5
            stroke.Parent = toast

            local padding = Instance.new("UIPadding")
            padding.PaddingLeft = UDim.new(0, 14)
            padding.PaddingRight = UDim.new(0, 14)
            padding.Parent = toast

            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Horizontal
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.Padding = UDim.new(0, 10)
            layout.Parent = toast

            local sizeConstraint = Instance.new("UISizeConstraint")
            sizeConstraint.MinSize = Vector2.new(150, 44)
            sizeConstraint.MaxSize = Vector2.new(400, 44)
            sizeConstraint.Parent = toast

            -- Icon
            if self.ShowIcon and style.Icon then
                local icon = Instance.new("ImageLabel")
                icon.Name = "Icon"
                icon.Size = UDim2.new(0, 18, 0, 18)
                icon.BackgroundTransparency = 1
                icon.Image = style.Icon
                icon.ImageColor3 = style.IconColor
                icon.LayoutOrder = 1
                icon.Parent = toast
                self._icon = icon

                -- Spinning animation for loading
                if self.ToastType == Toast.Type.Loading then
                    task.spawn(function()
                        while self._icon and self._icon.Parent do
                            self._icon.Rotation = self._icon.Rotation + 5
                            task.wait(0.02)
                        end
                    end)
                end
            end

            -- Message
            local message = Instance.new("TextLabel")
            message.Name = "Message"
            message.Size = UDim2.new(0, 0, 1, 0)
            message.AutomaticSize = Enum.AutomaticSize.X
            message.BackgroundTransparency = 1
            message.Font = Enum.Font.GothamMedium
            message.Text = self.Message
            message.TextColor3 = style.Text
            message.TextSize = 13
            message.LayoutOrder = 2
            message.Parent = toast
            self._message = message

            -- Action button
            if self.Action then
                local actionBtn = Instance.new("TextButton")
                actionBtn.Size = UDim2.new(0, 0, 0, 26)
                actionBtn.AutomaticSize = Enum.AutomaticSize.X
                actionBtn.BackgroundColor3 = style.Border
                actionBtn.BackgroundTransparency = 0.8
                actionBtn.BorderSizePixel = 0
                actionBtn.Font = Enum.Font.GothamMedium
                actionBtn.Text = self.Action.Text
                actionBtn.TextColor3 = style.Text
                actionBtn.TextSize = 12
                actionBtn.AutoButtonColor = false
                actionBtn.LayoutOrder = 3
                actionBtn.Parent = toast

                local actionCorner = Instance.new("UICorner")
                actionCorner.CornerRadius = UDim.new(0, 6)
                actionCorner.Parent = actionBtn

                local actionPadding = Instance.new("UIPadding")
                actionPadding.PaddingLeft = UDim.new(0, 10)
                actionPadding.PaddingRight = UDim.new(0, 10)
                actionPadding.Parent = actionBtn

                table.insert(self._connections, actionBtn.MouseButton1Click:Connect(function()
                    if self.Action.OnClick then
                        self.Action.OnClick()
                    end
                    self:Hide()
                end))
            end

            -- Close button
            if self.Closable then
                local closeBtn = Instance.new("ImageButton")
                closeBtn.Name = "CloseBtn"
                closeBtn.Size = UDim2.new(0, 18, 0, 18)
                closeBtn.BackgroundTransparency = 1
                closeBtn.Image = "rbxassetid://7072725342"
                closeBtn.ImageColor3 = style.Text
                closeBtn.ImageTransparency = 0.5
                closeBtn.LayoutOrder = 4
                closeBtn.Parent = toast

                table.insert(self._connections, closeBtn.MouseButton1Click:Connect(function()
                    self:Hide()
                end))

                table.insert(self._connections, closeBtn.MouseEnter:Connect(function()
                    TweenService:Create(closeBtn, TweenInfo.new(0.1), {
                        ImageTransparency = 0,
                    }):Play()
                end))

                table.insert(self._connections, closeBtn.MouseLeave:Connect(function()
                    TweenService:Create(closeBtn, TweenInfo.new(0.1), {
                        ImageTransparency = 0.5,
                    }):Play()
                end))
            end

            return self
        end

        --// Show
        function Toast:Show(animate)
            if self._isVisible then return self end

            self._isVisible = true
            animate = animate ~= false

            self.Instance.Visible = true

            if animate then
                self.Instance.Position = UDim2.new(0, 0, 0, -50)
                self.Instance.BackgroundTransparency = 1

                TweenService:Create(self.Instance, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                    Position = UDim2.new(0, 0, 0, 0),
                    BackgroundTransparency = 0,
                }):Play()
            end

            -- Auto hide after duration
            if self.Duration > 0 and self.ToastType ~= Toast.Type.Loading then
                task.delay(self.Duration, function()
                    self:Hide()
                end)
            end

            return self
        end

        --// Hide
        function Toast:Hide(animate)
            if not self._isVisible then return self end

            self._isVisible = false
            animate = animate ~= false

            if animate then
                TweenService:Create(self.Instance, TweenInfo.new(0.2), {
                    Position = UDim2.new(0, 0, 0, -20),
                    BackgroundTransparency = 1,
                }):Play()

                task.delay(0.2, function()
                    if not self._isVisible then
                        self.Instance.Visible = false
                        if self.OnClose then
                            self.OnClose()
                        end
                    end
                end)
            else
                self.Instance.Visible = false
                if self.OnClose then
                    self.OnClose()
                end
            end

            return self
        end

        --// Update message
        function Toast:SetMessage(message)
            self.Message = message
            if self._message then
                self._message.Text = message
            end
            return self
        end

        --// Update type
        function Toast:SetType(toastType)
            self.ToastType = toastType
            -- Note: Would need to rebuild to change type visually
            return self
        end

        --// Destroy
        function Toast:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return Toast


    end


    -- ============================================================================
    -- Module: NexusUI/Notifications/Notification
    -- ============================================================================
    NexusUI_Modules["NexusUI/Notifications/Notification"] = function()
        local script = CreateMockScript("NexusUI/Notifications/Notification")

        --[[
            NexusUI Notification Component
            Rich notification with title, description, and actions
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Notification Component Module
        local Notification = {}
        Notification.__index = Notification
        Notification.ClassName = "Notification"

        --// Notification Types
        Notification.Type = {
            Default = "Default",
            Success = "Success",
            Error = "Error",
            Warning = "Warning",
            Info = "Info",
        }

        --// Constructor
        function Notification.new(config)
            local self = setmetatable({}, Notification)

            config = config or {}

            self.Title = config.Title or "Notification"
            self.Message = config.Message or ""
            self.NotificationType = config.Type or Notification.Type.Default
            self.Duration = config.Duration or 5
            self.ShowIcon = config.ShowIcon ~= false
            self.ShowProgress = config.ShowProgress or false
            self.Closable = config.Closable ~= false
            self.Actions = config.Actions or {} -- Array of {Text, OnClick, Primary}
            self.Avatar = config.Avatar -- Image URL for avatar
            self.Icon = config.Icon -- Custom icon override

            -- Callbacks
            self.OnClose = config.OnClose
            self.OnClick = config.OnClick

            -- State
            self._isVisible = false
            self._connections = {}
            self._progressThread = nil

            return self
        end

        --// Get type style
        function Notification:_getTypeStyle()
            local styles = {
                Default = {
                    AccentColor = Color3.fromRGB(99, 102, 241),
                    Icon = "rbxassetid://7072718185",
                },
                Success = {
                    AccentColor = Color3.fromRGB(34, 197, 94),
                    Icon = "rbxassetid://7072706016",
                },
                Error = {
                    AccentColor = Color3.fromRGB(239, 68, 68),
                    Icon = "rbxassetid://7072706350",
                },
                Warning = {
                    AccentColor = Color3.fromRGB(245, 158, 11),
                    Icon = "rbxassetid://7072725760",
                },
                Info = {
                    AccentColor = Color3.fromRGB(59, 130, 246),
                    Icon = "rbxassetid://7072718185",
                },
            }

            return styles[self.NotificationType] or styles.Default
        end

        --// Create notification
        function Notification:Create(parent)
            local style = self:_getTypeStyle()

            -- Notification container
            local notification = Instance.new("Frame")
            notification.Name = "Notification"
            notification.Size = UDim2.new(0, 320, 0, 0)
            notification.AutomaticSize = Enum.AutomaticSize.Y
            notification.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            notification.BorderSizePixel = 0
            notification.Visible = false

            if parent then
                notification.Parent = parent
            end

            self.Instance = notification

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 12)
            corner.Parent = notification

            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(63, 63, 70)
            stroke.Thickness = 1
            stroke.Parent = notification

            -- Shadow
            local shadow = Instance.new("ImageLabel")
            shadow.Size = UDim2.new(1, 20, 1, 20)
            shadow.Position = UDim2.new(0.5, 0, 0.5, 6)
            shadow.AnchorPoint = Vector2.new(0.5, 0.5)
            shadow.BackgroundTransparency = 1
            shadow.Image = "rbxassetid://6015897843"
            shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
            shadow.ImageTransparency = 0.5
            shadow.ScaleType = Enum.ScaleType.Slice
            shadow.SliceCenter = Rect.new(49, 49, 450, 450)
            shadow.ZIndex = notification.ZIndex - 1
            shadow.Parent = notification

            -- Accent bar
            local accentBar = Instance.new("Frame")
            accentBar.Size = UDim2.new(0, 4, 1, 0)
            accentBar.BackgroundColor3 = style.AccentColor
            accentBar.BorderSizePixel = 0
            accentBar.Parent = notification

            local accentCorner = Instance.new("UICorner")
            accentCorner.CornerRadius = UDim.new(0, 2)
            accentCorner.Parent = accentBar

            -- Content container
            local content = Instance.new("Frame")
            content.Size = UDim2.new(1, -12, 0, 0)
            content.AutomaticSize = Enum.AutomaticSize.Y
            content.Position = UDim2.new(0, 12, 0, 0)
            content.BackgroundTransparency = 1
            content.Parent = notification

            local contentPadding = Instance.new("UIPadding")
            contentPadding.PaddingTop = UDim.new(0, 14)
            contentPadding.PaddingBottom = UDim.new(0, 14)
            contentPadding.PaddingLeft = UDim.new(0, 10)
            contentPadding.PaddingRight = UDim.new(0, 10)
            contentPadding.Parent = content

            -- Header row
            local header = Instance.new("Frame")
            header.Size = UDim2.new(1, 0, 0, 24)
            header.BackgroundTransparency = 1
            header.Parent = content

            local headerLayout = Instance.new("UIListLayout")
            headerLayout.FillDirection = Enum.FillDirection.Horizontal
            headerLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            headerLayout.Padding = UDim.new(0, 10)
            headerLayout.Parent = header

            -- Icon or Avatar
            if self.Avatar then
                local avatar = Instance.new("ImageLabel")
                avatar.Size = UDim2.new(0, 24, 0, 24)
                avatar.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
                avatar.Image = self.Avatar
                avatar.ScaleType = Enum.ScaleType.Crop
                avatar.LayoutOrder = 1
                avatar.Parent = header

                local avatarCorner = Instance.new("UICorner")
                avatarCorner.CornerRadius = UDim.new(1, 0)
                avatarCorner.Parent = avatar

            elseif self.ShowIcon then
                local iconContainer = Instance.new("Frame")
                iconContainer.Size = UDim2.new(0, 24, 0, 24)
                iconContainer.BackgroundColor3 = style.AccentColor
                iconContainer.BackgroundTransparency = 0.85
                iconContainer.BorderSizePixel = 0
                iconContainer.LayoutOrder = 1
                iconContainer.Parent = header

                local iconCorner = Instance.new("UICorner")
                iconCorner.CornerRadius = UDim.new(0, 6)
                iconCorner.Parent = iconContainer

                local icon = Instance.new("ImageLabel")
                icon.Size = UDim2.new(0.6, 0, 0.6, 0)
                icon.Position = UDim2.new(0.5, 0, 0.5, 0)
                icon.AnchorPoint = Vector2.new(0.5, 0.5)
                icon.BackgroundTransparency = 1
                icon.Image = self.Icon or style.Icon
                icon.ImageColor3 = style.AccentColor
                icon.Parent = iconContainer
            end

            -- Title
            local title = Instance.new("TextLabel")
            title.Size = UDim2.new(1, self.Closable and -58 or -34, 1, 0)
            title.BackgroundTransparency = 1
            title.Font = Enum.Font.GothamMedium
            title.Text = self.Title
            title.TextColor3 = Color3.fromRGB(250, 250, 250)
            title.TextSize = 14
            title.TextXAlignment = Enum.TextXAlignment.Left
            title.TextTruncate = Enum.TextTruncate.AtEnd
            title.LayoutOrder = 2
            title.Parent = header

            -- Close button
            if self.Closable then
                local closeBtn = Instance.new("ImageButton")
                closeBtn.Size = UDim2.new(0, 20, 0, 20)
                closeBtn.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
                closeBtn.BackgroundTransparency = 1
                closeBtn.Image = "rbxassetid://7072725342"
                closeBtn.ImageColor3 = Color3.fromRGB(161, 161, 170)
                closeBtn.LayoutOrder = 3
                closeBtn.Parent = header

                local closeBtnCorner = Instance.new("UICorner")
                closeBtnCorner.CornerRadius = UDim.new(0, 4)
                closeBtnCorner.Parent = closeBtn

                table.insert(self._connections, closeBtn.MouseButton1Click:Connect(function()
                    self:Hide()
                end))

                table.insert(self._connections, closeBtn.MouseEnter:Connect(function()
                    TweenService:Create(closeBtn, TweenInfo.new(0.1), {
                        BackgroundTransparency = 0,
                        ImageColor3 = Color3.fromRGB(250, 250, 250),
                    }):Play()
                end))

                table.insert(self._connections, closeBtn.MouseLeave:Connect(function()
                    TweenService:Create(closeBtn, TweenInfo.new(0.1), {
                        BackgroundTransparency = 1,
                        ImageColor3 = Color3.fromRGB(161, 161, 170),
                    }):Play()
                end))
            end

            -- Message
            if self.Message and self.Message ~= "" then
                local message = Instance.new("TextLabel")
                message.Size = UDim2.new(1, 0, 0, 0)
                message.AutomaticSize = Enum.AutomaticSize.Y
                message.Position = UDim2.new(0, 0, 0, 30)
                message.BackgroundTransparency = 1
                message.Font = Enum.Font.Gotham
                message.Text = self.Message
                message.TextColor3 = Color3.fromRGB(161, 161, 170)
                message.TextSize = 13
                message.TextXAlignment = Enum.TextXAlignment.Left
                message.TextWrapped = true
                message.Parent = content
                self._messageLabel = message
            end

            -- Actions
            if #self.Actions > 0 then
                local actionsContainer = Instance.new("Frame")
                actionsContainer.Size = UDim2.new(1, 0, 0, 32)
                actionsContainer.Position = UDim2.new(0, 0, 0, self.Message and self.Message ~= "" and 60 or 30)
                actionsContainer.BackgroundTransparency = 1
                actionsContainer.Parent = content

                local actionsLayout = Instance.new("UIListLayout")
                actionsLayout.FillDirection = Enum.FillDirection.Horizontal
                actionsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
                actionsLayout.Padding = UDim.new(0, 8)
                actionsLayout.Parent = actionsContainer

                for i, action in ipairs(self.Actions) do
                    local btn = Instance.new("TextButton")
                    btn.Size = UDim2.new(0, 0, 0, 28)
                    btn.AutomaticSize = Enum.AutomaticSize.X
                    btn.BackgroundColor3 = action.Primary and style.AccentColor or Color3.fromRGB(63, 63, 70)
                    btn.BackgroundTransparency = action.Primary and 0 or 1
                    btn.BorderSizePixel = 0
                    btn.Font = Enum.Font.GothamMedium
                    btn.Text = action.Text
                    btn.TextColor3 = action.Primary and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(161, 161, 170)
                    btn.TextSize = 12
                    btn.AutoButtonColor = false
                    btn.LayoutOrder = i
                    btn.Parent = actionsContainer

                    local btnCorner = Instance.new("UICorner")
                    btnCorner.CornerRadius = UDim.new(0, 6)
                    btnCorner.Parent = btn

                    local btnPadding = Instance.new("UIPadding")
                    btnPadding.PaddingLeft = UDim.new(0, 12)
                    btnPadding.PaddingRight = UDim.new(0, 12)
                    btnPadding.Parent = btn

                    table.insert(self._connections, btn.MouseButton1Click:Connect(function()
                        if action.OnClick then
                            action.OnClick()
                        end
                        self:Hide()
                    end))

                    table.insert(self._connections, btn.MouseEnter:Connect(function()
                        TweenService:Create(btn, TweenInfo.new(0.1), {
                            BackgroundTransparency = 0,
                        }):Play()
                    end))

                    table.insert(self._connections, btn.MouseLeave:Connect(function()
                        TweenService:Create(btn, TweenInfo.new(0.1), {
                            BackgroundTransparency = action.Primary and 0 or 1,
                        }):Play()
                    end))
                end
            end

            -- Progress bar
            if self.ShowProgress and self.Duration > 0 then
                local progressTrack = Instance.new("Frame")
                progressTrack.Size = UDim2.new(1, -8, 0, 3)
                progressTrack.Position = UDim2.new(0.5, 0, 1, -6)
                progressTrack.AnchorPoint = Vector2.new(0.5, 0)
                progressTrack.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
                progressTrack.BorderSizePixel = 0
                progressTrack.Parent = notification

                local progressCorner = Instance.new("UICorner")
                progressCorner.CornerRadius = UDim.new(1, 0)
                progressCorner.Parent = progressTrack

                local progressFill = Instance.new("Frame")
                progressFill.Size = UDim2.new(1, 0, 1, 0)
                progressFill.BackgroundColor3 = style.AccentColor
                progressFill.BorderSizePixel = 0
                progressFill.Parent = progressTrack
                self._progressFill = progressFill

                local progressFillCorner = Instance.new("UICorner")
                progressFillCorner.CornerRadius = UDim.new(1, 0)
                progressFillCorner.Parent = progressFill
            end

            return self
        end

        --// Show
        function Notification:Show(animate)
            if self._isVisible then return self end

            self._isVisible = true
            animate = animate ~= false

            self.Instance.Visible = true

            if animate then
                self.Instance.Position = UDim2.new(1, 0, 0, 0)
                self.Instance.BackgroundTransparency = 1

                TweenService:Create(self.Instance, TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {
                    Position = UDim2.new(0, 0, 0, 0),
                    BackgroundTransparency = 0,
                }):Play()
            end

            -- Progress and auto-hide
            if self.Duration > 0 then
                if self._progressFill then
                    TweenService:Create(self._progressFill, TweenInfo.new(self.Duration, Enum.EasingStyle.Linear), {
                        Size = UDim2.new(0, 0, 1, 0),
                    }):Play()
                end

                task.delay(self.Duration, function()
                    self:Hide()
                end)
            end

            return self
        end

        --// Hide
        function Notification:Hide(animate)
            if not self._isVisible then return self end

            self._isVisible = false
            animate = animate ~= false

            if animate then
                TweenService:Create(self.Instance, TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {
                    Position = UDim2.new(1, 0, 0, 0),
                    BackgroundTransparency = 1,
                }):Play()

                task.delay(0.2, function()
                    if not self._isVisible then
                        self.Instance.Visible = false
                        if self.OnClose then
                            self.OnClose()
                        end
                    end
                end)
            else
                self.Instance.Visible = false
                if self.OnClose then
                    self.OnClose()
                end
            end

            return self
        end

        --// Destroy
        function Notification:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return Notification


    end


    -- ============================================================================
    -- Module: NexusUI/Notifications/Alert
    -- ============================================================================
    NexusUI_Modules["NexusUI/Notifications/Alert"] = function()
        local script = CreateMockScript("NexusUI/Notifications/Alert")

        --[[
            NexusUI Alert Component
            Inline alert/callout component
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Alert Component Module
        local Alert = {}
        Alert.__index = Alert
        Alert.ClassName = "Alert"

        --// Alert Types
        Alert.Type = {
            Default = "Default",
            Success = "Success",
            Error = "Error",
            Warning = "Warning",
            Info = "Info",
        }

        --// Constructor
        function Alert.new(config)
            local self = setmetatable({}, Alert)

            config = config or {}

            self.Title = config.Title
            self.Message = config.Message or "Alert message"
            self.AlertType = config.Type or Alert.Type.Default
            self.Closable = config.Closable or false
            self.ShowIcon = config.ShowIcon ~= false
            self.Bordered = config.Bordered ~= false

            -- Callbacks
            self.OnClose = config.OnClose

            -- State
            self._connections = {}

            return self
        end

        --// Get type style
        function Alert:_getTypeStyle()
            local styles = {
                Default = {
                    Background = Color3.fromRGB(39, 39, 42),
                    Border = Color3.fromRGB(63, 63, 70),
                    Text = Color3.fromRGB(250, 250, 250),
                    Icon = "rbxassetid://7072718185",
                    IconColor = Color3.fromRGB(161, 161, 170),
                },
                Success = {
                    Background = Color3.fromRGB(20, 83, 45),
                    Border = Color3.fromRGB(34, 197, 94),
                    Text = Color3.fromRGB(187, 247, 208),
                    Icon = "rbxassetid://7072706016",
                    IconColor = Color3.fromRGB(34, 197, 94),
                },
                Error = {
                    Background = Color3.fromRGB(127, 29, 29),
                    Border = Color3.fromRGB(239, 68, 68),
                    Text = Color3.fromRGB(254, 202, 202),
                    Icon = "rbxassetid://7072706350",
                    IconColor = Color3.fromRGB(239, 68, 68),
                },
                Warning = {
                    Background = Color3.fromRGB(120, 53, 15),
                    Border = Color3.fromRGB(245, 158, 11),
                    Text = Color3.fromRGB(254, 243, 199),
                    Icon = "rbxassetid://7072725760",
                    IconColor = Color3.fromRGB(245, 158, 11),
                },
                Info = {
                    Background = Color3.fromRGB(30, 58, 138),
                    Border = Color3.fromRGB(59, 130, 246),
                    Text = Color3.fromRGB(191, 219, 254),
                    Icon = "rbxassetid://7072718185",
                    IconColor = Color3.fromRGB(59, 130, 246),
                },
            }

            return styles[self.AlertType] or styles.Default
        end

        --// Create alert
        function Alert:Create(parent)
            local style = self:_getTypeStyle()

            -- Alert container
            local alert = Instance.new("Frame")
            alert.Name = "Alert"
            alert.Size = UDim2.new(1, 0, 0, 0)
            alert.AutomaticSize = Enum.AutomaticSize.Y
            alert.BackgroundColor3 = style.Background
            alert.BackgroundTransparency = 0.5
            alert.BorderSizePixel = 0

            if parent then
                alert.Parent = parent
            end

            self.Instance = alert

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = alert

            if self.Bordered then
                local stroke = Instance.new("UIStroke")
                stroke.Color = style.Border
                stroke.Thickness = 1
                stroke.Parent = alert
            end

            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, 12)
            padding.PaddingBottom = UDim.new(0, 12)
            padding.PaddingLeft = UDim.new(0, 14)
            padding.PaddingRight = UDim.new(0, 14)
            padding.Parent = alert

            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Horizontal
            layout.VerticalAlignment = Enum.VerticalAlignment.Top
            layout.Padding = UDim.new(0, 12)
            layout.Parent = alert

            -- Icon
            if self.ShowIcon then
                local icon = Instance.new("ImageLabel")
                icon.Size = UDim2.new(0, 18, 0, 18)
                icon.BackgroundTransparency = 1
                icon.Image = style.Icon
                icon.ImageColor3 = style.IconColor
                icon.LayoutOrder = 1
                icon.Parent = alert
            end

            -- Text container
            local textContainer = Instance.new("Frame")
            textContainer.Size = UDim2.new(1, self.Closable and -56 or -30, 0, 0)
            textContainer.AutomaticSize = Enum.AutomaticSize.Y
            textContainer.BackgroundTransparency = 1
            textContainer.LayoutOrder = 2
            textContainer.Parent = alert

            local textLayout = Instance.new("UIListLayout")
            textLayout.Padding = UDim.new(0, 4)
            textLayout.Parent = textContainer

            -- Title
            if self.Title then
                local title = Instance.new("TextLabel")
                title.Size = UDim2.new(1, 0, 0, 0)
                title.AutomaticSize = Enum.AutomaticSize.Y
                title.BackgroundTransparency = 1
                title.Font = Enum.Font.GothamMedium
                title.Text = self.Title
                title.TextColor3 = style.Text
                title.TextSize = 14
                title.TextXAlignment = Enum.TextXAlignment.Left
                title.TextWrapped = true
                title.LayoutOrder = 1
                title.Parent = textContainer
                self._title = title
            end

            -- Message
            local message = Instance.new("TextLabel")
            message.Size = UDim2.new(1, 0, 0, 0)
            message.AutomaticSize = Enum.AutomaticSize.Y
            message.BackgroundTransparency = 1
            message.Font = Enum.Font.Gotham
            message.Text = self.Message
            message.TextColor3 = style.Text
            message.TextTransparency = self.Title and 0.2 or 0
            message.TextSize = 13
            message.TextXAlignment = Enum.TextXAlignment.Left
            message.TextWrapped = true
            message.LayoutOrder = 2
            message.Parent = textContainer
            self._message = message

            -- Close button
            if self.Closable then
                local closeBtn = Instance.new("ImageButton")
                closeBtn.Size = UDim2.new(0, 18, 0, 18)
                closeBtn.BackgroundTransparency = 1
                closeBtn.Image = "rbxassetid://7072725342"
                closeBtn.ImageColor3 = style.Text
                closeBtn.ImageTransparency = 0.3
                closeBtn.LayoutOrder = 3
                closeBtn.Parent = alert

                table.insert(self._connections, closeBtn.MouseButton1Click:Connect(function()
                    self:Hide()
                end))

                table.insert(self._connections, closeBtn.MouseEnter:Connect(function()
                    TweenService:Create(closeBtn, TweenInfo.new(0.1), {
                        ImageTransparency = 0,
                    }):Play()
                end))

                table.insert(self._connections, closeBtn.MouseLeave:Connect(function()
                    TweenService:Create(closeBtn, TweenInfo.new(0.1), {
                        ImageTransparency = 0.3,
                    }):Play()
                end))
            end

            return self
        end

        --// Show
        function Alert:Show(animate)
            self.Instance.Visible = true
            animate = animate ~= false

            if animate then
                self.Instance.BackgroundTransparency = 1
                TweenService:Create(self.Instance, TweenInfo.new(0.2), {
                    BackgroundTransparency = 0.5,
                }):Play()
            end

            return self
        end

        --// Hide
        function Alert:Hide(animate)
            animate = animate ~= false

            if animate then
                TweenService:Create(self.Instance, TweenInfo.new(0.15), {
                    BackgroundTransparency = 1,
                }):Play()

                task.delay(0.15, function()
                    self.Instance.Visible = false
                    if self.OnClose then
                        self.OnClose()
                    end
                end)
            else
                self.Instance.Visible = false
                if self.OnClose then
                    self.OnClose()
                end
            end

            return self
        end

        --// Set message
        function Alert:SetMessage(message)
            self.Message = message
            if self._message then
                self._message.Text = message
            end
            return self
        end

        --// Set title
        function Alert:SetTitle(title)
            self.Title = title
            if self._title then
                self._title.Text = title
            end
            return self
        end

        --// Destroy
        function Alert:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return Alert


    end


    -- ============================================================================
    -- Module: NexusUI/Notifications/Manager
    -- ============================================================================
    NexusUI_Modules["NexusUI/Notifications/Manager"] = function()
        local script = CreateMockScript("NexusUI/Notifications/Manager")

        --[[
            NexusUI Notification Manager
            Manages all notifications and toasts
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Toast = NexusRequire("NexusUI/Toast")
        local Notification = NexusRequire("NexusUI/Notification")

        --// Manager Module
        local Manager = {}
        Manager.__index = Manager
        Manager.ClassName = "NotificationManager"

        --// Position configurations
        local POSITIONS = {
            TopRight = {
                Position = UDim2.new(1, -20, 0, 20),
                AnchorPoint = Vector2.new(1, 0),
                Direction = 1,
            },
            TopLeft = {
                Position = UDim2.new(0, 20, 0, 20),
                AnchorPoint = Vector2.new(0, 0),
                Direction = 1,
            },
            TopCenter = {
                Position = UDim2.new(0.5, 0, 0, 20),
                AnchorPoint = Vector2.new(0.5, 0),
                Direction = 1,
            },
            BottomRight = {
                Position = UDim2.new(1, -20, 1, -20),
                AnchorPoint = Vector2.new(1, 1),
                Direction = -1,
            },
            BottomLeft = {
                Position = UDim2.new(0, 20, 1, -20),
                AnchorPoint = Vector2.new(0, 1),
                Direction = -1,
            },
            BottomCenter = {
                Position = UDim2.new(0.5, 0, 1, -20),
                AnchorPoint = Vector2.new(0.5, 1),
                Direction = -1,
            },
        }

        --// Constructor
        function Manager.new(config)
            local self = setmetatable({}, Manager)

            config = config or {}

            self.MaxVisible = config.MaxVisible or 5
            self.Gap = config.Gap or 10
            self.ToastPosition = config.ToastPosition or "TopRight"
            self.NotificationPosition = config.NotificationPosition or "TopRight"

            -- State
            self._toasts = {}
            self._notifications = {}
            self._screenGui = nil
            self._toastContainer = nil
            self._notificationContainer = nil

            return self
        end

        --// Create manager
        function Manager:Create(parent)
            -- Get or create screen gui
            if parent and parent:IsA("ScreenGui") then
                self._screenGui = parent
            else
                self._screenGui = Instance.new("ScreenGui")
                self._screenGui.Name = "NexusUI_Notifications"
                self._screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
                self._screenGui.DisplayOrder = 999
                self._screenGui.Parent = game:GetService("CoreGui")
            end

            -- Toast container
            local toastConfig = POSITIONS[self.ToastPosition]
            self._toastContainer = Instance.new("Frame")
            self._toastContainer.Name = "ToastContainer"
            self._toastContainer.Size = UDim2.new(0, 400, 0, 0)
            self._toastContainer.AutomaticSize = Enum.AutomaticSize.Y
            self._toastContainer.Position = toastConfig.Position
            self._toastContainer.AnchorPoint = toastConfig.AnchorPoint
            self._toastContainer.BackgroundTransparency = 1
            self._toastContainer.Parent = self._screenGui

            local toastLayout = Instance.new("UIListLayout")
            toastLayout.Padding = UDim.new(0, self.Gap)
            toastLayout.HorizontalAlignment = string.find(self.ToastPosition, "Right") and Enum.HorizontalAlignment.Right or 
                (string.find(self.ToastPosition, "Left") and Enum.HorizontalAlignment.Left or Enum.HorizontalAlignment.Center)
            toastLayout.VerticalAlignment = toastConfig.Direction == 1 and Enum.VerticalAlignment.Top or Enum.VerticalAlignment.Bottom
            toastLayout.SortOrder = Enum.SortOrder.LayoutOrder
            toastLayout.Parent = self._toastContainer

            -- Notification container
            local notifConfig = POSITIONS[self.NotificationPosition]
            self._notificationContainer = Instance.new("Frame")
            self._notificationContainer.Name = "NotificationContainer"
            self._notificationContainer.Size = UDim2.new(0, 340, 0, 0)
            self._notificationContainer.AutomaticSize = Enum.AutomaticSize.Y
            self._notificationContainer.Position = notifConfig.Position
            self._notificationContainer.AnchorPoint = notifConfig.AnchorPoint
            self._notificationContainer.BackgroundTransparency = 1
            self._notificationContainer.Parent = self._screenGui

            local notifLayout = Instance.new("UIListLayout")
            notifLayout.Padding = UDim.new(0, self.Gap)
            notifLayout.HorizontalAlignment = string.find(self.NotificationPosition, "Right") and Enum.HorizontalAlignment.Right or 
                (string.find(self.NotificationPosition, "Left") and Enum.HorizontalAlignment.Left or Enum.HorizontalAlignment.Center)
            notifLayout.VerticalAlignment = notifConfig.Direction == 1 and Enum.VerticalAlignment.Top or Enum.VerticalAlignment.Bottom
            notifLayout.SortOrder = Enum.SortOrder.LayoutOrder
            notifLayout.Parent = self._notificationContainer

            return self
        end

        --// Show toast
        function Manager:Toast(message, toastType, duration)
            local toast = Toast.new({
                Message = message,
                Type = toastType or "Default",
                Duration = duration or 3,
                OnClose = function()
                    self:_removeToast(toast)
                end,
            })

            toast:Create(self._toastContainer)
            toast.Instance.LayoutOrder = #self._toasts + 1

            table.insert(self._toasts, toast)

            -- Remove oldest if over max
            while #self._toasts > self.MaxVisible do
                local oldest = table.remove(self._toasts, 1)
                oldest:Hide()
            end

            toast:Show()

            return toast
        end

        --// Show notification
        function Manager:Notify(title, message, notifType, duration)
            local notification = Notification.new({
                Title = title,
                Message = message,
                Type = notifType or "Default",
                Duration = duration or 5,
                ShowProgress = true,
                OnClose = function()
                    self:_removeNotification(notification)
                end,
            })

            notification:Create(self._notificationContainer)
            notification.Instance.LayoutOrder = #self._notifications + 1

            table.insert(self._notifications, notification)

            -- Remove oldest if over max
            while #self._notifications > self.MaxVisible do
                local oldest = table.remove(self._notifications, 1)
                oldest:Hide()
            end

            notification:Show()

            return notification
        end

        --// Show alert (in a modal-like way)
        function Manager:Alert(title, message, alertType)
            -- Create simple alert dialog
            local overlay = Instance.new("TextButton")
            overlay.Size = UDim2.new(1, 0, 1, 0)
            overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            overlay.BackgroundTransparency = 0.5
            overlay.BorderSizePixel = 0
            overlay.Text = ""
            overlay.ZIndex = 1000
            overlay.Parent = self._screenGui

            local alertContainer = Instance.new("Frame")
            alertContainer.Size = UDim2.new(0, 360, 0, 0)
            alertContainer.AutomaticSize = Enum.AutomaticSize.Y
            alertContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
            alertContainer.AnchorPoint = Vector2.new(0.5, 0.5)
            alertContainer.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            alertContainer.BorderSizePixel = 0
            alertContainer.ZIndex = 1001
            alertContainer.Parent = self._screenGui

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 12)
            corner.Parent = alertContainer

            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(63, 63, 70)
            stroke.Thickness = 1
            stroke.Parent = alertContainer

            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, 20)
            padding.PaddingBottom = UDim.new(0, 20)
            padding.PaddingLeft = UDim.new(0, 20)
            padding.PaddingRight = UDim.new(0, 20)
            padding.Parent = alertContainer

            local layout = Instance.new("UIListLayout")
            layout.Padding = UDim.new(0, 12)
            layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            layout.Parent = alertContainer

            -- Icon based on type
            local iconColors = {
                Success = Color3.fromRGB(34, 197, 94),
                Error = Color3.fromRGB(239, 68, 68),
                Warning = Color3.fromRGB(245, 158, 11),
                Info = Color3.fromRGB(59, 130, 246),
            }
            local iconImages = {
                Success = "rbxassetid://7072706016",
                Error = "rbxassetid://7072706350",
                Warning = "rbxassetid://7072725760",
                Info = "rbxassetid://7072718185",
            }

            local iconColor = iconColors[alertType] or Color3.fromRGB(99, 102, 241)
            local iconImage = iconImages[alertType] or "rbxassetid://7072718185"

            local iconContainer = Instance.new("Frame")
            iconContainer.Size = UDim2.new(0, 48, 0, 48)
            iconContainer.BackgroundColor3 = iconColor
            iconContainer.BackgroundTransparency = 0.9
            iconContainer.BorderSizePixel = 0
            iconContainer.LayoutOrder = 1
            iconContainer.Parent = alertContainer

            local iconCorner = Instance.new("UICorner")
            iconCorner.CornerRadius = UDim.new(1, 0)
            iconCorner.Parent = iconContainer

            local icon = Instance.new("ImageLabel")
            icon.Size = UDim2.new(0.5, 0, 0.5, 0)
            icon.Position = UDim2.new(0.5, 0, 0.5, 0)
            icon.AnchorPoint = Vector2.new(0.5, 0.5)
            icon.BackgroundTransparency = 1
            icon.Image = iconImage
            icon.ImageColor3 = iconColor
            icon.Parent = iconContainer

            -- Title
            local titleLabel = Instance.new("TextLabel")
            titleLabel.Size = UDim2.new(1, 0, 0, 0)
            titleLabel.AutomaticSize = Enum.AutomaticSize.Y
            titleLabel.BackgroundTransparency = 1
            titleLabel.Font = Enum.Font.GothamBold
            titleLabel.Text = title or "Alert"
            titleLabel.TextColor3 = Color3.fromRGB(250, 250, 250)
            titleLabel.TextSize = 18
            titleLabel.TextWrapped = true
            titleLabel.LayoutOrder = 2
            titleLabel.Parent = alertContainer

            -- Message
            local messageLabel = Instance.new("TextLabel")
            messageLabel.Size = UDim2.new(1, 0, 0, 0)
            messageLabel.AutomaticSize = Enum.AutomaticSize.Y
            messageLabel.BackgroundTransparency = 1
            messageLabel.Font = Enum.Font.Gotham
            messageLabel.Text = message or ""
            messageLabel.TextColor3 = Color3.fromRGB(161, 161, 170)
            messageLabel.TextSize = 14
            messageLabel.TextWrapped = true
            messageLabel.LayoutOrder = 3
            messageLabel.Parent = alertContainer

            -- OK Button
            local okBtn = Instance.new("TextButton")
            okBtn.Size = UDim2.new(1, 0, 0, 40)
            okBtn.BackgroundColor3 = iconColor
            okBtn.BorderSizePixel = 0
            okBtn.Font = Enum.Font.GothamMedium
            okBtn.Text = "OK"
            okBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
            okBtn.TextSize = 14
            okBtn.AutoButtonColor = false
            okBtn.LayoutOrder = 4
            okBtn.Parent = alertContainer

            local okCorner = Instance.new("UICorner")
            okCorner.CornerRadius = UDim.new(0, 8)
            okCorner.Parent = okBtn

            local function close()
                TweenService:Create(overlay, TweenInfo.new(0.15), {
                    BackgroundTransparency = 1,
                }):Play()

                TweenService:Create(alertContainer, TweenInfo.new(0.15), {
                    Position = UDim2.new(0.5, 0, 0.5, 20),
                    BackgroundTransparency = 1,
                }):Play()

                task.delay(0.15, function()
                    overlay:Destroy()
                    alertContainer:Destroy()
                end)
            end

            okBtn.MouseButton1Click:Connect(close)
            overlay.MouseButton1Click:Connect(close)

            -- Animate in
            overlay.BackgroundTransparency = 1
            alertContainer.Position = UDim2.new(0.5, 0, 0.5, 20)
            alertContainer.BackgroundTransparency = 1

            TweenService:Create(overlay, TweenInfo.new(0.2), {
                BackgroundTransparency = 0.5,
            }):Play()

            TweenService:Create(alertContainer, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                Position = UDim2.new(0.5, 0, 0.5, 0),
                BackgroundTransparency = 0,
            }):Play()
        end

        --// Remove toast from tracking
        function Manager:_removeToast(toast)
            for i, t in ipairs(self._toasts) do
                if t == toast then
                    table.remove(self._toasts, i)
                    break
                end
            end
        end

        --// Remove notification from tracking
        function Manager:_removeNotification(notification)
            for i, n in ipairs(self._notifications) do
                if n == notification then
                    table.remove(self._notifications, i)
                    break
                end
            end
        end

        --// Clear all toasts
        function Manager:ClearToasts()
            for _, toast in ipairs(self._toasts) do
                toast:Hide(false)
            end
            self._toasts = {}
            return self
        end

        --// Clear all notifications
        function Manager:ClearNotifications()
            for _, notification in ipairs(self._notifications) do
                notification:Hide(false)
            end
            self._notifications = {}
            return self
        end

        --// Clear all
        function Manager:ClearAll()
            self:ClearToasts()
            self:ClearNotifications()
            return self
        end

        --// Destroy
        function Manager:Destroy()
            self:ClearAll()

            if self._screenGui then
                self._screenGui:Destroy()
                self._screenGui = nil
            end
        end

        return Manager


    end


    -- ============================================================================
    -- Module: NexusUI/Notifications/Banner
    -- ============================================================================
    NexusUI_Modules["NexusUI/Notifications/Banner"] = function()
        local script = CreateMockScript("NexusUI/Notifications/Banner")

        --[[
            NexusUI Banner Component
            Full-width banner notification
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Banner Component Module
        local Banner = {}
        Banner.__index = Banner
        Banner.ClassName = "Banner"

        --// Banner Types
        Banner.Type = {
            Default = "Default",
            Success = "Success",
            Error = "Error",
            Warning = "Warning",
            Info = "Info",
        }

        --// Banner Positions
        Banner.Position = {
            Top = "Top",
            Bottom = "Bottom",
        }

        --// Constructor
        function Banner.new(config)
            local self = setmetatable({}, Banner)

            config = config or {}

            self.Message = config.Message or "Banner message"
            self.BannerType = config.Type or Banner.Type.Default
            self.BannerPosition = config.Position or Banner.Position.Top
            self.Closable = config.Closable ~= false
            self.ShowIcon = config.ShowIcon ~= false
            self.Action = config.Action -- {Text, OnClick}

            -- Callbacks
            self.OnClose = config.OnClose

            -- State
            self._isVisible = false
            self._connections = {}

            return self
        end

        --// Get type style
        function Banner:_getTypeStyle()
            local styles = {
                Default = {
                    Background = Color3.fromRGB(39, 39, 42),
                    Text = Color3.fromRGB(250, 250, 250),
                    Icon = "rbxassetid://7072718185",
                    IconColor = Color3.fromRGB(161, 161, 170),
                },
                Success = {
                    Background = Color3.fromRGB(20, 83, 45),
                    Text = Color3.fromRGB(187, 247, 208),
                    Icon = "rbxassetid://7072706016",
                    IconColor = Color3.fromRGB(34, 197, 94),
                },
                Error = {
                    Background = Color3.fromRGB(127, 29, 29),
                    Text = Color3.fromRGB(254, 202, 202),
                    Icon = "rbxassetid://7072706350",
                    IconColor = Color3.fromRGB(239, 68, 68),
                },
                Warning = {
                    Background = Color3.fromRGB(120, 53, 15),
                    Text = Color3.fromRGB(254, 243, 199),
                    Icon = "rbxassetid://7072725760",
                    IconColor = Color3.fromRGB(245, 158, 11),
                },
                Info = {
                    Background = Color3.fromRGB(30, 58, 138),
                    Text = Color3.fromRGB(191, 219, 254),
                    Icon = "rbxassetid://7072718185",
                    IconColor = Color3.fromRGB(59, 130, 246),
                },
            }

            return styles[self.BannerType] or styles.Default
        end

        --// Create banner
        function Banner:Create(parent)
            local style = self:_getTypeStyle()

            -- Banner container
            local banner = Instance.new("Frame")
            banner.Name = "Banner"
            banner.Size = UDim2.new(1, 0, 0, 44)
            banner.BackgroundColor3 = style.Background
            banner.BorderSizePixel = 0
            banner.Visible = false

            if self.BannerPosition == Banner.Position.Top then
                banner.Position = UDim2.new(0, 0, 0, -44)
            else
                banner.Position = UDim2.new(0, 0, 1, 0)
            end

            if parent then
                banner.Parent = parent
            end

            self.Instance = banner

            local padding = Instance.new("UIPadding")
            padding.PaddingLeft = UDim.new(0, 20)
            padding.PaddingRight = UDim.new(0, 20)
            padding.Parent = banner

            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Horizontal
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            layout.Padding = UDim.new(0, 12)
            layout.Parent = banner

            -- Icon
            if self.ShowIcon then
                local icon = Instance.new("ImageLabel")
                icon.Size = UDim2.new(0, 18, 0, 18)
                icon.BackgroundTransparency = 1
                icon.Image = style.Icon
                icon.ImageColor3 = style.IconColor
                icon.LayoutOrder = 1
                icon.Parent = banner
            end

            -- Message
            local message = Instance.new("TextLabel")
            message.Size = UDim2.new(0, 0, 1, 0)
            message.AutomaticSize = Enum.AutomaticSize.X
            message.BackgroundTransparency = 1
            message.Font = Enum.Font.GothamMedium
            message.Text = self.Message
            message.TextColor3 = style.Text
            message.TextSize = 14
            message.LayoutOrder = 2
            message.Parent = banner
            self._message = message

            -- Action button
            if self.Action then
                local actionBtn = Instance.new("TextButton")
                actionBtn.Size = UDim2.new(0, 0, 0, 28)
                actionBtn.AutomaticSize = Enum.AutomaticSize.X
                actionBtn.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                actionBtn.BackgroundTransparency = 0.85
                actionBtn.BorderSizePixel = 0
                actionBtn.Font = Enum.Font.GothamMedium
                actionBtn.Text = self.Action.Text
                actionBtn.TextColor3 = style.Text
                actionBtn.TextSize = 12
                actionBtn.AutoButtonColor = false
                actionBtn.LayoutOrder = 3
                actionBtn.Parent = banner

                local actionCorner = Instance.new("UICorner")
                actionCorner.CornerRadius = UDim.new(0, 6)
                actionCorner.Parent = actionBtn

                local actionPadding = Instance.new("UIPadding")
                actionPadding.PaddingLeft = UDim.new(0, 12)
                actionPadding.PaddingRight = UDim.new(0, 12)
                actionPadding.Parent = actionBtn

                table.insert(self._connections, actionBtn.MouseButton1Click:Connect(function()
                    if self.Action.OnClick then
                        self.Action.OnClick()
                    end
                end))
            end

            -- Close button
            if self.Closable then
                local closeBtn = Instance.new("ImageButton")
                closeBtn.Size = UDim2.new(0, 20, 0, 20)
                closeBtn.Position = UDim2.new(1, -30, 0.5, 0)
                closeBtn.AnchorPoint = Vector2.new(0, 0.5)
                closeBtn.BackgroundTransparency = 1
                closeBtn.Image = "rbxassetid://7072725342"
                closeBtn.ImageColor3 = style.Text
                closeBtn.ImageTransparency = 0.3
                closeBtn.Parent = banner

                table.insert(self._connections, closeBtn.MouseButton1Click:Connect(function()
                    self:Hide()
                end))

                table.insert(self._connections, closeBtn.MouseEnter:Connect(function()
                    TweenService:Create(closeBtn, TweenInfo.new(0.1), {
                        ImageTransparency = 0,
                    }):Play()
                end))

                table.insert(self._connections, closeBtn.MouseLeave:Connect(function()
                    TweenService:Create(closeBtn, TweenInfo.new(0.1), {
                        ImageTransparency = 0.3,
                    }):Play()
                end))
            end

            return self
        end

        --// Show
        function Banner:Show(animate)
            if self._isVisible then return self end

            self._isVisible = true
            animate = animate ~= false

            self.Instance.Visible = true

            local targetPosition = self.BannerPosition == Banner.Position.Top and 
                UDim2.new(0, 0, 0, 0) or UDim2.new(0, 0, 1, -44)

            if animate then
                TweenService:Create(self.Instance, TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {
                    Position = targetPosition,
                }):Play()
            else
                self.Instance.Position = targetPosition
            end

            return self
        end

        --// Hide
        function Banner:Hide(animate)
            if not self._isVisible then return self end

            self._isVisible = false
            animate = animate ~= false

            local targetPosition = self.BannerPosition == Banner.Position.Top and 
                UDim2.new(0, 0, 0, -44) or UDim2.new(0, 0, 1, 0)

            if animate then
                TweenService:Create(self.Instance, TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {
                    Position = targetPosition,
                }):Play()

                task.delay(0.2, function()
                    if not self._isVisible then
                        self.Instance.Visible = false
                        if self.OnClose then
                            self.OnClose()
                        end
                    end
                end)
            else
                self.Instance.Visible = false
                if self.OnClose then
                    self.OnClose()
                end
            end

            return self
        end

        --// Set message
        function Banner:SetMessage(message)
            self.Message = message
            if self._message then
                self._message.Text = message
            end
            return self
        end

        --// Destroy
        function Banner:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return Banner


    end


    -- ============================================================================
    -- Module: NexusUI/Notifications/Snackbar
    -- ============================================================================
    NexusUI_Modules["NexusUI/Notifications/Snackbar"] = function()
        local script = CreateMockScript("NexusUI/Notifications/Snackbar")

        --[[
            NexusUI Snackbar Component
            Bottom-aligned snackbar notification
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Snackbar Component Module
        local Snackbar = {}
        Snackbar.__index = Snackbar
        Snackbar.ClassName = "Snackbar"

        --// Constructor
        function Snackbar.new(config)
            local self = setmetatable({}, Snackbar)

            config = config or {}

            self.Message = config.Message or "Snackbar message"
            self.Duration = config.Duration or 4
            self.Action = config.Action -- {Text, OnClick}

            -- Callbacks
            self.OnClose = config.OnClose

            -- State
            self._isVisible = false
            self._connections = {}

            return self
        end

        --// Create snackbar
        function Snackbar:Create(parent)
            -- Snackbar container
            local snackbar = Instance.new("Frame")
            snackbar.Name = "Snackbar"
            snackbar.Size = UDim2.new(0, 0, 0, 48)
            snackbar.AutomaticSize = Enum.AutomaticSize.X
            snackbar.Position = UDim2.new(0.5, 0, 1, 0)
            snackbar.AnchorPoint = Vector2.new(0.5, 0)
            snackbar.BackgroundColor3 = Color3.fromRGB(50, 50, 55)
            snackbar.BorderSizePixel = 0
            snackbar.Visible = false

            if parent then
                snackbar.Parent = parent
            end

            self.Instance = snackbar

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 10)
            corner.Parent = snackbar

            -- Shadow
            local shadow = Instance.new("ImageLabel")
            shadow.Size = UDim2.new(1, 16, 1, 16)
            shadow.Position = UDim2.new(0.5, 0, 0.5, 4)
            shadow.AnchorPoint = Vector2.new(0.5, 0.5)
            shadow.BackgroundTransparency = 1
            shadow.Image = "rbxassetid://6015897843"
            shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
            shadow.ImageTransparency = 0.5
            shadow.ScaleType = Enum.ScaleType.Slice
            shadow.SliceCenter = Rect.new(49, 49, 450, 450)
            shadow.ZIndex = snackbar.ZIndex - 1
            shadow.Parent = snackbar

            local padding = Instance.new("UIPadding")
            padding.PaddingLeft = UDim.new(0, 16)
            padding.PaddingRight = UDim.new(0, 16)
            padding.Parent = snackbar

            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Horizontal
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.Padding = UDim.new(0, 20)
            layout.Parent = snackbar

            local sizeConstraint = Instance.new("UISizeConstraint")
            sizeConstraint.MinSize = Vector2.new(200, 48)
            sizeConstraint.MaxSize = Vector2.new(500, 48)
            sizeConstraint.Parent = snackbar

            -- Message
            local message = Instance.new("TextLabel")
            message.Size = UDim2.new(0, 0, 1, 0)
            message.AutomaticSize = Enum.AutomaticSize.X
            message.BackgroundTransparency = 1
            message.Font = Enum.Font.GothamMedium
            message.Text = self.Message
            message.TextColor3 = Color3.fromRGB(250, 250, 250)
            message.TextSize = 14
            message.LayoutOrder = 1
            message.Parent = snackbar
            self._message = message

            -- Action button
            if self.Action then
                local actionBtn = Instance.new("TextButton")
                actionBtn.Size = UDim2.new(0, 0, 0, 32)
                actionBtn.AutomaticSize = Enum.AutomaticSize.X
                actionBtn.BackgroundTransparency = 1
                actionBtn.BorderSizePixel = 0
                actionBtn.Font = Enum.Font.GothamBold
                actionBtn.Text = string.upper(self.Action.Text)
                actionBtn.TextColor3 = Color3.fromRGB(139, 92, 246)
                actionBtn.TextSize = 13
                actionBtn.AutoButtonColor = false
                actionBtn.LayoutOrder = 2
                actionBtn.Parent = snackbar

                table.insert(self._connections, actionBtn.MouseButton1Click:Connect(function()
                    if self.Action.OnClick then
                        self.Action.OnClick()
                    end
                    self:Hide()
                end))

                table.insert(self._connections, actionBtn.MouseEnter:Connect(function()
                    TweenService:Create(actionBtn, TweenInfo.new(0.1), {
                        TextColor3 = Color3.fromRGB(167, 139, 250),
                    }):Play()
                end))

                table.insert(self._connections, actionBtn.MouseLeave:Connect(function()
                    TweenService:Create(actionBtn, TweenInfo.new(0.1), {
                        TextColor3 = Color3.fromRGB(139, 92, 246),
                    }):Play()
                end))
            end

            return self
        end

        --// Show
        function Snackbar:Show(animate)
            if self._isVisible then return self end

            self._isVisible = true
            animate = animate ~= false

            self.Instance.Visible = true

            if animate then
                TweenService:Create(self.Instance, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                    Position = UDim2.new(0.5, 0, 1, -68),
                }):Play()
            else
                self.Instance.Position = UDim2.new(0.5, 0, 1, -68)
            end

            -- Auto hide
            if self.Duration > 0 then
                task.delay(self.Duration, function()
                    self:Hide()
                end)
            end

            return self
        end

        --// Hide
        function Snackbar:Hide(animate)
            if not self._isVisible then return self end

            self._isVisible = false
            animate = animate ~= false

            if animate then
                TweenService:Create(self.Instance, TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {
                    Position = UDim2.new(0.5, 0, 1, 0),
                }):Play()

                task.delay(0.2, function()
                    if not self._isVisible then
                        self.Instance.Visible = false
                        if self.OnClose then
                            self.OnClose()
                        end
                    end
                end)
            else
                self.Instance.Visible = false
                if self.OnClose then
                    self.OnClose()
                end
            end

            return self
        end

        --// Set message
        function Snackbar:SetMessage(message)
            self.Message = message
            if self._message then
                self._message.Text = message
            end
            return self
        end

        --// Destroy
        function Snackbar:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return Snackbar


    end


    -- ============================================================================
    -- Module: NexusUI/Notifications/init
    -- ============================================================================
    NexusUI_Modules["NexusUI/Notifications/init"] = function()
        local script = CreateMockScript("NexusUI/Notifications/init")

        --[[
            NexusUI Notifications Module
            Toast, notification, and alert system
        ]]

        --// Notifications Module
        local Notifications = {}

        Notifications.Toast = NexusRequire("NexusUI/Notifications/Toast")
        Notifications.Notification = NexusRequire("NexusUI/Notifications/Notification")
        Notifications.Alert = NexusRequire("NexusUI/Notifications/Alert")
        Notifications.Manager = NexusRequire("NexusUI/Notifications/Manager")
        Notifications.Banner = NexusRequire("NexusUI/Notifications/Banner")
        Notifications.Snackbar = NexusRequire("NexusUI/Notifications/Snackbar")

        -- Quick access to manager
        local _manager

        function Notifications.getManager()
            if not _manager then
                _manager = Notifications.Manager.new()
                _manager:Create()
            end
            return _manager
        end

        -- Convenience methods
        function Notifications.toast(message, type, duration)
            return Notifications.getManager():Toast(message, type, duration)
        end

        function Notifications.notify(title, message, type, duration)
            return Notifications.getManager():Notify(title, message, type, duration)
        end

        function Notifications.alert(title, message, type)
            return Notifications.getManager():Alert(title, message, type)
        end

        function Notifications.success(message)
            return Notifications.toast(message, "Success")
        end

        function Notifications.error(message)
            return Notifications.toast(message, "Error")
        end

        function Notifications.warning(message)
            return Notifications.toast(message, "Warning")
        end

        function Notifications.info(message)
            return Notifications.toast(message, "Info")
        end

        return Notifications


    end


    -- ============================================================================
    -- Module: NexusUI/Visualizers/LineChart
    -- ============================================================================
    NexusUI_Modules["NexusUI/Visualizers/LineChart"] = function()
        local script = CreateMockScript("NexusUI/Visualizers/LineChart")

        --[[
            NexusUI Line Chart Component
            Renders line charts with multiple series support
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// LineChart Module
        local LineChart = {}
        LineChart.__index = LineChart
        LineChart.ClassName = "LineChart"

        --// Constructor
        function LineChart.new(config)
            local self = setmetatable({}, LineChart)

            config = config or {}

            self.Data = config.Data or {} -- Array of {Label, Value} or multiple series
            self.Series = config.Series or {} -- [{Name, Color, Data}]
            self.Width = config.Width or 300
            self.Height = config.Height or 200
            self.ShowGrid = config.ShowGrid ~= false
            self.ShowLabels = config.ShowLabels ~= false
            self.ShowPoints = config.ShowPoints ~= false
            self.ShowTooltip = config.ShowTooltip ~= false
            self.Animated = config.Animated ~= false
            self.LineWidth = config.LineWidth or 2
            self.PointRadius = config.PointRadius or 4
            self.GridLines = config.GridLines or 5
            self.Smooth = config.Smooth or false
            self.FillArea = config.FillArea or false

            -- Colors
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
            self.GridColor = config.GridColor or Color3.fromRGB(63, 63, 70)
            self.LabelColor = config.LabelColor or Color3.fromRGB(161, 161, 170)
            self.DefaultLineColor = config.LineColor or Color3.fromRGB(99, 102, 241)

            -- State
            self._connections = {}
            self._lines = {}
            self._points = {}

            return self
        end

        --// Calculate chart bounds
        function LineChart:_calculateBounds()
            local minY, maxY = math.huge, -math.huge
            local data = #self.Series > 0 and self.Series or {{Data = self.Data, Color = self.DefaultLineColor}}

            for _, series in ipairs(data) do
                for _, point in ipairs(series.Data or {}) do
                    local value = type(point) == "table" and point.Value or point
                    minY = math.min(minY, value)
                    maxY = math.max(maxY, value)
                end
            end

            -- Add padding
            local padding = (maxY - minY) * 0.1
            if padding == 0 then padding = 1 end

            return minY - padding, maxY + padding
        end

        --// Create line between points
        function LineChart:_createLine(startPos, endPos, color, parent, thickness)
            local distance = (endPos - startPos).Magnitude
            local angle = math.atan2(endPos.Y - startPos.Y, endPos.X - startPos.X)

            local line = Instance.new("Frame")
            line.Name = "Line"
            line.BackgroundColor3 = color
            line.BorderSizePixel = 0
            line.Size = UDim2.new(0, distance, 0, thickness or self.LineWidth)
            line.Position = UDim2.new(0, startPos.X, 0, startPos.Y)
            line.AnchorPoint = Vector2.new(0, 0.5)
            line.Rotation = math.deg(angle)
            line.Parent = parent

            return line
        end

        --// Create point marker
        function LineChart:_createPoint(pos, color, parent)
            local point = Instance.new("Frame")
            point.Name = "Point"
            point.BackgroundColor3 = color
            point.BorderSizePixel = 0
            point.Size = UDim2.new(0, self.PointRadius * 2, 0, self.PointRadius * 2)
            point.Position = UDim2.new(0, pos.X - self.PointRadius, 0, pos.Y - self.PointRadius)
            point.Parent = parent

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(1, 0)
            corner.Parent = point

            return point
        end

        --// Create chart
        function LineChart:Create(parent)
            -- Main container
            local chart = Instance.new("Frame")
            chart.Name = "LineChart"
            chart.Size = UDim2.new(0, self.Width, 0, self.Height)
            chart.BackgroundColor3 = self.BackgroundColor
            chart.BorderSizePixel = 0

            if parent then
                chart.Parent = parent
            end

            self.Instance = chart

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = chart

            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, 30)
            padding.PaddingBottom = UDim.new(0, 30)
            padding.PaddingLeft = UDim.new(0, 40)
            padding.PaddingRight = UDim.new(0, 20)
            padding.Parent = chart

            -- Chart area
            local chartArea = Instance.new("Frame")
            chartArea.Name = "ChartArea"
            chartArea.Size = UDim2.new(1, 0, 1, 0)
            chartArea.BackgroundTransparency = 1
            chartArea.ClipsDescendants = true
            chartArea.Parent = chart
            self._chartArea = chartArea

            -- Grid container
            if self.ShowGrid then
                self:_createGrid()
            end

            -- Lines container
            local linesContainer = Instance.new("Frame")
            linesContainer.Name = "Lines"
            linesContainer.Size = UDim2.new(1, 0, 1, 0)
            linesContainer.BackgroundTransparency = 1
            linesContainer.Parent = chartArea
            self._linesContainer = linesContainer

            -- Draw initial data
            self:Update()

            return self
        end

        --// Create grid lines
        function LineChart:_createGrid()
            local minY, maxY = self:_calculateBounds()
            local chartArea = self._chartArea

            -- Horizontal grid lines
            for i = 0, self.GridLines do
                local y = i / self.GridLines

                local gridLine = Instance.new("Frame")
                gridLine.Name = "GridLine_H_" .. i
                gridLine.Size = UDim2.new(1, 0, 0, 1)
                gridLine.Position = UDim2.new(0, 0, y, 0)
                gridLine.BackgroundColor3 = self.GridColor
                gridLine.BackgroundTransparency = 0.7
                gridLine.BorderSizePixel = 0
                gridLine.Parent = chartArea

                -- Y-axis labels
                if self.ShowLabels then
                    local value = maxY - (y * (maxY - minY))

                    local label = Instance.new("TextLabel")
                    label.Size = UDim2.new(0, 35, 0, 14)
                    label.Position = UDim2.new(0, -40, y, -7)
                    label.BackgroundTransparency = 1
                    label.Font = Enum.Font.Gotham
                    label.Text = tostring(math.floor(value * 10) / 10)
                    label.TextColor3 = self.LabelColor
                    label.TextSize = 10
                    label.TextXAlignment = Enum.TextXAlignment.Right
                    label.Parent = chartArea
                end
            end
        end

        --// Update chart with new data
        function LineChart:Update(newData)
            if newData then
                if newData.Data then
                    self.Data = newData.Data
                end
                if newData.Series then
                    self.Series = newData.Series
                end
            end

            -- Clear existing lines and points
            for _, line in ipairs(self._lines) do
                line:Destroy()
            end
            self._lines = {}

            for _, point in ipairs(self._points) do
                point:Destroy()
            end
            self._points = {}

            -- Get data to plot
            local data = #self.Series > 0 and self.Series or {{Data = self.Data, Color = self.DefaultLineColor, Name = "Series 1"}}

            if #data == 0 then return self end

            local minY, maxY = self:_calculateBounds()
            local chartWidth = self._chartArea.AbsoluteSize.X
            local chartHeight = self._chartArea.AbsoluteSize.Y

            -- Draw each series
            for _, series in ipairs(data) do
                local seriesData = series.Data or {}
                local color = series.Color or self.DefaultLineColor

                if #seriesData < 2 then continue end

                local points = {}

                -- Calculate point positions
                for i, point in ipairs(seriesData) do
                    local value = type(point) == "table" and point.Value or point
                    local x = ((i - 1) / (#seriesData - 1)) * chartWidth
                    local y = chartHeight - ((value - minY) / (maxY - minY)) * chartHeight

                    table.insert(points, Vector2.new(x, y))
                end

                -- Draw lines
                for i = 1, #points - 1 do
                    local line = self:_createLine(points[i], points[i + 1], color, self._linesContainer)
                    table.insert(self._lines, line)

                    -- Animate
                    if self.Animated then
                        line.BackgroundTransparency = 1
                        TweenService:Create(line, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, i * 0.05), {
                            BackgroundTransparency = 0,
                        }):Play()
                    end
                end

                -- Draw points
                if self.ShowPoints then
                    for i, pos in ipairs(points) do
                        local point = self:_createPoint(pos, color, self._linesContainer)
                        table.insert(self._points, point)

                        if self.Animated then
                            point.Size = UDim2.new(0, 0, 0, 0)
                            point.Position = UDim2.new(0, pos.X, 0, pos.Y)
                            TweenService:Create(point, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, i * 0.05), {
                                Size = UDim2.new(0, self.PointRadius * 2, 0, self.PointRadius * 2),
                                Position = UDim2.new(0, pos.X - self.PointRadius, 0, pos.Y - self.PointRadius),
                            }):Play()
                        end
                    end
                end
            end

            return self
        end

        --// Add data point
        function LineChart:AddPoint(value, seriesIndex)
            seriesIndex = seriesIndex or 1

            if #self.Series > 0 then
                table.insert(self.Series[seriesIndex].Data, value)
            else
                table.insert(self.Data, value)
            end

            self:Update()
            return self
        end

        --// Set data
        function LineChart:SetData(data)
            self.Data = data
            self:Update()
            return self
        end

        --// Destroy
        function LineChart:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return LineChart


    end


    -- ============================================================================
    -- Module: NexusUI/Visualizers/BarChart
    -- ============================================================================
    NexusUI_Modules["NexusUI/Visualizers/BarChart"] = function()
        local script = CreateMockScript("NexusUI/Visualizers/BarChart")

        --[[
            NexusUI Bar Chart Component
            Vertical and horizontal bar charts
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// BarChart Module
        local BarChart = {}
        BarChart.__index = BarChart
        BarChart.ClassName = "BarChart"

        --// Constructor
        function BarChart.new(config)
            local self = setmetatable({}, BarChart)

            config = config or {}

            self.Data = config.Data or {} -- [{Label, Value, Color?}]
            self.Width = config.Width or 300
            self.Height = config.Height or 200
            self.Horizontal = config.Horizontal or false
            self.ShowLabels = config.ShowLabels ~= false
            self.ShowValues = config.ShowValues ~= false
            self.ShowGrid = config.ShowGrid ~= false
            self.Animated = config.Animated ~= false
            self.BarSpacing = config.BarSpacing or 0.2 -- Percentage of bar width
            self.BarRadius = config.BarRadius or 4
            self.Stacked = config.Stacked or false
            self.Grouped = config.Grouped or false

            -- Colors
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
            self.GridColor = config.GridColor or Color3.fromRGB(63, 63, 70)
            self.LabelColor = config.LabelColor or Color3.fromRGB(161, 161, 170)
            self.DefaultColors = config.Colors or {
                Color3.fromRGB(99, 102, 241),
                Color3.fromRGB(236, 72, 153),
                Color3.fromRGB(34, 197, 94),
                Color3.fromRGB(245, 158, 11),
                Color3.fromRGB(239, 68, 68),
                Color3.fromRGB(59, 130, 246),
                Color3.fromRGB(168, 85, 247),
                Color3.fromRGB(20, 184, 166),
            }

            -- State
            self._connections = {}
            self._bars = {}

            return self
        end

        --// Create bar chart
        function BarChart:Create(parent)
            -- Main container
            local chart = Instance.new("Frame")
            chart.Name = "BarChart"
            chart.Size = UDim2.new(0, self.Width, 0, self.Height)
            chart.BackgroundColor3 = self.BackgroundColor
            chart.BorderSizePixel = 0

            if parent then
                chart.Parent = parent
            end

            self.Instance = chart

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = chart

            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, 20)
            padding.PaddingBottom = UDim.new(0, self.ShowLabels and 35 or 20)
            padding.PaddingLeft = UDim.new(0, self.ShowValues and 40 or 20)
            padding.PaddingRight = UDim.new(0, 20)
            padding.Parent = chart

            -- Chart area
            local chartArea = Instance.new("Frame")
            chartArea.Name = "ChartArea"
            chartArea.Size = UDim2.new(1, 0, 1, 0)
            chartArea.BackgroundTransparency = 1
            chartArea.ClipsDescendants = true
            chartArea.Parent = chart
            self._chartArea = chartArea

            -- Bars container
            local barsContainer = Instance.new("Frame")
            barsContainer.Name = "Bars"
            barsContainer.Size = UDim2.new(1, 0, 1, 0)
            barsContainer.BackgroundTransparency = 1
            barsContainer.Parent = chartArea
            self._barsContainer = barsContainer

            -- Draw initial data
            self:Update()

            return self
        end

        --// Update chart
        function BarChart:Update(newData)
            if newData then
                self.Data = newData
            end

            -- Clear existing bars
            for _, bar in ipairs(self._bars) do
                bar:Destroy()
            end
            self._bars = {}

            -- Clear existing labels
            for _, child in ipairs(self._chartArea:GetChildren()) do
                if child.Name:find("Label_") or child.Name:find("Value_") then
                    child:Destroy()
                end
            end

            local data = self.Data
            if #data == 0 then return self end

            -- Find max value
            local maxValue = 0
            for _, item in ipairs(data) do
                local value = type(item) == "table" and item.Value or item
                maxValue = math.max(maxValue, value)
            end

            if maxValue == 0 then maxValue = 1 end

            local chartWidth = self._chartArea.AbsoluteSize.X
            local chartHeight = self._chartArea.AbsoluteSize.Y

            local barCount = #data
            local totalSpacing = self.BarSpacing * barCount
            local barWidthRatio = (1 - totalSpacing) / barCount

            -- Create bars
            for i, item in ipairs(data) do
                local value = type(item) == "table" and item.Value or item
                local label = type(item) == "table" and item.Label or tostring(i)
                local color = type(item) == "table" and item.Color or self.DefaultColors[((i - 1) % #self.DefaultColors) + 1]

                local heightRatio = value / maxValue
                local xPos = (i - 1) / barCount + self.BarSpacing / 2 / barCount

                -- Bar frame
                local bar = Instance.new("Frame")
                bar.Name = "Bar_" .. i
                bar.BackgroundColor3 = color
                bar.BorderSizePixel = 0

                if self.Horizontal then
                    bar.Size = self.Animated and UDim2.new(0, 0, barWidthRatio, 0) or UDim2.new(heightRatio, 0, barWidthRatio, 0)
                    bar.Position = UDim2.new(0, 0, xPos, 0)
                else
                    bar.Size = self.Animated and UDim2.new(barWidthRatio, 0, 0, 0) or UDim2.new(barWidthRatio, 0, heightRatio, 0)
                    bar.Position = UDim2.new(xPos, 0, 1 - heightRatio, 0)
                    bar.AnchorPoint = Vector2.new(0, 0)
                end

                bar.Parent = self._barsContainer

                local barCorner = Instance.new("UICorner")
                barCorner.CornerRadius = UDim.new(0, self.BarRadius)
                barCorner.Parent = bar

                table.insert(self._bars, bar)

                -- Animate
                if self.Animated then
                    if self.Horizontal then
                        TweenService:Create(bar, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, i * 0.05), {
                            Size = UDim2.new(heightRatio, 0, barWidthRatio, 0),
                        }):Play()
                    else
                        TweenService:Create(bar, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false, i * 0.05), {
                            Size = UDim2.new(barWidthRatio, 0, heightRatio, 0),
                            Position = UDim2.new(xPos, 0, 1 - heightRatio, 0),
                        }):Play()
                    end
                end

                -- Label
                if self.ShowLabels then
                    local labelText = Instance.new("TextLabel")
                    labelText.Name = "Label_" .. i
                    labelText.Size = UDim2.new(barWidthRatio, 0, 0, 16)
                    labelText.Position = UDim2.new(xPos, 0, 1, 5)
                    labelText.BackgroundTransparency = 1
                    labelText.Font = Enum.Font.Gotham
                    labelText.Text = label
                    labelText.TextColor3 = self.LabelColor
                    labelText.TextSize = 10
                    labelText.TextTruncate = Enum.TextTruncate.AtEnd
                    labelText.Parent = self._chartArea
                end

                -- Value label
                if self.ShowValues then
                    local valueText = Instance.new("TextLabel")
                    valueText.Name = "Value_" .. i
                    valueText.Size = UDim2.new(barWidthRatio, 0, 0, 14)
                    valueText.Position = UDim2.new(xPos, 0, 1 - heightRatio, -18)
                    valueText.BackgroundTransparency = 1
                    valueText.Font = Enum.Font.GothamMedium
                    valueText.Text = tostring(math.floor(value * 100) / 100)
                    valueText.TextColor3 = color
                    valueText.TextSize = 10
                    valueText.Parent = self._chartArea
                end

                -- Hover effect
                local button = Instance.new("TextButton")
                button.Size = UDim2.new(1, 0, 1, 0)
                button.BackgroundTransparency = 1
                button.Text = ""
                button.Parent = bar

                table.insert(self._connections, button.MouseEnter:Connect(function()
                    TweenService:Create(bar, TweenInfo.new(0.15), {
                        BackgroundTransparency = 0.2,
                    }):Play()
                end))

                table.insert(self._connections, button.MouseLeave:Connect(function()
                    TweenService:Create(bar, TweenInfo.new(0.15), {
                        BackgroundTransparency = 0,
                    }):Play()
                end))
            end

            return self
        end

        --// Set data
        function BarChart:SetData(data)
            self.Data = data
            self:Update()
            return self
        end

        --// Destroy
        function BarChart:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return BarChart


    end


    -- ============================================================================
    -- Module: NexusUI/Visualizers/PieChart
    -- ============================================================================
    NexusUI_Modules["NexusUI/Visualizers/PieChart"] = function()
        local script = CreateMockScript("NexusUI/Visualizers/PieChart")

        --[[
            NexusUI Pie Chart Component
            Circular pie chart with segments
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// PieChart Module
        local PieChart = {}
        PieChart.__index = PieChart
        PieChart.ClassName = "PieChart"

        --// Constructor
        function PieChart.new(config)
            local self = setmetatable({}, PieChart)

            config = config or {}

            self.Data = config.Data or {} -- [{Label, Value, Color?}]
            self.Size = config.Size or 150
            self.ShowLabels = config.ShowLabels or false
            self.ShowLegend = config.ShowLegend ~= false
            self.ShowValues = config.ShowValues or false
            self.Animated = config.Animated ~= false
            self.InnerRadius = config.InnerRadius or 0 -- For donut chart
            self.StartAngle = config.StartAngle or -90

            -- Colors
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
            self.LabelColor = config.LabelColor or Color3.fromRGB(250, 250, 250)
            self.DefaultColors = config.Colors or {
                Color3.fromRGB(99, 102, 241),
                Color3.fromRGB(236, 72, 153),
                Color3.fromRGB(34, 197, 94),
                Color3.fromRGB(245, 158, 11),
                Color3.fromRGB(239, 68, 68),
                Color3.fromRGB(59, 130, 246),
                Color3.fromRGB(168, 85, 247),
                Color3.fromRGB(20, 184, 166),
            }

            -- State
            self._connections = {}
            self._segments = {}

            return self
        end

        --// Create a pie segment
        function PieChart:_createSegment(startAngle, endAngle, color, parent)
            -- Create segment using UI gradients and clipping
            local segment = Instance.new("Frame")
            segment.Name = "Segment"
            segment.Size = UDim2.new(1, 0, 1, 0)
            segment.Position = UDim2.new(0.5, 0, 0.5, 0)
            segment.AnchorPoint = Vector2.new(0.5, 0.5)
            segment.BackgroundTransparency = 1
            segment.Parent = parent

            -- Use ImageLabel for pie segment (would need custom asset in real implementation)
            -- For this implementation, we'll use a simplified approach
            local wedge = Instance.new("Frame")
            wedge.Size = UDim2.new(0.5, 0, 0.5, 0)
            wedge.Position = UDim2.new(0.5, 0, 0.5, 0)
            wedge.AnchorPoint = Vector2.new(0, 1)
            wedge.BackgroundColor3 = color
            wedge.BorderSizePixel = 0
            wedge.Rotation = startAngle
            wedge.ClipsDescendants = true
            wedge.Parent = segment

            local wedgeClip = Instance.new("Frame")
            wedgeClip.Size = UDim2.new(2, 0, 2, 0)
            wedgeClip.Position = UDim2.new(0, 0, 1, 0)
            wedgeClip.AnchorPoint = Vector2.new(0, 1)
            wedgeClip.BackgroundColor3 = color
            wedgeClip.BorderSizePixel = 0
            wedgeClip.Rotation = math.min(endAngle - startAngle, 90)
            wedgeClip.Parent = wedge

            return segment
        end

        --// Create pie chart
        function PieChart:Create(parent)
            -- Main container
            local chart = Instance.new("Frame")
            chart.Name = "PieChart"
            chart.Size = UDim2.new(0, self.Size + (self.ShowLegend and 150 or 0), 0, self.Size)
            chart.BackgroundColor3 = self.BackgroundColor
            chart.BorderSizePixel = 0

            if parent then
                chart.Parent = parent
            end

            self.Instance = chart

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = chart

            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, 15)
            padding.PaddingBottom = UDim.new(0, 15)
            padding.PaddingLeft = UDim.new(0, 15)
            padding.PaddingRight = UDim.new(0, 15)
            padding.Parent = chart

            -- Pie container
            local pieContainer = Instance.new("Frame")
            pieContainer.Name = "PieContainer"
            pieContainer.Size = UDim2.new(0, self.Size - 30, 0, self.Size - 30)
            pieContainer.BackgroundTransparency = 1
            pieContainer.ClipsDescendants = true
            pieContainer.Parent = chart
            self._pieContainer = pieContainer

            local pieCorner = Instance.new("UICorner")
            pieCorner.CornerRadius = UDim.new(1, 0)
            pieCorner.Parent = pieContainer

            -- Legend container
            if self.ShowLegend then
                local legendContainer = Instance.new("Frame")
                legendContainer.Name = "Legend"
                legendContainer.Size = UDim2.new(0, 120, 1, 0)
                legendContainer.Position = UDim2.new(0, self.Size - 20, 0, 0)
                legendContainer.BackgroundTransparency = 1
                legendContainer.Parent = chart
                self._legendContainer = legendContainer

                local legendLayout = Instance.new("UIListLayout")
                legendLayout.Padding = UDim.new(0, 8)
                legendLayout.Parent = legendContainer
            end

            -- Draw initial data
            self:Update()

            return self
        end

        --// Update chart
        function PieChart:Update(newData)
            if newData then
                self.Data = newData
            end

            -- Clear existing segments
            for _, segment in ipairs(self._segments) do
                segment:Destroy()
            end
            self._segments = {}

            -- Clear legend
            if self._legendContainer then
                for _, child in ipairs(self._legendContainer:GetChildren()) do
                    if child:IsA("Frame") then
                        child:Destroy()
                    end
                end
            end

            local data = self.Data
            if #data == 0 then return self end

            -- Calculate total
            local total = 0
            for _, item in ipairs(data) do
                local value = type(item) == "table" and item.Value or item
                total = total + value
            end

            if total == 0 then return self end

            -- Create segments
            local currentAngle = self.StartAngle

            for i, item in ipairs(data) do
                local value = type(item) == "table" and item.Value or item
                local label = type(item) == "table" and item.Label or tostring(i)
                local color = type(item) == "table" and item.Color or self.DefaultColors[((i - 1) % #self.DefaultColors) + 1]

                local percentage = value / total
                local angle = percentage * 360

                -- Create colored segment frame (simplified visualization)
                local segment = Instance.new("Frame")
                segment.Name = "Segment_" .. i
                segment.Size = UDim2.new(0.5, 0, 0.5, 0)
                segment.Position = UDim2.new(0.5, 0, 0.5, 0)
                segment.AnchorPoint = Vector2.new(0, 0)
                segment.BackgroundColor3 = color
                segment.BorderSizePixel = 0
                segment.Rotation = currentAngle
                segment.Parent = self._pieContainer

                table.insert(self._segments, segment)

                -- Legend item
                if self.ShowLegend and self._legendContainer then
                    local legendItem = Instance.new("Frame")
                    legendItem.Size = UDim2.new(1, 0, 0, 20)
                    legendItem.BackgroundTransparency = 1
                    legendItem.Parent = self._legendContainer

                    local colorBox = Instance.new("Frame")
                    colorBox.Size = UDim2.new(0, 12, 0, 12)
                    colorBox.Position = UDim2.new(0, 0, 0.5, 0)
                    colorBox.AnchorPoint = Vector2.new(0, 0.5)
                    colorBox.BackgroundColor3 = color
                    colorBox.BorderSizePixel = 0
                    colorBox.Parent = legendItem

                    local colorBoxCorner = Instance.new("UICorner")
                    colorBoxCorner.CornerRadius = UDim.new(0, 3)
                    colorBoxCorner.Parent = colorBox

                    local legendLabel = Instance.new("TextLabel")
                    legendLabel.Size = UDim2.new(1, -18, 1, 0)
                    legendLabel.Position = UDim2.new(0, 18, 0, 0)
                    legendLabel.BackgroundTransparency = 1
                    legendLabel.Font = Enum.Font.Gotham
                    legendLabel.Text = label .. " (" .. math.floor(percentage * 100) .. "%)"
                    legendLabel.TextColor3 = self.LabelColor
                    legendLabel.TextSize = 11
                    legendLabel.TextXAlignment = Enum.TextXAlignment.Left
                    legendLabel.TextTruncate = Enum.TextTruncate.AtEnd
                    legendLabel.Parent = legendItem
                end

                currentAngle = currentAngle + angle
            end

            -- Add center circle for donut effect
            if self.InnerRadius > 0 then
                local center = Instance.new("Frame")
                center.Name = "Center"
                center.Size = UDim2.new(self.InnerRadius / 50, 0, self.InnerRadius / 50, 0)
                center.Position = UDim2.new(0.5, 0, 0.5, 0)
                center.AnchorPoint = Vector2.new(0.5, 0.5)
                center.BackgroundColor3 = self.BackgroundColor
                center.BorderSizePixel = 0
                center.ZIndex = 2
                center.Parent = self._pieContainer

                local centerCorner = Instance.new("UICorner")
                centerCorner.CornerRadius = UDim.new(1, 0)
                centerCorner.Parent = center

                table.insert(self._segments, center)
            end

            return self
        end

        --// Set data
        function PieChart:SetData(data)
            self.Data = data
            self:Update()
            return self
        end

        --// Destroy
        function PieChart:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return PieChart


    end


    -- ============================================================================
    -- Module: NexusUI/Visualizers/AreaChart
    -- ============================================================================
    NexusUI_Modules["NexusUI/Visualizers/AreaChart"] = function()
        local script = CreateMockScript("NexusUI/Visualizers/AreaChart")

        --[[
            NexusUI Area Chart Component
            Line chart with filled area underneath
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// AreaChart Module
        local AreaChart = {}
        AreaChart.__index = AreaChart
        AreaChart.ClassName = "AreaChart"

        --// Constructor
        function AreaChart.new(config)
            local self = setmetatable({}, AreaChart)

            config = config or {}

            self.Data = config.Data or {}
            self.Series = config.Series or {}
            self.Width = config.Width or 300
            self.Height = config.Height or 200
            self.ShowGrid = config.ShowGrid ~= false
            self.ShowLabels = config.ShowLabels ~= false
            self.ShowPoints = config.ShowPoints or false
            self.Animated = config.Animated ~= false
            self.Stacked = config.Stacked or false
            self.FillOpacity = config.FillOpacity or 0.3

            -- Colors
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
            self.GridColor = config.GridColor or Color3.fromRGB(63, 63, 70)
            self.LabelColor = config.LabelColor or Color3.fromRGB(161, 161, 170)
            self.LineColor = config.LineColor or Color3.fromRGB(99, 102, 241)
            self.FillColor = config.FillColor or Color3.fromRGB(99, 102, 241)

            -- State
            self._connections = {}

            return self
        end

        --// Create chart
        function AreaChart:Create(parent)
            local chart = Instance.new("Frame")
            chart.Name = "AreaChart"
            chart.Size = UDim2.new(0, self.Width, 0, self.Height)
            chart.BackgroundColor3 = self.BackgroundColor
            chart.BorderSizePixel = 0

            if parent then
                chart.Parent = parent
            end

            self.Instance = chart

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = chart

            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, 20)
            padding.PaddingBottom = UDim.new(0, 30)
            padding.PaddingLeft = UDim.new(0, 40)
            padding.PaddingRight = UDim.new(0, 20)
            padding.Parent = chart

            local chartArea = Instance.new("Frame")
            chartArea.Name = "ChartArea"
            chartArea.Size = UDim2.new(1, 0, 1, 0)
            chartArea.BackgroundTransparency = 1
            chartArea.ClipsDescendants = true
            chartArea.Parent = chart
            self._chartArea = chartArea

            -- Fill area (background gradient)
            local fillArea = Instance.new("Frame")
            fillArea.Name = "FillArea"
            fillArea.Size = UDim2.new(1, 0, 1, 0)
            fillArea.Position = UDim2.new(0, 0, 1, 0)
            fillArea.AnchorPoint = Vector2.new(0, 1)
            fillArea.BackgroundColor3 = self.FillColor
            fillArea.BackgroundTransparency = 1 - self.FillOpacity
            fillArea.BorderSizePixel = 0
            fillArea.Parent = chartArea
            self._fillArea = fillArea

            local gradient = Instance.new("UIGradient")
            gradient.Rotation = 90
            gradient.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 0),
                NumberSequenceKeypoint.new(1, 0.8),
            })
            gradient.Parent = fillArea

            self:Update()

            return self
        end

        --// Update chart
        function AreaChart:Update(newData)
            if newData then
                self.Data = newData.Data or self.Data
                self.Series = newData.Series or self.Series
            end

            local data = self.Data
            if #data == 0 then return self end

            -- Find min/max values
            local minY, maxY = math.huge, -math.huge
            for _, point in ipairs(data) do
                local value = type(point) == "table" and point.Value or point
                minY = math.min(minY, value)
                maxY = math.max(maxY, value)
            end

            local padding = (maxY - minY) * 0.1
            if padding == 0 then padding = 1 end
            minY = minY - padding
            maxY = maxY + padding

            -- Calculate fill height based on average value
            local avgValue = 0
            for _, point in ipairs(data) do
                local value = type(point) == "table" and point.Value or point
                avgValue = avgValue + value
            end
            avgValue = avgValue / #data

            local fillHeight = ((avgValue - minY) / (maxY - minY))

            if self.Animated then
                self._fillArea.Size = UDim2.new(1, 0, 0, 0)
                TweenService:Create(self._fillArea, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                    Size = UDim2.new(1, 0, fillHeight, 0),
                }):Play()
            else
                self._fillArea.Size = UDim2.new(1, 0, fillHeight, 0)
            end

            return self
        end

        --// Set data
        function AreaChart:SetData(data)
            self.Data = data
            self:Update()
            return self
        end

        --// Destroy
        function AreaChart:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return AreaChart


    end


    -- ============================================================================
    -- Module: NexusUI/Visualizers/RadarChart
    -- ============================================================================
    NexusUI_Modules["NexusUI/Visualizers/RadarChart"] = function()
        local script = CreateMockScript("NexusUI/Visualizers/RadarChart")

        --[[
            NexusUI Radar Chart Component
            Spider/radar chart for multi-dimensional data
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// RadarChart Module
        local RadarChart = {}
        RadarChart.__index = RadarChart
        RadarChart.ClassName = "RadarChart"

        --// Constructor
        function RadarChart.new(config)
            local self = setmetatable({}, RadarChart)

            config = config or {}

            self.Data = config.Data or {} -- [{Label, Value}]
            self.Size = config.Size or 200
            self.ShowLabels = config.ShowLabels ~= false
            self.ShowGrid = config.ShowGrid ~= false
            self.Animated = config.Animated ~= false
            self.GridLevels = config.GridLevels or 5
            self.MaxValue = config.MaxValue or 100

            -- Colors
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
            self.GridColor = config.GridColor or Color3.fromRGB(63, 63, 70)
            self.LabelColor = config.LabelColor or Color3.fromRGB(161, 161, 170)
            self.FillColor = config.FillColor or Color3.fromRGB(99, 102, 241)
            self.LineColor = config.LineColor or Color3.fromRGB(99, 102, 241)
            self.FillOpacity = config.FillOpacity or 0.3

            -- State
            self._connections = {}

            return self
        end

        --// Create chart
        function RadarChart:Create(parent)
            local chart = Instance.new("Frame")
            chart.Name = "RadarChart"
            chart.Size = UDim2.new(0, self.Size, 0, self.Size)
            chart.BackgroundColor3 = self.BackgroundColor
            chart.BorderSizePixel = 0

            if parent then
                chart.Parent = parent
            end

            self.Instance = chart

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = chart

            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, 30)
            padding.PaddingBottom = UDim.new(0, 30)
            padding.PaddingLeft = UDim.new(0, 30)
            padding.PaddingRight = UDim.new(0, 30)
            padding.Parent = chart

            local chartArea = Instance.new("Frame")
            chartArea.Name = "ChartArea"
            chartArea.Size = UDim2.new(1, 0, 1, 0)
            chartArea.BackgroundTransparency = 1
            chartArea.Parent = chart
            self._chartArea = chartArea

            self:Update()

            return self
        end

        --// Draw grid
        function RadarChart:_drawGrid()
            local data = self.Data
            if #data < 3 then return end

            local center = Vector2.new(
                self._chartArea.AbsoluteSize.X / 2,
                self._chartArea.AbsoluteSize.Y / 2
            )
            local radius = math.min(center.X, center.Y)
            local numAxes = #data

            -- Draw axis lines
            for i = 1, numAxes do
                local angle = ((i - 1) / numAxes) * math.pi * 2 - math.pi / 2
                local endX = center.X + math.cos(angle) * radius
                local endY = center.Y + math.sin(angle) * radius

                local axisLine = Instance.new("Frame")
                axisLine.Name = "Axis_" .. i
                axisLine.BackgroundColor3 = self.GridColor
                axisLine.BackgroundTransparency = 0.5
                axisLine.BorderSizePixel = 0

                local distance = math.sqrt((endX - center.X)^2 + (endY - center.Y)^2)
                local lineAngle = math.atan2(endY - center.Y, endX - center.X)

                axisLine.Size = UDim2.new(0, distance, 0, 1)
                axisLine.Position = UDim2.new(0, center.X, 0, center.Y)
                axisLine.AnchorPoint = Vector2.new(0, 0.5)
                axisLine.Rotation = math.deg(lineAngle)
                axisLine.Parent = self._chartArea

                -- Label
                if self.ShowLabels then
                    local label = Instance.new("TextLabel")
                    label.Size = UDim2.new(0, 60, 0, 16)
                    label.Position = UDim2.new(0, endX, 0, endY)
                    label.AnchorPoint = Vector2.new(0.5, 0.5)
                    label.BackgroundTransparency = 1
                    label.Font = Enum.Font.Gotham
                    label.Text = data[i].Label or tostring(i)
                    label.TextColor3 = self.LabelColor
                    label.TextSize = 10
                    label.Parent = self._chartArea
                end
            end
        end

        --// Update chart
        function RadarChart:Update(newData)
            if newData then
                self.Data = newData
            end

            -- Clear existing
            for _, child in ipairs(self._chartArea:GetChildren()) do
                child:Destroy()
            end

            if self.ShowGrid then
                self:_drawGrid()
            end

            -- Draw data polygon would go here
            -- Simplified for this implementation

            return self
        end

        --// Set data
        function RadarChart:SetData(data)
            self.Data = data
            self:Update()
            return self
        end

        --// Destroy
        function RadarChart:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return RadarChart


    end


    -- ============================================================================
    -- Module: NexusUI/Visualizers/DonutChart
    -- ============================================================================
    NexusUI_Modules["NexusUI/Visualizers/DonutChart"] = function()
        local script = CreateMockScript("NexusUI/Visualizers/DonutChart")

        --[[
            NexusUI Donut Chart Component
            Pie chart with center cutout
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// DonutChart Module
        local DonutChart = {}
        DonutChart.__index = DonutChart
        DonutChart.ClassName = "DonutChart"

        --// Constructor
        function DonutChart.new(config)
            local self = setmetatable({}, DonutChart)

            config = config or {}

            self.Data = config.Data or {}
            self.Size = config.Size or 150
            self.InnerRadius = config.InnerRadius or 0.6 -- Percentage
            self.ShowLegend = config.ShowLegend ~= false
            self.ShowCenter = config.ShowCenter ~= false
            self.CenterText = config.CenterText or ""
            self.CenterValue = config.CenterValue or ""
            self.Animated = config.Animated ~= false

            -- Colors
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
            self.LabelColor = config.LabelColor or Color3.fromRGB(250, 250, 250)
            self.DefaultColors = config.Colors or {
                Color3.fromRGB(99, 102, 241),
                Color3.fromRGB(236, 72, 153),
                Color3.fromRGB(34, 197, 94),
                Color3.fromRGB(245, 158, 11),
                Color3.fromRGB(239, 68, 68),
            }

            -- State
            self._connections = {}

            return self
        end

        --// Create chart
        function DonutChart:Create(parent)
            local chart = Instance.new("Frame")
            chart.Name = "DonutChart"
            chart.Size = UDim2.new(0, self.Size + (self.ShowLegend and 120 or 0) + 30, 0, self.Size + 30)
            chart.BackgroundColor3 = self.BackgroundColor
            chart.BorderSizePixel = 0

            if parent then
                chart.Parent = parent
            end

            self.Instance = chart

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = chart

            -- Donut container
            local donutContainer = Instance.new("Frame")
            donutContainer.Name = "DonutContainer"
            donutContainer.Size = UDim2.new(0, self.Size, 0, self.Size)
            donutContainer.Position = UDim2.new(0, 15, 0, 15)
            donutContainer.BackgroundTransparency = 1
            donutContainer.Parent = chart
            self._donutContainer = donutContainer

            -- Ring segments container
            local ringContainer = Instance.new("Frame")
            ringContainer.Name = "Ring"
            ringContainer.Size = UDim2.new(1, 0, 1, 0)
            ringContainer.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
            ringContainer.BorderSizePixel = 0
            ringContainer.Parent = donutContainer
            self._ringContainer = ringContainer

            local ringCorner = Instance.new("UICorner")
            ringCorner.CornerRadius = UDim.new(1, 0)
            ringCorner.Parent = ringContainer

            -- Center circle
            local center = Instance.new("Frame")
            center.Name = "Center"
            center.Size = UDim2.new(self.InnerRadius, 0, self.InnerRadius, 0)
            center.Position = UDim2.new(0.5, 0, 0.5, 0)
            center.AnchorPoint = Vector2.new(0.5, 0.5)
            center.BackgroundColor3 = self.BackgroundColor
            center.BorderSizePixel = 0
            center.ZIndex = 2
            center.Parent = donutContainer
            self._center = center

            local centerCorner = Instance.new("UICorner")
            centerCorner.CornerRadius = UDim.new(1, 0)
            centerCorner.Parent = center

            -- Center text
            if self.ShowCenter then
                local centerLabel = Instance.new("TextLabel")
                centerLabel.Size = UDim2.new(0.8, 0, 0, 16)
                centerLabel.Position = UDim2.new(0.5, 0, 0.4, 0)
                centerLabel.AnchorPoint = Vector2.new(0.5, 0.5)
                centerLabel.BackgroundTransparency = 1
                centerLabel.Font = Enum.Font.Gotham
                centerLabel.Text = self.CenterText
                centerLabel.TextColor3 = Color3.fromRGB(161, 161, 170)
                centerLabel.TextSize = 11
                centerLabel.TextScaled = false
                centerLabel.Parent = center
                self._centerLabel = centerLabel

                local centerValue = Instance.new("TextLabel")
                centerValue.Size = UDim2.new(0.8, 0, 0, 20)
                centerValue.Position = UDim2.new(0.5, 0, 0.6, 0)
                centerValue.AnchorPoint = Vector2.new(0.5, 0.5)
                centerValue.BackgroundTransparency = 1
                centerValue.Font = Enum.Font.GothamBold
                centerValue.Text = self.CenterValue
                centerValue.TextColor3 = self.LabelColor
                centerValue.TextSize = 18
                centerValue.TextScaled = false
                centerValue.Parent = center
                self._centerValue = centerValue
            end

            -- Legend
            if self.ShowLegend then
                local legend = Instance.new("Frame")
                legend.Name = "Legend"
                legend.Size = UDim2.new(0, 110, 0, self.Size)
                legend.Position = UDim2.new(0, self.Size + 20, 0, 15)
                legend.BackgroundTransparency = 1
                legend.Parent = chart
                self._legend = legend

                local legendLayout = Instance.new("UIListLayout")
                legendLayout.Padding = UDim.new(0, 8)
                legendLayout.VerticalAlignment = Enum.VerticalAlignment.Center
                legendLayout.Parent = legend
            end

            self:Update()

            return self
        end

        --// Update chart
        function DonutChart:Update(newData)
            if newData then
                self.Data = newData.Data or self.Data
                self.CenterText = newData.CenterText or self.CenterText
                self.CenterValue = newData.CenterValue or self.CenterValue
            end

            -- Update center text
            if self._centerLabel then
                self._centerLabel.Text = self.CenterText
            end
            if self._centerValue then
                self._centerValue.Text = self.CenterValue
            end

            -- Clear existing legend items
            if self._legend then
                for _, child in ipairs(self._legend:GetChildren()) do
                    if child:IsA("Frame") then
                        child:Destroy()
                    end
                end
            end

            -- Create legend items
            local total = 0
            for _, item in ipairs(self.Data) do
                total = total + (type(item) == "table" and item.Value or item)
            end

            if self._legend then
                for i, item in ipairs(self.Data) do
                    local value = type(item) == "table" and item.Value or item
                    local label = type(item) == "table" and item.Label or tostring(i)
                    local color = type(item) == "table" and item.Color or self.DefaultColors[((i - 1) % #self.DefaultColors) + 1]
                    local percentage = total > 0 and math.floor((value / total) * 100) or 0

                    local legendItem = Instance.new("Frame")
                    legendItem.Size = UDim2.new(1, 0, 0, 22)
                    legendItem.BackgroundTransparency = 1
                    legendItem.Parent = self._legend

                    local colorDot = Instance.new("Frame")
                    colorDot.Size = UDim2.new(0, 10, 0, 10)
                    colorDot.Position = UDim2.new(0, 0, 0.5, 0)
                    colorDot.AnchorPoint = Vector2.new(0, 0.5)
                    colorDot.BackgroundColor3 = color
                    colorDot.BorderSizePixel = 0
                    colorDot.Parent = legendItem

                    local dotCorner = Instance.new("UICorner")
                    dotCorner.CornerRadius = UDim.new(1, 0)
                    dotCorner.Parent = colorDot

                    local itemLabel = Instance.new("TextLabel")
                    itemLabel.Size = UDim2.new(1, -16, 1, 0)
                    itemLabel.Position = UDim2.new(0, 16, 0, 0)
                    itemLabel.BackgroundTransparency = 1
                    itemLabel.Font = Enum.Font.Gotham
                    itemLabel.Text = label .. " " .. percentage .. "%"
                    itemLabel.TextColor3 = self.LabelColor
                    itemLabel.TextSize = 11
                    itemLabel.TextXAlignment = Enum.TextXAlignment.Left
                    itemLabel.TextTruncate = Enum.TextTruncate.AtEnd
                    itemLabel.Parent = legendItem
                end
            end

            return self
        end

        --// Set center text
        function DonutChart:SetCenterText(text, value)
            self.CenterText = text or self.CenterText
            self.CenterValue = value or self.CenterValue

            if self._centerLabel then
                self._centerLabel.Text = self.CenterText
            end
            if self._centerValue then
                self._centerValue.Text = self.CenterValue
            end

            return self
        end

        --// Set data
        function DonutChart:SetData(data)
            self.Data = data
            self:Update()
            return self
        end

        --// Destroy
        function DonutChart:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return DonutChart


    end


    -- ============================================================================
    -- Module: NexusUI/Visualizers/Sparkline
    -- ============================================================================
    NexusUI_Modules["NexusUI/Visualizers/Sparkline"] = function()
        local script = CreateMockScript("NexusUI/Visualizers/Sparkline")

        --[[
            NexusUI Sparkline Component
            Compact inline chart for trends
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Sparkline Module
        local Sparkline = {}
        Sparkline.__index = Sparkline
        Sparkline.ClassName = "Sparkline"

        --// Constructor
        function Sparkline.new(config)
            local self = setmetatable({}, Sparkline)

            config = config or {}

            self.Data = config.Data or {}
            self.Width = config.Width or 100
            self.Height = config.Height or 30
            self.LineWidth = config.LineWidth or 1.5
            self.ShowArea = config.ShowArea or false
            self.ShowMinMax = config.ShowMinMax or false
            self.ShowLastPoint = config.ShowLastPoint ~= false
            self.Animated = config.Animated ~= false

            -- Colors
            self.LineColor = config.LineColor or Color3.fromRGB(99, 102, 241)
            self.AreaColor = config.AreaColor or Color3.fromRGB(99, 102, 241)
            self.AreaOpacity = config.AreaOpacity or 0.2
            self.PositiveColor = config.PositiveColor or Color3.fromRGB(34, 197, 94)
            self.NegativeColor = config.NegativeColor or Color3.fromRGB(239, 68, 68)

            -- State
            self._connections = {}
            self._lines = {}

            return self
        end

        --// Create sparkline
        function Sparkline:Create(parent)
            local sparkline = Instance.new("Frame")
            sparkline.Name = "Sparkline"
            sparkline.Size = UDim2.new(0, self.Width, 0, self.Height)
            sparkline.BackgroundTransparency = 1
            sparkline.ClipsDescendants = true

            if parent then
                sparkline.Parent = parent
            end

            self.Instance = sparkline

            -- Area fill
            if self.ShowArea then
                local area = Instance.new("Frame")
                area.Name = "Area"
                area.Size = UDim2.new(1, 0, 1, 0)
                area.Position = UDim2.new(0, 0, 1, 0)
                area.AnchorPoint = Vector2.new(0, 1)
                area.BackgroundColor3 = self.AreaColor
                area.BackgroundTransparency = 1 - self.AreaOpacity
                area.BorderSizePixel = 0
                area.Parent = sparkline
                self._area = area

                local gradient = Instance.new("UIGradient")
                gradient.Rotation = 90
                gradient.Transparency = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 0),
                    NumberSequenceKeypoint.new(1, 0.9),
                })
                gradient.Parent = area
            end

            -- Lines container
            local linesContainer = Instance.new("Frame")
            linesContainer.Name = "Lines"
            linesContainer.Size = UDim2.new(1, 0, 1, 0)
            linesContainer.BackgroundTransparency = 1
            linesContainer.Parent = sparkline
            self._linesContainer = linesContainer

            -- Last point indicator
            if self.ShowLastPoint then
                local lastPoint = Instance.new("Frame")
                lastPoint.Name = "LastPoint"
                lastPoint.Size = UDim2.new(0, 6, 0, 6)
                lastPoint.BackgroundColor3 = self.LineColor
                lastPoint.BorderSizePixel = 0
                lastPoint.Visible = false
                lastPoint.Parent = sparkline
                self._lastPoint = lastPoint

                local pointCorner = Instance.new("UICorner")
                pointCorner.CornerRadius = UDim.new(1, 0)
                pointCorner.Parent = lastPoint
            end

            self:Update()

            return self
        end

        --// Create line segment
        function Sparkline:_createLine(startPos, endPos, color)
            local distance = (endPos - startPos).Magnitude
            local angle = math.atan2(endPos.Y - startPos.Y, endPos.X - startPos.X)

            local line = Instance.new("Frame")
            line.BackgroundColor3 = color or self.LineColor
            line.BorderSizePixel = 0
            line.Size = UDim2.new(0, distance, 0, self.LineWidth)
            line.Position = UDim2.new(0, startPos.X, 0, startPos.Y)
            line.AnchorPoint = Vector2.new(0, 0.5)
            line.Rotation = math.deg(angle)
            line.Parent = self._linesContainer

            return line
        end

        --// Update sparkline
        function Sparkline:Update(newData)
            if newData then
                self.Data = newData
            end

            -- Clear existing lines
            for _, line in ipairs(self._lines) do
                line:Destroy()
            end
            self._lines = {}

            local data = self.Data
            if #data < 2 then return self end

            -- Find min/max
            local minVal, maxVal = math.huge, -math.huge
            for _, val in ipairs(data) do
                minVal = math.min(minVal, val)
                maxVal = math.max(maxVal, val)
            end

            local range = maxVal - minVal
            if range == 0 then range = 1 end

            local width = self.Width
            local height = self.Height

            -- Calculate points
            local points = {}
            for i, val in ipairs(data) do
                local x = ((i - 1) / (#data - 1)) * width
                local y = height - ((val - minVal) / range) * height
                table.insert(points, Vector2.new(x, y))
            end

            -- Determine trend color
            local trendColor = self.LineColor
            if #data >= 2 then
                if data[#data] > data[1] then
                    trendColor = self.PositiveColor
                elseif data[#data] < data[1] then
                    trendColor = self.NegativeColor
                end
            end

            -- Draw lines
            for i = 1, #points - 1 do
                local line = self:_createLine(points[i], points[i + 1], trendColor)
                table.insert(self._lines, line)
            end

            -- Update area
            if self._area then
                local avgHeight = 0
                for _, val in ipairs(data) do
                    avgHeight = avgHeight + ((val - minVal) / range)
                end
                avgHeight = avgHeight / #data

                self._area.BackgroundColor3 = trendColor
                self._area.Size = UDim2.new(1, 0, avgHeight, 0)
            end

            -- Update last point
            if self._lastPoint and #points > 0 then
                local lastPos = points[#points]
                self._lastPoint.Position = UDim2.new(0, lastPos.X - 3, 0, lastPos.Y - 3)
                self._lastPoint.BackgroundColor3 = trendColor
                self._lastPoint.Visible = true
            end

            return self
        end

        --// Add data point
        function Sparkline:AddPoint(value, maxPoints)
            table.insert(self.Data, value)

            if maxPoints and #self.Data > maxPoints then
                table.remove(self.Data, 1)
            end

            self:Update()
            return self
        end

        --// Set data
        function Sparkline:SetData(data)
            self.Data = data
            self:Update()
            return self
        end

        --// Destroy
        function Sparkline:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return Sparkline


    end


    -- ============================================================================
    -- Module: NexusUI/Visualizers/Gauge
    -- ============================================================================
    NexusUI_Modules["NexusUI/Visualizers/Gauge"] = function()
        local script = CreateMockScript("NexusUI/Visualizers/Gauge")

        --[[
            NexusUI Gauge Component
            Circular gauge/meter for displaying values
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Gauge Module
        local Gauge = {}
        Gauge.__index = Gauge
        Gauge.ClassName = "Gauge"

        --// Constructor
        function Gauge.new(config)
            local self = setmetatable({}, Gauge)

            config = config or {}

            self.Value = config.Value or 0
            self.MinValue = config.MinValue or 0
            self.MaxValue = config.MaxValue or 100
            self.Size = config.Size or 120
            self.Thickness = config.Thickness or 10
            self.StartAngle = config.StartAngle or 135
            self.EndAngle = config.EndAngle or 405
            self.ShowValue = config.ShowValue ~= false
            self.ShowLabel = config.ShowLabel or false
            self.Label = config.Label or ""
            self.Unit = config.Unit or ""
            self.Animated = config.Animated ~= false
            self.Segments = config.Segments or 0 -- 0 = continuous

            -- Colors
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
            self.TrackColor = config.TrackColor or Color3.fromRGB(63, 63, 70)
            self.FillColor = config.FillColor or Color3.fromRGB(99, 102, 241)
            self.LabelColor = config.LabelColor or Color3.fromRGB(161, 161, 170)
            self.ValueColor = config.ValueColor or Color3.fromRGB(250, 250, 250)

            -- Color thresholds
            self.Thresholds = config.Thresholds or nil -- [{Value, Color}]

            -- State
            self._connections = {}

            return self
        end

        --// Get color for current value
        function Gauge:_getColorForValue(value)
            if not self.Thresholds then
                return self.FillColor
            end

            local color = self.FillColor
            for _, threshold in ipairs(self.Thresholds) do
                if value >= threshold.Value then
                    color = threshold.Color
                end
            end

            return color
        end

        --// Create gauge
        function Gauge:Create(parent)
            local gauge = Instance.new("Frame")
            gauge.Name = "Gauge"
            gauge.Size = UDim2.new(0, self.Size, 0, self.Size)
            gauge.BackgroundColor3 = self.BackgroundColor
            gauge.BorderSizePixel = 0

            if parent then
                gauge.Parent = parent
            end

            self.Instance = gauge

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = gauge

            -- Track ring (background)
            local track = Instance.new("Frame")
            track.Name = "Track"
            track.Size = UDim2.new(1, -20, 1, -20)
            track.Position = UDim2.new(0.5, 0, 0.5, 0)
            track.AnchorPoint = Vector2.new(0.5, 0.5)
            track.BackgroundColor3 = self.TrackColor
            track.BorderSizePixel = 0
            track.Parent = gauge
            self._track = track

            local trackCorner = Instance.new("UICorner")
            trackCorner.CornerRadius = UDim.new(1, 0)
            trackCorner.Parent = track

            -- Inner circle (cutout)
            local inner = Instance.new("Frame")
            inner.Name = "Inner"
            inner.Size = UDim2.new(1, -self.Thickness * 2, 1, -self.Thickness * 2)
            inner.Position = UDim2.new(0.5, 0, 0.5, 0)
            inner.AnchorPoint = Vector2.new(0.5, 0.5)
            inner.BackgroundColor3 = self.BackgroundColor
            inner.BorderSizePixel = 0
            inner.ZIndex = 3
            inner.Parent = gauge
            self._inner = inner

            local innerCorner = Instance.new("UICorner")
            innerCorner.CornerRadius = UDim.new(1, 0)
            innerCorner.Parent = inner

            -- Fill ring (would need proper arc implementation)
            local fill = Instance.new("Frame")
            fill.Name = "Fill"
            fill.Size = UDim2.new(1, -20, 1, -20)
            fill.Position = UDim2.new(0.5, 0, 0.5, 0)
            fill.AnchorPoint = Vector2.new(0.5, 0.5)
            fill.BackgroundColor3 = self.FillColor
            fill.BorderSizePixel = 0
            fill.ZIndex = 2
            fill.Parent = gauge
            self._fill = fill

            local fillCorner = Instance.new("UICorner")
            fillCorner.CornerRadius = UDim.new(1, 0)
            fillCorner.Parent = fill

            -- Use UIGradient to simulate arc (simplified)
            local gradient = Instance.new("UIGradient")
            gradient.Rotation = 0
            gradient.Parent = fill
            self._gradient = gradient

            -- Value display
            if self.ShowValue then
                local valueLabel = Instance.new("TextLabel")
                valueLabel.Size = UDim2.new(0.7, 0, 0, 28)
                valueLabel.Position = UDim2.new(0.5, 0, 0.5, self.ShowLabel and -8 or 0)
                valueLabel.AnchorPoint = Vector2.new(0.5, 0.5)
                valueLabel.BackgroundTransparency = 1
                valueLabel.Font = Enum.Font.GothamBold
                valueLabel.Text = tostring(math.floor(self.Value))
                valueLabel.TextColor3 = self.ValueColor
                valueLabel.TextSize = 24
                valueLabel.ZIndex = 4
                valueLabel.Parent = gauge
                self._valueLabel = valueLabel

                if self.Unit ~= "" then
                    local unitLabel = Instance.new("TextLabel")
                    unitLabel.Size = UDim2.new(0.5, 0, 0, 14)
                    unitLabel.Position = UDim2.new(0.5, 0, 0.5, 14)
                    unitLabel.AnchorPoint = Vector2.new(0.5, 0.5)
                    unitLabel.BackgroundTransparency = 1
                    unitLabel.Font = Enum.Font.Gotham
                    unitLabel.Text = self.Unit
                    unitLabel.TextColor3 = self.LabelColor
                    unitLabel.TextSize = 11
                    unitLabel.ZIndex = 4
                    unitLabel.Parent = gauge
                    self._unitLabel = unitLabel
                end
            end

            -- Label
            if self.ShowLabel and self.Label ~= "" then
                local labelText = Instance.new("TextLabel")
                labelText.Size = UDim2.new(0.8, 0, 0, 14)
                labelText.Position = UDim2.new(0.5, 0, 0.5, 16)
                labelText.AnchorPoint = Vector2.new(0.5, 0.5)
                labelText.BackgroundTransparency = 1
                labelText.Font = Enum.Font.Gotham
                labelText.Text = self.Label
                labelText.TextColor3 = self.LabelColor
                labelText.TextSize = 10
                labelText.ZIndex = 4
                labelText.Parent = gauge
                self._labelText = labelText
            end

            self:Update()

            return self
        end

        --// Update gauge
        function Gauge:Update(newValue)
            if newValue ~= nil then
                self.Value = newValue
            end

            -- Calculate percentage
            local range = self.MaxValue - self.MinValue
            local percentage = (self.Value - self.MinValue) / range
            percentage = math.clamp(percentage, 0, 1)

            -- Update value text
            if self._valueLabel then
                self._valueLabel.Text = tostring(math.floor(self.Value))
            end

            -- Update fill color based on thresholds
            local color = self:_getColorForValue(self.Value)
            self._fill.BackgroundColor3 = color

            -- Update gradient to simulate arc (simplified visualization)
            local rotation = percentage * 360

            if self.Animated then
                -- Animate gradient rotation
                local currentRotation = self._gradient.Rotation
                local tween = TweenService:Create(self._gradient, TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {
                    Rotation = rotation,
                })
                tween:Play()
            else
                self._gradient.Rotation = rotation
            end

            -- Update fill visibility based on percentage
            self._gradient.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 0),
                NumberSequenceKeypoint.new(math.max(0.01, percentage), 0),
                NumberSequenceKeypoint.new(math.min(0.99, percentage + 0.01), 1),
                NumberSequenceKeypoint.new(1, 1),
            })

            return self
        end

        --// Set value
        function Gauge:SetValue(value)
            self:Update(value)
            return self
        end

        --// Set label
        function Gauge:SetLabel(label)
            self.Label = label
            if self._labelText then
                self._labelText.Text = label
            end
            return self
        end

        --// Destroy
        function Gauge:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return Gauge


    end


    -- ============================================================================
    -- Module: NexusUI/Visualizers/Heatmap
    -- ============================================================================
    NexusUI_Modules["NexusUI/Visualizers/Heatmap"] = function()
        local script = CreateMockScript("NexusUI/Visualizers/Heatmap")

        --[[
            NexusUI Heatmap Component
            Grid-based color intensity visualization
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Heatmap Module
        local Heatmap = {}
        Heatmap.__index = Heatmap
        Heatmap.ClassName = "Heatmap"

        --// Constructor
        function Heatmap.new(config)
            local self = setmetatable({}, Heatmap)

            config = config or {}

            self.Data = config.Data or {} -- 2D array
            self.Rows = config.Rows or 7
            self.Columns = config.Columns or 12
            self.CellSize = config.CellSize or 20
            self.CellGap = config.CellGap or 2
            self.ShowLabels = config.ShowLabels or false
            self.ShowTooltip = config.ShowTooltip ~= false
            self.Animated = config.Animated ~= false
            self.RowLabels = config.RowLabels or nil
            self.ColumnLabels = config.ColumnLabels or nil

            -- Colors
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
            self.LabelColor = config.LabelColor or Color3.fromRGB(161, 161, 170)
            self.MinColor = config.MinColor or Color3.fromRGB(39, 39, 42)
            self.MaxColor = config.MaxColor or Color3.fromRGB(99, 102, 241)
            self.ColorScale = config.ColorScale or nil -- Array of colors for gradient

            -- State
            self._connections = {}
            self._cells = {}

            return self
        end

        --// Interpolate color based on value
        function Heatmap:_getColorForValue(value, min, max)
            local t = (value - min) / (max - min)
            t = math.clamp(t, 0, 1)

            if self.ColorScale and #self.ColorScale >= 2 then
                -- Multi-color scale
                local scaledT = t * (#self.ColorScale - 1)
                local index = math.floor(scaledT)
                local fraction = scaledT - index

                index = math.clamp(index, 0, #self.ColorScale - 2)

                local c1 = self.ColorScale[index + 1]
                local c2 = self.ColorScale[index + 2]

                return Color3.new(
                    c1.R + (c2.R - c1.R) * fraction,
                    c1.G + (c2.G - c1.G) * fraction,
                    c1.B + (c2.B - c1.B) * fraction
                )
            else
                -- Two-color interpolation
                return Color3.new(
                    self.MinColor.R + (self.MaxColor.R - self.MinColor.R) * t,
                    self.MinColor.G + (self.MaxColor.G - self.MinColor.G) * t,
                    self.MinColor.B + (self.MaxColor.B - self.MinColor.B) * t
                )
            end
        end

        --// Create heatmap
        function Heatmap:Create(parent)
            local labelOffset = self.ShowLabels and 30 or 0
            local width = self.Columns * (self.CellSize + self.CellGap) - self.CellGap + labelOffset + 20
            local height = self.Rows * (self.CellSize + self.CellGap) - self.CellGap + labelOffset + 20

            local heatmap = Instance.new("Frame")
            heatmap.Name = "Heatmap"
            heatmap.Size = UDim2.new(0, width, 0, height)
            heatmap.BackgroundColor3 = self.BackgroundColor
            heatmap.BorderSizePixel = 0

            if parent then
                heatmap.Parent = parent
            end

            self.Instance = heatmap

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = heatmap

            -- Grid container
            local grid = Instance.new("Frame")
            grid.Name = "Grid"
            grid.Size = UDim2.new(1, -20 - labelOffset, 1, -20 - labelOffset)
            grid.Position = UDim2.new(0, 10 + labelOffset, 0, 10 + labelOffset)
            grid.BackgroundTransparency = 1
            grid.Parent = heatmap
            self._grid = grid

            -- Row labels
            if self.ShowLabels and self.RowLabels then
                for i, label in ipairs(self.RowLabels) do
                    local labelText = Instance.new("TextLabel")
                    labelText.Size = UDim2.new(0, labelOffset - 5, 0, self.CellSize)
                    labelText.Position = UDim2.new(0, 5, 0, 10 + labelOffset + (i - 1) * (self.CellSize + self.CellGap))
                    labelText.BackgroundTransparency = 1
                    labelText.Font = Enum.Font.Gotham
                    labelText.Text = label
                    labelText.TextColor3 = self.LabelColor
                    labelText.TextSize = 10
                    labelText.TextXAlignment = Enum.TextXAlignment.Right
                    labelText.Parent = heatmap
                end
            end

            -- Column labels
            if self.ShowLabels and self.ColumnLabels then
                for i, label in ipairs(self.ColumnLabels) do
                    local labelText = Instance.new("TextLabel")
                    labelText.Size = UDim2.new(0, self.CellSize, 0, labelOffset - 5)
                    labelText.Position = UDim2.new(0, 10 + labelOffset + (i - 1) * (self.CellSize + self.CellGap), 0, 5)
                    labelText.BackgroundTransparency = 1
                    labelText.Font = Enum.Font.Gotham
                    labelText.Text = label
                    labelText.TextColor3 = self.LabelColor
                    labelText.TextSize = 10
                    labelText.Rotation = -45
                    labelText.Parent = heatmap
                end
            end

            self:Update()

            return self
        end

        --// Update heatmap
        function Heatmap:Update(newData)
            if newData then
                self.Data = newData
            end

            -- Clear existing cells
            for _, cell in ipairs(self._cells) do
                cell:Destroy()
            end
            self._cells = {}

            -- Find min/max values
            local minVal, maxVal = math.huge, -math.huge
            for _, row in ipairs(self.Data) do
                for _, val in ipairs(row) do
                    minVal = math.min(minVal, val)
                    maxVal = math.max(maxVal, val)
                end
            end

            if minVal == maxVal then
                maxVal = minVal + 1
            end

            -- Create cells
            for rowIndex, row in ipairs(self.Data) do
                for colIndex, value in ipairs(row) do
                    local cell = Instance.new("Frame")
                    cell.Name = string.format("Cell_%d_%d", rowIndex, colIndex)
                    cell.Size = UDim2.new(0, self.CellSize, 0, self.CellSize)
                    cell.Position = UDim2.new(
                        0, (colIndex - 1) * (self.CellSize + self.CellGap),
                        0, (rowIndex - 1) * (self.CellSize + self.CellGap)
                    )
                    cell.BackgroundColor3 = self:_getColorForValue(value, minVal, maxVal)
                    cell.BorderSizePixel = 0
                    cell.Parent = self._grid

                    local cellCorner = Instance.new("UICorner")
                    cellCorner.CornerRadius = UDim.new(0, 3)
                    cellCorner.Parent = cell

                    table.insert(self._cells, cell)

                    -- Animation
                    if self.Animated then
                        cell.BackgroundTransparency = 1
                        TweenService:Create(cell, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, (rowIndex + colIndex) * 0.02), {
                            BackgroundTransparency = 0,
                        }):Play()
                    end

                    -- Tooltip on hover
                    if self.ShowTooltip then
                        local button = Instance.new("TextButton")
                        button.Size = UDim2.new(1, 0, 1, 0)
                        button.BackgroundTransparency = 1
                        button.Text = ""
                        button.Parent = cell

                        table.insert(self._connections, button.MouseEnter:Connect(function()
                            -- Show tooltip (simplified)
                            TweenService:Create(cell, TweenInfo.new(0.1), {
                                Size = UDim2.new(0, self.CellSize + 4, 0, self.CellSize + 4),
                                Position = UDim2.new(
                                    0, (colIndex - 1) * (self.CellSize + self.CellGap) - 2,
                                    0, (rowIndex - 1) * (self.CellSize + self.CellGap) - 2
                                ),
                            }):Play()
                        end))

                        table.insert(self._connections, button.MouseLeave:Connect(function()
                            TweenService:Create(cell, TweenInfo.new(0.1), {
                                Size = UDim2.new(0, self.CellSize, 0, self.CellSize),
                                Position = UDim2.new(
                                    0, (colIndex - 1) * (self.CellSize + self.CellGap),
                                    0, (rowIndex - 1) * (self.CellSize + self.CellGap)
                                ),
                            }):Play()
                        end))
                    end
                end
            end

            return self
        end

        --// Set data
        function Heatmap:SetData(data)
            self.Data = data
            self:Update()
            return self
        end

        --// Destroy
        function Heatmap:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return Heatmap


    end


    -- ============================================================================
    -- Module: NexusUI/Visualizers/FPSGraph
    -- ============================================================================
    NexusUI_Modules["NexusUI/Visualizers/FPSGraph"] = function()
        local script = CreateMockScript("NexusUI/Visualizers/FPSGraph")

        --[[
            NexusUI FPS Graph Component
            Real-time FPS visualization
        ]]

        --// Services
        local RunService = game:GetService("RunService")
        local TweenService = game:GetService("TweenService")

        --// FPSGraph Module
        local FPSGraph = {}
        FPSGraph.__index = FPSGraph
        FPSGraph.ClassName = "FPSGraph"

        --// Constructor
        function FPSGraph.new(config)
            local self = setmetatable({}, FPSGraph)

            config = config or {}

            self.Width = config.Width or 200
            self.Height = config.Height or 80
            self.MaxDataPoints = config.MaxDataPoints or 60
            self.UpdateRate = config.UpdateRate or 1/30 -- 30 updates per second
            self.ShowValue = config.ShowValue ~= false
            self.ShowMin = config.ShowMin or false
            self.ShowMax = config.ShowMax or false
            self.ShowAverage = config.ShowAverage or false

            -- Colors
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
            self.GridColor = config.GridColor or Color3.fromRGB(39, 39, 42)
            self.LineColor = config.LineColor or Color3.fromRGB(34, 197, 94)
            self.LowFPSColor = config.LowFPSColor or Color3.fromRGB(239, 68, 68)
            self.MediumFPSColor = config.MediumFPSColor or Color3.fromRGB(245, 158, 11)
            self.TextColor = config.TextColor or Color3.fromRGB(250, 250, 250)

            -- Thresholds
            self.LowFPSThreshold = config.LowFPSThreshold or 30
            self.MediumFPSThreshold = config.MediumFPSThreshold or 45

            -- State
            self._fpsData = {}
            self._currentFPS = 60
            self._frameCount = 0
            self._lastTime = os.clock()
            self._connections = {}
            self._running = false

            return self
        end

        --// Get color for FPS value
        function FPSGraph:_getColorForFPS(fps)
            if fps < self.LowFPSThreshold then
                return self.LowFPSColor
            elseif fps < self.MediumFPSThreshold then
                return self.MediumFPSColor
            else
                return self.LineColor
            end
        end

        --// Create graph
        function FPSGraph:Create(parent)
            local graph = Instance.new("Frame")
            graph.Name = "FPSGraph"
            graph.Size = UDim2.new(0, self.Width, 0, self.Height)
            graph.BackgroundColor3 = self.BackgroundColor
            graph.BorderSizePixel = 0

            if parent then
                graph.Parent = parent
            end

            self.Instance = graph

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = graph

            -- Header
            local header = Instance.new("Frame")
            header.Size = UDim2.new(1, 0, 0, 24)
            header.BackgroundTransparency = 1
            header.Parent = graph

            local title = Instance.new("TextLabel")
            title.Size = UDim2.new(0, 60, 1, 0)
            title.Position = UDim2.new(0, 10, 0, 0)
            title.BackgroundTransparency = 1
            title.Font = Enum.Font.GothamMedium
            title.Text = "FPS"
            title.TextColor3 = Color3.fromRGB(161, 161, 170)
            title.TextSize = 11
            title.TextXAlignment = Enum.TextXAlignment.Left
            title.Parent = header

            local fpsValue = Instance.new("TextLabel")
            fpsValue.Name = "FPSValue"
            fpsValue.Size = UDim2.new(0, 60, 1, 0)
            fpsValue.Position = UDim2.new(1, -70, 0, 0)
            fpsValue.BackgroundTransparency = 1
            fpsValue.Font = Enum.Font.GothamBold
            fpsValue.Text = "60"
            fpsValue.TextColor3 = self.LineColor
            fpsValue.TextSize = 14
            fpsValue.TextXAlignment = Enum.TextXAlignment.Right
            fpsValue.Parent = header
            self._fpsLabel = fpsValue

            -- Graph area
            local graphArea = Instance.new("Frame")
            graphArea.Name = "GraphArea"
            graphArea.Size = UDim2.new(1, -20, 1, -34)
            graphArea.Position = UDim2.new(0, 10, 0, 28)
            graphArea.BackgroundColor3 = self.GridColor
            graphArea.BackgroundTransparency = 0.5
            graphArea.BorderSizePixel = 0
            graphArea.ClipsDescendants = true
            graphArea.Parent = graph
            self._graphArea = graphArea

            local graphCorner = Instance.new("UICorner")
            graphCorner.CornerRadius = UDim.new(0, 4)
            graphCorner.Parent = graphArea

            -- Lines container
            local linesContainer = Instance.new("Frame")
            linesContainer.Name = "Lines"
            linesContainer.Size = UDim2.new(1, 0, 1, 0)
            linesContainer.BackgroundTransparency = 1
            linesContainer.Parent = graphArea
            self._linesContainer = linesContainer

            -- Grid lines
            for i = 1, 3 do
                local gridLine = Instance.new("Frame")
                gridLine.Size = UDim2.new(1, 0, 0, 1)
                gridLine.Position = UDim2.new(0, 0, i * 0.25, 0)
                gridLine.BackgroundColor3 = self.GridColor
                gridLine.BackgroundTransparency = 0.5
                gridLine.BorderSizePixel = 0
                gridLine.Parent = graphArea
            end

            -- Stats display
            if self.ShowMin or self.ShowMax or self.ShowAverage then
                local stats = Instance.new("Frame")
                stats.Size = UDim2.new(1, 0, 0, 14)
                stats.Position = UDim2.new(0, 0, 1, -14)
                stats.BackgroundTransparency = 1
                stats.Parent = graph

                local statsLayout = Instance.new("UIListLayout")
                statsLayout.FillDirection = Enum.FillDirection.Horizontal
                statsLayout.Padding = UDim.new(0, 15)
                statsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
                statsLayout.Parent = stats

                if self.ShowMin then
                    local minLabel = Instance.new("TextLabel")
                    minLabel.Name = "Min"
                    minLabel.Size = UDim2.new(0, 50, 1, 0)
                    minLabel.BackgroundTransparency = 1
                    minLabel.Font = Enum.Font.Gotham
                    minLabel.Text = "Min: --"
                    minLabel.TextColor3 = self.LowFPSColor
                    minLabel.TextSize = 9
                    minLabel.Parent = stats
                    self._minLabel = minLabel
                end

                if self.ShowAverage then
                    local avgLabel = Instance.new("TextLabel")
                    avgLabel.Name = "Avg"
                    avgLabel.Size = UDim2.new(0, 50, 1, 0)
                    avgLabel.BackgroundTransparency = 1
                    avgLabel.Font = Enum.Font.Gotham
                    avgLabel.Text = "Avg: --"
                    avgLabel.TextColor3 = self.MediumFPSColor
                    avgLabel.TextSize = 9
                    avgLabel.Parent = stats
                    self._avgLabel = avgLabel
                end

                if self.ShowMax then
                    local maxLabel = Instance.new("TextLabel")
                    maxLabel.Name = "Max"
                    maxLabel.Size = UDim2.new(0, 50, 1, 0)
                    maxLabel.BackgroundTransparency = 1
                    maxLabel.Font = Enum.Font.Gotham
                    maxLabel.Text = "Max: --"
                    maxLabel.TextColor3 = self.LineColor
                    maxLabel.TextSize = 9
                    maxLabel.Parent = stats
                    self._maxLabel = maxLabel
                end
            end

            return self
        end

        --// Start monitoring
        function FPSGraph:Start()
            if self._running then return self end
            self._running = true

            -- FPS counter
            local fpsConnection = RunService.Heartbeat:Connect(function()
                self._frameCount = self._frameCount + 1
            end)
            table.insert(self._connections, fpsConnection)

            -- Update loop
            local lastUpdate = os.clock()
            local updateConnection = RunService.Heartbeat:Connect(function()
                local now = os.clock()
                local elapsed = now - self._lastTime

                if elapsed >= 1 then
                    self._currentFPS = self._frameCount / elapsed
                    self._frameCount = 0
                    self._lastTime = now

                    -- Store data point
                    table.insert(self._fpsData, self._currentFPS)
                    if #self._fpsData > self.MaxDataPoints then
                        table.remove(self._fpsData, 1)
                    end
                end

                -- Update display at update rate
                if now - lastUpdate >= self.UpdateRate then
                    lastUpdate = now
                    self:_updateDisplay()
                end
            end)
            table.insert(self._connections, updateConnection)

            return self
        end

        --// Stop monitoring
        function FPSGraph:Stop()
            self._running = false

            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            return self
        end

        --// Update display
        function FPSGraph:_updateDisplay()
            local fps = math.floor(self._currentFPS + 0.5)
            local color = self:_getColorForFPS(fps)

            -- Update FPS label
            if self._fpsLabel then
                self._fpsLabel.Text = tostring(fps)
                self._fpsLabel.TextColor3 = color
            end

            -- Update graph
            self:_drawGraph()

            -- Update stats
            if #self._fpsData > 0 then
                local min, max, sum = math.huge, -math.huge, 0
                for _, val in ipairs(self._fpsData) do
                    min = math.min(min, val)
                    max = math.max(max, val)
                    sum = sum + val
                end
                local avg = sum / #self._fpsData

                if self._minLabel then
                    self._minLabel.Text = "Min: " .. math.floor(min)
                end
                if self._maxLabel then
                    self._maxLabel.Text = "Max: " .. math.floor(max)
                end
                if self._avgLabel then
                    self._avgLabel.Text = "Avg: " .. math.floor(avg)
                end
            end
        end

        --// Draw graph
        function FPSGraph:_drawGraph()
            -- Clear existing lines
            for _, child in ipairs(self._linesContainer:GetChildren()) do
                child:Destroy()
            end

            local data = self._fpsData
            if #data < 2 then return end

            local graphWidth = self._graphArea.AbsoluteSize.X
            local graphHeight = self._graphArea.AbsoluteSize.Y

            -- Normalize to 0-120 FPS range
            local maxFPS = 120

            local points = {}
            for i, fps in ipairs(data) do
                local x = ((i - 1) / (self.MaxDataPoints - 1)) * graphWidth
                local y = graphHeight - (math.min(fps, maxFPS) / maxFPS) * graphHeight
                table.insert(points, Vector2.new(x, y))
            end

            -- Draw lines
            for i = 1, #points - 1 do
                local startPos = points[i]
                local endPos = points[i + 1]

                local distance = (endPos - startPos).Magnitude
                local angle = math.atan2(endPos.Y - startPos.Y, endPos.X - startPos.X)

                local fps = data[i]
                local color = self:_getColorForFPS(fps)

                local line = Instance.new("Frame")
                line.BackgroundColor3 = color
                line.BorderSizePixel = 0
                line.Size = UDim2.new(0, distance + 1, 0, 2)
                line.Position = UDim2.new(0, startPos.X, 0, startPos.Y)
                line.AnchorPoint = Vector2.new(0, 0.5)
                line.Rotation = math.deg(angle)
                line.Parent = self._linesContainer
            end
        end

        --// Get current FPS
        function FPSGraph:GetFPS()
            return math.floor(self._currentFPS + 0.5)
        end

        --// Destroy
        function FPSGraph:Destroy()
            self:Stop()

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return FPSGraph


    end


    -- ============================================================================
    -- Module: NexusUI/Visualizers/MemoryGraph
    -- ============================================================================
    NexusUI_Modules["NexusUI/Visualizers/MemoryGraph"] = function()
        local script = CreateMockScript("NexusUI/Visualizers/MemoryGraph")

        --[[
            NexusUI Memory Graph Component
            Real-time memory usage visualization
        ]]

        --// Services
        local RunService = game:GetService("RunService")

        --// MemoryGraph Module
        local MemoryGraph = {}
        MemoryGraph.__index = MemoryGraph
        MemoryGraph.ClassName = "MemoryGraph"

        --// Constructor
        function MemoryGraph.new(config)
            local self = setmetatable({}, MemoryGraph)

            config = config or {}

            self.Width = config.Width or 200
            self.Height = config.Height or 80
            self.MaxDataPoints = config.MaxDataPoints or 60
            self.UpdateRate = config.UpdateRate or 1 -- Update every second
            self.ShowValue = config.ShowValue ~= false

            -- Colors
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
            self.GridColor = config.GridColor or Color3.fromRGB(39, 39, 42)
            self.LineColor = config.LineColor or Color3.fromRGB(139, 92, 246)
            self.HighMemColor = config.HighMemColor or Color3.fromRGB(239, 68, 68)
            self.TextColor = config.TextColor or Color3.fromRGB(250, 250, 250)

            -- Thresholds (in MB)
            self.HighMemThreshold = config.HighMemThreshold or 500

            -- State
            self._memoryData = {}
            self._currentMemory = 0
            self._connections = {}
            self._running = false

            return self
        end

        --// Create graph
        function MemoryGraph:Create(parent)
            local graph = Instance.new("Frame")
            graph.Name = "MemoryGraph"
            graph.Size = UDim2.new(0, self.Width, 0, self.Height)
            graph.BackgroundColor3 = self.BackgroundColor
            graph.BorderSizePixel = 0

            if parent then
                graph.Parent = parent
            end

            self.Instance = graph

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = graph

            -- Header
            local header = Instance.new("Frame")
            header.Size = UDim2.new(1, 0, 0, 24)
            header.BackgroundTransparency = 1
            header.Parent = graph

            local title = Instance.new("TextLabel")
            title.Size = UDim2.new(0, 80, 1, 0)
            title.Position = UDim2.new(0, 10, 0, 0)
            title.BackgroundTransparency = 1
            title.Font = Enum.Font.GothamMedium
            title.Text = "Memory"
            title.TextColor3 = Color3.fromRGB(161, 161, 170)
            title.TextSize = 11
            title.TextXAlignment = Enum.TextXAlignment.Left
            title.Parent = header

            local memValue = Instance.new("TextLabel")
            memValue.Name = "MemValue"
            memValue.Size = UDim2.new(0, 80, 1, 0)
            memValue.Position = UDim2.new(1, -90, 0, 0)
            memValue.BackgroundTransparency = 1
            memValue.Font = Enum.Font.GothamBold
            memValue.Text = "0 MB"
            memValue.TextColor3 = self.LineColor
            memValue.TextSize = 14
            memValue.TextXAlignment = Enum.TextXAlignment.Right
            memValue.Parent = header
            self._memLabel = memValue

            -- Graph area
            local graphArea = Instance.new("Frame")
            graphArea.Name = "GraphArea"
            graphArea.Size = UDim2.new(1, -20, 1, -34)
            graphArea.Position = UDim2.new(0, 10, 0, 28)
            graphArea.BackgroundColor3 = self.GridColor
            graphArea.BackgroundTransparency = 0.5
            graphArea.BorderSizePixel = 0
            graphArea.ClipsDescendants = true
            graphArea.Parent = graph
            self._graphArea = graphArea

            local graphCorner = Instance.new("UICorner")
            graphCorner.CornerRadius = UDim.new(0, 4)
            graphCorner.Parent = graphArea

            -- Fill area
            local fillArea = Instance.new("Frame")
            fillArea.Name = "Fill"
            fillArea.Size = UDim2.new(1, 0, 0, 0)
            fillArea.Position = UDim2.new(0, 0, 1, 0)
            fillArea.AnchorPoint = Vector2.new(0, 1)
            fillArea.BackgroundColor3 = self.LineColor
            fillArea.BackgroundTransparency = 0.7
            fillArea.BorderSizePixel = 0
            fillArea.Parent = graphArea
            self._fillArea = fillArea

            local gradient = Instance.new("UIGradient")
            gradient.Rotation = 90
            gradient.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 0),
                NumberSequenceKeypoint.new(1, 0.8),
            })
            gradient.Parent = fillArea

            -- Lines container
            local linesContainer = Instance.new("Frame")
            linesContainer.Name = "Lines"
            linesContainer.Size = UDim2.new(1, 0, 1, 0)
            linesContainer.BackgroundTransparency = 1
            linesContainer.Parent = graphArea
            self._linesContainer = linesContainer

            return self
        end

        --// Start monitoring
        function MemoryGraph:Start()
            if self._running then return self end
            self._running = true

            local lastUpdate = os.clock()

            local connection = RunService.Heartbeat:Connect(function()
                local now = os.clock()

                if now - lastUpdate >= self.UpdateRate then
                    lastUpdate = now

                    -- Get memory usage
                    self._currentMemory = collectgarbage("count") / 1024 -- KB to MB

                    -- Store data point
                    table.insert(self._memoryData, self._currentMemory)
                    if #self._memoryData > self.MaxDataPoints then
                        table.remove(self._memoryData, 1)
                    end

                    self:_updateDisplay()
                end
            end)

            table.insert(self._connections, connection)

            return self
        end

        --// Stop monitoring
        function MemoryGraph:Stop()
            self._running = false

            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            return self
        end

        --// Update display
        function MemoryGraph:_updateDisplay()
            local mem = self._currentMemory
            local color = mem > self.HighMemThreshold and self.HighMemColor or self.LineColor

            -- Update label
            if self._memLabel then
                self._memLabel.Text = string.format("%.1f MB", mem)
                self._memLabel.TextColor3 = color
            end

            -- Update fill area
            if self._fillArea then
                local maxMem = 1000 -- Assume 1GB max for display
                local fillHeight = math.min(mem / maxMem, 1)
                self._fillArea.Size = UDim2.new(1, 0, fillHeight, 0)
                self._fillArea.BackgroundColor3 = color
            end

            -- Draw graph
            self:_drawGraph()
        end

        --// Draw graph
        function MemoryGraph:_drawGraph()
            for _, child in ipairs(self._linesContainer:GetChildren()) do
                child:Destroy()
            end

            local data = self._memoryData
            if #data < 2 then return end

            local graphWidth = self._graphArea.AbsoluteSize.X
            local graphHeight = self._graphArea.AbsoluteSize.Y

            local maxMem = 0
            for _, mem in ipairs(data) do
                maxMem = math.max(maxMem, mem)
            end
            maxMem = math.max(maxMem, 100) -- At least 100MB scale

            local points = {}
            for i, mem in ipairs(data) do
                local x = ((i - 1) / (self.MaxDataPoints - 1)) * graphWidth
                local y = graphHeight - (mem / maxMem) * graphHeight
                table.insert(points, Vector2.new(x, y))
            end

            for i = 1, #points - 1 do
                local startPos = points[i]
                local endPos = points[i + 1]

                local distance = (endPos - startPos).Magnitude
                local angle = math.atan2(endPos.Y - startPos.Y, endPos.X - startPos.X)

                local line = Instance.new("Frame")
                line.BackgroundColor3 = self.LineColor
                line.BorderSizePixel = 0
                line.Size = UDim2.new(0, distance + 1, 0, 2)
                line.Position = UDim2.new(0, startPos.X, 0, startPos.Y)
                line.AnchorPoint = Vector2.new(0, 0.5)
                line.Rotation = math.deg(angle)
                line.Parent = self._linesContainer
            end
        end

        --// Get current memory
        function MemoryGraph:GetMemory()
            return self._currentMemory
        end

        --// Destroy
        function MemoryGraph:Destroy()
            self:Stop()

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return MemoryGraph


    end


    -- ============================================================================
    -- Module: NexusUI/Visualizers/NetworkGraph
    -- ============================================================================
    NexusUI_Modules["NexusUI/Visualizers/NetworkGraph"] = function()
        local script = CreateMockScript("NexusUI/Visualizers/NetworkGraph")

        --[[
            NexusUI Network Graph Component
            Real-time network latency/ping visualization
        ]]

        --// Services
        local RunService = game:GetService("RunService")
        local Players = game:GetService("Players")

        --// NetworkGraph Module
        local NetworkGraph = {}
        NetworkGraph.__index = NetworkGraph
        NetworkGraph.ClassName = "NetworkGraph"

        --// Constructor
        function NetworkGraph.new(config)
            local self = setmetatable({}, NetworkGraph)

            config = config or {}

            self.Width = config.Width or 200
            self.Height = config.Height or 80
            self.MaxDataPoints = config.MaxDataPoints or 60
            self.UpdateRate = config.UpdateRate or 0.5
            self.ShowValue = config.ShowValue ~= false

            -- Colors
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
            self.GridColor = config.GridColor or Color3.fromRGB(39, 39, 42)
            self.LineColor = config.LineColor or Color3.fromRGB(59, 130, 246)
            self.HighPingColor = config.HighPingColor or Color3.fromRGB(239, 68, 68)
            self.MediumPingColor = config.MediumPingColor or Color3.fromRGB(245, 158, 11)
            self.TextColor = config.TextColor or Color3.fromRGB(250, 250, 250)

            -- Thresholds (in ms)
            self.HighPingThreshold = config.HighPingThreshold or 150
            self.MediumPingThreshold = config.MediumPingThreshold or 80

            -- State
            self._pingData = {}
            self._currentPing = 0
            self._connections = {}
            self._running = false

            return self
        end

        --// Get color for ping value
        function NetworkGraph:_getColorForPing(ping)
            if ping > self.HighPingThreshold then
                return self.HighPingColor
            elseif ping > self.MediumPingThreshold then
                return self.MediumPingColor
            else
                return self.LineColor
            end
        end

        --// Create graph
        function NetworkGraph:Create(parent)
            local graph = Instance.new("Frame")
            graph.Name = "NetworkGraph"
            graph.Size = UDim2.new(0, self.Width, 0, self.Height)
            graph.BackgroundColor3 = self.BackgroundColor
            graph.BorderSizePixel = 0

            if parent then
                graph.Parent = parent
            end

            self.Instance = graph

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = graph

            -- Header
            local header = Instance.new("Frame")
            header.Size = UDim2.new(1, 0, 0, 24)
            header.BackgroundTransparency = 1
            header.Parent = graph

            local title = Instance.new("TextLabel")
            title.Size = UDim2.new(0, 60, 1, 0)
            title.Position = UDim2.new(0, 10, 0, 0)
            title.BackgroundTransparency = 1
            title.Font = Enum.Font.GothamMedium
            title.Text = "Ping"
            title.TextColor3 = Color3.fromRGB(161, 161, 170)
            title.TextSize = 11
            title.TextXAlignment = Enum.TextXAlignment.Left
            title.Parent = header

            local pingValue = Instance.new("TextLabel")
            pingValue.Name = "PingValue"
            pingValue.Size = UDim2.new(0, 70, 1, 0)
            pingValue.Position = UDim2.new(1, -80, 0, 0)
            pingValue.BackgroundTransparency = 1
            pingValue.Font = Enum.Font.GothamBold
            pingValue.Text = "0 ms"
            pingValue.TextColor3 = self.LineColor
            pingValue.TextSize = 14
            pingValue.TextXAlignment = Enum.TextXAlignment.Right
            pingValue.Parent = header
            self._pingLabel = pingValue

            -- Graph area
            local graphArea = Instance.new("Frame")
            graphArea.Name = "GraphArea"
            graphArea.Size = UDim2.new(1, -20, 1, -34)
            graphArea.Position = UDim2.new(0, 10, 0, 28)
            graphArea.BackgroundColor3 = self.GridColor
            graphArea.BackgroundTransparency = 0.5
            graphArea.BorderSizePixel = 0
            graphArea.ClipsDescendants = true
            graphArea.Parent = graph
            self._graphArea = graphArea

            local graphCorner = Instance.new("UICorner")
            graphCorner.CornerRadius = UDim.new(0, 4)
            graphCorner.Parent = graphArea

            -- Lines container
            local linesContainer = Instance.new("Frame")
            linesContainer.Name = "Lines"
            linesContainer.Size = UDim2.new(1, 0, 1, 0)
            linesContainer.BackgroundTransparency = 1
            linesContainer.Parent = graphArea
            self._linesContainer = linesContainer

            -- Status indicator
            local status = Instance.new("Frame")
            status.Name = "Status"
            status.Size = UDim2.new(0, 8, 0, 8)
            status.Position = UDim2.new(0, 10, 0, 8)
            status.BackgroundColor3 = self.LineColor
            status.BorderSizePixel = 0
            status.Parent = graph
            self._statusIndicator = status

            local statusCorner = Instance.new("UICorner")
            statusCorner.CornerRadius = UDim.new(1, 0)
            statusCorner.Parent = status

            return self
        end

        --// Start monitoring
        function NetworkGraph:Start()
            if self._running then return self end
            self._running = true

            local lastUpdate = os.clock()

            local connection = RunService.Heartbeat:Connect(function()
                local now = os.clock()

                if now - lastUpdate >= self.UpdateRate then
                    lastUpdate = now

                    -- Get ping
                    local player = Players.LocalPlayer
                    if player then
                        local success, ping = pcall(function()
                            return player:GetNetworkPing()
                        end)

                        if success then
                            self._currentPing = ping * 1000 -- Convert to ms
                        end
                    end

                    -- Store data point
                    table.insert(self._pingData, self._currentPing)
                    if #self._pingData > self.MaxDataPoints then
                        table.remove(self._pingData, 1)
                    end

                    self:_updateDisplay()
                end
            end)

            table.insert(self._connections, connection)

            return self
        end

        --// Stop monitoring
        function NetworkGraph:Stop()
            self._running = false

            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            return self
        end

        --// Update display
        function NetworkGraph:_updateDisplay()
            local ping = math.floor(self._currentPing + 0.5)
            local color = self:_getColorForPing(ping)

            -- Update label
            if self._pingLabel then
                self._pingLabel.Text = ping .. " ms"
                self._pingLabel.TextColor3 = color
            end

            -- Update status indicator
            if self._statusIndicator then
                self._statusIndicator.BackgroundColor3 = color
            end

            -- Draw graph
            self:_drawGraph()
        end

        --// Draw graph
        function NetworkGraph:_drawGraph()
            for _, child in ipairs(self._linesContainer:GetChildren()) do
                child:Destroy()
            end

            local data = self._pingData
            if #data < 2 then return end

            local graphWidth = self._graphArea.AbsoluteSize.X
            local graphHeight = self._graphArea.AbsoluteSize.Y

            -- Auto-scale with minimum 200ms
            local maxPing = 200
            for _, p in ipairs(data) do
                maxPing = math.max(maxPing, p)
            end

            local points = {}
            for i, p in ipairs(data) do
                local x = ((i - 1) / (self.MaxDataPoints - 1)) * graphWidth
                local y = graphHeight - (math.min(p, maxPing) / maxPing) * graphHeight
                table.insert(points, Vector2.new(x, y))
            end

            for i = 1, #points - 1 do
                local startPos = points[i]
                local endPos = points[i + 1]

                local distance = (endPos - startPos).Magnitude
                local angle = math.atan2(endPos.Y - startPos.Y, endPos.X - startPos.X)

                local pingVal = data[i]
                local lineColor = self:_getColorForPing(pingVal)

                local line = Instance.new("Frame")
                line.BackgroundColor3 = lineColor
                line.BorderSizePixel = 0
                line.Size = UDim2.new(0, distance + 1, 0, 2)
                line.Position = UDim2.new(0, startPos.X, 0, startPos.Y)
                line.AnchorPoint = Vector2.new(0, 0.5)
                line.Rotation = math.deg(angle)
                line.Parent = self._linesContainer
            end
        end

        --// Get current ping
        function NetworkGraph:GetPing()
            return math.floor(self._currentPing + 0.5)
        end

        --// Destroy
        function NetworkGraph:Destroy()
            self:Stop()

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return NetworkGraph


    end


    -- ============================================================================
    -- Module: NexusUI/Visualizers/PerformancePanel
    -- ============================================================================
    NexusUI_Modules["NexusUI/Visualizers/PerformancePanel"] = function()
        local script = CreateMockScript("NexusUI/Visualizers/PerformancePanel")

        --[[
            NexusUI Performance Panel Component
            Comprehensive performance monitoring panel with FPS, memory, and network
        ]]

        --// Services
        local RunService = game:GetService("RunService")
        local Players = game:GetService("Players")
        local TweenService = game:GetService("TweenService")

        --// PerformancePanel Module
        local PerformancePanel = {}
        PerformancePanel.__index = PerformancePanel
        PerformancePanel.ClassName = "PerformancePanel"

        --// Constructor
        function PerformancePanel.new(config)
            local self = setmetatable({}, PerformancePanel)

            config = config or {}

            self.Width = config.Width or 220
            self.Height = config.Height or 120
            self.Compact = config.Compact or false
            self.ShowFPS = config.ShowFPS ~= false
            self.ShowMemory = config.ShowMemory ~= false
            self.ShowPing = config.ShowPing ~= false
            self.ShowUptime = config.ShowUptime or false
            self.Draggable = config.Draggable ~= false
            self.Position = config.Position or UDim2.new(1, -230, 0, 10)

            -- Colors
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(18, 18, 21)
            self.TextColor = config.TextColor or Color3.fromRGB(250, 250, 250)
            self.LabelColor = config.LabelColor or Color3.fromRGB(113, 113, 122)
            self.AccentColor = config.AccentColor or Color3.fromRGB(99, 102, 241)

            -- FPS Colors
            self.HighFPSColor = config.HighFPSColor or Color3.fromRGB(34, 197, 94)
            self.MediumFPSColor = config.MediumFPSColor or Color3.fromRGB(245, 158, 11)
            self.LowFPSColor = config.LowFPSColor or Color3.fromRGB(239, 68, 68)

            -- Thresholds
            self.LowFPSThreshold = config.LowFPSThreshold or 30
            self.MediumFPSThreshold = config.MediumFPSThreshold or 45
            self.HighPingThreshold = config.HighPingThreshold or 150

            -- State
            self._connections = {}
            self._running = false
            self._frameCount = 0
            self._lastFPSTime = os.clock()
            self._currentFPS = 60
            self._currentMemory = 0
            self._currentPing = 0
            self._startTime = os.clock()
            self._fpsHistory = {}

            return self
        end

        --// Get FPS color
        function PerformancePanel:_getFPSColor(fps)
            if fps < self.LowFPSThreshold then
                return self.LowFPSColor
            elseif fps < self.MediumFPSThreshold then
                return self.MediumFPSColor
            else
                return self.HighFPSColor
            end
        end

        --// Create panel
        function PerformancePanel:Create(parent)
            local panel = Instance.new("Frame")
            panel.Name = "PerformancePanel"
            panel.Size = UDim2.new(0, self.Width, 0, self.Height)
            panel.Position = self.Position
            panel.BackgroundColor3 = self.BackgroundColor
            panel.BorderSizePixel = 0

            if parent then
                panel.Parent = parent
            end

            self.Instance = panel

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 10)
            corner.Parent = panel

            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(39, 39, 42)
            stroke.Thickness = 1
            stroke.Parent = panel

            -- Padding
            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, 12)
            padding.PaddingBottom = UDim.new(0, 12)
            padding.PaddingLeft = UDim.new(0, 14)
            padding.PaddingRight = UDim.new(0, 14)
            padding.Parent = panel

            -- Header
            local header = Instance.new("Frame")
            header.Size = UDim2.new(1, 0, 0, 20)
            header.BackgroundTransparency = 1
            header.Parent = panel

            local title = Instance.new("TextLabel")
            title.Size = UDim2.new(1, 0, 1, 0)
            title.BackgroundTransparency = 1
            title.Font = Enum.Font.GothamBold
            title.Text = "Performance"
            title.TextColor3 = self.TextColor
            title.TextSize = 12
            title.TextXAlignment = Enum.TextXAlignment.Left
            title.Parent = header

            -- Status indicator
            local statusDot = Instance.new("Frame")
            statusDot.Size = UDim2.new(0, 8, 0, 8)
            statusDot.Position = UDim2.new(1, -8, 0.5, 0)
            statusDot.AnchorPoint = Vector2.new(0, 0.5)
            statusDot.BackgroundColor3 = self.HighFPSColor
            statusDot.BorderSizePixel = 0
            statusDot.Parent = header
            self._statusDot = statusDot

            local statusCorner = Instance.new("UICorner")
            statusCorner.CornerRadius = UDim.new(1, 0)
            statusCorner.Parent = statusDot

            -- Stats container
            local stats = Instance.new("Frame")
            stats.Size = UDim2.new(1, 0, 1, -28)
            stats.Position = UDim2.new(0, 0, 0, 28)
            stats.BackgroundTransparency = 1
            stats.Parent = panel

            local statsLayout = Instance.new("UIListLayout")
            statsLayout.Padding = UDim.new(0, 8)
            statsLayout.Parent = stats

            -- FPS row
            if self.ShowFPS then
                local fpsRow = self:_createStatRow("FPS", "60", self.HighFPSColor, stats)
                self._fpsValueLabel = fpsRow:FindFirstChild("Value")
                self._fpsBar = fpsRow:FindFirstChild("Bar")
            end

            -- Memory row
            if self.ShowMemory then
                local memRow = self:_createStatRow("Memory", "0 MB", self.AccentColor, stats)
                self._memValueLabel = memRow:FindFirstChild("Value")
                self._memBar = memRow:FindFirstChild("Bar")
            end

            -- Ping row
            if self.ShowPing then
                local pingRow = self:_createStatRow("Ping", "0 ms", Color3.fromRGB(59, 130, 246), stats)
                self._pingValueLabel = pingRow:FindFirstChild("Value")
                self._pingBar = pingRow:FindFirstChild("Bar")
            end

            -- Uptime row
            if self.ShowUptime then
                local uptimeRow = self:_createStatRow("Uptime", "00:00", Color3.fromRGB(168, 85, 247), stats)
                self._uptimeValueLabel = uptimeRow:FindFirstChild("Value")
            end

            -- Draggable
            if self.Draggable then
                self:_setupDragging()
            end

            return self
        end

        --// Create stat row
        function PerformancePanel:_createStatRow(label, value, color, parent)
            local row = Instance.new("Frame")
            row.Name = label .. "Row"
            row.Size = UDim2.new(1, 0, 0, 18)
            row.BackgroundTransparency = 1
            row.Parent = parent

            local labelText = Instance.new("TextLabel")
            labelText.Name = "Label"
            labelText.Size = UDim2.new(0, 60, 1, 0)
            labelText.BackgroundTransparency = 1
            labelText.Font = Enum.Font.Gotham
            labelText.Text = label
            labelText.TextColor3 = self.LabelColor
            labelText.TextSize = 11
            labelText.TextXAlignment = Enum.TextXAlignment.Left
            labelText.Parent = row

            local valueText = Instance.new("TextLabel")
            valueText.Name = "Value"
            valueText.Size = UDim2.new(0, 60, 1, 0)
            valueText.Position = UDim2.new(1, -60, 0, 0)
            valueText.BackgroundTransparency = 1
            valueText.Font = Enum.Font.GothamMedium
            valueText.Text = value
            valueText.TextColor3 = color
            valueText.TextSize = 11
            valueText.TextXAlignment = Enum.TextXAlignment.Right
            valueText.Parent = row

            -- Progress bar
            local barTrack = Instance.new("Frame")
            barTrack.Name = "BarTrack"
            barTrack.Size = UDim2.new(1, -130, 0, 4)
            barTrack.Position = UDim2.new(0, 65, 0.5, 0)
            barTrack.AnchorPoint = Vector2.new(0, 0.5)
            barTrack.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
            barTrack.BorderSizePixel = 0
            barTrack.Parent = row

            local barCorner = Instance.new("UICorner")
            barCorner.CornerRadius = UDim.new(1, 0)
            barCorner.Parent = barTrack

            local bar = Instance.new("Frame")
            bar.Name = "Bar"
            bar.Size = UDim2.new(0.5, 0, 1, 0)
            bar.BackgroundColor3 = color
            bar.BorderSizePixel = 0
            bar.Parent = barTrack

            local barFillCorner = Instance.new("UICorner")
            barFillCorner.CornerRadius = UDim.new(1, 0)
            barFillCorner.Parent = bar

            return row
        end

        --// Setup dragging
        function PerformancePanel:_setupDragging()
            local dragging = false
            local dragStart = nil
            local startPos = nil

            local dragInput = Instance.new("TextButton")
            dragInput.Size = UDim2.new(1, 0, 0, 28)
            dragInput.BackgroundTransparency = 1
            dragInput.Text = ""
            dragInput.ZIndex = 2
            dragInput.Parent = self.Instance

            table.insert(self._connections, dragInput.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    dragging = true
                    dragStart = input.Position
                    startPos = self.Instance.Position
                end
            end))

            table.insert(self._connections, dragInput.InputEnded:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    dragging = false
                end
            end))

            table.insert(self._connections, game:GetService("UserInputService").InputChanged:Connect(function(input)
                if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                    local delta = input.Position - dragStart
                    self.Instance.Position = UDim2.new(
                        startPos.X.Scale,
                        startPos.X.Offset + delta.X,
                        startPos.Y.Scale,
                        startPos.Y.Offset + delta.Y
                    )
                end
            end))
        end

        --// Start monitoring
        function PerformancePanel:Start()
            if self._running then return self end
            self._running = true

            -- FPS counter
            local fpsConnection = RunService.Heartbeat:Connect(function()
                self._frameCount = self._frameCount + 1

                local now = os.clock()
                local elapsed = now - self._lastFPSTime

                if elapsed >= 0.5 then
                    self._currentFPS = self._frameCount / elapsed
                    self._frameCount = 0
                    self._lastFPSTime = now

                    -- Store history
                    table.insert(self._fpsHistory, self._currentFPS)
                    if #self._fpsHistory > 60 then
                        table.remove(self._fpsHistory, 1)
                    end
                end
            end)
            table.insert(self._connections, fpsConnection)

            -- Update display
            local updateConnection = RunService.Heartbeat:Connect(function()
                self:_updateDisplay()
            end)
            table.insert(self._connections, updateConnection)

            -- Memory and ping (less frequent)
            local statsConnection
            statsConnection = task.spawn(function()
                while self._running do
                    -- Memory
                    self._currentMemory = collectgarbage("count") / 1024

                    -- Ping
                    local player = Players.LocalPlayer
                    if player then
                        local success, ping = pcall(function()
                            return player:GetNetworkPing()
                        end)
                        if success then
                            self._currentPing = ping * 1000
                        end
                    end

                    task.wait(1)
                end
            end)

            return self
        end

        --// Stop monitoring
        function PerformancePanel:Stop()
            self._running = false

            for _, connection in ipairs(self._connections) do
                if typeof(connection) == "RBXScriptConnection" then
                    connection:Disconnect()
                end
            end
            self._connections = {}

            return self
        end

        --// Update display
        function PerformancePanel:_updateDisplay()
            local fps = math.floor(self._currentFPS + 0.5)
            local fpsColor = self:_getFPSColor(fps)

            -- Update FPS
            if self._fpsValueLabel then
                self._fpsValueLabel.Text = tostring(fps)
                self._fpsValueLabel.TextColor3 = fpsColor
            end
            if self._fpsBar then
                self._fpsBar.Size = UDim2.new(math.min(fps / 60, 1), 0, 1, 0)
                self._fpsBar.BackgroundColor3 = fpsColor
            end

            -- Update status dot
            if self._statusDot then
                self._statusDot.BackgroundColor3 = fpsColor
            end

            -- Update memory
            if self._memValueLabel then
                self._memValueLabel.Text = string.format("%.0f MB", self._currentMemory)
            end
            if self._memBar then
                self._memBar.Size = UDim2.new(math.min(self._currentMemory / 500, 1), 0, 1, 0)
            end

            -- Update ping
            local ping = math.floor(self._currentPing + 0.5)
            local pingColor = ping > self.HighPingThreshold and self.LowFPSColor or 
                              ping > 80 and self.MediumFPSColor or Color3.fromRGB(59, 130, 246)

            if self._pingValueLabel then
                self._pingValueLabel.Text = ping .. " ms"
                self._pingValueLabel.TextColor3 = pingColor
            end
            if self._pingBar then
                self._pingBar.Size = UDim2.new(math.min(ping / 200, 1), 0, 1, 0)
                self._pingBar.BackgroundColor3 = pingColor
            end

            -- Update uptime
            if self._uptimeValueLabel then
                local uptime = os.clock() - self._startTime
                local mins = math.floor(uptime / 60)
                local secs = math.floor(uptime % 60)
                self._uptimeValueLabel.Text = string.format("%02d:%02d", mins, secs)
            end
        end

        --// Get stats
        function PerformancePanel:GetStats()
            return {
                FPS = math.floor(self._currentFPS + 0.5),
                Memory = self._currentMemory,
                Ping = math.floor(self._currentPing + 0.5),
                Uptime = os.clock() - self._startTime,
            }
        end

        --// Toggle visibility
        function PerformancePanel:Toggle()
            self.Instance.Visible = not self.Instance.Visible
            return self
        end

        --// Destroy
        function PerformancePanel:Destroy()
            self:Stop()

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return PerformancePanel


    end


    -- ============================================================================
    -- Module: NexusUI/Visualizers/init
    -- ============================================================================
    NexusUI_Modules["NexusUI/Visualizers/init"] = function()
        local script = CreateMockScript("NexusUI/Visualizers/init")

        --[[
            NexusUI Visualizers Module
            Charts, graphs, and data visualization components
        ]]

        --// Visualizers Module
        local Visualizers = {}

        Visualizers.LineChart = NexusRequire("NexusUI/Visualizers/LineChart")
        Visualizers.BarChart = NexusRequire("NexusUI/Visualizers/BarChart")
        Visualizers.PieChart = NexusRequire("NexusUI/Visualizers/PieChart")
        Visualizers.AreaChart = NexusRequire("NexusUI/Visualizers/AreaChart")
        Visualizers.RadarChart = NexusRequire("NexusUI/Visualizers/RadarChart")
        Visualizers.DonutChart = NexusRequire("NexusUI/Visualizers/DonutChart")
        Visualizers.Sparkline = NexusRequire("NexusUI/Visualizers/Sparkline")
        Visualizers.Gauge = NexusRequire("NexusUI/Visualizers/Gauge")
        Visualizers.Heatmap = NexusRequire("NexusUI/Visualizers/Heatmap")
        Visualizers.FPSGraph = NexusRequire("NexusUI/Visualizers/FPSGraph")
        Visualizers.MemoryGraph = NexusRequire("NexusUI/Visualizers/MemoryGraph")
        Visualizers.NetworkGraph = NexusRequire("NexusUI/Visualizers/NetworkGraph")
        Visualizers.PerformancePanel = NexusRequire("NexusUI/Visualizers/PerformancePanel")

        return Visualizers


    end


    -- ============================================================================
    -- Module: NexusUI/Special/Console
    -- ============================================================================
    NexusUI_Modules["NexusUI/Special/Console"] = function()
        local script = CreateMockScript("NexusUI/Special/Console")

        --[[
            NexusUI Console Component
            Developer console with command execution
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")
        local HttpService = game:GetService("HttpService")

        --// Console Module
        local Console = {}
        Console.__index = Console
        Console.ClassName = "Console"

        --// Log levels
        Console.Level = {
            Debug = 1,
            Info = 2,
            Warn = 3,
            Error = 4,
            Success = 5,
        }

        --// Level colors
        local LEVEL_COLORS = {
            [1] = Color3.fromRGB(113, 113, 122), -- Debug
            [2] = Color3.fromRGB(250, 250, 250), -- Info
            [3] = Color3.fromRGB(245, 158, 11), -- Warn
            [4] = Color3.fromRGB(239, 68, 68), -- Error
            [5] = Color3.fromRGB(34, 197, 94), -- Success
        }

        local LEVEL_PREFIXES = {
            [1] = "[DEBUG]",
            [2] = "[INFO]",
            [3] = "[WARN]",
            [4] = "[ERROR]",
            [5] = "[SUCCESS]",
        }

        --// Constructor
        function Console.new(config)
            local self = setmetatable({}, Console)

            config = config or {}

            self.Width = config.Width or 500
            self.Height = config.Height or 300
            self.MaxLines = config.MaxLines or 500
            self.ShowTimestamp = config.ShowTimestamp ~= false
            self.ShowLevel = config.ShowLevel ~= false
            self.AutoScroll = config.AutoScroll ~= false
            self.EnableInput = config.EnableInput ~= false
            self.FilterLevel = config.FilterLevel or Console.Level.Debug

            -- Colors
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(13, 13, 15)
            self.TextColor = config.TextColor or Color3.fromRGB(250, 250, 250)
            self.InputColor = config.InputColor or Color3.fromRGB(24, 24, 27)
            self.BorderColor = config.BorderColor or Color3.fromRGB(39, 39, 42)

            -- Callbacks
            self.OnCommand = config.OnCommand

            -- State
            self._logs = {}
            self._commandHistory = {}
            self._historyIndex = 0
            self._connections = {}

            return self
        end

        --// Create console
        function Console:Create(parent)
            local console = Instance.new("Frame")
            console.Name = "Console"
            console.Size = UDim2.new(0, self.Width, 0, self.Height)
            console.BackgroundColor3 = self.BackgroundColor
            console.BorderSizePixel = 0

            if parent then
                console.Parent = parent
            end

            self.Instance = console

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = console

            local stroke = Instance.new("UIStroke")
            stroke.Color = self.BorderColor
            stroke.Thickness = 1
            stroke.Parent = console

            -- Header
            local header = Instance.new("Frame")
            header.Size = UDim2.new(1, 0, 0, 32)
            header.BackgroundColor3 = Color3.fromRGB(18, 18, 21)
            header.BorderSizePixel = 0
            header.Parent = console

            local headerCorner = Instance.new("UICorner")
            headerCorner.CornerRadius = UDim.new(0, 8)
            headerCorner.Parent = header

            -- Fix bottom corners of header
            local headerFix = Instance.new("Frame")
            headerFix.Size = UDim2.new(1, 0, 0, 8)
            headerFix.Position = UDim2.new(0, 0, 1, -8)
            headerFix.BackgroundColor3 = Color3.fromRGB(18, 18, 21)
            headerFix.BorderSizePixel = 0
            headerFix.Parent = header

            local title = Instance.new("TextLabel")
            title.Size = UDim2.new(1, -80, 1, 0)
            title.Position = UDim2.new(0, 12, 0, 0)
            title.BackgroundTransparency = 1
            title.Font = Enum.Font.GothamMedium
            title.Text = "Console"
            title.TextColor3 = Color3.fromRGB(161, 161, 170)
            title.TextSize = 12
            title.TextXAlignment = Enum.TextXAlignment.Left
            title.Parent = header

            -- Clear button
            local clearBtn = Instance.new("TextButton")
            clearBtn.Size = UDim2.new(0, 50, 0, 22)
            clearBtn.Position = UDim2.new(1, -60, 0.5, 0)
            clearBtn.AnchorPoint = Vector2.new(0, 0.5)
            clearBtn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
            clearBtn.BorderSizePixel = 0
            clearBtn.Font = Enum.Font.GothamMedium
            clearBtn.Text = "Clear"
            clearBtn.TextColor3 = Color3.fromRGB(161, 161, 170)
            clearBtn.TextSize = 11
            clearBtn.AutoButtonColor = false
            clearBtn.Parent = header

            local clearBtnCorner = Instance.new("UICorner")
            clearBtnCorner.CornerRadius = UDim.new(0, 4)
            clearBtnCorner.Parent = clearBtn

            table.insert(self._connections, clearBtn.MouseButton1Click:Connect(function()
                self:Clear()
            end))

            -- Log area
            local logArea = Instance.new("ScrollingFrame")
            logArea.Name = "LogArea"
            logArea.Size = UDim2.new(1, -16, 1, self.EnableInput and -80 or -48)
            logArea.Position = UDim2.new(0, 8, 0, 40)
            logArea.BackgroundTransparency = 1
            logArea.BorderSizePixel = 0
            logArea.ScrollBarThickness = 4
            logArea.ScrollBarImageColor3 = Color3.fromRGB(63, 63, 70)
            logArea.CanvasSize = UDim2.new(0, 0, 0, 0)
            logArea.AutomaticCanvasSize = Enum.AutomaticSize.Y
            logArea.Parent = console
            self._logArea = logArea

            local logLayout = Instance.new("UIListLayout")
            logLayout.Padding = UDim.new(0, 2)
            logLayout.Parent = logArea

            -- Input area
            if self.EnableInput then
                local inputContainer = Instance.new("Frame")
                inputContainer.Size = UDim2.new(1, -16, 0, 32)
                inputContainer.Position = UDim2.new(0, 8, 1, -40)
                inputContainer.BackgroundColor3 = self.InputColor
                inputContainer.BorderSizePixel = 0
                inputContainer.Parent = console

                local inputCorner = Instance.new("UICorner")
                inputCorner.CornerRadius = UDim.new(0, 6)
                inputCorner.Parent = inputContainer

                local prefix = Instance.new("TextLabel")
                prefix.Size = UDim2.new(0, 20, 1, 0)
                prefix.Position = UDim2.new(0, 8, 0, 0)
                prefix.BackgroundTransparency = 1
                prefix.Font = Enum.Font.Code
                prefix.Text = ">"
                prefix.TextColor3 = Color3.fromRGB(99, 102, 241)
                prefix.TextSize = 14
                prefix.Parent = inputContainer

                local input = Instance.new("TextBox")
                input.Size = UDim2.new(1, -35, 1, 0)
                input.Position = UDim2.new(0, 28, 0, 0)
                input.BackgroundTransparency = 1
                input.Font = Enum.Font.Code
                input.PlaceholderText = "Enter command..."
                input.PlaceholderColor3 = Color3.fromRGB(82, 82, 91)
                input.Text = ""
                input.TextColor3 = self.TextColor
                input.TextSize = 13
                input.TextXAlignment = Enum.TextXAlignment.Left
                input.ClearTextOnFocus = false
                input.Parent = inputContainer
                self._input = input

                -- Input handling
                table.insert(self._connections, input.FocusLost:Connect(function(enterPressed)
                    if enterPressed and input.Text ~= "" then
                        self:ExecuteCommand(input.Text)
                        table.insert(self._commandHistory, input.Text)
                        self._historyIndex = #self._commandHistory + 1
                        input.Text = ""
                    end
                end))

                -- Command history navigation
                table.insert(self._connections, game:GetService("UserInputService").InputBegan:Connect(function(inputObj)
                    if not input:IsFocused() then return end

                    if inputObj.KeyCode == Enum.KeyCode.Up then
                        if self._historyIndex > 1 then
                            self._historyIndex = self._historyIndex - 1
                            input.Text = self._commandHistory[self._historyIndex] or ""
                        end
                    elseif inputObj.KeyCode == Enum.KeyCode.Down then
                        if self._historyIndex < #self._commandHistory then
                            self._historyIndex = self._historyIndex + 1
                            input.Text = self._commandHistory[self._historyIndex] or ""
                        elseif self._historyIndex == #self._commandHistory then
                            self._historyIndex = self._historyIndex + 1
                            input.Text = ""
                        end
                    end
                end))
            end

            return self
        end

        --// Log message
        function Console:Log(message, level)
            level = level or Console.Level.Info

            if level < self.FilterLevel then return self end

            local logEntry = {
                Message = message,
                Level = level,
                Timestamp = os.date("%H:%M:%S"),
                Time = os.clock(),
            }

            table.insert(self._logs, logEntry)

            -- Trim old logs
            while #self._logs > self.MaxLines do
                table.remove(self._logs, 1)
                -- Remove from display
                local firstChild = self._logArea:FindFirstChildOfClass("TextLabel")
                if firstChild then
                    firstChild:Destroy()
                end
            end

            -- Create log line
            local text = ""

            if self.ShowTimestamp then
                text = text .. "[" .. logEntry.Timestamp .. "] "
            end

            if self.ShowLevel then
                text = text .. LEVEL_PREFIXES[level] .. " "
            end

            text = text .. message

            local logLine = Instance.new("TextLabel")
            logLine.Size = UDim2.new(1, 0, 0, 0)
            logLine.AutomaticSize = Enum.AutomaticSize.Y
            logLine.BackgroundTransparency = 1
            logLine.Font = Enum.Font.Code
            logLine.Text = text
            logLine.TextColor3 = LEVEL_COLORS[level] or self.TextColor
            logLine.TextSize = 12
            logLine.TextXAlignment = Enum.TextXAlignment.Left
            logLine.TextWrapped = true
            logLine.RichText = true
            logLine.Parent = self._logArea

            -- Auto scroll
            if self.AutoScroll then
                self._logArea.CanvasPosition = Vector2.new(0, self._logArea.AbsoluteCanvasSize.Y)
            end

            return self
        end

        --// Convenience methods
        function Console:Debug(message)
            return self:Log(message, Console.Level.Debug)
        end

        function Console:Info(message)
            return self:Log(message, Console.Level.Info)
        end

        function Console:Warn(message)
            return self:Log(message, Console.Level.Warn)
        end

        function Console:Error(message)
            return self:Log(message, Console.Level.Error)
        end

        function Console:Success(message)
            return self:Log(message, Console.Level.Success)
        end

        --// Execute command
        function Console:ExecuteCommand(command)
            self:Log("> " .. command, Console.Level.Debug)

            if self.OnCommand then
                local success, result = pcall(self.OnCommand, command)
                if success then
                    if result then
                        self:Log(tostring(result), Console.Level.Info)
                    end
                else
                    self:Error("Command error: " .. tostring(result))
                end
            else
                -- Default: try to execute as Lua
                local func, err = loadstring(command)
                if func then
                    local success, result = pcall(func)
                    if success then
                        if result ~= nil then
                            self:Success(tostring(result))
                        else
                            self:Success("Executed successfully")
                        end
                    else
                        self:Error(tostring(result))
                    end
                else
                    self:Error("Syntax error: " .. tostring(err))
                end
            end

            return self
        end

        --// Clear console
        function Console:Clear()
            self._logs = {}

            for _, child in ipairs(self._logArea:GetChildren()) do
                if child:IsA("TextLabel") then
                    child:Destroy()
                end
            end

            return self
        end

        --// Set filter level
        function Console:SetFilterLevel(level)
            self.FilterLevel = level
            return self
        end

        --// Get logs
        function Console:GetLogs()
            return self._logs
        end

        --// Export logs
        function Console:Export()
            local text = ""
            for _, log in ipairs(self._logs) do
                text = text .. "[" .. log.Timestamp .. "] " .. LEVEL_PREFIXES[log.Level] .. " " .. log.Message .. "\n"
            end
            return text
        end

        --// Destroy
        function Console:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return Console


    end


    -- ============================================================================
    -- Module: NexusUI/Special/CodeEditor
    -- ============================================================================
    NexusUI_Modules["NexusUI/Special/CodeEditor"] = function()
        local script = CreateMockScript("NexusUI/Special/CodeEditor")

        --[[
            NexusUI Code Editor Component
            Syntax-highlighted code editor for scripts
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")
        local UserInputService = game:GetService("UserInputService")

        --// CodeEditor Module
        local CodeEditor = {}
        CodeEditor.__index = CodeEditor
        CodeEditor.ClassName = "CodeEditor"

        --// Syntax highlighting patterns (Lua/Luau)
        local KEYWORDS = {
            "and", "break", "do", "else", "elseif", "end", "false", "for", "function",
            "if", "in", "local", "nil", "not", "or", "repeat", "return", "then",
            "true", "until", "while", "continue", "export", "type", "typeof"
        }

        local BUILTINS = {
            "print", "warn", "error", "assert", "type", "typeof", "tostring", "tonumber",
            "pairs", "ipairs", "next", "select", "unpack", "pcall", "xpcall", "coroutine",
            "table", "string", "math", "os", "debug", "game", "workspace", "script",
            "wait", "delay", "spawn", "tick", "time", "Instance", "Vector2", "Vector3",
            "CFrame", "Color3", "BrickColor", "UDim", "UDim2", "Enum", "task", "require"
        }

        --// Syntax colors
        local SYNTAX_COLORS = {
            Keyword = Color3.fromRGB(198, 120, 221),
            Builtin = Color3.fromRGB(97, 175, 239),
            String = Color3.fromRGB(152, 195, 121),
            Number = Color3.fromRGB(209, 154, 102),
            Comment = Color3.fromRGB(92, 99, 112),
            Operator = Color3.fromRGB(86, 182, 194),
            Normal = Color3.fromRGB(171, 178, 191),
        }

        --// Constructor
        function CodeEditor.new(config)
            local self = setmetatable({}, CodeEditor)

            config = config or {}

            self.Width = config.Width or 500
            self.Height = config.Height or 350
            self.ShowLineNumbers = config.ShowLineNumbers ~= false
            self.TabSize = config.TabSize or 4
            self.FontSize = config.FontSize or 13
            self.SyntaxHighlight = config.SyntaxHighlight ~= false
            self.ReadOnly = config.ReadOnly or false

            -- Colors
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(30, 30, 35)
            self.GutterColor = config.GutterColor or Color3.fromRGB(24, 24, 27)
            self.TextColor = config.TextColor or SYNTAX_COLORS.Normal
            self.LineNumberColor = config.LineNumberColor or Color3.fromRGB(82, 82, 91)
            self.SelectionColor = config.SelectionColor or Color3.fromRGB(99, 102, 241)
            self.CursorColor = config.CursorColor or Color3.fromRGB(250, 250, 250)

            -- Callbacks
            self.OnChange = config.OnChange
            self.OnExecute = config.OnExecute -- Ctrl+Enter

            -- State
            self._text = config.Text or ""
            self._cursorPos = 0
            self._selectionStart = nil
            self._lines = {}
            self._connections = {}

            return self
        end

        --// Create editor
        function CodeEditor:Create(parent)
            local editor = Instance.new("Frame")
            editor.Name = "CodeEditor"
            editor.Size = UDim2.new(0, self.Width, 0, self.Height)
            editor.BackgroundColor3 = self.BackgroundColor
            editor.BorderSizePixel = 0

            if parent then
                editor.Parent = parent
            end

            self.Instance = editor

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = editor

            -- Header
            local header = Instance.new("Frame")
            header.Size = UDim2.new(1, 0, 0, 36)
            header.BackgroundColor3 = self.GutterColor
            header.BorderSizePixel = 0
            header.Parent = editor

            local headerCorner = Instance.new("UICorner")
            headerCorner.CornerRadius = UDim.new(0, 8)
            headerCorner.Parent = header

            local headerFix = Instance.new("Frame")
            headerFix.Size = UDim2.new(1, 0, 0, 8)
            headerFix.Position = UDim2.new(0, 0, 1, -8)
            headerFix.BackgroundColor3 = self.GutterColor
            headerFix.BorderSizePixel = 0
            headerFix.Parent = header

            -- Title
            local title = Instance.new("TextLabel")
            title.Size = UDim2.new(0, 150, 1, 0)
            title.Position = UDim2.new(0, 12, 0, 0)
            title.BackgroundTransparency = 1
            title.Font = Enum.Font.GothamMedium
            title.Text = "Script Editor"
            title.TextColor3 = Color3.fromRGB(161, 161, 170)
            title.TextSize = 12
            title.TextXAlignment = Enum.TextXAlignment.Left
            title.Parent = header

            -- Action buttons
            local actionsContainer = Instance.new("Frame")
            actionsContainer.Size = UDim2.new(0, 160, 0, 24)
            actionsContainer.Position = UDim2.new(1, -170, 0.5, 0)
            actionsContainer.AnchorPoint = Vector2.new(0, 0.5)
            actionsContainer.BackgroundTransparency = 1
            actionsContainer.Parent = header

            local actionsLayout = Instance.new("UIListLayout")
            actionsLayout.FillDirection = Enum.FillDirection.Horizontal
            actionsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
            actionsLayout.Padding = UDim.new(0, 8)
            actionsLayout.Parent = actionsContainer

            -- Clear button
            local clearBtn = self:_createButton("Clear", actionsContainer, function()
                self:SetText("")
            end)

            -- Execute button
            local executeBtn = self:_createButton("Execute", actionsContainer, function()
                self:Execute()
            end, Color3.fromRGB(34, 197, 94))

            -- Editor area
            local editorArea = Instance.new("Frame")
            editorArea.Size = UDim2.new(1, 0, 1, -36)
            editorArea.Position = UDim2.new(0, 0, 0, 36)
            editorArea.BackgroundTransparency = 1
            editorArea.ClipsDescendants = true
            editorArea.Parent = editor

            -- Line numbers gutter
            if self.ShowLineNumbers then
                local gutter = Instance.new("Frame")
                gutter.Name = "Gutter"
                gutter.Size = UDim2.new(0, 45, 1, 0)
                gutter.BackgroundColor3 = self.GutterColor
                gutter.BorderSizePixel = 0
                gutter.Parent = editorArea
                self._gutter = gutter

                local gutterScroll = Instance.new("ScrollingFrame")
                gutterScroll.Size = UDim2.new(1, 0, 1, 0)
                gutterScroll.BackgroundTransparency = 1
                gutterScroll.BorderSizePixel = 0
                gutterScroll.ScrollBarThickness = 0
                gutterScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
                gutterScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
                gutterScroll.ScrollingEnabled = false
                gutterScroll.Parent = gutter
                self._gutterScroll = gutterScroll

                local gutterLayout = Instance.new("UIListLayout")
                gutterLayout.Parent = gutterScroll

                local gutterPadding = Instance.new("UIPadding")
                gutterPadding.PaddingTop = UDim.new(0, 8)
                gutterPadding.Parent = gutterScroll
            end

            -- Code scroll area
            local codeScroll = Instance.new("ScrollingFrame")
            codeScroll.Name = "CodeArea"
            codeScroll.Size = UDim2.new(1, self.ShowLineNumbers and -45 or 0, 1, 0)
            codeScroll.Position = UDim2.new(0, self.ShowLineNumbers and 45 or 0, 0, 0)
            codeScroll.BackgroundTransparency = 1
            codeScroll.BorderSizePixel = 0
            codeScroll.ScrollBarThickness = 6
            codeScroll.ScrollBarImageColor3 = Color3.fromRGB(63, 63, 70)
            codeScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
            codeScroll.AutomaticCanvasSize = Enum.AutomaticSize.XY
            codeScroll.Parent = editorArea
            self._codeScroll = codeScroll

            local codePadding = Instance.new("UIPadding")
            codePadding.PaddingTop = UDim.new(0, 8)
            codePadding.PaddingLeft = UDim.new(0, 8)
            codePadding.PaddingRight = UDim.new(0, 8)
            codePadding.PaddingBottom = UDim.new(0, 8)
            codePadding.Parent = codeScroll

            -- Text input
            local codeInput = Instance.new("TextBox")
            codeInput.Name = "CodeInput"
            codeInput.Size = UDim2.new(1, 0, 0, 0)
            codeInput.AutomaticSize = Enum.AutomaticSize.Y
            codeInput.BackgroundTransparency = 1
            codeInput.Font = Enum.Font.Code
            codeInput.Text = self._text
            codeInput.TextColor3 = self.TextColor
            codeInput.TextSize = self.FontSize
            codeInput.TextXAlignment = Enum.TextXAlignment.Left
            codeInput.TextYAlignment = Enum.TextYAlignment.Top
            codeInput.MultiLine = true
            codeInput.ClearTextOnFocus = false
            codeInput.TextEditable = not self.ReadOnly
            codeInput.TextWrapped = false
            codeInput.Parent = codeScroll
            self._codeInput = codeInput

            -- Sync scrolling with gutter
            if self._gutterScroll then
                table.insert(self._connections, codeScroll:GetPropertyChangedSignal("CanvasPosition"):Connect(function()
                    self._gutterScroll.CanvasPosition = Vector2.new(0, codeScroll.CanvasPosition.Y)
                end))
            end

            -- Text change handling
            table.insert(self._connections, codeInput:GetPropertyChangedSignal("Text"):Connect(function()
                self._text = codeInput.Text
                self:_updateLineNumbers()

                if self.OnChange then
                    self.OnChange(self._text)
                end
            end))

            -- Keyboard shortcuts
            table.insert(self._connections, UserInputService.InputBegan:Connect(function(input, processed)
                if not codeInput:IsFocused() then return end

                if input.KeyCode == Enum.KeyCode.Return and UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
                    self:Execute()
                elseif input.KeyCode == Enum.KeyCode.Tab then
                    -- Insert tab
                    local cursorPos = codeInput.CursorPosition
                    local text = codeInput.Text
                    local tab = string.rep(" ", self.TabSize)
                    codeInput.Text = text:sub(1, cursorPos - 1) .. tab .. text:sub(cursorPos)
                    codeInput.CursorPosition = cursorPos + self.TabSize
                end
            end))

            -- Initial line numbers
            self:_updateLineNumbers()

            return self
        end

        --// Create button helper
        function CodeEditor:_createButton(text, parent, callback, color)
            local btn = Instance.new("TextButton")
            btn.Size = UDim2.new(0, 60, 1, 0)
            btn.BackgroundColor3 = color or Color3.fromRGB(39, 39, 42)
            btn.BorderSizePixel = 0
            btn.Font = Enum.Font.GothamMedium
            btn.Text = text
            btn.TextColor3 = Color3.fromRGB(250, 250, 250)
            btn.TextSize = 11
            btn.AutoButtonColor = false
            btn.Parent = parent

            local btnCorner = Instance.new("UICorner")
            btnCorner.CornerRadius = UDim.new(0, 4)
            btnCorner.Parent = btn

            table.insert(self._connections, btn.MouseButton1Click:Connect(callback))

            table.insert(self._connections, btn.MouseEnter:Connect(function()
                TweenService:Create(btn, TweenInfo.new(0.1), {
                    BackgroundTransparency = 0.2,
                }):Play()
            end))

            table.insert(self._connections, btn.MouseLeave:Connect(function()
                TweenService:Create(btn, TweenInfo.new(0.1), {
                    BackgroundTransparency = 0,
                }):Play()
            end))

            return btn
        end

        --// Update line numbers
        function CodeEditor:_updateLineNumbers()
            if not self._gutterScroll then return end

            -- Clear existing
            for _, child in ipairs(self._gutterScroll:GetChildren()) do
                if child:IsA("TextLabel") then
                    child:Destroy()
                end
            end

            -- Count lines
            local lineCount = 1
            for _ in self._text:gmatch("\n") do
                lineCount = lineCount + 1
            end

            -- Create line numbers
            for i = 1, lineCount do
                local lineNum = Instance.new("TextLabel")
                lineNum.Size = UDim2.new(1, -8, 0, self.FontSize + 4)
                lineNum.BackgroundTransparency = 1
                lineNum.Font = Enum.Font.Code
                lineNum.Text = tostring(i)
                lineNum.TextColor3 = self.LineNumberColor
                lineNum.TextSize = self.FontSize
                lineNum.TextXAlignment = Enum.TextXAlignment.Right
                lineNum.Parent = self._gutterScroll
            end
        end

        --// Set text
        function CodeEditor:SetText(text)
            self._text = text
            if self._codeInput then
                self._codeInput.Text = text
            end
            self:_updateLineNumbers()
            return self
        end

        --// Get text
        function CodeEditor:GetText()
            return self._text
        end

        --// Execute code
        function CodeEditor:Execute()
            if self.OnExecute then
                self.OnExecute(self._text)
            else
                -- Default execution
                local func, err = loadstring(self._text)
                if func then
                    local success, result = pcall(func)
                    if not success then
                        warn("[CodeEditor] Runtime error:", result)
                    end
                else
                    warn("[CodeEditor] Syntax error:", err)
                end
            end
            return self
        end

        --// Destroy
        function CodeEditor:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return CodeEditor


    end


    -- ============================================================================
    -- Module: NexusUI/Special/Terminal
    -- ============================================================================
    NexusUI_Modules["NexusUI/Special/Terminal"] = function()
        local script = CreateMockScript("NexusUI/Special/Terminal")

        --[[
            NexusUI Terminal Component
            Command-line style terminal interface
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Terminal Module
        local Terminal = {}
        Terminal.__index = Terminal
        Terminal.ClassName = "Terminal"

        --// Constructor
        function Terminal.new(config)
            local self = setmetatable({}, Terminal)

            config = config or {}

            self.Width = config.Width or 500
            self.Height = config.Height or 300
            self.MaxLines = config.MaxLines or 1000
            self.Prompt = config.Prompt or ">"
            self.Title = config.Title or "Terminal"

            -- Colors
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(0, 0, 0)
            self.TextColor = config.TextColor or Color3.fromRGB(0, 255, 0)
            self.PromptColor = config.PromptColor or Color3.fromRGB(0, 200, 255)
            self.ErrorColor = config.ErrorColor or Color3.fromRGB(255, 80, 80)

            -- Commands
            self.Commands = config.Commands or {}

            -- Callbacks
            self.OnCommand = config.OnCommand

            -- State
            self._history = {}
            self._historyIndex = 0
            self._output = {}
            self._connections = {}

            return self
        end

        --// Create terminal
        function Terminal:Create(parent)
            local terminal = Instance.new("Frame")
            terminal.Name = "Terminal"
            terminal.Size = UDim2.new(0, self.Width, 0, self.Height)
            terminal.BackgroundColor3 = self.BackgroundColor
            terminal.BorderSizePixel = 0

            if parent then
                terminal.Parent = parent
            end

            self.Instance = terminal

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = terminal

            -- Title bar
            local titleBar = Instance.new("Frame")
            titleBar.Size = UDim2.new(1, 0, 0, 28)
            titleBar.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            titleBar.BorderSizePixel = 0
            titleBar.Parent = terminal

            local titleCorner = Instance.new("UICorner")
            titleCorner.CornerRadius = UDim.new(0, 8)
            titleCorner.Parent = titleBar

            local titleFix = Instance.new("Frame")
            titleFix.Size = UDim2.new(1, 0, 0, 8)
            titleFix.Position = UDim2.new(0, 0, 1, -8)
            titleFix.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            titleFix.BorderSizePixel = 0
            titleFix.Parent = titleBar

            -- Window controls (decorative)
            local controls = Instance.new("Frame")
            controls.Size = UDim2.new(0, 60, 0, 12)
            controls.Position = UDim2.new(0, 10, 0.5, 0)
            controls.AnchorPoint = Vector2.new(0, 0.5)
            controls.BackgroundTransparency = 1
            controls.Parent = titleBar

            local controlsLayout = Instance.new("UIListLayout")
            controlsLayout.FillDirection = Enum.FillDirection.Horizontal
            controlsLayout.Padding = UDim.new(0, 6)
            controlsLayout.Parent = controls

            for _, color in ipairs({Color3.fromRGB(255, 96, 92), Color3.fromRGB(255, 189, 68), Color3.fromRGB(39, 201, 63)}) do
                local dot = Instance.new("Frame")
                dot.Size = UDim2.new(0, 12, 0, 12)
                dot.BackgroundColor3 = color
                dot.BorderSizePixel = 0
                dot.Parent = controls

                local dotCorner = Instance.new("UICorner")
                dotCorner.CornerRadius = UDim.new(1, 0)
                dotCorner.Parent = dot
            end

            -- Title text
            local title = Instance.new("TextLabel")
            title.Size = UDim2.new(1, 0, 1, 0)
            title.BackgroundTransparency = 1
            title.Font = Enum.Font.GothamMedium
            title.Text = self.Title
            title.TextColor3 = Color3.fromRGB(150, 150, 150)
            title.TextSize = 12
            title.Parent = titleBar

            -- Output area
            local outputArea = Instance.new("ScrollingFrame")
            outputArea.Name = "Output"
            outputArea.Size = UDim2.new(1, -20, 1, -68)
            outputArea.Position = UDim2.new(0, 10, 0, 32)
            outputArea.BackgroundTransparency = 1
            outputArea.BorderSizePixel = 0
            outputArea.ScrollBarThickness = 4
            outputArea.ScrollBarImageColor3 = Color3.fromRGB(60, 60, 60)
            outputArea.CanvasSize = UDim2.new(0, 0, 0, 0)
            outputArea.AutomaticCanvasSize = Enum.AutomaticSize.Y
            outputArea.Parent = terminal
            self._outputArea = outputArea

            local outputLayout = Instance.new("UIListLayout")
            outputLayout.Padding = UDim.new(0, 2)
            outputLayout.Parent = outputArea

            -- Input area
            local inputContainer = Instance.new("Frame")
            inputContainer.Size = UDim2.new(1, -20, 0, 24)
            inputContainer.Position = UDim2.new(0, 10, 1, -32)
            inputContainer.BackgroundTransparency = 1
            inputContainer.Parent = terminal

            local promptLabel = Instance.new("TextLabel")
            promptLabel.Size = UDim2.new(0, 15, 1, 0)
            promptLabel.BackgroundTransparency = 1
            promptLabel.Font = Enum.Font.Code
            promptLabel.Text = self.Prompt
            promptLabel.TextColor3 = self.PromptColor
            promptLabel.TextSize = 14
            promptLabel.TextXAlignment = Enum.TextXAlignment.Left
            promptLabel.Parent = inputContainer

            local input = Instance.new("TextBox")
            input.Size = UDim2.new(1, -20, 1, 0)
            input.Position = UDim2.new(0, 20, 0, 0)
            input.BackgroundTransparency = 1
            input.Font = Enum.Font.Code
            input.PlaceholderText = ""
            input.Text = ""
            input.TextColor3 = self.TextColor
            input.TextSize = 14
            input.TextXAlignment = Enum.TextXAlignment.Left
            input.ClearTextOnFocus = false
            input.Parent = inputContainer
            self._input = input

            -- Blinking cursor effect
            local cursor = Instance.new("Frame")
            cursor.Size = UDim2.new(0, 8, 0, 14)
            cursor.Position = UDim2.new(0, 20, 0.5, 0)
            cursor.AnchorPoint = Vector2.new(0, 0.5)
            cursor.BackgroundColor3 = self.TextColor
            cursor.BorderSizePixel = 0
            cursor.Parent = inputContainer
            self._cursor = cursor

            task.spawn(function()
                while self._cursor and self._cursor.Parent do
                    self._cursor.Visible = not self._cursor.Visible
                    task.wait(0.5)
                end
            end)

            -- Input handling
            table.insert(self._connections, input.FocusLost:Connect(function(enterPressed)
                if enterPressed and input.Text ~= "" then
                    local cmd = input.Text
                    self:WriteLine(self.Prompt .. " " .. cmd, self.TextColor)
                    self:ExecuteCommand(cmd)
                    table.insert(self._history, cmd)
                    self._historyIndex = #self._history + 1
                    input.Text = ""
                end
            end))

            -- History navigation
            table.insert(self._connections, game:GetService("UserInputService").InputBegan:Connect(function(inputObj)
                if not input:IsFocused() then return end

                if inputObj.KeyCode == Enum.KeyCode.Up then
                    if self._historyIndex > 1 then
                        self._historyIndex = self._historyIndex - 1
                        input.Text = self._history[self._historyIndex] or ""
                    end
                elseif inputObj.KeyCode == Enum.KeyCode.Down then
                    if self._historyIndex < #self._history then
                        self._historyIndex = self._historyIndex + 1
                        input.Text = self._history[self._historyIndex] or ""
                    elseif self._historyIndex == #self._history then
                        self._historyIndex = self._historyIndex + 1
                        input.Text = ""
                    end
                end
            end))

            -- Welcome message
            self:WriteLine("NexusUI Terminal v1.0", Color3.fromRGB(100, 200, 255))
            self:WriteLine("Type 'help' for available commands", Color3.fromRGB(150, 150, 150))
            self:WriteLine("")

            return self
        end

        --// Write line to output
        function Terminal:WriteLine(text, color)
            color = color or self.TextColor

            local line = Instance.new("TextLabel")
            line.Size = UDim2.new(1, 0, 0, 0)
            line.AutomaticSize = Enum.AutomaticSize.Y
            line.BackgroundTransparency = 1
            line.Font = Enum.Font.Code
            line.Text = text
            line.TextColor3 = color
            line.TextSize = 13
            line.TextXAlignment = Enum.TextXAlignment.Left
            line.TextWrapped = true
            line.RichText = true
            line.Parent = self._outputArea

            table.insert(self._output, line)

            -- Trim old lines
            while #self._output > self.MaxLines do
                local oldLine = table.remove(self._output, 1)
                oldLine:Destroy()
            end

            -- Auto scroll
            self._outputArea.CanvasPosition = Vector2.new(0, self._outputArea.AbsoluteCanvasSize.Y)

            return self
        end

        --// Write error
        function Terminal:WriteError(text)
            return self:WriteLine("Error: " .. text, self.ErrorColor)
        end

        --// Execute command
        function Terminal:ExecuteCommand(command)
            local parts = {}
            for part in command:gmatch("%S+") do
                table.insert(parts, part)
            end

            local cmd = parts[1]
            local args = {unpack(parts, 2)}

            -- Check custom commands
            if self.Commands[cmd] then
                local success, err = pcall(self.Commands[cmd], self, unpack(args))
                if not success then
                    self:WriteError(tostring(err))
                end
                return self
            end

            -- Built-in commands
            if cmd == "help" then
                self:WriteLine("Available commands:", Color3.fromRGB(150, 150, 150))
                self:WriteLine("  help     - Show this message")
                self:WriteLine("  clear    - Clear terminal")
                self:WriteLine("  echo     - Print message")
                self:WriteLine("  run      - Execute Lua code")
                for name, _ in pairs(self.Commands) do
                    self:WriteLine("  " .. name)
                end
            elseif cmd == "clear" then
                self:Clear()
            elseif cmd == "echo" then
                self:WriteLine(table.concat(args, " "))
            elseif cmd == "run" then
                local code = table.concat(args, " ")
                local func, err = loadstring(code)
                if func then
                    local success, result = pcall(func)
                    if success then
                        if result ~= nil then
                            self:WriteLine(tostring(result))
                        end
                    else
                        self:WriteError(tostring(result))
                    end
                else
                    self:WriteError(tostring(err))
                end
            else
                -- Custom callback
                if self.OnCommand then
                    local success, result = pcall(self.OnCommand, cmd, args)
                    if success and result then
                        self:WriteLine(tostring(result))
                    elseif not success then
                        self:WriteError(tostring(result))
                    else
                        self:WriteError("Unknown command: " .. cmd)
                    end
                else
                    self:WriteError("Unknown command: " .. cmd)
                end
            end

            return self
        end

        --// Clear terminal
        function Terminal:Clear()
            for _, line in ipairs(self._output) do
                line:Destroy()
            end
            self._output = {}
            return self
        end

        --// Register command
        function Terminal:RegisterCommand(name, callback)
            self.Commands[name] = callback
            return self
        end

        --// Destroy
        function Terminal:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return Terminal


    end


    -- ============================================================================
    -- Module: NexusUI/Special/ESP
    -- ============================================================================
    NexusUI_Modules["NexusUI/Special/ESP"] = function()
        local script = CreateMockScript("NexusUI/Special/ESP")

        --[[
            NexusUI ESP Component
            Player/entity ESP (Extra Sensory Perception) overlay
        ]]

        --// Services
        local RunService = game:GetService("RunService")
        local Players = game:GetService("Players")
        local Workspace = game:GetService("Workspace")

        --// ESP Module
        local ESP = {}
        ESP.__index = ESP
        ESP.ClassName = "ESP"

        --// Constructor
        function ESP.new(config)
            local self = setmetatable({}, ESP)

            config = config or {}

            self.Enabled = config.Enabled or false
            self.ShowBox = config.ShowBox ~= false
            self.ShowName = config.ShowName ~= false
            self.ShowHealth = config.ShowHealth or false
            self.ShowDistance = config.ShowDistance or false
            self.ShowTracers = config.ShowTracers or false
            self.ShowSkeleton = config.ShowSkeleton or false
            self.TeamCheck = config.TeamCheck or false
            self.MaxDistance = config.MaxDistance or 1000

            -- Colors
            self.BoxColor = config.BoxColor or Color3.fromRGB(255, 255, 255)
            self.NameColor = config.NameColor or Color3.fromRGB(255, 255, 255)
            self.HealthColor = config.HealthColor or Color3.fromRGB(0, 255, 0)
            self.DistanceColor = config.DistanceColor or Color3.fromRGB(200, 200, 200)
            self.TracerColor = config.TracerColor or Color3.fromRGB(255, 255, 255)
            self.TeamColor = config.TeamColor or nil -- Use team color if available
            self.EnemyColor = config.EnemyColor or Color3.fromRGB(255, 50, 50)
            self.FriendlyColor = config.FriendlyColor or Color3.fromRGB(50, 255, 50)

            -- State
            self._drawings = {}
            self._connections = {}
            self._running = false

            return self
        end

        --// Create ESP instance
        function ESP:Create(parent)
            -- ESP uses Drawing library for Roblox executors
            -- This is a fallback using frames for non-executor environments

            local container = Instance.new("Frame")
            container.Name = "ESPContainer"
            container.Size = UDim2.new(1, 0, 1, 0)
            container.BackgroundTransparency = 1
            container.Parent = parent

            self.Instance = container

            return self
        end

        --// Check if player is on same team
        function ESP:_isFriendly(player)
            local localPlayer = Players.LocalPlayer
            if not localPlayer or not self.TeamCheck then return false end

            return player.Team and localPlayer.Team and player.Team == localPlayer.Team
        end

        --// Get screen position from world position
        function ESP:_worldToScreen(position)
            local camera = Workspace.CurrentCamera
            if not camera then return nil, false end

            local screenPos, onScreen = camera:WorldToViewportPoint(position)
            return Vector2.new(screenPos.X, screenPos.Y), onScreen
        end

        --// Create or update player ESP
        function ESP:_updatePlayerESP(player)
            local character = player.Character
            if not character then return end

            local humanoid = character:FindFirstChild("Humanoid")
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            local head = character:FindFirstChild("Head")

            if not humanoid or not rootPart or not head then return end
            if humanoid.Health <= 0 then return end

            local localPlayer = Players.LocalPlayer
            if player == localPlayer then return end

            -- Distance check
            local localCharacter = localPlayer and localPlayer.Character
            local localRoot = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")

            local distance = 0
            if localRoot then
                distance = (rootPart.Position - localRoot.Position).Magnitude
                if distance > self.MaxDistance then
                    self:_hidePlayerESP(player)
                    return
                end
            end

            -- Team check
            local isFriendly = self:_isFriendly(player)
            if self.TeamCheck and isFriendly then
                self:_hidePlayerESP(player)
                return
            end

            -- Get ESP color
            local espColor = self.BoxColor
            if self.TeamColor and player.Team then
                espColor = player.TeamColor.Color
            elseif isFriendly then
                espColor = self.FriendlyColor
            else
                espColor = self.EnemyColor
            end

            -- Get screen positions
            local rootScreen, rootOnScreen = self:_worldToScreen(rootPart.Position)
            local headScreen, headOnScreen = self:_worldToScreen(head.Position + Vector3.new(0, 1, 0))

            if not rootOnScreen and not headOnScreen then
                self:_hidePlayerESP(player)
                return
            end

            -- Create/update drawings
            local drawings = self._drawings[player.UserId]
            if not drawings then
                drawings = self:_createPlayerDrawings(player)
                self._drawings[player.UserId] = drawings
            end

            -- Update box
            if self.ShowBox and drawings.box then
                local boxHeight = math.abs(headScreen.Y - rootScreen.Y) + 20
                local boxWidth = boxHeight * 0.6

                drawings.box.Visible = true
                drawings.box.Position = UDim2.new(0, rootScreen.X - boxWidth/2, 0, headScreen.Y - 10)
                drawings.box.Size = UDim2.new(0, boxWidth, 0, boxHeight)

                if drawings.boxStroke then
                    drawings.boxStroke.Color = espColor
                end
            end

            -- Update name
            if self.ShowName and drawings.name then
                drawings.name.Visible = true
                drawings.name.Position = UDim2.new(0, rootScreen.X, 0, headScreen.Y - 25)
                drawings.name.Text = player.DisplayName
                drawings.name.TextColor3 = self.NameColor
            end

            -- Update health
            if self.ShowHealth and drawings.health then
                local healthPercent = humanoid.Health / humanoid.MaxHealth

                drawings.health.Visible = true
                drawings.healthBar.Visible = true

                local boxHeight = math.abs(headScreen.Y - rootScreen.Y) + 20
                local boxWidth = boxHeight * 0.6

                drawings.health.Position = UDim2.new(0, rootScreen.X - boxWidth/2 - 6, 0, headScreen.Y - 10)
                drawings.health.Size = UDim2.new(0, 4, 0, boxHeight)

                drawings.healthBar.Size = UDim2.new(1, 0, healthPercent, 0)
                drawings.healthBar.Position = UDim2.new(0, 0, 1 - healthPercent, 0)
                drawings.healthBar.BackgroundColor3 = Color3.fromRGB(
                    255 * (1 - healthPercent),
                    255 * healthPercent,
                    0
                )
            end

            -- Update distance
            if self.ShowDistance and drawings.distance then
                drawings.distance.Visible = true
                drawings.distance.Position = UDim2.new(0, rootScreen.X, 0, rootScreen.Y + 5)
                drawings.distance.Text = string.format("[%dm]", math.floor(distance))
                drawings.distance.TextColor3 = self.DistanceColor
            end

            -- Update tracer
            if self.ShowTracers and drawings.tracer then
                local camera = Workspace.CurrentCamera
                local viewportSize = camera.ViewportSize

                drawings.tracer.Visible = true
                drawings.tracer.Position = UDim2.new(0, viewportSize.X / 2, 0, viewportSize.Y)
                -- Tracer line would connect to player position
            end
        end

        --// Create player drawings
        function ESP:_createPlayerDrawings(player)
            local drawings = {}

            -- Box
            if self.ShowBox then
                local box = Instance.new("Frame")
                box.Name = "Box"
                box.BackgroundTransparency = 1
                box.BorderSizePixel = 0
                box.Visible = false
                box.Parent = self.Instance

                local stroke = Instance.new("UIStroke")
                stroke.Color = self.BoxColor
                stroke.Thickness = 1
                stroke.Parent = box

                drawings.box = box
                drawings.boxStroke = stroke
            end

            -- Name
            if self.ShowName then
                local name = Instance.new("TextLabel")
                name.Name = "Name"
                name.BackgroundTransparency = 1
                name.Font = Enum.Font.GothamMedium
                name.TextSize = 13
                name.TextStrokeTransparency = 0.5
                name.AnchorPoint = Vector2.new(0.5, 1)
                name.Visible = false
                name.Parent = self.Instance

                drawings.name = name
            end

            -- Health bar
            if self.ShowHealth then
                local health = Instance.new("Frame")
                health.Name = "HealthBg"
                health.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
                health.BorderSizePixel = 0
                health.Visible = false
                health.Parent = self.Instance

                local healthCorner = Instance.new("UICorner")
                healthCorner.CornerRadius = UDim.new(0, 2)
                healthCorner.Parent = health

                local healthBar = Instance.new("Frame")
                healthBar.Name = "HealthBar"
                healthBar.BackgroundColor3 = self.HealthColor
                healthBar.BorderSizePixel = 0
                healthBar.AnchorPoint = Vector2.new(0, 1)
                healthBar.Parent = health

                local healthBarCorner = Instance.new("UICorner")
                healthBarCorner.CornerRadius = UDim.new(0, 2)
                healthBarCorner.Parent = healthBar

                drawings.health = health
                drawings.healthBar = healthBar
            end

            -- Distance
            if self.ShowDistance then
                local distance = Instance.new("TextLabel")
                distance.Name = "Distance"
                distance.BackgroundTransparency = 1
                distance.Font = Enum.Font.Gotham
                distance.TextSize = 11
                distance.TextStrokeTransparency = 0.5
                distance.AnchorPoint = Vector2.new(0.5, 0)
                distance.Visible = false
                distance.Parent = self.Instance

                drawings.distance = distance
            end

            return drawings
        end

        --// Hide player ESP
        function ESP:_hidePlayerESP(player)
            local drawings = self._drawings[player.UserId]
            if not drawings then return end

            for _, drawing in pairs(drawings) do
                if typeof(drawing) == "Instance" then
                    drawing.Visible = false
                end
            end
        end

        --// Remove player ESP
        function ESP:_removePlayerESP(player)
            local drawings = self._drawings[player.UserId]
            if not drawings then return end

            for _, drawing in pairs(drawings) do
                if typeof(drawing) == "Instance" then
                    drawing:Destroy()
                end
            end

            self._drawings[player.UserId] = nil
        end

        --// Start ESP
        function ESP:Start()
            if self._running then return self end
            self._running = true
            self.Enabled = true

            -- Update loop
            local updateConnection = RunService.RenderStepped:Connect(function()
                if not self.Enabled then return end

                for _, player in ipairs(Players:GetPlayers()) do
                    self:_updatePlayerESP(player)
                end
            end)
            table.insert(self._connections, updateConnection)

            -- Player added/removed
            table.insert(self._connections, Players.PlayerAdded:Connect(function(player)
                -- Will be handled by update loop
            end))

            table.insert(self._connections, Players.PlayerRemoving:Connect(function(player)
                self:_removePlayerESP(player)
            end))

            return self
        end

        --// Stop ESP
        function ESP:Stop()
            self._running = false
            self.Enabled = false

            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            -- Hide all drawings
            for _, player in ipairs(Players:GetPlayers()) do
                self:_hidePlayerESP(player)
            end

            return self
        end

        --// Toggle
        function ESP:Toggle()
            if self.Enabled then
                self:Stop()
            else
                self:Start()
            end
            return self
        end

        --// Set option
        function ESP:SetOption(option, value)
            self[option] = value
            return self
        end

        --// Destroy
        function ESP:Destroy()
            self:Stop()

            for userId, drawings in pairs(self._drawings) do
                for _, drawing in pairs(drawings) do
                    if typeof(drawing) == "Instance" then
                        drawing:Destroy()
                    end
                end
            end
            self._drawings = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return ESP


    end


    -- ============================================================================
    -- Module: NexusUI/Special/Watermark
    -- ============================================================================
    NexusUI_Modules["NexusUI/Special/Watermark"] = function()
        local script = CreateMockScript("NexusUI/Special/Watermark")

        --[[
            NexusUI Watermark Component
            Customizable watermark/branding display
        ]]

        --// Services
        local RunService = game:GetService("RunService")
        local Players = game:GetService("Players")
        local TweenService = game:GetService("TweenService")

        --// Watermark Module
        local Watermark = {}
        Watermark.__index = Watermark
        Watermark.ClassName = "Watermark"

        --// Constructor
        function Watermark.new(config)
            local self = setmetatable({}, Watermark)

            config = config or {}

            self.Title = config.Title or "NexusUI"
            self.Subtitle = config.Subtitle or nil
            self.ShowFPS = config.ShowFPS or false
            self.ShowPing = config.ShowPing or false
            self.ShowTime = config.ShowTime or false
            self.ShowUsername = config.ShowUsername or false
            self.Position = config.Position or "TopRight" -- TopRight, TopLeft, BottomRight, BottomLeft
            self.Draggable = config.Draggable or false

            -- Colors
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(18, 18, 21)
            self.TextColor = config.TextColor or Color3.fromRGB(250, 250, 250)
            self.AccentColor = config.AccentColor or Color3.fromRGB(99, 102, 241)

            -- State
            self._fps = 60
            self._ping = 0
            self._frameCount = 0
            self._lastTime = os.clock()
            self._connections = {}

            return self
        end

        --// Get position UDim2
        function Watermark:_getPositionConfig()
            local positions = {
                TopRight = {
                    Position = UDim2.new(1, -10, 0, 10),
                    AnchorPoint = Vector2.new(1, 0),
                },
                TopLeft = {
                    Position = UDim2.new(0, 10, 0, 10),
                    AnchorPoint = Vector2.new(0, 0),
                },
                BottomRight = {
                    Position = UDim2.new(1, -10, 1, -10),
                    AnchorPoint = Vector2.new(1, 1),
                },
                BottomLeft = {
                    Position = UDim2.new(0, 10, 1, -10),
                    AnchorPoint = Vector2.new(0, 1),
                },
            }

            return positions[self.Position] or positions.TopRight
        end

        --// Create watermark
        function Watermark:Create(parent)
            local posConfig = self:_getPositionConfig()

            local watermark = Instance.new("Frame")
            watermark.Name = "Watermark"
            watermark.Size = UDim2.new(0, 0, 0, 26)
            watermark.AutomaticSize = Enum.AutomaticSize.X
            watermark.Position = posConfig.Position
            watermark.AnchorPoint = posConfig.AnchorPoint
            watermark.BackgroundColor3 = self.BackgroundColor
            watermark.BorderSizePixel = 0

            if parent then
                watermark.Parent = parent
            end

            self.Instance = watermark

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 6)
            corner.Parent = watermark

            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(39, 39, 42)
            stroke.Thickness = 1
            stroke.Parent = watermark

            local padding = Instance.new("UIPadding")
            padding.PaddingLeft = UDim.new(0, 10)
            padding.PaddingRight = UDim.new(0, 10)
            padding.Parent = watermark

            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Horizontal
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.Padding = UDim.new(0, 8)
            layout.Parent = watermark

            -- Accent bar
            local accent = Instance.new("Frame")
            accent.Size = UDim2.new(0, 3, 0.6, 0)
            accent.BackgroundColor3 = self.AccentColor
            accent.BorderSizePixel = 0
            accent.LayoutOrder = 1
            accent.Parent = watermark

            local accentCorner = Instance.new("UICorner")
            accentCorner.CornerRadius = UDim.new(1, 0)
            accentCorner.Parent = accent

            -- Title
            local title = Instance.new("TextLabel")
            title.Size = UDim2.new(0, 0, 1, 0)
            title.AutomaticSize = Enum.AutomaticSize.X
            title.BackgroundTransparency = 1
            title.Font = Enum.Font.GothamBold
            title.Text = self.Title
            title.TextColor3 = self.TextColor
            title.TextSize = 12
            title.LayoutOrder = 2
            title.Parent = watermark
            self._titleLabel = title

            -- Subtitle
            if self.Subtitle then
                local subtitle = Instance.new("TextLabel")
                subtitle.Size = UDim2.new(0, 0, 1, 0)
                subtitle.AutomaticSize = Enum.AutomaticSize.X
                subtitle.BackgroundTransparency = 1
                subtitle.Font = Enum.Font.Gotham
                subtitle.Text = self.Subtitle
                subtitle.TextColor3 = Color3.fromRGB(113, 113, 122)
                subtitle.TextSize = 11
                subtitle.LayoutOrder = 3
                subtitle.Parent = watermark
                self._subtitleLabel = subtitle
            end

            -- Separator
            local addSeparator = function(order)
                local sep = Instance.new("Frame")
                sep.Size = UDim2.new(0, 1, 0.5, 0)
                sep.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
                sep.BorderSizePixel = 0
                sep.LayoutOrder = order
                sep.Parent = watermark
                return sep
            end

            -- Info items
            local currentOrder = 10

            if self.ShowUsername then
                addSeparator(currentOrder)
                currentOrder = currentOrder + 1

                local username = Instance.new("TextLabel")
                username.Size = UDim2.new(0, 0, 1, 0)
                username.AutomaticSize = Enum.AutomaticSize.X
                username.BackgroundTransparency = 1
                username.Font = Enum.Font.Gotham
                username.Text = Players.LocalPlayer.Name
                username.TextColor3 = Color3.fromRGB(161, 161, 170)
                username.TextSize = 11
                username.LayoutOrder = currentOrder
                username.Parent = watermark
                currentOrder = currentOrder + 1
            end

            if self.ShowFPS then
                addSeparator(currentOrder)
                currentOrder = currentOrder + 1

                local fps = Instance.new("TextLabel")
                fps.Name = "FPS"
                fps.Size = UDim2.new(0, 40, 1, 0)
                fps.BackgroundTransparency = 1
                fps.Font = Enum.Font.GothamMedium
                fps.Text = "60 FPS"
                fps.TextColor3 = Color3.fromRGB(34, 197, 94)
                fps.TextSize = 11
                fps.LayoutOrder = currentOrder
                fps.Parent = watermark
                self._fpsLabel = fps
                currentOrder = currentOrder + 1
            end

            if self.ShowPing then
                addSeparator(currentOrder)
                currentOrder = currentOrder + 1

                local ping = Instance.new("TextLabel")
                ping.Name = "Ping"
                ping.Size = UDim2.new(0, 45, 1, 0)
                ping.BackgroundTransparency = 1
                ping.Font = Enum.Font.GothamMedium
                ping.Text = "0 ms"
                ping.TextColor3 = Color3.fromRGB(59, 130, 246)
                ping.TextSize = 11
                ping.LayoutOrder = currentOrder
                ping.Parent = watermark
                self._pingLabel = ping
                currentOrder = currentOrder + 1
            end

            if self.ShowTime then
                addSeparator(currentOrder)
                currentOrder = currentOrder + 1

                local time = Instance.new("TextLabel")
                time.Name = "Time"
                time.Size = UDim2.new(0, 50, 1, 0)
                time.BackgroundTransparency = 1
                time.Font = Enum.Font.Gotham
                time.Text = os.date("%H:%M")
                time.TextColor3 = Color3.fromRGB(161, 161, 170)
                time.TextSize = 11
                time.LayoutOrder = currentOrder
                time.Parent = watermark
                self._timeLabel = time
            end

            -- Draggable
            if self.Draggable then
                self:_setupDragging()
            end

            -- Start update loop
            self:_startUpdating()

            return self
        end

        --// Setup dragging
        function Watermark:_setupDragging()
            local dragging = false
            local dragStart = nil
            local startPos = nil

            local dragInput = Instance.new("TextButton")
            dragInput.Size = UDim2.new(1, 0, 1, 0)
            dragInput.BackgroundTransparency = 1
            dragInput.Text = ""
            dragInput.ZIndex = 2
            dragInput.Parent = self.Instance

            table.insert(self._connections, dragInput.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    dragging = true
                    dragStart = input.Position
                    startPos = self.Instance.Position
                end
            end))

            table.insert(self._connections, dragInput.InputEnded:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    dragging = false
                end
            end))

            table.insert(self._connections, game:GetService("UserInputService").InputChanged:Connect(function(input)
                if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                    local delta = input.Position - dragStart
                    self.Instance.Position = UDim2.new(
                        startPos.X.Scale,
                        startPos.X.Offset + delta.X,
                        startPos.Y.Scale,
                        startPos.Y.Offset + delta.Y
                    )
                end
            end))
        end

        --// Start update loop
        function Watermark:_startUpdating()
            -- FPS counter
            if self.ShowFPS then
                table.insert(self._connections, RunService.Heartbeat:Connect(function()
                    self._frameCount = self._frameCount + 1

                    local now = os.clock()
                    local elapsed = now - self._lastTime

                    if elapsed >= 0.5 then
                        self._fps = self._frameCount / elapsed
                        self._frameCount = 0
                        self._lastTime = now

                        local fps = math.floor(self._fps + 0.5)
                        self._fpsLabel.Text = fps .. " FPS"

                        -- Color based on FPS
                        if fps >= 50 then
                            self._fpsLabel.TextColor3 = Color3.fromRGB(34, 197, 94)
                        elseif fps >= 30 then
                            self._fpsLabel.TextColor3 = Color3.fromRGB(245, 158, 11)
                        else
                            self._fpsLabel.TextColor3 = Color3.fromRGB(239, 68, 68)
                        end
                    end
                end))
            end

            -- Ping updater
            if self.ShowPing then
                task.spawn(function()
                    while self.Instance and self.Instance.Parent do
                        local success, ping = pcall(function()
                            return Players.LocalPlayer:GetNetworkPing()
                        end)

                        if success then
                            self._ping = math.floor(ping * 1000 + 0.5)
                            self._pingLabel.Text = self._ping .. " ms"

                            if self._ping < 80 then
                                self._pingLabel.TextColor3 = Color3.fromRGB(59, 130, 246)
                            elseif self._ping < 150 then
                                self._pingLabel.TextColor3 = Color3.fromRGB(245, 158, 11)
                            else
                                self._pingLabel.TextColor3 = Color3.fromRGB(239, 68, 68)
                            end
                        end

                        task.wait(1)
                    end
                end)
            end

            -- Time updater
            if self.ShowTime then
                task.spawn(function()
                    while self.Instance and self.Instance.Parent do
                        self._timeLabel.Text = os.date("%H:%M")
                        task.wait(1)
                    end
                end)
            end
        end

        --// Set title
        function Watermark:SetTitle(title)
            self.Title = title
            if self._titleLabel then
                self._titleLabel.Text = title
            end
            return self
        end

        --// Set subtitle
        function Watermark:SetSubtitle(subtitle)
            self.Subtitle = subtitle
            if self._subtitleLabel then
                self._subtitleLabel.Text = subtitle
            end
            return self
        end

        --// Toggle visibility
        function Watermark:Toggle()
            self.Instance.Visible = not self.Instance.Visible
            return self
        end

        --// Destroy
        function Watermark:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return Watermark


    end


    -- ============================================================================
    -- Module: NexusUI/Special/Crosshair
    -- ============================================================================
    NexusUI_Modules["NexusUI/Special/Crosshair"] = function()
        local script = CreateMockScript("NexusUI/Special/Crosshair")

        --[[
            NexusUI Crosshair Component
            Customizable crosshair overlay
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Crosshair Module
        local Crosshair = {}
        Crosshair.__index = Crosshair
        Crosshair.ClassName = "Crosshair"

        --// Crosshair types
        Crosshair.Type = {
            Cross = "Cross",
            Dot = "Dot",
            Circle = "Circle",
            Square = "Square",
            Custom = "Custom",
        }

        --// Constructor
        function Crosshair.new(config)
            local self = setmetatable({}, Crosshair)

            config = config or {}

            self.CrosshairType = config.Type or Crosshair.Type.Cross
            self.Size = config.Size or 10
            self.Gap = config.Gap or 4
            self.Thickness = config.Thickness or 2
            self.Outline = config.Outline ~= false
            self.OutlineThickness = config.OutlineThickness or 1
            self.Dynamic = config.Dynamic or false -- Expand when moving

            -- Colors
            self.Color = config.Color or Color3.fromRGB(0, 255, 0)
            self.OutlineColor = config.OutlineColor or Color3.fromRGB(0, 0, 0)

            -- State
            self._lines = {}
            self._connections = {}

            return self
        end

        --// Create crosshair
        function Crosshair:Create(parent)
            local crosshair = Instance.new("Frame")
            crosshair.Name = "Crosshair"
            crosshair.Size = UDim2.new(0, self.Size * 2 + self.Gap * 2, 0, self.Size * 2 + self.Gap * 2)
            crosshair.Position = UDim2.new(0.5, 0, 0.5, 0)
            crosshair.AnchorPoint = Vector2.new(0.5, 0.5)
            crosshair.BackgroundTransparency = 1

            if parent then
                crosshair.Parent = parent
            end

            self.Instance = crosshair

            -- Create crosshair based on type
            if self.CrosshairType == Crosshair.Type.Cross then
                self:_createCross()
            elseif self.CrosshairType == Crosshair.Type.Dot then
                self:_createDot()
            elseif self.CrosshairType == Crosshair.Type.Circle then
                self:_createCircle()
            elseif self.CrosshairType == Crosshair.Type.Square then
                self:_createSquare()
            end

            return self
        end

        --// Create cross crosshair
        function Crosshair:_createCross()
            local centerX = self.Size + self.Gap
            local centerY = self.Size + self.Gap

            -- Top line
            local top = self:_createLine(
                UDim2.new(0.5, 0, 0, 0),
                UDim2.new(0, self.Thickness, 0, self.Size),
                Vector2.new(0.5, 0)
            )
            table.insert(self._lines, top)

            -- Bottom line
            local bottom = self:_createLine(
                UDim2.new(0.5, 0, 1, 0),
                UDim2.new(0, self.Thickness, 0, self.Size),
                Vector2.new(0.5, 1)
            )
            table.insert(self._lines, bottom)

            -- Left line
            local left = self:_createLine(
                UDim2.new(0, 0, 0.5, 0),
                UDim2.new(0, self.Size, 0, self.Thickness),
                Vector2.new(0, 0.5)
            )
            table.insert(self._lines, left)

            -- Right line
            local right = self:_createLine(
                UDim2.new(1, 0, 0.5, 0),
                UDim2.new(0, self.Size, 0, self.Thickness),
                Vector2.new(1, 0.5)
            )
            table.insert(self._lines, right)

            -- Center dot (optional)
            local dot = Instance.new("Frame")
            dot.Size = UDim2.new(0, self.Thickness, 0, self.Thickness)
            dot.Position = UDim2.new(0.5, 0, 0.5, 0)
            dot.AnchorPoint = Vector2.new(0.5, 0.5)
            dot.BackgroundColor3 = self.Color
            dot.BorderSizePixel = 0
            dot.Parent = self.Instance

            if self.Outline then
                local dotStroke = Instance.new("UIStroke")
                dotStroke.Color = self.OutlineColor
                dotStroke.Thickness = self.OutlineThickness
                dotStroke.Parent = dot
            end
        end

        --// Create line helper
        function Crosshair:_createLine(position, size, anchorPoint)
            local line = Instance.new("Frame")
            line.Size = size
            line.Position = position
            line.AnchorPoint = anchorPoint
            line.BackgroundColor3 = self.Color
            line.BorderSizePixel = 0
            line.Parent = self.Instance

            if self.Outline then
                local stroke = Instance.new("UIStroke")
                stroke.Color = self.OutlineColor
                stroke.Thickness = self.OutlineThickness
                stroke.Parent = line
            end

            return line
        end

        --// Create dot crosshair
        function Crosshair:_createDot()
            local dot = Instance.new("Frame")
            dot.Size = UDim2.new(0, self.Size, 0, self.Size)
            dot.Position = UDim2.new(0.5, 0, 0.5, 0)
            dot.AnchorPoint = Vector2.new(0.5, 0.5)
            dot.BackgroundColor3 = self.Color
            dot.BorderSizePixel = 0
            dot.Parent = self.Instance

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(1, 0)
            corner.Parent = dot

            if self.Outline then
                local stroke = Instance.new("UIStroke")
                stroke.Color = self.OutlineColor
                stroke.Thickness = self.OutlineThickness
                stroke.Parent = dot
            end

            table.insert(self._lines, dot)
        end

        --// Create circle crosshair
        function Crosshair:_createCircle()
            local circle = Instance.new("Frame")
            circle.Size = UDim2.new(0, self.Size * 2, 0, self.Size * 2)
            circle.Position = UDim2.new(0.5, 0, 0.5, 0)
            circle.AnchorPoint = Vector2.new(0.5, 0.5)
            circle.BackgroundTransparency = 1
            circle.BorderSizePixel = 0
            circle.Parent = self.Instance

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(1, 0)
            corner.Parent = circle

            local stroke = Instance.new("UIStroke")
            stroke.Color = self.Color
            stroke.Thickness = self.Thickness
            stroke.Parent = circle

            if self.Outline then
                -- Inner outline would need separate element
            end

            table.insert(self._lines, circle)

            -- Center dot
            local dot = Instance.new("Frame")
            dot.Size = UDim2.new(0, self.Thickness, 0, self.Thickness)
            dot.Position = UDim2.new(0.5, 0, 0.5, 0)
            dot.AnchorPoint = Vector2.new(0.5, 0.5)
            dot.BackgroundColor3 = self.Color
            dot.BorderSizePixel = 0
            dot.Parent = self.Instance

            local dotCorner = Instance.new("UICorner")
            dotCorner.CornerRadius = UDim.new(1, 0)
            dotCorner.Parent = dot
        end

        --// Create square crosshair
        function Crosshair:_createSquare()
            local square = Instance.new("Frame")
            square.Size = UDim2.new(0, self.Size * 2, 0, self.Size * 2)
            square.Position = UDim2.new(0.5, 0, 0.5, 0)
            square.AnchorPoint = Vector2.new(0.5, 0.5)
            square.BackgroundTransparency = 1
            square.BorderSizePixel = 0
            square.Parent = self.Instance

            local stroke = Instance.new("UIStroke")
            stroke.Color = self.Color
            stroke.Thickness = self.Thickness
            stroke.Parent = square

            table.insert(self._lines, square)
        end

        --// Set color
        function Crosshair:SetColor(color)
            self.Color = color

            for _, line in ipairs(self._lines) do
                if line:IsA("Frame") then
                    if line.BackgroundTransparency < 1 then
                        line.BackgroundColor3 = color
                    end

                    local stroke = line:FindFirstChildOfClass("UIStroke")
                    if stroke and stroke.Color ~= self.OutlineColor then
                        stroke.Color = color
                    end
                end
            end

            return self
        end

        --// Set size
        function Crosshair:SetSize(size)
            self.Size = size
            -- Would need to rebuild
            return self
        end

        --// Toggle visibility
        function Crosshair:Toggle()
            self.Instance.Visible = not self.Instance.Visible
            return self
        end

        --// Destroy
        function Crosshair:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return Crosshair


    end


    -- ============================================================================
    -- Module: NexusUI/Special/Aimbot
    -- ============================================================================
    NexusUI_Modules["NexusUI/Special/Aimbot"] = function()
        local script = CreateMockScript("NexusUI/Special/Aimbot")

        --[[
            NexusUI Aimbot Component
            Aimbot/aim assist configuration panel
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Aimbot Module (UI only - settings panel)
        local Aimbot = {}
        Aimbot.__index = Aimbot
        Aimbot.ClassName = "AimbotSettings"

        --// Constructor
        function Aimbot.new(config)
            local self = setmetatable({}, Aimbot)

            config = config or {}

            -- Settings
            self.Enabled = config.Enabled or false
            self.FOV = config.FOV or 100
            self.Smoothness = config.Smoothness or 10
            self.TargetPart = config.TargetPart or "Head"
            self.TeamCheck = config.TeamCheck ~= false
            self.WallCheck = config.WallCheck ~= false
            self.ShowFOV = config.ShowFOV or false
            self.AimKey = config.AimKey or Enum.UserInputType.MouseButton2
            self.Prediction = config.Prediction or false
            self.PredictionAmount = config.PredictionAmount or 0.1

            -- Callbacks
            self.OnSettingsChanged = config.OnSettingsChanged

            -- State
            self._connections = {}

            return self
        end

        --// Create settings panel
        function Aimbot:Create(parent)
            local panel = Instance.new("Frame")
            panel.Name = "AimbotSettings"
            panel.Size = UDim2.new(0, 280, 0, 0)
            panel.AutomaticSize = Enum.AutomaticSize.Y
            panel.BackgroundColor3 = Color3.fromRGB(24, 24, 27)
            panel.BorderSizePixel = 0

            if parent then
                panel.Parent = parent
            end

            self.Instance = panel

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = panel

            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, 12)
            padding.PaddingBottom = UDim.new(0, 12)
            padding.PaddingLeft = UDim.new(0, 12)
            padding.PaddingRight = UDim.new(0, 12)
            padding.Parent = panel

            local layout = Instance.new("UIListLayout")
            layout.Padding = UDim.new(0, 8)
            layout.Parent = panel

            -- Header
            local header = Instance.new("TextLabel")
            header.Size = UDim2.new(1, 0, 0, 20)
            header.BackgroundTransparency = 1
            header.Font = Enum.Font.GothamBold
            header.Text = "Aimbot Settings"
            header.TextColor3 = Color3.fromRGB(250, 250, 250)
            header.TextSize = 14
            header.TextXAlignment = Enum.TextXAlignment.Left
            header.LayoutOrder = 1
            header.Parent = panel

            -- Enabled toggle
            self:_createToggle("Enabled", self.Enabled, function(value)
                self.Enabled = value
                self:_notifyChange()
            end, 2)

            -- FOV slider
            self:_createSlider("FOV", self.FOV, 10, 500, function(value)
                self.FOV = value
                self:_notifyChange()
            end, 3)

            -- Smoothness slider
            self:_createSlider("Smoothness", self.Smoothness, 1, 50, function(value)
                self.Smoothness = value
                self:_notifyChange()
            end, 4)

            -- Target part dropdown
            self:_createDropdown("Target Part", {"Head", "Torso", "Random"}, self.TargetPart, function(value)
                self.TargetPart = value
                self:_notifyChange()
            end, 5)

            -- Team check toggle
            self:_createToggle("Team Check", self.TeamCheck, function(value)
                self.TeamCheck = value
                self:_notifyChange()
            end, 6)

            -- Wall check toggle
            self:_createToggle("Wall Check", self.WallCheck, function(value)
                self.WallCheck = value
                self:_notifyChange()
            end, 7)

            -- Show FOV toggle
            self:_createToggle("Show FOV Circle", self.ShowFOV, function(value)
                self.ShowFOV = value
                self:_notifyChange()
            end, 8)

            -- Prediction toggle
            self:_createToggle("Prediction", self.Prediction, function(value)
                self.Prediction = value
                self:_notifyChange()
            end, 9)

            return self
        end

        --// Create toggle helper
        function Aimbot:_createToggle(name, defaultValue, callback, order)
            local row = Instance.new("Frame")
            row.Size = UDim2.new(1, 0, 0, 28)
            row.BackgroundTransparency = 1
            row.LayoutOrder = order
            row.Parent = self.Instance

            local label = Instance.new("TextLabel")
            label.Size = UDim2.new(1, -50, 1, 0)
            label.BackgroundTransparency = 1
            label.Font = Enum.Font.Gotham
            label.Text = name
            label.TextColor3 = Color3.fromRGB(161, 161, 170)
            label.TextSize = 12
            label.TextXAlignment = Enum.TextXAlignment.Left
            label.Parent = row

            local toggle = Instance.new("Frame")
            toggle.Size = UDim2.new(0, 40, 0, 20)
            toggle.Position = UDim2.new(1, 0, 0.5, 0)
            toggle.AnchorPoint = Vector2.new(1, 0.5)
            toggle.BackgroundColor3 = defaultValue and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(63, 63, 70)
            toggle.BorderSizePixel = 0
            toggle.Parent = row

            local toggleCorner = Instance.new("UICorner")
            toggleCorner.CornerRadius = UDim.new(1, 0)
            toggleCorner.Parent = toggle

            local knob = Instance.new("Frame")
            knob.Size = UDim2.new(0, 16, 0, 16)
            knob.Position = defaultValue and UDim2.new(1, -18, 0.5, 0) or UDim2.new(0, 2, 0.5, 0)
            knob.AnchorPoint = Vector2.new(0, 0.5)
            knob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            knob.BorderSizePixel = 0
            knob.Parent = toggle

            local knobCorner = Instance.new("UICorner")
            knobCorner.CornerRadius = UDim.new(1, 0)
            knobCorner.Parent = knob

            local button = Instance.new("TextButton")
            button.Size = UDim2.new(1, 0, 1, 0)
            button.BackgroundTransparency = 1
            button.Text = ""
            button.Parent = toggle

            local enabled = defaultValue

            table.insert(self._connections, button.MouseButton1Click:Connect(function()
                enabled = not enabled

                TweenService:Create(toggle, TweenInfo.new(0.2), {
                    BackgroundColor3 = enabled and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(63, 63, 70),
                }):Play()

                TweenService:Create(knob, TweenInfo.new(0.2), {
                    Position = enabled and UDim2.new(1, -18, 0.5, 0) or UDim2.new(0, 2, 0.5, 0),
                }):Play()

                callback(enabled)
            end))
        end

        --// Create slider helper
        function Aimbot:_createSlider(name, defaultValue, min, max, callback, order)
            local row = Instance.new("Frame")
            row.Size = UDim2.new(1, 0, 0, 40)
            row.BackgroundTransparency = 1
            row.LayoutOrder = order
            row.Parent = self.Instance

            local label = Instance.new("TextLabel")
            label.Size = UDim2.new(1, -40, 0, 16)
            label.BackgroundTransparency = 1
            label.Font = Enum.Font.Gotham
            label.Text = name
            label.TextColor3 = Color3.fromRGB(161, 161, 170)
            label.TextSize = 12
            label.TextXAlignment = Enum.TextXAlignment.Left
            label.Parent = row

            local valueLabel = Instance.new("TextLabel")
            valueLabel.Size = UDim2.new(0, 40, 0, 16)
            valueLabel.Position = UDim2.new(1, 0, 0, 0)
            valueLabel.AnchorPoint = Vector2.new(1, 0)
            valueLabel.BackgroundTransparency = 1
            valueLabel.Font = Enum.Font.GothamMedium
            valueLabel.Text = tostring(math.floor(defaultValue))
            valueLabel.TextColor3 = Color3.fromRGB(99, 102, 241)
            valueLabel.TextSize = 12
            valueLabel.TextXAlignment = Enum.TextXAlignment.Right
            valueLabel.Parent = row

            local track = Instance.new("Frame")
            track.Size = UDim2.new(1, 0, 0, 6)
            track.Position = UDim2.new(0, 0, 0, 24)
            track.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
            track.BorderSizePixel = 0
            track.Parent = row

            local trackCorner = Instance.new("UICorner")
            trackCorner.CornerRadius = UDim.new(1, 0)
            trackCorner.Parent = track

            local fill = Instance.new("Frame")
            fill.Size = UDim2.new((defaultValue - min) / (max - min), 0, 1, 0)
            fill.BackgroundColor3 = Color3.fromRGB(99, 102, 241)
            fill.BorderSizePixel = 0
            fill.Parent = track

            local fillCorner = Instance.new("UICorner")
            fillCorner.CornerRadius = UDim.new(1, 0)
            fillCorner.Parent = fill

            local input = Instance.new("TextButton")
            input.Size = UDim2.new(1, 0, 1, 10)
            input.Position = UDim2.new(0, 0, 0, -5)
            input.BackgroundTransparency = 1
            input.Text = ""
            input.Parent = track

            local dragging = false

            local function update(inputX)
                local relativeX = math.clamp((inputX - track.AbsolutePosition.X) / track.AbsoluteSize.X, 0, 1)
                local value = min + (max - min) * relativeX

                fill.Size = UDim2.new(relativeX, 0, 1, 0)
                valueLabel.Text = tostring(math.floor(value))

                callback(value)
            end

            table.insert(self._connections, input.InputBegan:Connect(function(inputObj)
                if inputObj.UserInputType == Enum.UserInputType.MouseButton1 then
                    dragging = true
                    update(inputObj.Position.X)
                end
            end))

            table.insert(self._connections, input.InputEnded:Connect(function(inputObj)
                if inputObj.UserInputType == Enum.UserInputType.MouseButton1 then
                    dragging = false
                end
            end))

            table.insert(self._connections, game:GetService("UserInputService").InputChanged:Connect(function(inputObj)
                if dragging and inputObj.UserInputType == Enum.UserInputType.MouseMovement then
                    update(inputObj.Position.X)
                end
            end))
        end

        --// Create dropdown helper (simplified)
        function Aimbot:_createDropdown(name, options, defaultValue, callback, order)
            local row = Instance.new("Frame")
            row.Size = UDim2.new(1, 0, 0, 28)
            row.BackgroundTransparency = 1
            row.LayoutOrder = order
            row.Parent = self.Instance

            local label = Instance.new("TextLabel")
            label.Size = UDim2.new(0.5, 0, 1, 0)
            label.BackgroundTransparency = 1
            label.Font = Enum.Font.Gotham
            label.Text = name
            label.TextColor3 = Color3.fromRGB(161, 161, 170)
            label.TextSize = 12
            label.TextXAlignment = Enum.TextXAlignment.Left
            label.Parent = row

            local dropdown = Instance.new("TextButton")
            dropdown.Size = UDim2.new(0.5, -4, 1, 0)
            dropdown.Position = UDim2.new(0.5, 4, 0, 0)
            dropdown.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
            dropdown.BorderSizePixel = 0
            dropdown.Font = Enum.Font.Gotham
            dropdown.Text = defaultValue
            dropdown.TextColor3 = Color3.fromRGB(250, 250, 250)
            dropdown.TextSize = 11
            dropdown.AutoButtonColor = false
            dropdown.Parent = row

            local dropdownCorner = Instance.new("UICorner")
            dropdownCorner.CornerRadius = UDim.new(0, 4)
            dropdownCorner.Parent = dropdown

            local currentIndex = 1
            for i, opt in ipairs(options) do
                if opt == defaultValue then
                    currentIndex = i
                    break
                end
            end

            table.insert(self._connections, dropdown.MouseButton1Click:Connect(function()
                currentIndex = currentIndex % #options + 1
                dropdown.Text = options[currentIndex]
                callback(options[currentIndex])
            end))
        end

        --// Notify settings changed
        function Aimbot:_notifyChange()
            if self.OnSettingsChanged then
                self.OnSettingsChanged(self:GetSettings())
            end
        end

        --// Get settings
        function Aimbot:GetSettings()
            return {
                Enabled = self.Enabled,
                FOV = self.FOV,
                Smoothness = self.Smoothness,
                TargetPart = self.TargetPart,
                TeamCheck = self.TeamCheck,
                WallCheck = self.WallCheck,
                ShowFOV = self.ShowFOV,
                AimKey = self.AimKey,
                Prediction = self.Prediction,
                PredictionAmount = self.PredictionAmount,
            }
        end

        --// Set settings
        function Aimbot:SetSettings(settings)
            for key, value in pairs(settings) do
                self[key] = value
            end
            return self
        end

        --// Destroy
        function Aimbot:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return Aimbot


    end


    -- ============================================================================
    -- Module: NexusUI/Special/Playerlist
    -- ============================================================================
    NexusUI_Modules["NexusUI/Special/Playerlist"] = function()
        local script = CreateMockScript("NexusUI/Special/Playerlist")

        --[[
            NexusUI Playerlist Component
            Enhanced player list with additional info
        ]]

        --// Services
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local TweenService = game:GetService("TweenService")

        --// Playerlist Module
        local Playerlist = {}
        Playerlist.__index = Playerlist
        Playerlist.ClassName = "Playerlist"

        --// Constructor
        function Playerlist.new(config)
            local self = setmetatable({}, Playerlist)

            config = config or {}

            self.Width = config.Width or 280
            self.Height = config.Height or 400
            self.ShowHealth = config.ShowHealth or false
            self.ShowTeam = config.ShowTeam ~= false
            self.ShowDistance = config.ShowDistance or false
            self.ShowAvatar = config.ShowAvatar ~= false
            self.ShowActions = config.ShowActions or false
            self.UpdateRate = config.UpdateRate or 1

            -- Colors
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(24, 24, 27)
            self.HeaderColor = config.HeaderColor or Color3.fromRGB(18, 18, 21)
            self.TextColor = config.TextColor or Color3.fromRGB(250, 250, 250)
            self.SubTextColor = config.SubTextColor or Color3.fromRGB(113, 113, 122)

            -- Callbacks
            self.OnPlayerClick = config.OnPlayerClick

            -- State
            self._playerItems = {}
            self._connections = {}

            return self
        end

        --// Create playerlist
        function Playerlist:Create(parent)
            local playerlist = Instance.new("Frame")
            playerlist.Name = "Playerlist"
            playerlist.Size = UDim2.new(0, self.Width, 0, self.Height)
            playerlist.BackgroundColor3 = self.BackgroundColor
            playerlist.BorderSizePixel = 0

            if parent then
                playerlist.Parent = parent
            end

            self.Instance = playerlist

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 10)
            corner.Parent = playerlist

            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(39, 39, 42)
            stroke.Thickness = 1
            stroke.Parent = playerlist

            -- Header
            local header = Instance.new("Frame")
            header.Size = UDim2.new(1, 0, 0, 36)
            header.BackgroundColor3 = self.HeaderColor
            header.BorderSizePixel = 0
            header.Parent = playerlist

            local headerCorner = Instance.new("UICorner")
            headerCorner.CornerRadius = UDim.new(0, 10)
            headerCorner.Parent = header

            local headerFix = Instance.new("Frame")
            headerFix.Size = UDim2.new(1, 0, 0, 10)
            headerFix.Position = UDim2.new(0, 0, 1, -10)
            headerFix.BackgroundColor3 = self.HeaderColor
            headerFix.BorderSizePixel = 0
            headerFix.Parent = header

            local title = Instance.new("TextLabel")
            title.Size = UDim2.new(0.6, 0, 1, 0)
            title.Position = UDim2.new(0, 14, 0, 0)
            title.BackgroundTransparency = 1
            title.Font = Enum.Font.GothamBold
            title.Text = "Players"
            title.TextColor3 = self.TextColor
            title.TextSize = 13
            title.TextXAlignment = Enum.TextXAlignment.Left
            title.Parent = header

            local countLabel = Instance.new("TextLabel")
            countLabel.Name = "Count"
            countLabel.Size = UDim2.new(0, 50, 1, 0)
            countLabel.Position = UDim2.new(1, -60, 0, 0)
            countLabel.BackgroundTransparency = 1
            countLabel.Font = Enum.Font.GothamMedium
            countLabel.Text = #Players:GetPlayers() .. "/" .. Players.MaxPlayers
            countLabel.TextColor3 = self.SubTextColor
            countLabel.TextSize = 12
            countLabel.TextXAlignment = Enum.TextXAlignment.Right
            countLabel.Parent = header
            self._countLabel = countLabel

            -- Player list scroll
            local scroll = Instance.new("ScrollingFrame")
            scroll.Size = UDim2.new(1, -16, 1, -48)
            scroll.Position = UDim2.new(0, 8, 0, 42)
            scroll.BackgroundTransparency = 1
            scroll.BorderSizePixel = 0
            scroll.ScrollBarThickness = 4
            scroll.ScrollBarImageColor3 = Color3.fromRGB(63, 63, 70)
            scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
            scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
            scroll.Parent = playerlist
            self._scroll = scroll

            local scrollLayout = Instance.new("UIListLayout")
            scrollLayout.Padding = UDim.new(0, 4)
            scrollLayout.Parent = scroll

            -- Initialize player list
            self:_populatePlayers()

            -- Player events
            table.insert(self._connections, Players.PlayerAdded:Connect(function(player)
                self:_addPlayer(player)
                self:_updateCount()
            end))

            table.insert(self._connections, Players.PlayerRemoving:Connect(function(player)
                self:_removePlayer(player)
                self:_updateCount()
            end))

            -- Update loop
            task.spawn(function()
                while self.Instance and self.Instance.Parent do
                    self:_updatePlayers()
                    task.wait(self.UpdateRate)
                end
            end)

            return self
        end

        --// Populate initial players
        function Playerlist:_populatePlayers()
            for _, player in ipairs(Players:GetPlayers()) do
                self:_addPlayer(player)
            end
        end

        --// Add player item
        function Playerlist:_addPlayer(player)
            if self._playerItems[player.UserId] then return end

            local localPlayer = Players.LocalPlayer
            local isLocal = player == localPlayer

            local item = Instance.new("Frame")
            item.Name = "Player_" .. player.UserId
            item.Size = UDim2.new(1, 0, 0, self.ShowAvatar and 40 or 30)
            item.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            item.BackgroundTransparency = 0.5
            item.BorderSizePixel = 0
            item.Parent = self._scroll

            local itemCorner = Instance.new("UICorner")
            itemCorner.CornerRadius = UDim.new(0, 6)
            itemCorner.Parent = item

            -- Avatar
            if self.ShowAvatar then
                local avatar = Instance.new("ImageLabel")
                avatar.Size = UDim2.new(0, 28, 0, 28)
                avatar.Position = UDim2.new(0, 6, 0.5, 0)
                avatar.AnchorPoint = Vector2.new(0, 0.5)
                avatar.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
                avatar.BorderSizePixel = 0
                avatar.Parent = item

                local avatarCorner = Instance.new("UICorner")
                avatarCorner.CornerRadius = UDim.new(0, 6)
                avatarCorner.Parent = avatar

                -- Load avatar thumbnail
                task.spawn(function()
                    local success, content = pcall(function()
                        return Players:GetUserThumbnailAsync(
                            player.UserId,
                            Enum.ThumbnailType.HeadShot,
                            Enum.ThumbnailSize.Size48x48
                        )
                    end)
                    if success and avatar.Parent then
                        avatar.Image = content
                    end
                end)
            end

            -- Name
            local nameOffset = self.ShowAvatar and 42 or 10
            local name = Instance.new("TextLabel")
            name.Name = "Name"
            name.Size = UDim2.new(1, -nameOffset - 60, 0, 16)
            name.Position = UDim2.new(0, nameOffset, 0, self.ShowTeam and 4 or 7)
            name.BackgroundTransparency = 1
            name.Font = Enum.Font.GothamMedium
            name.Text = player.DisplayName
            name.TextColor3 = isLocal and Color3.fromRGB(99, 102, 241) or self.TextColor
            name.TextSize = 12
            name.TextXAlignment = Enum.TextXAlignment.Left
            name.TextTruncate = Enum.TextTruncate.AtEnd
            name.Parent = item

            -- Team/status
            if self.ShowTeam then
                local team = Instance.new("TextLabel")
                team.Name = "Team"
                team.Size = UDim2.new(1, -nameOffset - 60, 0, 12)
                team.Position = UDim2.new(0, nameOffset, 0, 20)
                team.BackgroundTransparency = 1
                team.Font = Enum.Font.Gotham
                team.Text = player.Team and player.Team.Name or "No Team"
                team.TextColor3 = player.Team and player.TeamColor.Color or self.SubTextColor
                team.TextSize = 10
                team.TextXAlignment = Enum.TextXAlignment.Left
                team.Parent = item
            end

            -- Health bar
            if self.ShowHealth then
                local healthBg = Instance.new("Frame")
                healthBg.Name = "HealthBg"
                healthBg.Size = UDim2.new(0, 40, 0, 4)
                healthBg.Position = UDim2.new(1, -50, 0.5, 0)
                healthBg.AnchorPoint = Vector2.new(0, 0.5)
                healthBg.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
                healthBg.BorderSizePixel = 0
                healthBg.Parent = item

                local healthCorner = Instance.new("UICorner")
                healthCorner.CornerRadius = UDim.new(1, 0)
                healthCorner.Parent = healthBg

                local healthFill = Instance.new("Frame")
                healthFill.Name = "Fill"
                healthFill.Size = UDim2.new(1, 0, 1, 0)
                healthFill.BackgroundColor3 = Color3.fromRGB(34, 197, 94)
                healthFill.BorderSizePixel = 0
                healthFill.Parent = healthBg

                local healthFillCorner = Instance.new("UICorner")
                healthFillCorner.CornerRadius = UDim.new(1, 0)
                healthFillCorner.Parent = healthFill
            end

            -- Distance
            if self.ShowDistance then
                local distance = Instance.new("TextLabel")
                distance.Name = "Distance"
                distance.Size = UDim2.new(0, 50, 1, 0)
                distance.Position = UDim2.new(1, -55, 0, 0)
                distance.BackgroundTransparency = 1
                distance.Font = Enum.Font.Gotham
                distance.Text = "--"
                distance.TextColor3 = self.SubTextColor
                distance.TextSize = 10
                distance.TextXAlignment = Enum.TextXAlignment.Right
                distance.Parent = item
            end

            -- Click interaction
            local button = Instance.new("TextButton")
            button.Size = UDim2.new(1, 0, 1, 0)
            button.BackgroundTransparency = 1
            button.Text = ""
            button.Parent = item

            table.insert(self._connections, button.MouseButton1Click:Connect(function()
                if self.OnPlayerClick then
                    self.OnPlayerClick(player)
                end
            end))

            table.insert(self._connections, button.MouseEnter:Connect(function()
                TweenService:Create(item, TweenInfo.new(0.1), {
                    BackgroundTransparency = 0,
                }):Play()
            end))

            table.insert(self._connections, button.MouseLeave:Connect(function()
                TweenService:Create(item, TweenInfo.new(0.1), {
                    BackgroundTransparency = 0.5,
                }):Play()
            end))

            self._playerItems[player.UserId] = item
        end

        --// Remove player item
        function Playerlist:_removePlayer(player)
            local item = self._playerItems[player.UserId]
            if item then
                item:Destroy()
                self._playerItems[player.UserId] = nil
            end
        end

        --// Update players
        function Playerlist:_updatePlayers()
            local localPlayer = Players.LocalPlayer
            local localCharacter = localPlayer and localPlayer.Character
            local localRoot = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")

            for userId, item in pairs(self._playerItems) do
                local player = Players:GetPlayerByUserId(userId)
                if not player then continue end

                local character = player.Character
                local humanoid = character and character:FindFirstChild("Humanoid")
                local rootPart = character and character:FindFirstChild("HumanoidRootPart")

                -- Update health
                if self.ShowHealth then
                    local healthBg = item:FindFirstChild("HealthBg")
                    if healthBg and humanoid then
                        local fill = healthBg:FindFirstChild("Fill")
                        if fill then
                            local healthPercent = humanoid.Health / humanoid.MaxHealth
                            fill.Size = UDim2.new(healthPercent, 0, 1, 0)

                            -- Color based on health
                            if healthPercent > 0.6 then
                                fill.BackgroundColor3 = Color3.fromRGB(34, 197, 94)
                            elseif healthPercent > 0.3 then
                                fill.BackgroundColor3 = Color3.fromRGB(245, 158, 11)
                            else
                                fill.BackgroundColor3 = Color3.fromRGB(239, 68, 68)
                            end
                        end
                    end
                end

                -- Update distance
                if self.ShowDistance then
                    local distLabel = item:FindFirstChild("Distance")
                    if distLabel and localRoot and rootPart then
                        local distance = (rootPart.Position - localRoot.Position).Magnitude
                        distLabel.Text = math.floor(distance) .. "m"
                    end
                end

                -- Update team
                if self.ShowTeam then
                    local teamLabel = item:FindFirstChild("Team")
                    if teamLabel then
                        teamLabel.Text = player.Team and player.Team.Name or "No Team"
                        teamLabel.TextColor3 = player.Team and player.TeamColor.Color or self.SubTextColor
                    end
                end
            end
        end

        --// Update count
        function Playerlist:_updateCount()
            if self._countLabel then
                self._countLabel.Text = #Players:GetPlayers() .. "/" .. Players.MaxPlayers
            end
        end

        --// Refresh list
        function Playerlist:Refresh()
            -- Clear existing
            for _, item in pairs(self._playerItems) do
                item:Destroy()
            end
            self._playerItems = {}

            -- Repopulate
            self:_populatePlayers()
            self:_updateCount()

            return self
        end

        --// Toggle visibility
        function Playerlist:Toggle()
            self.Instance.Visible = not self.Instance.Visible
            return self
        end

        --// Destroy
        function Playerlist:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return Playerlist


    end


    -- ============================================================================
    -- Module: NexusUI/Special/Killfeed
    -- ============================================================================
    NexusUI_Modules["NexusUI/Special/Killfeed"] = function()
        local script = CreateMockScript("NexusUI/Special/Killfeed")

        --[[
            NexusUI Killfeed Component
            Kill notification feed display
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Killfeed Module
        local Killfeed = {}
        Killfeed.__index = Killfeed
        Killfeed.ClassName = "Killfeed"

        --// Constructor
        function Killfeed.new(config)
            local self = setmetatable({}, Killfeed)

            config = config or {}

            self.MaxEntries = config.MaxEntries or 5
            self.EntryDuration = config.EntryDuration or 5
            self.Position = config.Position or "TopRight"
            self.ShowWeapon = config.ShowWeapon ~= false
            self.ShowHeadshot = config.ShowHeadshot or false
            self.Animated = config.Animated ~= false

            -- Colors
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(18, 18, 21)
            self.KillerColor = config.KillerColor or Color3.fromRGB(239, 68, 68)
            self.VictimColor = config.VictimColor or Color3.fromRGB(161, 161, 170)
            self.SelfColor = config.SelfColor or Color3.fromRGB(99, 102, 241)

            -- State
            self._entries = {}
            self._connections = {}

            return self
        end

        --// Get position config
        function Killfeed:_getPositionConfig()
            local positions = {
                TopRight = {
                    Position = UDim2.new(1, -10, 0, 100),
                    AnchorPoint = Vector2.new(1, 0),
                },
                TopLeft = {
                    Position = UDim2.new(0, 10, 0, 100),
                    AnchorPoint = Vector2.new(0, 0),
                },
                BottomRight = {
                    Position = UDim2.new(1, -10, 1, -100),
                    AnchorPoint = Vector2.new(1, 1),
                },
                BottomLeft = {
                    Position = UDim2.new(0, 10, 1, -100),
                    AnchorPoint = Vector2.new(0, 1),
                },
            }

            return positions[self.Position] or positions.TopRight
        end

        --// Create killfeed
        function Killfeed:Create(parent)
            local posConfig = self:_getPositionConfig()

            local killfeed = Instance.new("Frame")
            killfeed.Name = "Killfeed"
            killfeed.Size = UDim2.new(0, 250, 0, 0)
            killfeed.AutomaticSize = Enum.AutomaticSize.Y
            killfeed.Position = posConfig.Position
            killfeed.AnchorPoint = posConfig.AnchorPoint
            killfeed.BackgroundTransparency = 1

            if parent then
                killfeed.Parent = parent
            end

            self.Instance = killfeed

            local layout = Instance.new("UIListLayout")
            layout.Padding = UDim.new(0, 4)
            layout.VerticalAlignment = string.find(self.Position, "Bottom") and Enum.VerticalAlignment.Bottom or Enum.VerticalAlignment.Top
            layout.SortOrder = Enum.SortOrder.LayoutOrder
            layout.Parent = killfeed

            return self
        end

        --// Add kill entry
        function Killfeed:AddKill(killer, victim, weapon, isHeadshot)
            local localPlayer = game:GetService("Players").LocalPlayer

            local entry = Instance.new("Frame")
            entry.Name = "KillEntry"
            entry.Size = UDim2.new(1, 0, 0, 26)
            entry.BackgroundColor3 = self.BackgroundColor
            entry.BackgroundTransparency = 0.2
            entry.BorderSizePixel = 0
            entry.LayoutOrder = #self._entries + 1
            entry.Parent = self.Instance

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 6)
            corner.Parent = entry

            local padding = Instance.new("UIPadding")
            padding.PaddingLeft = UDim.new(0, 10)
            padding.PaddingRight = UDim.new(0, 10)
            padding.Parent = entry

            -- Content container
            local content = Instance.new("Frame")
            content.Size = UDim2.new(1, 0, 1, 0)
            content.BackgroundTransparency = 1
            content.Parent = entry

            local contentLayout = Instance.new("UIListLayout")
            contentLayout.FillDirection = Enum.FillDirection.Horizontal
            contentLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            contentLayout.Padding = UDim.new(0, 6)
            contentLayout.Parent = content

            -- Killer name
            local killerColor = killer == localPlayer.Name and self.SelfColor or self.KillerColor
            local killerLabel = Instance.new("TextLabel")
            killerLabel.Size = UDim2.new(0, 0, 1, 0)
            killerLabel.AutomaticSize = Enum.AutomaticSize.X
            killerLabel.BackgroundTransparency = 1
            killerLabel.Font = Enum.Font.GothamMedium
            killerLabel.Text = killer
            killerLabel.TextColor3 = killerColor
            killerLabel.TextSize = 12
            killerLabel.LayoutOrder = 1
            killerLabel.Parent = content

            -- Weapon/kill icon
            if self.ShowWeapon and weapon then
                local weaponLabel = Instance.new("TextLabel")
                weaponLabel.Size = UDim2.new(0, 0, 1, 0)
                weaponLabel.AutomaticSize = Enum.AutomaticSize.X
                weaponLabel.BackgroundTransparency = 1
                weaponLabel.Font = Enum.Font.Gotham
                weaponLabel.Text = "[" .. weapon .. "]"
                weaponLabel.TextColor3 = Color3.fromRGB(113, 113, 122)
                weaponLabel.TextSize = 10
                weaponLabel.LayoutOrder = 2
                weaponLabel.Parent = content
            else
                local arrow = Instance.new("TextLabel")
                arrow.Size = UDim2.new(0, 20, 1, 0)
                arrow.BackgroundTransparency = 1
                arrow.Font = Enum.Font.GothamBold
                arrow.Text = "→"
                arrow.TextColor3 = Color3.fromRGB(113, 113, 122)
                arrow.TextSize = 12
                arrow.LayoutOrder = 2
                arrow.Parent = content
            end

            -- Headshot indicator
            if self.ShowHeadshot and isHeadshot then
                local headshotIcon = Instance.new("TextLabel")
                headshotIcon.Size = UDim2.new(0, 16, 1, 0)
                headshotIcon.BackgroundTransparency = 1
                headshotIcon.Font = Enum.Font.GothamBold
                headshotIcon.Text = "◉"
                headshotIcon.TextColor3 = Color3.fromRGB(245, 158, 11)
                headshotIcon.TextSize = 10
                headshotIcon.LayoutOrder = 3
                headshotIcon.Parent = content
            end

            -- Victim name
            local victimColor = victim == localPlayer.Name and self.SelfColor or self.VictimColor
            local victimLabel = Instance.new("TextLabel")
            victimLabel.Size = UDim2.new(0, 0, 1, 0)
            victimLabel.AutomaticSize = Enum.AutomaticSize.X
            victimLabel.BackgroundTransparency = 1
            victimLabel.Font = Enum.Font.GothamMedium
            victimLabel.Text = victim
            victimLabel.TextColor3 = victimColor
            victimLabel.TextSize = 12
            victimLabel.LayoutOrder = 4
            victimLabel.Parent = content

            -- Animate in
            if self.Animated then
                entry.BackgroundTransparency = 1
                content.Position = UDim2.new(0.2, 0, 0, 0)

                TweenService:Create(entry, TweenInfo.new(0.2), {
                    BackgroundTransparency = 0.2,
                }):Play()

                TweenService:Create(content, TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {
                    Position = UDim2.new(0, 0, 0, 0),
                }):Play()
            end

            -- Store entry
            table.insert(self._entries, entry)

            -- Remove oldest if over limit
            while #self._entries > self.MaxEntries do
                local oldest = table.remove(self._entries, 1)
                self:_removeEntry(oldest)
            end

            -- Auto remove after duration
            task.delay(self.EntryDuration, function()
                for i, e in ipairs(self._entries) do
                    if e == entry then
                        table.remove(self._entries, i)
                        self:_removeEntry(entry)
                        break
                    end
                end
            end)

            return self
        end

        --// Remove entry with animation
        function Killfeed:_removeEntry(entry)
            if not entry or not entry.Parent then return end

            if self.Animated then
                TweenService:Create(entry, TweenInfo.new(0.15), {
                    BackgroundTransparency = 1,
                }):Play()

                task.delay(0.15, function()
                    if entry and entry.Parent then
                        entry:Destroy()
                    end
                end)
            else
                entry:Destroy()
            end
        end

        --// Clear all entries
        function Killfeed:Clear()
            for _, entry in ipairs(self._entries) do
                entry:Destroy()
            end
            self._entries = {}
            return self
        end

        --// Toggle visibility
        function Killfeed:Toggle()
            self.Instance.Visible = not self.Instance.Visible
            return self
        end

        --// Destroy
        function Killfeed:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return Killfeed


    end


    -- ============================================================================
    -- Module: NexusUI/Special/Minimap
    -- ============================================================================
    NexusUI_Modules["NexusUI/Special/Minimap"] = function()
        local script = CreateMockScript("NexusUI/Special/Minimap")

        --[[
            NexusUI Minimap Component
            Simple top-down minimap display
        ]]

        --// Services
        local RunService = game:GetService("RunService")
        local Players = game:GetService("Players")
        local Workspace = game:GetService("Workspace")

        --// Minimap Module
        local Minimap = {}
        Minimap.__index = Minimap
        Minimap.ClassName = "Minimap"

        --// Constructor
        function Minimap.new(config)
            local self = setmetatable({}, Minimap)

            config = config or {}

            self.Size = config.Size or 150
            self.Scale = config.Scale or 10 -- Studs per pixel
            self.ShowPlayers = config.ShowPlayers ~= false
            self.ShowTeam = config.ShowTeam ~= false
            self.ShowNames = config.ShowNames or false
            self.Rotation = config.Rotation ~= false -- Rotate with player
            self.Position = config.Position or "BottomLeft"

            -- Colors
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(18, 18, 21)
            self.BorderColor = config.BorderColor or Color3.fromRGB(39, 39, 42)
            self.SelfColor = config.SelfColor or Color3.fromRGB(99, 102, 241)
            self.EnemyColor = config.EnemyColor or Color3.fromRGB(239, 68, 68)
            self.TeamColor = config.TeamColor or Color3.fromRGB(34, 197, 94)

            -- State
            self._markers = {}
            self._connections = {}

            return self
        end

        --// Get position config
        function Minimap:_getPositionConfig()
            local positions = {
                TopRight = {
                    Position = UDim2.new(1, -10, 0, 10),
                    AnchorPoint = Vector2.new(1, 0),
                },
                TopLeft = {
                    Position = UDim2.new(0, 10, 0, 10),
                    AnchorPoint = Vector2.new(0, 0),
                },
                BottomRight = {
                    Position = UDim2.new(1, -10, 1, -10),
                    AnchorPoint = Vector2.new(1, 1),
                },
                BottomLeft = {
                    Position = UDim2.new(0, 10, 1, -10),
                    AnchorPoint = Vector2.new(0, 1),
                },
            }

            return positions[self.Position] or positions.BottomLeft
        end

        --// Create minimap
        function Minimap:Create(parent)
            local posConfig = self:_getPositionConfig()

            local minimap = Instance.new("Frame")
            minimap.Name = "Minimap"
            minimap.Size = UDim2.new(0, self.Size, 0, self.Size)
            minimap.Position = posConfig.Position
            minimap.AnchorPoint = posConfig.AnchorPoint
            minimap.BackgroundColor3 = self.BackgroundColor
            minimap.BorderSizePixel = 0

            if parent then
                minimap.Parent = parent
            end

            self.Instance = minimap

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = minimap

            local stroke = Instance.new("UIStroke")
            stroke.Color = self.BorderColor
            stroke.Thickness = 2
            stroke.Parent = minimap

            -- Map container (clips markers)
            local mapContainer = Instance.new("Frame")
            mapContainer.Name = "MapContainer"
            mapContainer.Size = UDim2.new(1, -8, 1, -8)
            mapContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
            mapContainer.AnchorPoint = Vector2.new(0.5, 0.5)
            mapContainer.BackgroundTransparency = 1
            mapContainer.ClipsDescendants = true
            mapContainer.Parent = minimap
            self._mapContainer = mapContainer

            local mapCorner = Instance.new("UICorner")
            mapCorner.CornerRadius = UDim.new(0, 6)
            mapCorner.Parent = mapContainer

            -- Self marker (center)
            local selfMarker = Instance.new("Frame")
            selfMarker.Name = "SelfMarker"
            selfMarker.Size = UDim2.new(0, 10, 0, 10)
            selfMarker.Position = UDim2.new(0.5, 0, 0.5, 0)
            selfMarker.AnchorPoint = Vector2.new(0.5, 0.5)
            selfMarker.BackgroundColor3 = self.SelfColor
            selfMarker.BorderSizePixel = 0
            selfMarker.ZIndex = 10
            selfMarker.Parent = mapContainer
            self._selfMarker = selfMarker

            local selfCorner = Instance.new("UICorner")
            selfCorner.CornerRadius = UDim.new(1, 0)
            selfCorner.Parent = selfMarker

            -- Direction indicator
            local directionIndicator = Instance.new("Frame")
            directionIndicator.Size = UDim2.new(0, 0, 0, 0)
            directionIndicator.Position = UDim2.new(0.5, 0, 0, -2)
            directionIndicator.AnchorPoint = Vector2.new(0.5, 1)
            directionIndicator.BackgroundTransparency = 1
            directionIndicator.BorderSizePixel = 0
            directionIndicator.Parent = selfMarker

            local arrow = Instance.new("ImageLabel")
            arrow.Size = UDim2.new(0, 8, 0, 8)
            arrow.BackgroundTransparency = 1
            arrow.Image = "rbxassetid://7072723678" -- Triangle/arrow
            arrow.ImageColor3 = self.SelfColor
            arrow.Rotation = 0
            arrow.Parent = directionIndicator
            self._directionArrow = arrow

            -- Compass
            local compassLabels = {"N", "E", "S", "W"}
            local compassPositions = {
                {0.5, 0.05}, {0.95, 0.5}, {0.5, 0.95}, {0.05, 0.5}
            }

            for i, label in ipairs(compassLabels) do
                local compassLabel = Instance.new("TextLabel")
                compassLabel.Size = UDim2.new(0, 16, 0, 16)
                compassLabel.Position = UDim2.new(compassPositions[i][1], 0, compassPositions[i][2], 0)
                compassLabel.AnchorPoint = Vector2.new(0.5, 0.5)
                compassLabel.BackgroundTransparency = 1
                compassLabel.Font = Enum.Font.GothamBold
                compassLabel.Text = label
                compassLabel.TextColor3 = Color3.fromRGB(82, 82, 91)
                compassLabel.TextSize = 10
                compassLabel.ZIndex = 5
                compassLabel.Parent = mapContainer
            end

            -- Start update loop
            self:Start()

            return self
        end

        --// Start updating
        function Minimap:Start()
            -- Update loop
            local connection = RunService.Heartbeat:Connect(function()
                self:_update()
            end)
            table.insert(self._connections, connection)

            -- Player events
            table.insert(self._connections, Players.PlayerAdded:Connect(function(player)
                -- Will be handled by update
            end))

            table.insert(self._connections, Players.PlayerRemoving:Connect(function(player)
                self:_removeMarker(player)
            end))

            return self
        end

        --// Stop updating
        function Minimap:Stop()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}
            return self
        end

        --// Update minimap
        function Minimap:_update()
            local localPlayer = Players.LocalPlayer
            local localCharacter = localPlayer and localPlayer.Character
            local localRoot = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")

            if not localRoot then return end

            local localPos = localRoot.Position
            local localRotation = localRoot.CFrame:ToEulerAnglesYXZ()

            -- Update self rotation
            if self.Rotation then
                -- Map rotates with player
                -- (Implementation would rotate the container)
            end

            -- Update player markers
            if self.ShowPlayers then
                for _, player in ipairs(Players:GetPlayers()) do
                    if player == localPlayer then continue end

                    local character = player.Character
                    local rootPart = character and character:FindFirstChild("HumanoidRootPart")
                    local humanoid = character and character:FindFirstChild("Humanoid")

                    if not rootPart or not humanoid or humanoid.Health <= 0 then
                        self:_removeMarker(player)
                        continue
                    end

                    -- Calculate relative position
                    local relativePos = rootPart.Position - localPos
                    local mapX = relativePos.X / self.Scale
                    local mapZ = relativePos.Z / self.Scale

                    -- Check if within map bounds
                    local maxDist = self.Size / 2 - 10
                    local dist = math.sqrt(mapX^2 + mapZ^2)

                    if dist > maxDist then
                        -- Clamp to edge
                        local ratio = maxDist / dist
                        mapX = mapX * ratio
                        mapZ = mapZ * ratio
                    end

                    -- Get or create marker
                    local marker = self._markers[player.UserId]
                    if not marker then
                        marker = self:_createMarker(player)
                        self._markers[player.UserId] = marker
                    end

                    -- Update marker position
                    marker.Position = UDim2.new(0.5, mapX, 0.5, mapZ)
                    marker.Visible = true

                    -- Update color based on team
                    if self.ShowTeam and player.Team then
                        local isFriendly = localPlayer.Team and player.Team == localPlayer.Team
                        marker.BackgroundColor3 = isFriendly and self.TeamColor or self.EnemyColor
                    else
                        marker.BackgroundColor3 = self.EnemyColor
                    end
                end
            end
        end

        --// Create player marker
        function Minimap:_createMarker(player)
            local marker = Instance.new("Frame")
            marker.Name = "Marker_" .. player.UserId
            marker.Size = UDim2.new(0, 6, 0, 6)
            marker.AnchorPoint = Vector2.new(0.5, 0.5)
            marker.BackgroundColor3 = self.EnemyColor
            marker.BorderSizePixel = 0
            marker.ZIndex = 5
            marker.Parent = self._mapContainer

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(1, 0)
            corner.Parent = marker

            return marker
        end

        --// Remove player marker
        function Minimap:_removeMarker(player)
            local marker = self._markers[player.UserId]
            if marker then
                marker:Destroy()
                self._markers[player.UserId] = nil
            end
        end

        --// Set scale
        function Minimap:SetScale(scale)
            self.Scale = scale
            return self
        end

        --// Toggle visibility
        function Minimap:Toggle()
            self.Instance.Visible = not self.Instance.Visible
            return self
        end

        --// Destroy
        function Minimap:Destroy()
            self:Stop()

            for _, marker in pairs(self._markers) do
                marker:Destroy()
            end
            self._markers = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return Minimap


    end


    -- ============================================================================
    -- Module: NexusUI/Special/Spectate
    -- ============================================================================
    NexusUI_Modules["NexusUI/Special/Spectate"] = function()
        local script = CreateMockScript("NexusUI/Special/Spectate")

        --[[
            NexusUI Spectate Component
            Player spectating system
        ]]

        --// Services
        local RunService = game:GetService("RunService")
        local Players = game:GetService("Players")
        local Workspace = game:GetService("Workspace")
        local UserInputService = game:GetService("UserInputService")
        local TweenService = game:GetService("TweenService")

        --// Spectate Module
        local Spectate = {}
        Spectate.__index = Spectate
        Spectate.ClassName = "Spectate"

        --// Constructor
        function Spectate.new(config)
            local self = setmetatable({}, Spectate)

            config = config or {}

            self.ShowUI = config.ShowUI ~= false
            self.ShowHealth = config.ShowHealth ~= false
            self.ShowControls = config.ShowControls ~= false
            self.AutoCycle = config.AutoCycle or false
            self.CycleDelay = config.CycleDelay or 10

            -- Colors
            self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(18, 18, 21)
            self.TextColor = config.TextColor or Color3.fromRGB(250, 250, 250)
            self.AccentColor = config.AccentColor or Color3.fromRGB(99, 102, 241)

            -- Callbacks
            self.OnSpectate = config.OnSpectate
            self.OnStopSpectate = config.OnStopSpectate

            -- State
            self._spectating = nil
            self._originalCamera = nil
            self._connections = {}

            return self
        end

        --// Create UI
        function Spectate:Create(parent)
            if not self.ShowUI then
                return self
            end

            local spectateUI = Instance.new("Frame")
            spectateUI.Name = "SpectateUI"
            spectateUI.Size = UDim2.new(0, 300, 0, 50)
            spectateUI.Position = UDim2.new(0.5, 0, 0, 60)
            spectateUI.AnchorPoint = Vector2.new(0.5, 0)
            spectateUI.BackgroundColor3 = self.BackgroundColor
            spectateUI.BackgroundTransparency = 0.2
            spectateUI.BorderSizePixel = 0
            spectateUI.Visible = false

            if parent then
                spectateUI.Parent = parent
            end

            self.Instance = spectateUI

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 10)
            corner.Parent = spectateUI

            local padding = Instance.new("UIPadding")
            padding.PaddingLeft = UDim.new(0, 15)
            padding.PaddingRight = UDim.new(0, 15)
            padding.Parent = spectateUI

            -- Spectating label
            local label = Instance.new("TextLabel")
            label.Name = "Label"
            label.Size = UDim2.new(1, 0, 0, 18)
            label.Position = UDim2.new(0, 0, 0, 8)
            label.BackgroundTransparency = 1
            label.Font = Enum.Font.Gotham
            label.Text = "SPECTATING"
            label.TextColor3 = self.AccentColor
            label.TextSize = 10
            label.TextXAlignment = Enum.TextXAlignment.Center
            label.Parent = spectateUI

            -- Player name
            local playerName = Instance.new("TextLabel")
            playerName.Name = "PlayerName"
            playerName.Size = UDim2.new(1, 0, 0, 22)
            playerName.Position = UDim2.new(0, 0, 0, 24)
            playerName.BackgroundTransparency = 1
            playerName.Font = Enum.Font.GothamBold
            playerName.Text = "Player Name"
            playerName.TextColor3 = self.TextColor
            playerName.TextSize = 16
            playerName.TextXAlignment = Enum.TextXAlignment.Center
            playerName.Parent = spectateUI
            self._nameLabel = playerName

            -- Controls
            if self.ShowControls then
                local controls = Instance.new("Frame")
                controls.Size = UDim2.new(0, 120, 0, 28)
                controls.Position = UDim2.new(0.5, 0, 1, 10)
                controls.AnchorPoint = Vector2.new(0.5, 0)
                controls.BackgroundTransparency = 1
                controls.Parent = spectateUI

                local controlsLayout = Instance.new("UIListLayout")
                controlsLayout.FillDirection = Enum.FillDirection.Horizontal
                controlsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
                controlsLayout.Padding = UDim.new(0, 10)
                controlsLayout.Parent = controls

                -- Previous button
                local prevBtn = self:_createControlButton("<", controls, function()
                    self:Previous()
                end)

                -- Stop button
                local stopBtn = self:_createControlButton("×", controls, function()
                    self:StopSpectating()
                end)

                -- Next button
                local nextBtn = self:_createControlButton(">", controls, function()
                    self:Next()
                end)
            end

            return self
        end

        --// Create control button
        function Spectate:_createControlButton(text, parent, callback)
            local btn = Instance.new("TextButton")
            btn.Size = UDim2.new(0, 28, 0, 28)
            btn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
            btn.BorderSizePixel = 0
            btn.Font = Enum.Font.GothamBold
            btn.Text = text
            btn.TextColor3 = self.TextColor
            btn.TextSize = 16
            btn.AutoButtonColor = false
            btn.Parent = parent

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 6)
            corner.Parent = btn

            table.insert(self._connections, btn.MouseButton1Click:Connect(callback))

            table.insert(self._connections, btn.MouseEnter:Connect(function()
                TweenService:Create(btn, TweenInfo.new(0.1), {
                    BackgroundColor3 = self.AccentColor,
                }):Play()
            end))

            table.insert(self._connections, btn.MouseLeave:Connect(function()
                TweenService:Create(btn, TweenInfo.new(0.1), {
                    BackgroundColor3 = Color3.fromRGB(39, 39, 42),
                }):Play()
            end))

            return btn
        end

        --// Get spectatable players
        function Spectate:_getSpectatablePlayers()
            local players = {}
            local localPlayer = Players.LocalPlayer

            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= localPlayer then
                    local character = player.Character
                    local humanoid = character and character:FindFirstChild("Humanoid")

                    if humanoid and humanoid.Health > 0 then
                        table.insert(players, player)
                    end
                end
            end

            return players
        end

        --// Start spectating a player
        function Spectate:SpectatePlayer(player)
            if not player or player == Players.LocalPlayer then return self end

            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")

            if not character or not humanoid or humanoid.Health <= 0 then
                return self
            end

            -- Store original camera settings
            if not self._spectating then
                self._originalCamera = {
                    CameraType = Workspace.CurrentCamera.CameraType,
                    CameraSubject = Workspace.CurrentCamera.CameraSubject,
                }
            end

            -- Set camera to spectate
            Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
            Workspace.CurrentCamera.CameraSubject = humanoid

            self._spectating = player

            -- Update UI
            if self.Instance then
                self.Instance.Visible = true
                if self._nameLabel then
                    self._nameLabel.Text = player.DisplayName
                end
            end

            -- Callback
            if self.OnSpectate then
                self.OnSpectate(player)
            end

            -- Watch for death
            local connection
            connection = humanoid.Died:Connect(function()
                connection:Disconnect()
                if self._spectating == player then
                    self:Next()
                end
            end)
            table.insert(self._connections, connection)

            return self
        end

        --// Stop spectating
        function Spectate:StopSpectating()
            if not self._spectating then return self end

            -- Restore camera
            if self._originalCamera then
                local localPlayer = Players.LocalPlayer
                local character = localPlayer and localPlayer.Character
                local humanoid = character and character:FindFirstChild("Humanoid")

                Workspace.CurrentCamera.CameraType = self._originalCamera.CameraType
                Workspace.CurrentCamera.CameraSubject = humanoid or self._originalCamera.CameraSubject
            end

            local previousTarget = self._spectating
            self._spectating = nil
            self._originalCamera = nil

            -- Update UI
            if self.Instance then
                self.Instance.Visible = false
            end

            -- Callback
            if self.OnStopSpectate then
                self.OnStopSpectate(previousTarget)
            end

            return self
        end

        --// Next player
        function Spectate:Next()
            local players = self:_getSpectatablePlayers()
            if #players == 0 then
                self:StopSpectating()
                return self
            end

            local currentIndex = 1
            if self._spectating then
                for i, player in ipairs(players) do
                    if player == self._spectating then
                        currentIndex = i
                        break
                    end
                end
            end

            local nextIndex = currentIndex % #players + 1
            self:SpectatePlayer(players[nextIndex])

            return self
        end

        --// Previous player
        function Spectate:Previous()
            local players = self:_getSpectatablePlayers()
            if #players == 0 then
                self:StopSpectating()
                return self
            end

            local currentIndex = 1
            if self._spectating then
                for i, player in ipairs(players) do
                    if player == self._spectating then
                        currentIndex = i
                        break
                    end
                end
            end

            local prevIndex = (currentIndex - 2) % #players + 1
            self:SpectatePlayer(players[prevIndex])

            return self
        end

        --// Get current spectate target
        function Spectate:GetTarget()
            return self._spectating
        end

        --// Is spectating
        function Spectate:IsSpectating()
            return self._spectating ~= nil
        end

        --// Toggle (spectate first available or stop)
        function Spectate:Toggle()
            if self._spectating then
                self:StopSpectating()
            else
                local players = self:_getSpectatablePlayers()
                if #players > 0 then
                    self:SpectatePlayer(players[1])
                end
            end
            return self
        end

        --// Destroy
        function Spectate:Destroy()
            self:StopSpectating()

            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        return Spectate


    end


    -- ============================================================================
    -- Module: NexusUI/Special/init
    -- ============================================================================
    NexusUI_Modules["NexusUI/Special/init"] = function()
        local script = CreateMockScript("NexusUI/Special/init")

        --[[
            NexusUI Special Components Module
            Advanced executor-specific components
        ]]

        --// Special Components Module
        local Special = {}

        Special.Console = NexusRequire("NexusUI/Special/Console")
        Special.CodeEditor = NexusRequire("NexusUI/Special/CodeEditor")
        Special.Terminal = NexusRequire("NexusUI/Special/Terminal")
        Special.ESP = NexusRequire("NexusUI/Special/ESP")
        Special.Watermark = NexusRequire("NexusUI/Special/Watermark")
        Special.Crosshair = NexusRequire("NexusUI/Special/Crosshair")
        Special.Aimbot = NexusRequire("NexusUI/Special/Aimbot")
        Special.Playerlist = NexusRequire("NexusUI/Special/Playerlist")
        Special.Killfeed = NexusRequire("NexusUI/Special/Killfeed")
        Special.Minimap = NexusRequire("NexusUI/Special/Minimap")
        Special.Spectate = NexusRequire("NexusUI/Special/Spectate")

        return Special


    end


    -- ============================================================================
    -- Module: NexusUI/Features/Sound
    -- ============================================================================
    NexusUI_Modules["NexusUI/Features/Sound"] = function()
        local script = CreateMockScript("NexusUI/Features/Sound")

        --[[
            NexusUI Sound System
            UI sound effects management
        ]]

        --// Services
        local SoundService = game:GetService("SoundService")
        local TweenService = game:GetService("TweenService")

        --// Sound Module
        local Sound = {}
        Sound.__index = Sound
        Sound.ClassName = "SoundSystem"

        --// Sound packs
        local SoundPacks = {
            Default = {
                Click = "rbxassetid://6895079853",
                Hover = "rbxassetid://6895079949",
                Toggle = "rbxassetid://6895079707",
                Success = "rbxassetid://6026984224",
                Error = "rbxassetid://5356081124",
                Warning = "rbxassetid://4590657391",
                Notification = "rbxassetid://4590657391",
                Open = "rbxassetid://6895079586",
                Close = "rbxassetid://6895079453",
                Slide = "rbxassetid://6895079628",
                Type = "rbxassetid://6895079776",
            },
            Minimal = {
                Click = "rbxassetid://6895079853",
                Hover = "",
                Toggle = "rbxassetid://6895079707",
                Success = "",
                Error = "",
                Warning = "",
                Notification = "rbxassetid://4590657391",
                Open = "",
                Close = "",
                Slide = "",
                Type = "",
            },
            Gaming = {
                Click = "rbxassetid://6895079853",
                Hover = "rbxassetid://6895079949",
                Toggle = "rbxassetid://6895079707",
                Success = "rbxassetid://6026984224",
                Error = "rbxassetid://5356081124",
                Warning = "rbxassetid://4590657391",
                Notification = "rbxassetid://4590657391",
                Open = "rbxassetid://6895079586",
                Close = "rbxassetid://6895079453",
                Slide = "rbxassetid://6895079628",
                Type = "rbxassetid://6895079776",
            },
            Retro = {
                Click = "rbxassetid://6895079853",
                Hover = "rbxassetid://6895079949",
                Toggle = "rbxassetid://6895079707",
                Success = "rbxassetid://6026984224",
                Error = "rbxassetid://5356081124",
                Warning = "rbxassetid://4590657391",
                Notification = "rbxassetid://4590657391",
                Open = "rbxassetid://6895079586",
                Close = "rbxassetid://6895079453",
                Slide = "rbxassetid://6895079628",
                Type = "rbxassetid://6895079776",
            },
            Silent = {
                Click = "",
                Hover = "",
                Toggle = "",
                Success = "",
                Error = "",
                Warning = "",
                Notification = "",
                Open = "",
                Close = "",
                Slide = "",
                Type = "",
            },
        }

        --// Default volumes
        local DefaultVolumes = {
            Click = 0.3,
            Hover = 0.15,
            Toggle = 0.25,
            Success = 0.4,
            Error = 0.4,
            Warning = 0.35,
            Notification = 0.4,
            Open = 0.25,
            Close = 0.2,
            Slide = 0.2,
            Type = 0.1,
        }

        --// Singleton instance
        local _instance = nil

        --// Constructor
        function Sound.new(config)
            if _instance then
                return _instance
            end

            local self = setmetatable({}, Sound)

            config = config or {}

            self.Enabled = config.Enabled ~= false
            self.MasterVolume = config.MasterVolume or 0.5
            self.CurrentPack = config.SoundPack or "Default"
            self.Volumes = config.Volumes or {}

            -- State
            self._sounds = {}
            self._soundGroup = nil

            -- Initialize
            self:_initialize()

            _instance = self

            return self
        end

        --// Get singleton instance
        function Sound.getInstance()
            if not _instance then
                _instance = Sound.new()
            end
            return _instance
        end

        --// Initialize sound system
        function Sound:_initialize()
            -- Create sound group
            self._soundGroup = Instance.new("SoundGroup")
            self._soundGroup.Name = "NexusUI_Sounds"
            self._soundGroup.Volume = self.MasterVolume
            self._soundGroup.Parent = SoundService

            -- Pre-create sound instances for quick playback
            for soundName, soundId in pairs(SoundPacks[self.CurrentPack] or SoundPacks.Default) do
                if soundId and soundId ~= "" then
                    local sound = Instance.new("Sound")
                    sound.Name = soundName
                    sound.SoundId = soundId
                    sound.Volume = DefaultVolumes[soundName] or 0.3
                    sound.SoundGroup = self._soundGroup
                    sound.Parent = self._soundGroup
                    self._sounds[soundName] = sound
                end
            end
        end

        --// Play sound
        function Sound:Play(soundName, volume, pitch)
            if not self.Enabled then return end

            local sound = self._sounds[soundName]
            if not sound then
                -- Check if sound exists in current pack
                local pack = SoundPacks[self.CurrentPack] or SoundPacks.Default
                local soundId = pack[soundName]

                if not soundId or soundId == "" then return end

                -- Create new sound instance
                sound = Instance.new("Sound")
                sound.Name = soundName
                sound.SoundId = soundId
                sound.Volume = DefaultVolumes[soundName] or 0.3
                sound.SoundGroup = self._soundGroup
                sound.Parent = self._soundGroup
                self._sounds[soundName] = sound
            end

            -- Apply overrides
            local originalVolume = sound.Volume
            local originalPitch = sound.PlaybackSpeed

            if volume then
                sound.Volume = volume * self.MasterVolume
            else
                sound.Volume = (self.Volumes[soundName] or DefaultVolumes[soundName] or 0.3) * self.MasterVolume
            end

            if pitch then
                sound.PlaybackSpeed = pitch
            end

            -- Clone and play for overlapping sounds
            local clone = sound:Clone()
            clone.Parent = self._soundGroup
            clone:Play()

            -- Cleanup after play
            clone.Ended:Connect(function()
                clone:Destroy()
            end)

            -- Restore original values
            sound.Volume = originalVolume
            sound.PlaybackSpeed = originalPitch
        end

        --// Play click sound
        function Sound:Click()
            self:Play("Click")
        end

        --// Play hover sound
        function Sound:Hover()
            self:Play("Hover")
        end

        --// Play toggle sound
        function Sound:Toggle()
            self:Play("Toggle")
        end

        --// Play success sound
        function Sound:Success()
            self:Play("Success")
        end

        --// Play error sound
        function Sound:Error()
            self:Play("Error")
        end

        --// Play warning sound
        function Sound:Warning()
            self:Play("Warning")
        end

        --// Play notification sound
        function Sound:Notification()
            self:Play("Notification")
        end

        --// Play open sound
        function Sound:Open()
            self:Play("Open")
        end

        --// Play close sound
        function Sound:Close()
            self:Play("Close")
        end

        --// Play slide sound
        function Sound:Slide()
            self:Play("Slide")
        end

        --// Play type sound
        function Sound:Type()
            self:Play("Type")
        end

        --// Set sound pack
        function Sound:SetSoundPack(packName)
            if not SoundPacks[packName] then
                warn("[NexusUI Sound] Unknown sound pack:", packName)
                return self
            end

            self.CurrentPack = packName

            -- Clear existing sounds
            for _, sound in pairs(self._sounds) do
                sound:Destroy()
            end
            self._sounds = {}

            -- Re-initialize with new pack
            for soundName, soundId in pairs(SoundPacks[packName]) do
                if soundId and soundId ~= "" then
                    local sound = Instance.new("Sound")
                    sound.Name = soundName
                    sound.SoundId = soundId
                    sound.Volume = DefaultVolumes[soundName] or 0.3
                    sound.SoundGroup = self._soundGroup
                    sound.Parent = self._soundGroup
                    self._sounds[soundName] = sound
                end
            end

            return self
        end

        --// Get available sound packs
        function Sound:GetSoundPacks()
            local packs = {}
            for name in pairs(SoundPacks) do
                table.insert(packs, name)
            end
            return packs
        end

        --// Set master volume
        function Sound:SetMasterVolume(volume)
            self.MasterVolume = math.clamp(volume, 0, 1)
            if self._soundGroup then
                self._soundGroup.Volume = self.MasterVolume
            end
            return self
        end

        --// Set individual sound volume
        function Sound:SetSoundVolume(soundName, volume)
            self.Volumes[soundName] = math.clamp(volume, 0, 1)
            return self
        end

        --// Enable/disable sounds
        function Sound:SetEnabled(enabled)
            self.Enabled = enabled
            return self
        end

        --// Toggle sounds
        function Sound:Toggle()
            self.Enabled = not self.Enabled
            return self
        end

        --// Add custom sound pack
        function Sound:AddSoundPack(name, sounds)
            SoundPacks[name] = sounds
            return self
        end

        --// Destroy
        function Sound:Destroy()
            if self._soundGroup then
                self._soundGroup:Destroy()
                self._soundGroup = nil
            end

            self._sounds = {}
            _instance = nil
        end

        return Sound


    end


    -- ============================================================================
    -- Module: NexusUI/Features/Config
    -- ============================================================================
    NexusUI_Modules["NexusUI/Features/Config"] = function()
        local script = CreateMockScript("NexusUI/Features/Config")

        --[[
            NexusUI Config System
            Save and load configuration files
        ]]

        --// Services
        local HttpService = game:GetService("HttpService")
        local Players = game:GetService("Players")

        --// Config Module
        local Config = {}
        Config.__index = Config
        Config.ClassName = "ConfigSystem"

        --// Singleton instance
        local _instance = nil

        --// Constructor
        function Config.new(config)
            if _instance then
                return _instance
            end

            local self = setmetatable({}, Config)

            config = config or {}

            self.FolderName = config.FolderName or "NexusUI"
            self.ConfigFolder = config.ConfigFolder or "Configs"
            self.AutoSave = config.AutoSave or false
            self.AutoSaveInterval = config.AutoSaveInterval or 60
            self.CloudSync = config.CloudSync or false

            -- State
            self._configs = {}
            self._currentConfig = "Default"
            self._autoSaveConnection = nil
            self._callbacks = {}

            -- Initialize
            self:_initialize()

            _instance = self

            return self
        end

        --// Get singleton instance
        function Config.getInstance()
            if not _instance then
                _instance = Config.new()
            end
            return _instance
        end

        --// Initialize config system
        function Config:_initialize()
            -- Create folders if they don't exist
            pcall(function()
                if makefolder and not isfolder then
                    makefolder(self.FolderName)
                    makefolder(self.FolderName .. "/" .. self.ConfigFolder)
                elseif isfolder and not isfolder(self.FolderName) then
                    makefolder(self.FolderName)
                end

                if isfolder and not isfolder(self.FolderName .. "/" .. self.ConfigFolder) then
                    makefolder(self.FolderName .. "/" .. self.ConfigFolder)
                end
            end)

            -- Start auto-save if enabled
            if self.AutoSave then
                self:StartAutoSave()
            end
        end

        --// Get config file path
        function Config:_getPath(configName)
            return self.FolderName .. "/" .. self.ConfigFolder .. "/" .. configName .. ".json"
        end

        --// Save config
        function Config:Save(configName, data)
            configName = configName or self._currentConfig
            data = data or self._configs[configName] or {}

            local path = self:_getPath(configName)

            -- Add metadata
            local configData = {
                _metadata = {
                    name = configName,
                    savedAt = os.time(),
                    version = "1.0.0",
                    player = Players.LocalPlayer and Players.LocalPlayer.Name or "Unknown",
                },
                data = data,
            }

            local success, err = pcall(function()
                if writefile then
                    local json = HttpService:JSONEncode(configData)
                    writefile(path, json)
                else
                    warn("[NexusUI Config] writefile not available")
                end
            end)

            if success then
                self._configs[configName] = data
                self:_fireCallbacks("save", configName, data)
            else
                warn("[NexusUI Config] Failed to save config:", err)
            end

            return success
        end

        --// Load config
        function Config:Load(configName)
            configName = configName or self._currentConfig

            local path = self:_getPath(configName)

            local success, result = pcall(function()
                if readfile and isfile then
                    if isfile(path) then
                        local json = readfile(path)
                        return HttpService:JSONDecode(json)
                    end
                else
                    warn("[NexusUI Config] readfile/isfile not available")
                end
                return nil
            end)

            if success and result then
                local data = result.data or result
                self._configs[configName] = data
                self._currentConfig = configName
                self:_fireCallbacks("load", configName, data)
                return data
            else
                if not success then
                    warn("[NexusUI Config] Failed to load config:", result)
                end
            end

            return nil
        end

        --// Delete config
        function Config:Delete(configName)
            configName = configName or self._currentConfig

            local path = self:_getPath(configName)

            local success = pcall(function()
                if delfile and isfile then
                    if isfile(path) then
                        delfile(path)
                    end
                end
            end)

            if success then
                self._configs[configName] = nil
                self:_fireCallbacks("delete", configName)
            end

            return success
        end

        --// Get all configs
        function Config:GetConfigs()
            local configs = {}

            pcall(function()
                if listfiles and isfolder then
                    local folderPath = self.FolderName .. "/" .. self.ConfigFolder
                    if isfolder(folderPath) then
                        for _, file in ipairs(listfiles(folderPath)) do
                            local name = file:match("([^/\\]+)%.json$")
                            if name then
                                table.insert(configs, name)
                            end
                        end
                    end
                end
            end)

            return configs
        end

        --// Check if config exists
        function Config:Exists(configName)
            configName = configName or self._currentConfig
            local path = self:_getPath(configName)

            local exists = false
            pcall(function()
                if isfile then
                    exists = isfile(path)
                end
            end)

            return exists
        end

        --// Set value in current config
        function Config:Set(key, value)
            if not self._configs[self._currentConfig] then
                self._configs[self._currentConfig] = {}
            end

            -- Support nested keys (e.g., "settings.theme")
            local keys = {}
            for k in key:gmatch("[^%.]+") do
                table.insert(keys, k)
            end

            local current = self._configs[self._currentConfig]
            for i = 1, #keys - 1 do
                local k = keys[i]
                if type(current[k]) ~= "table" then
                    current[k] = {}
                end
                current = current[k]
            end

            current[keys[#keys]] = value
            self:_fireCallbacks("change", key, value)

            return self
        end

        --// Get value from current config
        function Config:Get(key, default)
            local data = self._configs[self._currentConfig]
            if not data then return default end

            -- Support nested keys
            local keys = {}
            for k in key:gmatch("[^%.]+") do
                table.insert(keys, k)
            end

            local current = data
            for _, k in ipairs(keys) do
                if type(current) ~= "table" then
                    return default
                end
                current = current[k]
            end

            return current ~= nil and current or default
        end

        --// Get all values in current config
        function Config:GetAll()
            return self._configs[self._currentConfig] or {}
        end

        --// Set current config
        function Config:SetCurrent(configName)
            self._currentConfig = configName
            return self
        end

        --// Get current config name
        function Config:GetCurrent()
            return self._currentConfig
        end

        --// Start auto-save
        function Config:StartAutoSave()
            if self._autoSaveConnection then return self end

            self._autoSaveConnection = task.spawn(function()
                while true do
                    task.wait(self.AutoSaveInterval)
                    if self._configs[self._currentConfig] then
                        self:Save()
                    end
                end
            end)

            return self
        end

        --// Stop auto-save
        function Config:StopAutoSave()
            if self._autoSaveConnection then
                task.cancel(self._autoSaveConnection)
                self._autoSaveConnection = nil
            end
            return self
        end

        --// Add callback
        function Config:OnChange(callback)
            table.insert(self._callbacks, callback)
            return #self._callbacks
        end

        --// Remove callback
        function Config:RemoveCallback(id)
            self._callbacks[id] = nil
        end

        --// Fire callbacks
        function Config:_fireCallbacks(event, ...)
            for _, callback in pairs(self._callbacks) do
                if callback then
                    pcall(callback, event, ...)
                end
            end
        end

        --// Export config to string
        function Config:Export(configName)
            configName = configName or self._currentConfig
            local data = self._configs[configName]

            if data then
                local success, json = pcall(function()
                    return HttpService:JSONEncode(data)
                end)

                if success then
                    return json
                end
            end

            return nil
        end

        --// Import config from string
        function Config:Import(configName, jsonString)
            local success, data = pcall(function()
                return HttpService:JSONDecode(jsonString)
            end)

            if success and data then
                self._configs[configName] = data
                self:Save(configName, data)
                return true
            end

            return false
        end

        --// Destroy
        function Config:Destroy()
            self:StopAutoSave()
            self._configs = {}
            self._callbacks = {}
            _instance = nil
        end

        return Config


    end


    -- ============================================================================
    -- Module: NexusUI/Features/Hotkey
    -- ============================================================================
    NexusUI_Modules["NexusUI/Features/Hotkey"] = function()
        local script = CreateMockScript("NexusUI/Features/Hotkey")

        --[[
            NexusUI Hotkey System
            Global hotkey/keybind management
        ]]

        --// Services
        local UserInputService = game:GetService("UserInputService")
        local RunService = game:GetService("RunService")

        --// Hotkey Module
        local Hotkey = {}
        Hotkey.__index = Hotkey
        Hotkey.ClassName = "HotkeySystem"

        --// Key name mappings
        local KeyNames = {
            [Enum.KeyCode.LeftControl] = "LCtrl",
            [Enum.KeyCode.RightControl] = "RCtrl",
            [Enum.KeyCode.LeftShift] = "LShift",
            [Enum.KeyCode.RightShift] = "RShift",
            [Enum.KeyCode.LeftAlt] = "LAlt",
            [Enum.KeyCode.RightAlt] = "RAlt",
            [Enum.KeyCode.Tab] = "Tab",
            [Enum.KeyCode.Space] = "Space",
            [Enum.KeyCode.Return] = "Enter",
            [Enum.KeyCode.Backspace] = "Back",
            [Enum.KeyCode.Delete] = "Del",
            [Enum.KeyCode.Insert] = "Ins",
            [Enum.KeyCode.Home] = "Home",
            [Enum.KeyCode.End] = "End",
            [Enum.KeyCode.PageUp] = "PgUp",
            [Enum.KeyCode.PageDown] = "PgDn",
            [Enum.KeyCode.Up] = "↑",
            [Enum.KeyCode.Down] = "↓",
            [Enum.KeyCode.Left] = "←",
            [Enum.KeyCode.Right] = "→",
            [Enum.KeyCode.Escape] = "Esc",
            [Enum.KeyCode.CapsLock] = "Caps",
            [Enum.KeyCode.Tilde] = "~",
        }

        --// Singleton instance
        local _instance = nil

        --// Constructor
        function Hotkey.new(config)
            if _instance then
                return _instance
            end

            local self = setmetatable({}, Hotkey)

            config = config or {}

            self.Enabled = config.Enabled ~= false
            self.AllowInTextbox = config.AllowInTextbox or false

            -- State
            self._bindings = {}
            self._holdBindings = {}
            self._combos = {}
            self._heldKeys = {}
            self._connections = {}

            -- Initialize
            self:_initialize()

            _instance = self

            return self
        end

        --// Get singleton instance
        function Hotkey.getInstance()
            if not _instance then
                _instance = Hotkey.new()
            end
            return _instance
        end

        --// Initialize hotkey system
        function Hotkey:_initialize()
            -- Input began
            local inputBeganConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                if not self.Enabled then return end

                -- Check if in textbox
                if gameProcessed and not self.AllowInTextbox then
                    local focused = UserInputService:GetFocusedTextBox()
                    if focused then return end
                end

                -- Handle keyboard
                if input.UserInputType == Enum.UserInputType.Keyboard then
                    self._heldKeys[input.KeyCode] = true
                    self:_checkBindings(input.KeyCode, true)
                    self:_checkCombos()
                end

                -- Handle mouse
                if input.UserInputType == Enum.UserInputType.MouseButton1 or
                   input.UserInputType == Enum.UserInputType.MouseButton2 or
                   input.UserInputType == Enum.UserInputType.MouseButton3 then
                    self:_checkMouseBindings(input.UserInputType, true)
                end
            end)
            table.insert(self._connections, inputBeganConnection)

            -- Input ended
            local inputEndedConnection = UserInputService.InputEnded:Connect(function(input, gameProcessed)
                if not self.Enabled then return end

                if input.UserInputType == Enum.UserInputType.Keyboard then
                    self._heldKeys[input.KeyCode] = nil
                    self:_checkBindings(input.KeyCode, false)
                end

                if input.UserInputType == Enum.UserInputType.MouseButton1 or
                   input.UserInputType == Enum.UserInputType.MouseButton2 or
                   input.UserInputType == Enum.UserInputType.MouseButton3 then
                    self:_checkMouseBindings(input.UserInputType, false)
                end
            end)
            table.insert(self._connections, inputEndedConnection)
        end

        --// Check bindings
        function Hotkey:_checkBindings(keyCode, pressed)
            local binding = self._bindings[keyCode]
            if binding then
                if pressed then
                    if binding.callback then
                        pcall(binding.callback)
                    end
                end
            end

            -- Check hold bindings
            local holdBinding = self._holdBindings[keyCode]
            if holdBinding then
                if pressed then
                    if holdBinding.onPress then
                        pcall(holdBinding.onPress)
                    end
                else
                    if holdBinding.onRelease then
                        pcall(holdBinding.onRelease)
                    end
                end
            end
        end

        --// Check mouse bindings
        function Hotkey:_checkMouseBindings(inputType, pressed)
            local binding = self._bindings[inputType]
            if binding then
                if pressed then
                    if binding.callback then
                        pcall(binding.callback)
                    end
                end
            end
        end

        --// Check combo bindings
        function Hotkey:_checkCombos()
            for _, combo in pairs(self._combos) do
                local allPressed = true
                for _, key in ipairs(combo.keys) do
                    if not self._heldKeys[key] then
                        allPressed = false
                        break
                    end
                end

                if allPressed then
                    if combo.callback then
                        pcall(combo.callback)
                    end
                end
            end
        end

        --// Bind key
        function Hotkey:Bind(key, callback, id)
            if type(key) == "string" then
                key = Enum.KeyCode[key]
            end

            id = id or tostring(key)

            self._bindings[key] = {
                id = id,
                key = key,
                callback = callback,
            }

            return id
        end

        --// Bind hold key (separate press/release)
        function Hotkey:BindHold(key, onPress, onRelease, id)
            if type(key) == "string" then
                key = Enum.KeyCode[key]
            end

            id = id or tostring(key) .. "_hold"

            self._holdBindings[key] = {
                id = id,
                key = key,
                onPress = onPress,
                onRelease = onRelease,
            }

            return id
        end

        --// Bind key combo (e.g., Ctrl+Shift+K)
        function Hotkey:BindCombo(keys, callback, id)
            local keyList = {}
            for _, key in ipairs(keys) do
                if type(key) == "string" then
                    key = Enum.KeyCode[key]
                end
                table.insert(keyList, key)
            end

            id = id or table.concat(keys, "+")

            self._combos[id] = {
                id = id,
                keys = keyList,
                callback = callback,
            }

            return id
        end

        --// Unbind key
        function Hotkey:Unbind(key)
            if type(key) == "string" then
                -- Check if it's a combo ID
                if self._combos[key] then
                    self._combos[key] = nil
                    return true
                end

                key = Enum.KeyCode[key]
            end

            self._bindings[key] = nil
            self._holdBindings[key] = nil

            return true
        end

        --// Unbind combo
        function Hotkey:UnbindCombo(id)
            self._combos[id] = nil
            return true
        end

        --// Clear all bindings
        function Hotkey:ClearAll()
            self._bindings = {}
            self._holdBindings = {}
            self._combos = {}
            return self
        end

        --// Check if key is held
        function Hotkey:IsKeyHeld(key)
            if type(key) == "string" then
                key = Enum.KeyCode[key]
            end
            return self._heldKeys[key] == true
        end

        --// Check if modifier is held
        function Hotkey:IsCtrlHeld()
            return self._heldKeys[Enum.KeyCode.LeftControl] or self._heldKeys[Enum.KeyCode.RightControl]
        end

        function Hotkey:IsShiftHeld()
            return self._heldKeys[Enum.KeyCode.LeftShift] or self._heldKeys[Enum.KeyCode.RightShift]
        end

        function Hotkey:IsAltHeld()
            return self._heldKeys[Enum.KeyCode.LeftAlt] or self._heldKeys[Enum.KeyCode.RightAlt]
        end

        --// Get key name
        function Hotkey:GetKeyName(key)
            if type(key) == "string" then
                return key
            end

            return KeyNames[key] or key.Name
        end

        --// Get all bindings
        function Hotkey:GetBindings()
            local bindings = {}

            for key, binding in pairs(self._bindings) do
                table.insert(bindings, {
                    key = key,
                    id = binding.id,
                    type = "press",
                })
            end

            for key, binding in pairs(self._holdBindings) do
                table.insert(bindings, {
                    key = key,
                    id = binding.id,
                    type = "hold",
                })
            end

            for id, combo in pairs(self._combos) do
                table.insert(bindings, {
                    keys = combo.keys,
                    id = id,
                    type = "combo",
                })
            end

            return bindings
        end

        --// Set enabled
        function Hotkey:SetEnabled(enabled)
            self.Enabled = enabled
            return self
        end

        --// Toggle
        function Hotkey:Toggle()
            self.Enabled = not self.Enabled
            return self
        end

        --// Destroy
        function Hotkey:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            self._bindings = {}
            self._holdBindings = {}
            self._combos = {}
            self._heldKeys = {}

            _instance = nil
        end

        return Hotkey


    end


    -- ============================================================================
    -- Module: NexusUI/Features/DragDrop
    -- ============================================================================
    NexusUI_Modules["NexusUI/Features/DragDrop"] = function()
        local script = CreateMockScript("NexusUI/Features/DragDrop")

        --[[
            NexusUI Drag and Drop System
            Dragging and dropping UI elements
        ]]

        --// Services
        local UserInputService = game:GetService("UserInputService")
        local TweenService = game:GetService("TweenService")

        --// DragDrop Module
        local DragDrop = {}
        DragDrop.__index = DragDrop
        DragDrop.ClassName = "DragDropSystem"

        --// Singleton instance
        local _instance = nil

        --// Constructor
        function DragDrop.new(config)
            if _instance then
                return _instance
            end

            local self = setmetatable({}, DragDrop)

            config = config or {}

            self.Enabled = config.Enabled ~= false
            self.SnapToGrid = config.SnapToGrid or false
            self.GridSize = config.GridSize or 10
            self.ShowPreview = config.ShowPreview ~= false
            self.AnimateDrop = config.AnimateDrop ~= false

            -- State
            self._draggables = {}
            self._dropZones = {}
            self._currentDrag = nil
            self._connections = {}

            -- Initialize
            self:_initialize()

            _instance = self

            return self
        end

        --// Get singleton instance
        function DragDrop.getInstance()
            if not _instance then
                _instance = DragDrop.new()
            end
            return _instance
        end

        --// Initialize drag drop system
        function DragDrop:_initialize()
            -- Global mouse move handler
            local moveConnection = UserInputService.InputChanged:Connect(function(input)
                if not self.Enabled or not self._currentDrag then return end

                if input.UserInputType == Enum.UserInputType.MouseMovement then
                    self:_updateDrag(input.Position)
                end
            end)
            table.insert(self._connections, moveConnection)

            -- Global mouse release handler
            local releaseConnection = UserInputService.InputEnded:Connect(function(input)
                if not self.Enabled or not self._currentDrag then return end

                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    self:_endDrag()
                end
            end)
            table.insert(self._connections, releaseConnection)
        end

        --// Make element draggable
        function DragDrop:MakeDraggable(element, config)
            config = config or {}

            local id = config.Id or element.Name .. "_" .. tostring(os.clock())

            local draggable = {
                id = id,
                element = element,
                handle = config.Handle or element,
                bounds = config.Bounds, -- Parent or ScreenGui
                constrainX = config.ConstrainX or false,
                constrainY = config.ConstrainY or false,
                onDragStart = config.OnDragStart,
                onDrag = config.OnDrag,
                onDragEnd = config.OnDragEnd,
                data = config.Data,
                canDrop = config.CanDrop,
                connections = {},
            }

            -- Setup drag start
            local inputBeganConnection = draggable.handle.InputBegan:Connect(function(input)
                if not self.Enabled then return end

                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    self:_startDrag(draggable, input.Position)
                end
            end)
            table.insert(draggable.connections, inputBeganConnection)

            self._draggables[id] = draggable

            return id
        end

        --// Remove draggable
        function DragDrop:RemoveDraggable(id)
            local draggable = self._draggables[id]
            if draggable then
                for _, connection in ipairs(draggable.connections) do
                    connection:Disconnect()
                end
                self._draggables[id] = nil
            end
            return self
        end

        --// Register drop zone
        function DragDrop:RegisterDropZone(element, config)
            config = config or {}

            local id = config.Id or element.Name .. "_dropzone_" .. tostring(os.clock())

            local dropZone = {
                id = id,
                element = element,
                accepts = config.Accepts, -- Function or table of draggable IDs
                onDragEnter = config.OnDragEnter,
                onDragLeave = config.OnDragLeave,
                onDrop = config.OnDrop,
                highlight = config.Highlight ~= false,
                highlightColor = config.HighlightColor or Color3.fromRGB(99, 102, 241),
            }

            self._dropZones[id] = dropZone

            return id
        end

        --// Remove drop zone
        function DragDrop:RemoveDropZone(id)
            self._dropZones[id] = nil
            return self
        end

        --// Start drag
        function DragDrop:_startDrag(draggable, mousePos)
            if self._currentDrag then return end

            local element = draggable.element

            self._currentDrag = {
                draggable = draggable,
                startPos = element.Position,
                offset = Vector2.new(
                    mousePos.X - element.AbsolutePosition.X,
                    mousePos.Y - element.AbsolutePosition.Y
                ),
                currentDropZone = nil,
            }

            -- Bring to front
            element.ZIndex = element.ZIndex + 100

            -- Create preview if needed
            if self.ShowPreview then
                -- Create semi-transparent clone as preview
            end

            -- Callback
            if draggable.onDragStart then
                draggable.onDragStart(draggable.element, draggable.data)
            end
        end

        --// Update drag position
        function DragDrop:_updateDrag(mousePos)
            local drag = self._currentDrag
            if not drag then return end

            local draggable = drag.draggable
            local element = draggable.element

            local newX = mousePos.X - drag.offset.X
            local newY = mousePos.Y - drag.offset.Y

            -- Apply constraints
            if draggable.constrainX then
                newX = drag.startPos.X.Offset
            end
            if draggable.constrainY then
                newY = drag.startPos.Y.Offset
            end

            -- Snap to grid
            if self.SnapToGrid then
                newX = math.floor(newX / self.GridSize + 0.5) * self.GridSize
                newY = math.floor(newY / self.GridSize + 0.5) * self.GridSize
            end

            -- Apply bounds
            if draggable.bounds then
                local bounds = draggable.bounds
                local boundsPos = bounds.AbsolutePosition
                local boundsSize = bounds.AbsoluteSize
                local elemSize = element.AbsoluteSize

                newX = math.clamp(newX, boundsPos.X, boundsPos.X + boundsSize.X - elemSize.X)
                newY = math.clamp(newY, boundsPos.Y, boundsPos.Y + boundsSize.Y - elemSize.Y)
            end

            -- Update position
            element.Position = UDim2.new(0, newX, 0, newY)

            -- Check drop zones
            self:_checkDropZones(Vector2.new(mousePos.X, mousePos.Y))

            -- Callback
            if draggable.onDrag then
                draggable.onDrag(element, Vector2.new(newX, newY), draggable.data)
            end
        end

        --// Check drop zones
        function DragDrop:_checkDropZones(mousePos)
            local drag = self._currentDrag
            if not drag then return end

            local currentZone = nil

            for _, zone in pairs(self._dropZones) do
                local zoneElem = zone.element
                local zonePos = zoneElem.AbsolutePosition
                local zoneSize = zoneElem.AbsoluteSize

                if mousePos.X >= zonePos.X and mousePos.X <= zonePos.X + zoneSize.X and
                   mousePos.Y >= zonePos.Y and mousePos.Y <= zonePos.Y + zoneSize.Y then

                    -- Check if zone accepts this draggable
                    local accepts = true
                    if zone.accepts then
                        if type(zone.accepts) == "function" then
                            accepts = zone.accepts(drag.draggable.id, drag.draggable.data)
                        elseif type(zone.accepts) == "table" then
                            accepts = table.find(zone.accepts, drag.draggable.id) ~= nil
                        end
                    end

                    if accepts then
                        currentZone = zone
                        break
                    end
                end
            end

            -- Handle zone changes
            if currentZone ~= drag.currentDropZone then
                -- Leave old zone
                if drag.currentDropZone then
                    if drag.currentDropZone.onDragLeave then
                        drag.currentDropZone.onDragLeave(drag.draggable.element, drag.draggable.data)
                    end
                    if drag.currentDropZone.highlight then
                        -- Remove highlight
                    end
                end

                -- Enter new zone
                if currentZone then
                    if currentZone.onDragEnter then
                        currentZone.onDragEnter(drag.draggable.element, drag.draggable.data)
                    end
                    if currentZone.highlight then
                        -- Add highlight
                    end
                end

                drag.currentDropZone = currentZone
            end
        end

        --// End drag
        function DragDrop:_endDrag()
            local drag = self._currentDrag
            if not drag then return end

            local draggable = drag.draggable
            local element = draggable.element

            -- Restore ZIndex
            element.ZIndex = element.ZIndex - 100

            -- Handle drop
            local dropped = false
            if drag.currentDropZone then
                if drag.currentDropZone.onDrop then
                    dropped = drag.currentDropZone.onDrop(element, draggable.data)
                else
                    dropped = true
                end

                -- Remove highlight
                if drag.currentDropZone.highlight then
                    -- Remove highlight
                end
            end

            -- Animate back if not dropped
            if not dropped and self.AnimateDrop then
                TweenService:Create(element, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                    Position = drag.startPos,
                }):Play()
            end

            -- Callback
            if draggable.onDragEnd then
                draggable.onDragEnd(element, dropped, drag.currentDropZone, draggable.data)
            end

            -- Clear preview
            if self.ShowPreview then
                -- Remove preview
            end

            self._currentDrag = nil
        end

        --// Cancel current drag
        function DragDrop:Cancel()
            if self._currentDrag then
                local drag = self._currentDrag
                local element = drag.draggable.element

                element.ZIndex = element.ZIndex - 100
                element.Position = drag.startPos

                self._currentDrag = nil
            end
            return self
        end

        --// Check if dragging
        function DragDrop:IsDragging()
            return self._currentDrag ~= nil
        end

        --// Get current drag info
        function DragDrop:GetCurrentDrag()
            if self._currentDrag then
                return {
                    id = self._currentDrag.draggable.id,
                    element = self._currentDrag.draggable.element,
                    data = self._currentDrag.draggable.data,
                }
            end
            return nil
        end

        --// Set enabled
        function DragDrop:SetEnabled(enabled)
            self.Enabled = enabled
            if not enabled and self._currentDrag then
                self:Cancel()
            end
            return self
        end

        --// Destroy
        function DragDrop:Destroy()
            self:Cancel()

            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            for _, draggable in pairs(self._draggables) do
                for _, conn in ipairs(draggable.connections) do
                    conn:Disconnect()
                end
            end

            self._draggables = {}
            self._dropZones = {}

            _instance = nil
        end

        return DragDrop


    end


    -- ============================================================================
    -- Module: NexusUI/Features/init
    -- ============================================================================
    NexusUI_Modules["NexusUI/Features/init"] = function()
        local script = CreateMockScript("NexusUI/Features/init")

        --[[
            NexusUI Features Module
            Core features and systems
        ]]

        --// Features Module
        local Features = {}

        Features.Sound = NexusRequire("NexusUI/Features/Sound")
        Features.Config = NexusRequire("NexusUI/Features/Config")
        Features.Hotkey = NexusRequire("NexusUI/Features/Hotkey")
        Features.DragDrop = NexusRequire("NexusUI/Features/DragDrop")

        return Features


    end


    -- ============================================================================
    -- Module: NexusUI/Layout/Flex
    -- ============================================================================
    NexusUI_Modules["NexusUI/Layout/Flex"] = function()
        local script = CreateMockScript("NexusUI/Layout/Flex")

        --[[
            NexusUI Flex Layout
            Flexbox-style layout system
        ]]

        --// Flex Module
        local Flex = {}
        Flex.__index = Flex
        Flex.ClassName = "FlexLayout"

        --// Directions
        Flex.Direction = {
            Row = "Row",
            RowReverse = "RowReverse",
            Column = "Column",
            ColumnReverse = "ColumnReverse",
        }

        --// Justify content
        Flex.Justify = {
            Start = "Start",
            End = "End",
            Center = "Center",
            SpaceBetween = "SpaceBetween",
            SpaceAround = "SpaceAround",
            SpaceEvenly = "SpaceEvenly",
        }

        --// Align items
        Flex.Align = {
            Start = "Start",
            End = "End",
            Center = "Center",
            Stretch = "Stretch",
            Baseline = "Baseline",
        }

        --// Constructor
        function Flex.new(config)
            local self = setmetatable({}, Flex)

            config = config or {}

            self.Direction = config.Direction or Flex.Direction.Row
            self.Justify = config.Justify or Flex.Justify.Start
            self.Align = config.Align or Flex.Align.Start
            self.Wrap = config.Wrap or false
            self.Gap = config.Gap or 0
            self.Padding = config.Padding or 0

            return self
        end

        --// Create flex container
        function Flex:Create(parent)
            local container = Instance.new("Frame")
            container.Name = "FlexContainer"
            container.Size = UDim2.new(1, 0, 1, 0)
            container.BackgroundTransparency = 1

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Apply layout
            self:_applyLayout()

            return self
        end

        --// Apply layout using UIListLayout
        function Flex:_applyLayout()
            local container = self.Instance
            if not container then return end

            -- Remove existing layout
            local existingLayout = container:FindFirstChildOfClass("UIListLayout")
            if existingLayout then
                existingLayout:Destroy()
            end

            local layout = Instance.new("UIListLayout")

            -- Direction
            if self.Direction == Flex.Direction.Row or self.Direction == Flex.Direction.RowReverse then
                layout.FillDirection = Enum.FillDirection.Horizontal
            else
                layout.FillDirection = Enum.FillDirection.Vertical
            end

            -- Justify (horizontal alignment for row, vertical for column)
            if self.Direction == Flex.Direction.Row or self.Direction == Flex.Direction.RowReverse then
                if self.Justify == Flex.Justify.Start then
                    layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
                elseif self.Justify == Flex.Justify.End then
                    layout.HorizontalAlignment = Enum.HorizontalAlignment.Right
                elseif self.Justify == Flex.Justify.Center then
                    layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
                end
            else
                if self.Justify == Flex.Justify.Start then
                    layout.VerticalAlignment = Enum.VerticalAlignment.Top
                elseif self.Justify == Flex.Justify.End then
                    layout.VerticalAlignment = Enum.VerticalAlignment.Bottom
                elseif self.Justify == Flex.Justify.Center then
                    layout.VerticalAlignment = Enum.VerticalAlignment.Center
                end
            end

            -- Align (cross-axis alignment)
            if self.Direction == Flex.Direction.Row or self.Direction == Flex.Direction.RowReverse then
                if self.Align == Flex.Align.Start then
                    layout.VerticalAlignment = Enum.VerticalAlignment.Top
                elseif self.Align == Flex.Align.End then
                    layout.VerticalAlignment = Enum.VerticalAlignment.Bottom
                elseif self.Align == Flex.Align.Center then
                    layout.VerticalAlignment = Enum.VerticalAlignment.Center
                end
            else
                if self.Align == Flex.Align.Start then
                    layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
                elseif self.Align == Flex.Align.End then
                    layout.HorizontalAlignment = Enum.HorizontalAlignment.Right
                elseif self.Align == Flex.Align.Center then
                    layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
                end
            end

            -- Gap
            layout.Padding = UDim.new(0, self.Gap)

            -- Wrapping
            layout.Wraps = self.Wrap

            layout.SortOrder = Enum.SortOrder.LayoutOrder
            layout.Parent = container

            -- Padding
            if self.Padding > 0 then
                local padding = Instance.new("UIPadding")
                padding.PaddingTop = UDim.new(0, self.Padding)
                padding.PaddingBottom = UDim.new(0, self.Padding)
                padding.PaddingLeft = UDim.new(0, self.Padding)
                padding.PaddingRight = UDim.new(0, self.Padding)
                padding.Parent = container
            end
        end

        --// Set direction
        function Flex:SetDirection(direction)
            self.Direction = direction
            self:_applyLayout()
            return self
        end

        --// Set justify
        function Flex:SetJustify(justify)
            self.Justify = justify
            self:_applyLayout()
            return self
        end

        --// Set align
        function Flex:SetAlign(align)
            self.Align = align
            self:_applyLayout()
            return self
        end

        --// Set gap
        function Flex:SetGap(gap)
            self.Gap = gap
            self:_applyLayout()
            return self
        end

        --// Set wrap
        function Flex:SetWrap(wrap)
            self.Wrap = wrap
            self:_applyLayout()
            return self
        end

        --// Add child
        function Flex:AddChild(child, order)
            if order then
                child.LayoutOrder = order
            end
            child.Parent = self.Instance
            return self
        end

        --// Remove child
        function Flex:RemoveChild(child)
            if child.Parent == self.Instance then
                child.Parent = nil
            end
            return self
        end

        --// Clear children
        function Flex:Clear()
            for _, child in ipairs(self.Instance:GetChildren()) do
                if not child:IsA("UIListLayout") and not child:IsA("UIPadding") then
                    child:Destroy()
                end
            end
            return self
        end

        --// Destroy
        function Flex:Destroy()
            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        --// Static helper to create flex layout on existing frame
        function Flex.apply(frame, config)
            config = config or {}

            local flex = Flex.new(config)
            flex.Instance = frame
            flex:_applyLayout()

            return flex
        end

        return Flex


    end


    -- ============================================================================
    -- Module: NexusUI/Layout/Grid
    -- ============================================================================
    NexusUI_Modules["NexusUI/Layout/Grid"] = function()
        local script = CreateMockScript("NexusUI/Layout/Grid")

        --[[
            NexusUI Grid Layout
            CSS Grid-style layout system
        ]]

        --// Grid Module
        local Grid = {}
        Grid.__index = Grid
        Grid.ClassName = "GridLayout"

        --// Constructor
        function Grid.new(config)
            local self = setmetatable({}, Grid)

            config = config or {}

            self.Columns = config.Columns or 3
            self.Rows = config.Rows or 0 -- 0 = auto
            self.CellSize = config.CellSize or UDim2.new(0, 100, 0, 100)
            self.CellPadding = config.CellPadding or UDim2.new(0, 10, 0, 10)
            self.StartCorner = config.StartCorner or "TopLeft"
            self.FillDirection = config.FillDirection or "Horizontal"
            self.HorizontalAlignment = config.HorizontalAlignment or "Left"
            self.VerticalAlignment = config.VerticalAlignment or "Top"
            self.SortOrder = config.SortOrder or "LayoutOrder"

            return self
        end

        --// Create grid container
        function Grid:Create(parent)
            local container = Instance.new("Frame")
            container.Name = "GridContainer"
            container.Size = UDim2.new(1, 0, 1, 0)
            container.BackgroundTransparency = 1

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Apply layout
            self:_applyLayout()

            return self
        end

        --// Apply layout using UIGridLayout
        function Grid:_applyLayout()
            local container = self.Instance
            if not container then return end

            -- Remove existing layout
            local existingLayout = container:FindFirstChildOfClass("UIGridLayout")
            if existingLayout then
                existingLayout:Destroy()
            end

            local layout = Instance.new("UIGridLayout")

            layout.CellSize = self.CellSize
            layout.CellPadding = self.CellPadding

            -- Start corner
            if self.StartCorner == "TopLeft" then
                layout.StartCorner = Enum.StartCorner.TopLeft
            elseif self.StartCorner == "TopRight" then
                layout.StartCorner = Enum.StartCorner.TopRight
            elseif self.StartCorner == "BottomLeft" then
                layout.StartCorner = Enum.StartCorner.BottomLeft
            elseif self.StartCorner == "BottomRight" then
                layout.StartCorner = Enum.StartCorner.BottomRight
            end

            -- Fill direction
            if self.FillDirection == "Horizontal" then
                layout.FillDirection = Enum.FillDirection.Horizontal
            else
                layout.FillDirection = Enum.FillDirection.Vertical
            end

            -- Alignment
            if self.HorizontalAlignment == "Left" then
                layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
            elseif self.HorizontalAlignment == "Center" then
                layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            elseif self.HorizontalAlignment == "Right" then
                layout.HorizontalAlignment = Enum.HorizontalAlignment.Right
            end

            if self.VerticalAlignment == "Top" then
                layout.VerticalAlignment = Enum.VerticalAlignment.Top
            elseif self.VerticalAlignment == "Center" then
                layout.VerticalAlignment = Enum.VerticalAlignment.Center
            elseif self.VerticalAlignment == "Bottom" then
                layout.VerticalAlignment = Enum.VerticalAlignment.Bottom
            end

            -- Sort order
            if self.SortOrder == "LayoutOrder" then
                layout.SortOrder = Enum.SortOrder.LayoutOrder
            else
                layout.SortOrder = Enum.SortOrder.Name
            end

            -- Columns constraint (if specified)
            if self.Columns > 0 then
                -- Note: UIGridLayout doesn't have column constraint
                -- We can approximate by adjusting CellSize
            end

            layout.Parent = container
            self._layout = layout
        end

        --// Set columns
        function Grid:SetColumns(columns)
            self.Columns = columns
            self:_applyLayout()
            return self
        end

        --// Set cell size
        function Grid:SetCellSize(size)
            self.CellSize = size
            self:_applyLayout()
            return self
        end

        --// Set cell padding
        function Grid:SetCellPadding(padding)
            self.CellPadding = padding
            self:_applyLayout()
            return self
        end

        --// Add child
        function Grid:AddChild(child, order)
            if order then
                child.LayoutOrder = order
            end
            child.Parent = self.Instance
            return self
        end

        --// Remove child
        function Grid:RemoveChild(child)
            if child.Parent == self.Instance then
                child.Parent = nil
            end
            return self
        end

        --// Clear children
        function Grid:Clear()
            for _, child in ipairs(self.Instance:GetChildren()) do
                if not child:IsA("UIGridLayout") then
                    child:Destroy()
                end
            end
            return self
        end

        --// Get content size
        function Grid:GetContentSize()
            if self._layout then
                return self._layout.AbsoluteContentSize
            end
            return Vector2.new(0, 0)
        end

        --// Destroy
        function Grid:Destroy()
            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        --// Static helper
        function Grid.apply(frame, config)
            config = config or {}

            local grid = Grid.new(config)
            grid.Instance = frame
            grid:_applyLayout()

            return grid
        end

        return Grid


    end


    -- ============================================================================
    -- Module: NexusUI/Layout/Stack
    -- ============================================================================
    NexusUI_Modules["NexusUI/Layout/Stack"] = function()
        local script = CreateMockScript("NexusUI/Layout/Stack")

        --[[
            NexusUI Stack Layout
            Vertical or horizontal stack layout
        ]]

        --// Stack Module
        local Stack = {}
        Stack.__index = Stack
        Stack.ClassName = "StackLayout"

        --// Constructor
        function Stack.new(config)
            local self = setmetatable({}, Stack)

            config = config or {}

            self.Direction = config.Direction or "Vertical" -- Vertical or Horizontal
            self.Spacing = config.Spacing or 8
            self.Padding = config.Padding or {0, 0, 0, 0} -- Top, Right, Bottom, Left
            self.HorizontalAlignment = config.HorizontalAlignment or "Left"
            self.VerticalAlignment = config.VerticalAlignment or "Top"

            return self
        end

        --// Create stack container
        function Stack:Create(parent)
            local container = Instance.new("Frame")
            container.Name = "StackContainer"
            container.Size = UDim2.new(1, 0, 0, 0)
            container.AutomaticSize = self.Direction == "Vertical" and Enum.AutomaticSize.Y or Enum.AutomaticSize.X
            container.BackgroundTransparency = 1

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Apply layout
            self:_applyLayout()

            return self
        end

        --// Apply layout
        function Stack:_applyLayout()
            local container = self.Instance
            if not container then return end

            -- Remove existing layout
            local existingLayout = container:FindFirstChildOfClass("UIListLayout")
            if existingLayout then
                existingLayout:Destroy()
            end

            local existingPadding = container:FindFirstChildOfClass("UIPadding")
            if existingPadding then
                existingPadding:Destroy()
            end

            local layout = Instance.new("UIListLayout")

            -- Direction
            if self.Direction == "Vertical" then
                layout.FillDirection = Enum.FillDirection.Vertical
            else
                layout.FillDirection = Enum.FillDirection.Horizontal
            end

            -- Spacing
            layout.Padding = UDim.new(0, self.Spacing)

            -- Alignment
            if self.HorizontalAlignment == "Left" then
                layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
            elseif self.HorizontalAlignment == "Center" then
                layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            elseif self.HorizontalAlignment == "Right" then
                layout.HorizontalAlignment = Enum.HorizontalAlignment.Right
            end

            if self.VerticalAlignment == "Top" then
                layout.VerticalAlignment = Enum.VerticalAlignment.Top
            elseif self.VerticalAlignment == "Center" then
                layout.VerticalAlignment = Enum.VerticalAlignment.Center
            elseif self.VerticalAlignment == "Bottom" then
                layout.VerticalAlignment = Enum.VerticalAlignment.Bottom
            end

            layout.SortOrder = Enum.SortOrder.LayoutOrder
            layout.Parent = container

            -- Padding
            local padding = self.Padding
            if type(padding) == "number" then
                padding = {padding, padding, padding, padding}
            end

            local uiPadding = Instance.new("UIPadding")
            uiPadding.PaddingTop = UDim.new(0, padding[1])
            uiPadding.PaddingRight = UDim.new(0, padding[2])
            uiPadding.PaddingBottom = UDim.new(0, padding[3])
            uiPadding.PaddingLeft = UDim.new(0, padding[4])
            uiPadding.Parent = container
        end

        --// Set direction
        function Stack:SetDirection(direction)
            self.Direction = direction

            if self.Instance then
                self.Instance.AutomaticSize = direction == "Vertical" and Enum.AutomaticSize.Y or Enum.AutomaticSize.X
            end

            self:_applyLayout()
            return self
        end

        --// Set spacing
        function Stack:SetSpacing(spacing)
            self.Spacing = spacing
            self:_applyLayout()
            return self
        end

        --// Set padding
        function Stack:SetPadding(padding)
            self.Padding = padding
            self:_applyLayout()
            return self
        end

        --// Add child
        function Stack:AddChild(child, order)
            if order then
                child.LayoutOrder = order
            else
                -- Auto-increment order
                local maxOrder = 0
                for _, c in ipairs(self.Instance:GetChildren()) do
                    if c:IsA("GuiObject") and c.LayoutOrder > maxOrder then
                        maxOrder = c.LayoutOrder
                    end
                end
                child.LayoutOrder = maxOrder + 1
            end
            child.Parent = self.Instance
            return self
        end

        --// Add spacer
        function Stack:AddSpacer(size)
            local spacer = Instance.new("Frame")
            spacer.Name = "Spacer"
            spacer.BackgroundTransparency = 1

            if self.Direction == "Vertical" then
                spacer.Size = UDim2.new(1, 0, 0, size or 0)
                if not size then
                    spacer.AutomaticSize = Enum.AutomaticSize.Y
                end
            else
                spacer.Size = UDim2.new(0, size or 0, 1, 0)
                if not size then
                    spacer.AutomaticSize = Enum.AutomaticSize.X
                end
            end

            self:AddChild(spacer)
            return spacer
        end

        --// Remove child
        function Stack:RemoveChild(child)
            if child.Parent == self.Instance then
                child.Parent = nil
            end
            return self
        end

        --// Clear
        function Stack:Clear()
            for _, child in ipairs(self.Instance:GetChildren()) do
                if not child:IsA("UIListLayout") and not child:IsA("UIPadding") then
                    child:Destroy()
                end
            end
            return self
        end

        --// Destroy
        function Stack:Destroy()
            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        --// Static helpers
        function Stack.Vertical(config)
            config = config or {}
            config.Direction = "Vertical"
            return Stack.new(config)
        end

        function Stack.Horizontal(config)
            config = config or {}
            config.Direction = "Horizontal"
            return Stack.new(config)
        end

        function Stack.apply(frame, config)
            config = config or {}

            local stack = Stack.new(config)
            stack.Instance = frame
            stack:_applyLayout()

            return stack
        end

        return Stack


    end


    -- ============================================================================
    -- Module: NexusUI/Layout/Center
    -- ============================================================================
    NexusUI_Modules["NexusUI/Layout/Center"] = function()
        local script = CreateMockScript("NexusUI/Layout/Center")

        --[[
            NexusUI Center Layout
            Centers content within container
        ]]

        --// Center Module
        local Center = {}
        Center.__index = Center
        Center.ClassName = "CenterLayout"

        --// Constructor
        function Center.new(config)
            local self = setmetatable({}, Center)

            config = config or {}

            self.Horizontal = config.Horizontal ~= false
            self.Vertical = config.Vertical ~= false

            return self
        end

        --// Create centered container
        function Center:Create(parent)
            local container = Instance.new("Frame")
            container.Name = "CenterContainer"
            container.Size = UDim2.new(1, 0, 1, 0)
            container.BackgroundTransparency = 1

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Inner container for content
            local inner = Instance.new("Frame")
            inner.Name = "Content"
            inner.BackgroundTransparency = 1
            inner.AutomaticSize = Enum.AutomaticSize.XY
            inner.Parent = container

            -- Position based on centering options
            if self.Horizontal and self.Vertical then
                inner.Position = UDim2.new(0.5, 0, 0.5, 0)
                inner.AnchorPoint = Vector2.new(0.5, 0.5)
            elseif self.Horizontal then
                inner.Position = UDim2.new(0.5, 0, 0, 0)
                inner.AnchorPoint = Vector2.new(0.5, 0)
            elseif self.Vertical then
                inner.Position = UDim2.new(0, 0, 0.5, 0)
                inner.AnchorPoint = Vector2.new(0, 0.5)
            end

            self._content = inner

            return self
        end

        --// Get content container
        function Center:GetContent()
            return self._content
        end

        --// Add child to content
        function Center:AddChild(child)
            child.Parent = self._content
            return self
        end

        --// Destroy
        function Center:Destroy()
            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        --// Static helper
        function Center.apply(element)
            element.Position = UDim2.new(0.5, 0, 0.5, 0)
            element.AnchorPoint = Vector2.new(0.5, 0.5)
            return element
        end

        function Center.horizontal(element)
            element.Position = UDim2.new(0.5, 0, element.Position.Y.Scale, element.Position.Y.Offset)
            element.AnchorPoint = Vector2.new(0.5, element.AnchorPoint.Y)
            return element
        end

        function Center.vertical(element)
            element.Position = UDim2.new(element.Position.X.Scale, element.Position.X.Offset, 0.5, 0)
            element.AnchorPoint = Vector2.new(element.AnchorPoint.X, 0.5)
            return element
        end

        return Center


    end


    -- ============================================================================
    -- Module: NexusUI/Layout/Spacer
    -- ============================================================================
    NexusUI_Modules["NexusUI/Layout/Spacer"] = function()
        local script = CreateMockScript("NexusUI/Layout/Spacer")

        --[[
            NexusUI Spacer Component
            Flexible spacer for layouts
        ]]

        --// Spacer Module
        local Spacer = {}
        Spacer.__index = Spacer
        Spacer.ClassName = "Spacer"

        --// Constructor
        function Spacer.new(config)
            local self = setmetatable({}, Spacer)

            config = config or {}

            self.Size = config.Size -- nil for flexible, number for fixed
            self.Direction = config.Direction or "Both" -- Horizontal, Vertical, Both

            return self
        end

        --// Create spacer
        function Spacer:Create(parent)
            local spacer = Instance.new("Frame")
            spacer.Name = "Spacer"
            spacer.BackgroundTransparency = 1
            spacer.BorderSizePixel = 0

            if self.Size then
                -- Fixed size
                if self.Direction == "Horizontal" then
                    spacer.Size = UDim2.new(0, self.Size, 1, 0)
                elseif self.Direction == "Vertical" then
                    spacer.Size = UDim2.new(1, 0, 0, self.Size)
                else
                    spacer.Size = UDim2.new(0, self.Size, 0, self.Size)
                end
            else
                -- Flexible (fills available space)
                if self.Direction == "Horizontal" then
                    spacer.Size = UDim2.new(1, 0, 0, 0)
                    spacer.AutomaticSize = Enum.AutomaticSize.None
                elseif self.Direction == "Vertical" then
                    spacer.Size = UDim2.new(0, 0, 1, 0)
                    spacer.AutomaticSize = Enum.AutomaticSize.None
                else
                    spacer.Size = UDim2.new(1, 0, 1, 0)
                end
            end

            if parent then
                spacer.Parent = parent
            end

            self.Instance = spacer

            return self
        end

        --// Set size
        function Spacer:SetSize(size)
            self.Size = size

            if self.Instance then
                if size then
                    if self.Direction == "Horizontal" then
                        self.Instance.Size = UDim2.new(0, size, 1, 0)
                    elseif self.Direction == "Vertical" then
                        self.Instance.Size = UDim2.new(1, 0, 0, size)
                    else
                        self.Instance.Size = UDim2.new(0, size, 0, size)
                    end
                end
            end

            return self
        end

        --// Destroy
        function Spacer:Destroy()
            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        --// Static helpers
        function Spacer.horizontal(size, parent)
            local spacer = Spacer.new({
                Size = size,
                Direction = "Horizontal"
            })
            return spacer:Create(parent)
        end

        function Spacer.vertical(size, parent)
            local spacer = Spacer.new({
                Size = size,
                Direction = "Vertical"
            })
            return spacer:Create(parent)
        end

        function Spacer.flex(parent)
            local spacer = Spacer.new({
                Direction = "Both"
            })
            return spacer:Create(parent)
        end

        return Spacer


    end


    -- ============================================================================
    -- Module: NexusUI/Layout/Responsive
    -- ============================================================================
    NexusUI_Modules["NexusUI/Layout/Responsive"] = function()
        local script = CreateMockScript("NexusUI/Layout/Responsive")

        --[[
            NexusUI Responsive Layout
            Responsive breakpoint system
        ]]

        --// Services
        local Workspace = game:GetService("Workspace")

        --// Responsive Module
        local Responsive = {}
        Responsive.__index = Responsive
        Responsive.ClassName = "ResponsiveLayout"

        --// Breakpoints
        Responsive.Breakpoints = {
            xs = 0,    -- Extra small (mobile)
            sm = 576,  -- Small
            md = 768,  -- Medium
            lg = 992,  -- Large
            xl = 1200, -- Extra large
            xxl = 1400, -- Extra extra large
        }

        --// Constructor
        function Responsive.new(config)
            local self = setmetatable({}, Responsive)

            config = config or {}

            self.Breakpoints = config.Breakpoints or Responsive.Breakpoints
            self.Styles = config.Styles or {} -- {breakpoint: {property: value}}

            -- State
            self._currentBreakpoint = nil
            self._connections = {}

            return self
        end

        --// Get current breakpoint
        function Responsive:_getBreakpoint()
            local camera = Workspace.CurrentCamera
            if not camera then return "md" end

            local width = camera.ViewportSize.X

            local current = "xs"
            for name, minWidth in pairs(self.Breakpoints) do
                if width >= minWidth then
                    -- Find the highest matching breakpoint
                    if minWidth >= (self.Breakpoints[current] or 0) then
                        current = name
                    end
                end
            end

            return current
        end

        --// Apply responsive styles
        function Responsive:Apply(element)
            self._element = element

            -- Initial application
            self:_updateStyles()

            -- Watch for viewport changes
            local camera = Workspace.CurrentCamera
            if camera then
                local connection = camera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
                    self:_updateStyles()
                end)
                table.insert(self._connections, connection)
            end

            return self
        end

        --// Update styles based on breakpoint
        function Responsive:_updateStyles()
            local breakpoint = self:_getBreakpoint()

            if breakpoint == self._currentBreakpoint then return end
            self._currentBreakpoint = breakpoint

            local element = self._element
            if not element then return end

            -- Get breakpoint order
            local order = {"xs", "sm", "md", "lg", "xl", "xxl"}
            local breakpointIndex = table.find(order, breakpoint) or 1

            -- Apply styles from smallest to current breakpoint (cascading)
            local appliedStyles = {}
            for i = 1, breakpointIndex do
                local bp = order[i]
                local styles = self.Styles[bp]

                if styles then
                    for property, value in pairs(styles) do
                        appliedStyles[property] = value
                    end
                end
            end

            -- Apply to element
            for property, value in pairs(appliedStyles) do
                pcall(function()
                    element[property] = value
                end)
            end
        end

        --// Add style for breakpoint
        function Responsive:AddStyle(breakpoint, property, value)
            if not self.Styles[breakpoint] then
                self.Styles[breakpoint] = {}
            end
            self.Styles[breakpoint][property] = value

            self:_updateStyles()
            return self
        end

        --// Set styles for breakpoint
        function Responsive:SetStyles(breakpoint, styles)
            self.Styles[breakpoint] = styles
            self:_updateStyles()
            return self
        end

        --// Get current breakpoint
        function Responsive:GetCurrentBreakpoint()
            return self._currentBreakpoint or self:_getBreakpoint()
        end

        --// Check breakpoint
        function Responsive:IsBreakpoint(breakpoint)
            return self:GetCurrentBreakpoint() == breakpoint
        end

        --// Check if at least breakpoint
        function Responsive:IsAtLeast(breakpoint)
            local order = {"xs", "sm", "md", "lg", "xl", "xxl"}
            local currentIndex = table.find(order, self:GetCurrentBreakpoint()) or 1
            local targetIndex = table.find(order, breakpoint) or 1

            return currentIndex >= targetIndex
        end

        --// Destroy
        function Responsive:Destroy()
            for _, connection in ipairs(self._connections) do
                connection:Disconnect()
            end
            self._connections = {}

            self._element = nil
        end

        --// Static helpers
        function Responsive.getBreakpoint()
            local camera = Workspace.CurrentCamera
            if not camera then return "md" end

            local width = camera.ViewportSize.X

            if width < 576 then return "xs"
            elseif width < 768 then return "sm"
            elseif width < 992 then return "md"
            elseif width < 1200 then return "lg"
            elseif width < 1400 then return "xl"
            else return "xxl" end
        end

        function Responsive.isMobile()
            return Responsive.getBreakpoint() == "xs" or Responsive.getBreakpoint() == "sm"
        end

        function Responsive.isDesktop()
            local bp = Responsive.getBreakpoint()
            return bp == "lg" or bp == "xl" or bp == "xxl"
        end

        return Responsive


    end


    -- ============================================================================
    -- Module: NexusUI/Layout/Container
    -- ============================================================================
    NexusUI_Modules["NexusUI/Layout/Container"] = function()
        local script = CreateMockScript("NexusUI/Layout/Container")

        --[[
            NexusUI Container Layout
            General-purpose container with common styling
        ]]

        --// Container Module
        local Container = {}
        Container.__index = Container
        Container.ClassName = "Container"

        --// Constructor
        function Container.new(config)
            local self = setmetatable({}, Container)

            config = config or {}

            self.Width = config.Width -- nil for full width
            self.MaxWidth = config.MaxWidth
            self.Padding = config.Padding or 0
            self.Centered = config.Centered ~= false
            self.Background = config.Background -- Color3 or nil
            self.BackgroundTransparency = config.BackgroundTransparency or (config.Background and 0 or 1)
            self.CornerRadius = config.CornerRadius or 0

            return self
        end

        --// Create container
        function Container:Create(parent)
            local container = Instance.new("Frame")
            container.Name = "Container"
            container.BackgroundTransparency = self.BackgroundTransparency
            container.BorderSizePixel = 0

            -- Size
            if self.Width then
                container.Size = UDim2.new(0, self.Width, 1, 0)
            else
                container.Size = UDim2.new(1, 0, 1, 0)
            end

            -- Centering
            if self.Centered then
                container.Position = UDim2.new(0.5, 0, 0, 0)
                container.AnchorPoint = Vector2.new(0.5, 0)
            end

            -- Background
            if self.Background then
                container.BackgroundColor3 = self.Background
            end

            -- Corner radius
            if self.CornerRadius > 0 then
                local corner = Instance.new("UICorner")
                corner.CornerRadius = UDim.new(0, self.CornerRadius)
                corner.Parent = container
            end

            -- Padding
            if self.Padding > 0 then
                local padding
                if type(self.Padding) == "number" then
                    padding = Instance.new("UIPadding")
                    padding.PaddingTop = UDim.new(0, self.Padding)
                    padding.PaddingBottom = UDim.new(0, self.Padding)
                    padding.PaddingLeft = UDim.new(0, self.Padding)
                    padding.PaddingRight = UDim.new(0, self.Padding)
                elseif type(self.Padding) == "table" then
                    padding = Instance.new("UIPadding")
                    padding.PaddingTop = UDim.new(0, self.Padding[1] or 0)
                    padding.PaddingRight = UDim.new(0, self.Padding[2] or 0)
                    padding.PaddingBottom = UDim.new(0, self.Padding[3] or 0)
                    padding.PaddingLeft = UDim.new(0, self.Padding[4] or 0)
                end

                if padding then
                    padding.Parent = container
                end
            end

            -- Max width constraint
            if self.MaxWidth then
                local constraint = Instance.new("UISizeConstraint")
                constraint.MaxSize = Vector2.new(self.MaxWidth, math.huge)
                constraint.Parent = container
            end

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            return self
        end

        --// Add child
        function Container:AddChild(child)
            child.Parent = self.Instance
            return self
        end

        --// Set background
        function Container:SetBackground(color, transparency)
            if self.Instance then
                if color then
                    self.Instance.BackgroundColor3 = color
                    self.Instance.BackgroundTransparency = transparency or 0
                else
                    self.Instance.BackgroundTransparency = 1
                end
            end
            return self
        end

        --// Destroy
        function Container:Destroy()
            if self.Instance then
                self.Instance:Destroy()
                self.Instance = nil
            end
        end

        --// Static helpers
        function Container.fluid(config)
            config = config or {}
            config.Width = nil
            return Container.new(config)
        end

        function Container.fixed(width, config)
            config = config or {}
            config.Width = width
            return Container.new(config)
        end

        function Container.responsive(config)
            -- Returns container that adjusts based on viewport
            config = config or {}

            local container = Container.new(config)

            -- Would integrate with Responsive module

            return container
        end

        return Container


    end


    -- ============================================================================
    -- Module: NexusUI/Layout/Utils
    -- ============================================================================
    NexusUI_Modules["NexusUI/Layout/Utils"] = function()
        local script = CreateMockScript("NexusUI/Layout/Utils")

        --[[
            NexusUI Layout Utilities
            Helper functions for layout calculations
        ]]

        --// Utils Module
        local Utils = {}

        --// Calculate aspect ratio
        function Utils.aspectRatio(width, height)
            return width / height
        end

        --// Fit element to container while maintaining aspect ratio
        function Utils.fitAspectRatio(containerWidth, containerHeight, contentWidth, contentHeight, mode)
            mode = mode or "contain" -- contain or cover

            local containerRatio = containerWidth / containerHeight
            local contentRatio = contentWidth / contentHeight

            local finalWidth, finalHeight

            if mode == "contain" then
                if contentRatio > containerRatio then
                    finalWidth = containerWidth
                    finalHeight = containerWidth / contentRatio
                else
                    finalHeight = containerHeight
                    finalWidth = containerHeight * contentRatio
                end
            else -- cover
                if contentRatio > containerRatio then
                    finalHeight = containerHeight
                    finalWidth = containerHeight * contentRatio
                else
                    finalWidth = containerWidth
                    finalHeight = containerWidth / contentRatio
                end
            end

            return finalWidth, finalHeight
        end

        --// Calculate position to center element
        function Utils.centerPosition(containerWidth, containerHeight, elementWidth, elementHeight)
            return (containerWidth - elementWidth) / 2, (containerHeight - elementHeight) / 2
        end

        --// Calculate grid cell size
        function Utils.gridCellSize(containerWidth, containerHeight, columns, rows, gapX, gapY)
            gapX = gapX or 0
            gapY = gapY or 0

            local totalGapX = gapX * (columns - 1)
            local totalGapY = gapY * (rows - 1)

            local cellWidth = (containerWidth - totalGapX) / columns
            local cellHeight = (containerHeight - totalGapY) / rows

            return cellWidth, cellHeight
        end

        --// Calculate percentage
        function Utils.percentage(value, total)
            return (value / total) * 100
        end

        --// Calculate value from percentage
        function Utils.fromPercentage(percentage, total)
            return (percentage / 100) * total
        end

        --// Clamp value
        function Utils.clamp(value, min, max)
            return math.max(min, math.min(max, value))
        end

        --// Linear interpolation
        function Utils.lerp(a, b, t)
            return a + (b - a) * t
        end

        --// Inverse lerp
        function Utils.inverseLerp(a, b, value)
            if a == b then return 0 end
            return (value - a) / (b - a)
        end

        --// Map value from one range to another
        function Utils.map(value, inMin, inMax, outMin, outMax)
            return outMin + (value - inMin) * (outMax - outMin) / (inMax - inMin)
        end

        --// Round to nearest multiple
        function Utils.roundToMultiple(value, multiple)
            return math.floor(value / multiple + 0.5) * multiple
        end

        --// Calculate absolute position from relative
        function Utils.absolutePosition(relativeX, relativeY, containerWidth, containerHeight)
            return relativeX * containerWidth, relativeY * containerHeight
        end

        --// Calculate relative position from absolute
        function Utils.relativePosition(absoluteX, absoluteY, containerWidth, containerHeight)
            return absoluteX / containerWidth, absoluteY / containerHeight
        end

        --// Calculate distance between two points
        function Utils.distance(x1, y1, x2, y2)
            return math.sqrt((x2 - x1)^2 + (y2 - y1)^2)
        end

        --// Check if point is inside rectangle
        function Utils.isInsideRect(pointX, pointY, rectX, rectY, rectWidth, rectHeight)
            return pointX >= rectX and pointX <= rectX + rectWidth and
                   pointY >= rectY and pointY <= rectY + rectHeight
        end

        --// Calculate overlap between two rectangles
        function Utils.rectangleOverlap(r1x, r1y, r1w, r1h, r2x, r2y, r2w, r2h)
            local overlapX = math.max(0, math.min(r1x + r1w, r2x + r2w) - math.max(r1x, r2x))
            local overlapY = math.max(0, math.min(r1y + r1h, r2y + r2h) - math.max(r1y, r2y))
            return overlapX * overlapY
        end

        --// Distribute items evenly
        function Utils.distributeEvenly(count, totalSpace, itemSize, includeEnds)
            if count <= 0 then return {} end

            local positions = {}
            local totalItemSpace = count * itemSize
            local remainingSpace = totalSpace - totalItemSpace

            local gaps
            if includeEnds then
                gaps = count + 1
            else
                gaps = math.max(1, count - 1)
            end

            local gapSize = remainingSpace / gaps

            for i = 1, count do
                local position
                if includeEnds then
                    position = gapSize + (i - 1) * (itemSize + gapSize)
                else
                    position = (i - 1) * (itemSize + gapSize)
                end
                table.insert(positions, position)
            end

            return positions
        end

        --// Calculate safe area (accounting for notches, etc.)
        function Utils.getSafeArea()
            -- Returns top, right, bottom, left insets
            -- In Roblox, we can use GuiService:GetGuiInset()
            local GuiService = game:GetService("GuiService")
            local inset = GuiService:GetGuiInset()

            return {
                top = inset.Y,
                right = 0,
                bottom = 0,
                left = 0,
            }
        end

        return Utils


    end


    -- ============================================================================
    -- Module: NexusUI/Layout/init
    -- ============================================================================
    NexusUI_Modules["NexusUI/Layout/init"] = function()
        local script = CreateMockScript("NexusUI/Layout/init")

        --[[
            NexusUI Layout Module
            Layout utilities and helpers
        ]]

        --// Layout Module
        local Layout = {}

        Layout.Flex = NexusRequire("NexusUI/Layout/Flex")
        Layout.Grid = NexusRequire("NexusUI/Layout/Grid")
        Layout.Stack = NexusRequire("NexusUI/Layout/Stack")
        Layout.Center = NexusRequire("NexusUI/Layout/Center")
        Layout.Spacer = NexusRequire("NexusUI/Layout/Spacer")
        Layout.Responsive = NexusRequire("NexusUI/Layout/Responsive")
        Layout.Container = NexusRequire("NexusUI/Layout/Container")
        Layout.Utils = NexusRequire("NexusUI/Layout/Utils")

        return Layout


    end


    -- ============================================================================
    -- Module: NexusUI/Assets/Icons
    -- ============================================================================
    NexusUI_Modules["NexusUI/Assets/Icons"] = function()
        local script = CreateMockScript("NexusUI/Assets/Icons")

        --[[
            NexusUI Icons
            Icon library and management
        ]]

        --// Icons Module
        local Icons = {}

        --// Icon asset IDs (using free Roblox asset IDs)
        Icons.List = {
            -- Navigation
            Home = "rbxassetid://7072719587",
            Menu = "rbxassetid://7072720871",
            MenuClose = "rbxassetid://7072725342",
            ArrowLeft = "rbxassetid://7072703107",
            ArrowRight = "rbxassetid://7072703296",
            ArrowUp = "rbxassetid://7072703444",
            ArrowDown = "rbxassetid://7072703000",
            ChevronLeft = "rbxassetid://7072706663",
            ChevronRight = "rbxassetid://7072706820",
            ChevronUp = "rbxassetid://7072706973",
            ChevronDown = "rbxassetid://7072706544",
            Expand = "rbxassetid://7072710755",
            Collapse = "rbxassetid://7072707660",

            -- Actions
            Check = "rbxassetid://7072706016",
            Close = "rbxassetid://7072725342",
            Plus = "rbxassetid://7072723422",
            Minus = "rbxassetid://7072721098",
            Edit = "rbxassetid://7072710028",
            Delete = "rbxassetid://7072709279",
            Copy = "rbxassetid://7072707989",
            Paste = "rbxassetid://7072722817",
            Cut = "rbxassetid://7072708890",
            Save = "rbxassetid://7072723844",
            Download = "rbxassetid://7072709629",
            Upload = "rbxassetid://7072725180",
            Refresh = "rbxassetid://7072723608",
            Undo = "rbxassetid://7072725042",
            Redo = "rbxassetid://7072723542",

            -- Status
            Info = "rbxassetid://7072718185",
            Warning = "rbxassetid://7072725760",
            Error = "rbxassetid://7072706350",
            Success = "rbxassetid://7072706016",
            Question = "rbxassetid://7072723351",

            -- UI Elements
            Settings = "rbxassetid://7072724058",
            Gear = "rbxassetid://7072717028",
            User = "rbxassetid://7072725527",
            Users = "rbxassetid://7072725596",
            Search = "rbxassetid://7072723946",
            Filter = "rbxassetid://7072717163",
            Sort = "rbxassetid://7072724249",
            Lock = "rbxassetid://7072720420",
            Unlock = "rbxassetid://7072725113",
            Eye = "rbxassetid://7072710906",
            EyeOff = "rbxassetid://7072711032",
            Heart = "rbxassetid://7072717700",
            HeartFilled = "rbxassetid://7072717561",
            Star = "rbxassetid://7072724388",
            StarFilled = "rbxassetid://7072724510",

            -- Media
            Play = "rbxassetid://7072723127",
            Pause = "rbxassetid://7072722602",
            Stop = "rbxassetid://7072724637",
            SkipForward = "rbxassetid://7072724138",
            SkipBack = "rbxassetid://7072724179",
            Volume = "rbxassetid://7072725667",
            VolumeOff = "rbxassetid://7072725706",
            Microphone = "rbxassetid://7072720953",
            MicrophoneOff = "rbxassetid://7072721026",
            Camera = "rbxassetid://7072706222",
            Image = "rbxassetid://7072717922",
            Video = "rbxassetid://7072725419",
            Music = "rbxassetid://7072721435",

            -- File
            File = "rbxassetid://7072711258",
            FileText = "rbxassetid://7072711384",
            Folder = "rbxassetid://7072716795",
            FolderOpen = "rbxassetid://7072716892",
            Archive = "rbxassetid://7072702841",

            -- Communication
            Mail = "rbxassetid://7072720659",
            Message = "rbxassetid://7072720800",
            Chat = "rbxassetid://7072706432",
            Bell = "rbxassetid://7072704113",
            BellOff = "rbxassetid://7072704273",

            -- Misc
            Clock = "rbxassetid://7072707510",
            Calendar = "rbxassetid://7072705891",
            Map = "rbxassetid://7072720734",
            Pin = "rbxassetid://7072723001",
            Link = "rbxassetid://7072720149",
            ExternalLink = "rbxassetid://7072710647",
            Code = "rbxassetid://7072707783",
            Terminal = "rbxassetid://7072724853",
            Database = "rbxassetid://7072709037",
            Cloud = "rbxassetid://7072707374",
            Sun = "rbxassetid://7072724735",
            Moon = "rbxassetid://7072721235",

            -- Gaming
            Gamepad = "rbxassetid://7072716958",
            Trophy = "rbxassetid://7072724969",
            Target = "rbxassetid://7072724783",
            Crosshair = "rbxassetid://7072708702",
            Shield = "rbxassetid://7072724165",
            Sword = "rbxassetid://7072724692",
        }

        --// Get icon by name
        function Icons.Get(name)
            return Icons.List[name]
        end

        --// Get all icon names
        function Icons.GetNames()
            local names = {}
            for name in pairs(Icons.List) do
                table.insert(names, name)
            end
            table.sort(names)
            return names
        end

        --// Check if icon exists
        function Icons.Exists(name)
            return Icons.List[name] ~= nil
        end

        --// Create icon image label
        function Icons.Create(name, size, color, parent)
            local iconId = Icons.List[name]
            if not iconId then
                warn("[NexusUI Icons] Unknown icon:", name)
                return nil
            end

            local icon = Instance.new("ImageLabel")
            icon.Name = "Icon_" .. name
            icon.Size = UDim2.new(0, size or 16, 0, size or 16)
            icon.BackgroundTransparency = 1
            icon.Image = iconId
            icon.ImageColor3 = color or Color3.fromRGB(255, 255, 255)
            icon.ScaleType = Enum.ScaleType.Fit

            if parent then
                icon.Parent = parent
            end

            return icon
        end

        --// Create icon button
        function Icons.CreateButton(name, size, color, parent)
            local iconId = Icons.List[name]
            if not iconId then
                warn("[NexusUI Icons] Unknown icon:", name)
                return nil
            end

            local button = Instance.new("ImageButton")
            button.Name = "IconBtn_" .. name
            button.Size = UDim2.new(0, size or 24, 0, size or 24)
            button.BackgroundTransparency = 1
            button.Image = iconId
            button.ImageColor3 = color or Color3.fromRGB(255, 255, 255)
            button.ScaleType = Enum.ScaleType.Fit
            button.AutoButtonColor = false

            if parent then
                button.Parent = parent
            end

            return button
        end

        --// Register custom icon
        function Icons.Register(name, assetId)
            Icons.List[name] = assetId
        end

        --// Register multiple icons
        function Icons.RegisterBatch(icons)
            for name, assetId in pairs(icons) do
                Icons.List[name] = assetId
            end
        end

        return Icons


    end


    -- ============================================================================
    -- Module: NexusUI/Assets/Images
    -- ============================================================================
    NexusUI_Modules["NexusUI/Assets/Images"] = function()
        local script = CreateMockScript("NexusUI/Assets/Images")

        --[[
            NexusUI Images
            Image asset management
        ]]

        --// Images Module
        local Images = {}

        --// Common images
        Images.List = {
            -- Shadows
            Shadow = "rbxassetid://6015897843",
            ShadowSmall = "rbxassetid://6015897843",

            -- Gradients
            GradientHorizontal = "rbxassetid://2968001672",
            GradientVertical = "rbxassetid://2968001672",
            GradientRadial = "rbxassetid://2968001672",

            -- Patterns
            Noise = "rbxassetid://8553713741",
            Dots = "rbxassetid://2508702972",
            Grid = "rbxassetid://2508702972",
            Lines = "rbxassetid://2508702972",

            -- Shapes
            Circle = "rbxassetid://3570695787",
            RoundedSquare = "rbxassetid://3570695787",
            Triangle = "rbxassetid://7072723678",

            -- UI Elements
            LoadingSpinner = "rbxassetid://6034818372",
            CheckMark = "rbxassetid://7072706016",

            -- Backgrounds
            AbstractBg1 = "rbxassetid://2508702972",
            AbstractBg2 = "rbxassetid://2508702972",
        }

        --// Get image by name
        function Images.Get(name)
            return Images.List[name]
        end

        --// Create image label
        function Images.Create(name, size, color, parent)
            local imageId = Images.List[name]
            if not imageId then
                warn("[NexusUI Images] Unknown image:", name)
                return nil
            end

            local image = Instance.new("ImageLabel")
            image.Name = "Image_" .. name
            image.Size = size or UDim2.new(1, 0, 1, 0)
            image.BackgroundTransparency = 1
            image.Image = imageId

            if color then
                image.ImageColor3 = color
            end

            if parent then
                image.Parent = parent
            end

            return image
        end

        --// Create shadow
        function Images.CreateShadow(parent, size, transparency)
            local shadow = Instance.new("ImageLabel")
            shadow.Name = "Shadow"
            shadow.Size = size or UDim2.new(1, 20, 1, 20)
            shadow.Position = UDim2.new(0.5, 0, 0.5, 4)
            shadow.AnchorPoint = Vector2.new(0.5, 0.5)
            shadow.BackgroundTransparency = 1
            shadow.Image = Images.List.Shadow
            shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
            shadow.ImageTransparency = transparency or 0.5
            shadow.ScaleType = Enum.ScaleType.Slice
            shadow.SliceCenter = Rect.new(49, 49, 450, 450)
            shadow.ZIndex = -1

            if parent then
                shadow.Parent = parent
            end

            return shadow
        end

        --// Register custom image
        function Images.Register(name, assetId)
            Images.List[name] = assetId
        end

        return Images


    end


    -- ============================================================================
    -- Module: NexusUI/Assets/Fonts
    -- ============================================================================
    NexusUI_Modules["NexusUI/Assets/Fonts"] = function()
        local script = CreateMockScript("NexusUI/Assets/Fonts")

        --[[
            NexusUI Fonts
            Font management and presets
        ]]

        --// Fonts Module
        local Fonts = {}

        --// Font presets
        Fonts.Presets = {
            -- Default fonts
            Default = Enum.Font.Gotham,
            DefaultMedium = Enum.Font.GothamMedium,
            DefaultBold = Enum.Font.GothamBold,

            -- System fonts
            System = Enum.Font.GothamMedium,
            SystemLight = Enum.Font.Gotham,
            SystemBold = Enum.Font.GothamBold,

            -- Display fonts
            Display = Enum.Font.GothamBlack,
            DisplayBold = Enum.Font.GothamBold,

            -- Code fonts
            Code = Enum.Font.Code,
            Monospace = Enum.Font.RobotoMono,

            -- Legacy fonts
            Legacy = Enum.Font.SourceSans,
            LegacyBold = Enum.Font.SourceSansBold,
            LegacyItalic = Enum.Font.SourceSansItalic,

            -- Special fonts
            Fantasy = Enum.Font.Fantasy,
            Cartoon = Enum.Font.Cartoon,
            SciFi = Enum.Font.SciFi,

            -- Modern fonts
            Ubuntu = Enum.Font.Ubuntu,
            Nunito = Enum.Font.Nunito,
            Michroma = Enum.Font.Michroma,
            Oswald = Enum.Font.Oswald,
            Bangers = Enum.Font.Bangers,
        }

        --// Font sizes
        Fonts.Sizes = {
            XSmall = 10,
            Small = 12,
            Normal = 14,
            Medium = 16,
            Large = 18,
            XLarge = 20,
            XXLarge = 24,
            Heading = 28,
            Title = 32,
            Display = 40,
        }

        --// Font weights (for TextLabel/TextButton RichText)
        Fonts.Weights = {
            Light = 300,
            Regular = 400,
            Medium = 500,
            SemiBold = 600,
            Bold = 700,
            ExtraBold = 800,
            Black = 900,
        }

        --// Get font by name
        function Fonts.Get(name)
            return Fonts.Presets[name] or Fonts.Presets.Default
        end

        --// Get size by name
        function Fonts.GetSize(name)
            return Fonts.Sizes[name] or Fonts.Sizes.Normal
        end

        --// Apply font to element
        function Fonts.Apply(element, fontName, sizeName)
            if element:IsA("TextLabel") or element:IsA("TextButton") or element:IsA("TextBox") then
                element.Font = Fonts.Get(fontName or "Default")
                element.TextSize = Fonts.GetSize(sizeName or "Normal")
            end
            return element
        end

        --// Create styled text (returns formatted string for RichText)
        function Fonts.StyledText(text, options)
            options = options or {}

            local result = text

            if options.Bold then
                result = "<b>" .. result .. "</b>"
            end

            if options.Italic then
                result = "<i>" .. result .. "</i>"
            end

            if options.Underline then
                result = "<u>" .. result .. "</u>"
            end

            if options.Strike then
                result = "<s>" .. result .. "</s>"
            end

            if options.Size then
                result = string.format('<font size="%d">%s</font>', options.Size, result)
            end

            if options.Color then
                local hex = string.format("#%02X%02X%02X", 
                    math.floor(options.Color.R * 255),
                    math.floor(options.Color.G * 255),
                    math.floor(options.Color.B * 255)
                )
                result = string.format('<font color="%s">%s</font>', hex, result)
            end

            return result
        end

        --// Register custom font preset
        function Fonts.Register(name, font)
            Fonts.Presets[name] = font
        end

        return Fonts


    end


    -- ============================================================================
    -- Module: NexusUI/Assets/Sounds
    -- ============================================================================
    NexusUI_Modules["NexusUI/Assets/Sounds"] = function()
        local script = CreateMockScript("NexusUI/Assets/Sounds")

        --[[
            NexusUI Sound Assets
            Sound asset definitions
        ]]

        --// Sounds Module
        local Sounds = {}

        --// Sound asset IDs
        Sounds.List = {
            -- UI Sounds
            Click = "rbxassetid://6895079853",
            Hover = "rbxassetid://6895079949",
            Toggle = "rbxassetid://6895079707",
            Open = "rbxassetid://6895079586",
            Close = "rbxassetid://6895079453",
            Slide = "rbxassetid://6895079628",
            Type = "rbxassetid://6895079776",

            -- Notification sounds
            Notification = "rbxassetid://4590657391",
            Success = "rbxassetid://6026984224",
            Error = "rbxassetid://5356081124",
            Warning = "rbxassetid://4590657391",

            -- Game sounds
            Coin = "rbxassetid://4612373660",
            LevelUp = "rbxassetid://5153893389",
            Achievement = "rbxassetid://4612373660",

            -- Menu sounds
            MenuOpen = "rbxassetid://6895079586",
            MenuClose = "rbxassetid://6895079453",
            MenuSelect = "rbxassetid://6895079853",

            -- Misc
            Pop = "rbxassetid://6895079853",
            Swoosh = "rbxassetid://6895079628",
            Ding = "rbxassetid://4590657391",
        }

        --// Get sound by name
        function Sounds.Get(name)
            return Sounds.List[name]
        end

        --// Get all sound names
        function Sounds.GetNames()
            local names = {}
            for name in pairs(Sounds.List) do
                table.insert(names, name)
            end
            table.sort(names)
            return names
        end

        --// Register custom sound
        function Sounds.Register(name, assetId)
            Sounds.List[name] = assetId
        end

        --// Create sound instance
        function Sounds.Create(name, volume, parent)
            local soundId = Sounds.List[name]
            if not soundId then
                warn("[NexusUI Sounds] Unknown sound:", name)
                return nil
            end

            local sound = Instance.new("Sound")
            sound.Name = "Sound_" .. name
            sound.SoundId = soundId
            sound.Volume = volume or 0.5

            if parent then
                sound.Parent = parent
            end

            return sound
        end

        --// Play sound once
        function Sounds.PlayOnce(name, volume, parent)
            local sound = Sounds.Create(name, volume, parent or game:GetService("SoundService"))
            if sound then
                sound:Play()
                sound.Ended:Connect(function()
                    sound:Destroy()
                end)
            end
            return sound
        end

        return Sounds


    end


    -- ============================================================================
    -- Module: NexusUI/Assets/Sprites
    -- ============================================================================
    NexusUI_Modules["NexusUI/Assets/Sprites"] = function()
        local script = CreateMockScript("NexusUI/Assets/Sprites")

        --[[
            NexusUI Sprites
            Sprite sheet and atlas management
        ]]

        --// Sprites Module
        local Sprites = {}

        --// Sprite sheets
        Sprites.Sheets = {
            UI = {
                Image = "rbxassetid://2508702972",
                Size = Vector2.new(512, 512),
                Sprites = {
                    Button = { Position = Vector2.new(0, 0), Size = Vector2.new(64, 32) },
                    ButtonHover = { Position = Vector2.new(64, 0), Size = Vector2.new(64, 32) },
                    Input = { Position = Vector2.new(0, 32), Size = Vector2.new(64, 32) },
                    Checkbox = { Position = Vector2.new(0, 64), Size = Vector2.new(24, 24) },
                    CheckboxChecked = { Position = Vector2.new(24, 64), Size = Vector2.new(24, 24) },
                    Radio = { Position = Vector2.new(48, 64), Size = Vector2.new(24, 24) },
                    RadioSelected = { Position = Vector2.new(72, 64), Size = Vector2.new(24, 24) },
                    Toggle = { Position = Vector2.new(0, 88), Size = Vector2.new(48, 24) },
                    ToggleOn = { Position = Vector2.new(48, 88), Size = Vector2.new(48, 24) },
                }
            },
            Icons = {
                Image = "rbxassetid://2508702972",
                Size = Vector2.new(512, 512),
                Sprites = {
                    Home = { Position = Vector2.new(0, 0), Size = Vector2.new(24, 24) },
                    Settings = { Position = Vector2.new(24, 0), Size = Vector2.new(24, 24) },
                    User = { Position = Vector2.new(48, 0), Size = Vector2.new(24, 24) },
                    Search = { Position = Vector2.new(72, 0), Size = Vector2.new(24, 24) },
                }
            }
        }

        --// Get sprite from sheet
        function Sprites.Get(sheetName, spriteName)
            local sheet = Sprites.Sheets[sheetName]
            if not sheet then
                warn("[NexusUI Sprites] Unknown sheet:", sheetName)
                return nil
            end

            local sprite = sheet.Sprites[spriteName]
            if not sprite then
                warn("[NexusUI Sprites] Unknown sprite:", spriteName, "in sheet:", sheetName)
                return nil
            end

            return {
                Image = sheet.Image,
                ImageRectOffset = sprite.Position,
                ImageRectSize = sprite.Size
            }
        end

        --// Create sprite image
        function Sprites.Create(sheetName, spriteName, size, color, parent)
            local spriteData = Sprites.Get(sheetName, spriteName)
            if not spriteData then return nil end

            local image = Instance.new("ImageLabel")
            image.Name = "Sprite_" .. spriteName
            image.Size = size or UDim2.new(0, spriteData.ImageRectSize.X, 0, spriteData.ImageRectSize.Y)
            image.BackgroundTransparency = 1
            image.Image = spriteData.Image
            image.ImageRectOffset = spriteData.ImageRectOffset
            image.ImageRectSize = spriteData.ImageRectSize

            if color then
                image.ImageColor3 = color
            end

            if parent then
                image.Parent = parent
            end

            return image
        end

        --// Register custom sprite sheet
        function Sprites.RegisterSheet(name, imageId, size, sprites)
            Sprites.Sheets[name] = {
                Image = imageId,
                Size = size,
                Sprites = sprites
            }
        end

        --// Add sprite to existing sheet
        function Sprites.AddSprite(sheetName, spriteName, position, size)
            local sheet = Sprites.Sheets[sheetName]
            if not sheet then
                warn("[NexusUI Sprites] Cannot add sprite, unknown sheet:", sheetName)
                return false
            end

            sheet.Sprites[spriteName] = {
                Position = position,
                Size = size
            }
            return true
        end

        return Sprites


    end


    -- ============================================================================
    -- Module: NexusUI/Assets/Loader
    -- ============================================================================
    NexusUI_Modules["NexusUI/Assets/Loader"] = function()
        local script = CreateMockScript("NexusUI/Assets/Loader")

        --[[
            NexusUI Asset Loader
            Preload and cache assets
        ]]

        --// Services
        local ContentProvider = game:GetService("ContentProvider")

        --// Loader Module
        local Loader = {}
        Loader.__index = Loader
        Loader.ClassName = "AssetLoader"

        --// Singleton
        local _instance = nil

        --// Constructor
        function Loader.new()
            if _instance then
                return _instance
            end

            local self = setmetatable({}, Loader)

            self._cache = {}
            self._loading = {}
            self._loadedCount = 0
            self._totalCount = 0

            _instance = self

            return self
        end

        --// Get instance
        function Loader.getInstance()
            if not _instance then
                _instance = Loader.new()
            end
            return _instance
        end

        --// Preload single asset
        function Loader:PreloadAsync(assetId, callback)
            if self._cache[assetId] then
                if callback then callback(true) end
                return true
            end

            if self._loading[assetId] then
                -- Already loading
                return false
            end

            self._loading[assetId] = true
            self._totalCount = self._totalCount + 1

            local success = pcall(function()
                ContentProvider:PreloadAsync({assetId})
            end)

            self._cache[assetId] = success
            self._loading[assetId] = nil
            self._loadedCount = self._loadedCount + 1

            if callback then callback(success) end

            return success
        end

        --// Preload multiple assets
        function Loader:PreloadBatchAsync(assetIds, progressCallback, completeCallback)
            local total = #assetIds
            local loaded = 0
            local results = {}

            for _, assetId in ipairs(assetIds) do
                task.spawn(function()
                    local success = self:PreloadAsync(assetId)
                    results[assetId] = success
                    loaded = loaded + 1

                    if progressCallback then
                        progressCallback(loaded, total, assetId, success)
                    end

                    if loaded >= total and completeCallback then
                        completeCallback(results)
                    end
                end)
            end
        end

        --// Preload all library assets
        function Loader:PreloadLibrary(progressCallback, completeCallback)
            local assets = {}

            -- Collect all asset IDs from library
            local Icons = NexusRequire("NexusUI/Icons")
            for _, assetId in pairs(Icons.List) do
                table.insert(assets, assetId)
            end

            local Images = NexusRequire("NexusUI/Images")
            for _, assetId in pairs(Images.List) do
                table.insert(assets, assetId)
            end

            local Sounds = NexusRequire("NexusUI/Sounds")
            for _, assetId in pairs(Sounds.List) do
                table.insert(assets, assetId)
            end

            self:PreloadBatchAsync(assets, progressCallback, completeCallback)
        end

        --// Check if asset is cached
        function Loader:IsCached(assetId)
            return self._cache[assetId] == true
        end

        --// Check if asset is loading
        function Loader:IsLoading(assetId)
            return self._loading[assetId] == true
        end

        --// Get loading progress
        function Loader:GetProgress()
            if self._totalCount == 0 then return 1 end
            return self._loadedCount / self._totalCount
        end

        --// Clear cache
        function Loader:ClearCache()
            self._cache = {}
            self._loadedCount = 0
            self._totalCount = 0
        end

        return Loader


    end


    -- ============================================================================
    -- Module: NexusUI/Assets/Cache
    -- ============================================================================
    NexusUI_Modules["NexusUI/Assets/Cache"] = function()
        local script = CreateMockScript("NexusUI/Assets/Cache")

        --[[
            NexusUI Asset Cache
            In-memory caching for loaded assets
        ]]

        --// Cache Module
        local Cache = {}
        Cache.__index = Cache
        Cache.ClassName = "AssetCache"

        --// Singleton
        local _instance = nil

        --// Constructor
        function Cache.new()
            if _instance then
                return _instance
            end

            local self = setmetatable({}, Cache)

            self._cache = {}
            self._metadata = {}
            self._maxSize = 100 -- Maximum cached items
            self._accessOrder = {} -- LRU tracking

            _instance = self

            return self
        end

        --// Get instance
        function Cache.getInstance()
            if not _instance then
                _instance = Cache.new()
            end
            return _instance
        end

        --// Set max cache size
        function Cache:SetMaxSize(size)
            self._maxSize = size
            self:_Cleanup()
        end

        --// Get cached item
        function Cache:Get(key)
            local item = self._cache[key]
            if item then
                self:_UpdateAccess(key)
                return item
            end
            return nil
        end

        --// Set cached item
        function Cache:Set(key, value, metadata)
            if self:GetSize() >= self._maxSize then
                self:_EvictOldest()
            end

            self._cache[key] = value
            self._metadata[key] = metadata or {}
            self:_UpdateAccess(key)
        end

        --// Check if item exists
        function Cache:Has(key)
            return self._cache[key] ~= nil
        end

        --// Remove item
        function Cache:Remove(key)
            self._cache[key] = nil
            self._metadata[key] = nil

            for i, k in ipairs(self._accessOrder) do
                if k == key then
                    table.remove(self._accessOrder, i)
                    break
                end
            end
        end

        --// Get cache size
        function Cache:GetSize()
            local count = 0
            for _ in pairs(self._cache) do
                count = count + 1
            end
            return count
        end

        --// Clear cache
        function Cache:Clear()
            self._cache = {}
            self._metadata = {}
            self._accessOrder = {}
        end

        --// Get all keys
        function Cache:GetKeys()
            local keys = {}
            for key in pairs(self._cache) do
                table.insert(keys, key)
            end
            return keys
        end

        --// Get metadata for item
        function Cache:GetMetadata(key)
            return self._metadata[key]
        end

        --// Update access order (LRU)
        function Cache:_UpdateAccess(key)
            -- Remove existing entry
            for i, k in ipairs(self._accessOrder) do
                if k == key then
                    table.remove(self._accessOrder, i)
                    break
                end
            end

            -- Add to end (most recently used)
            table.insert(self._accessOrder, key)
        end

        --// Evict oldest item (LRU)
        function Cache:_EvictOldest()
            if #self._accessOrder > 0 then
                local oldestKey = table.remove(self._accessOrder, 1)
                self._cache[oldestKey] = nil
                self._metadata[oldestKey] = nil
            end
        end

        --// Cleanup excess items
        function Cache:_Cleanup()
            while self:GetSize() > self._maxSize do
                self:_EvictOldest()
            end
        end

        --// Get or create cached item
        function Cache:GetOrCreate(key, createFunc)
            local item = self:Get(key)
            if item then
                return item
            end

            local newItem = createFunc()
            self:Set(key, newItem)
            return newItem
        end

        return Cache


    end


    -- ============================================================================
    -- Module: NexusUI/Assets/init
    -- ============================================================================
    NexusUI_Modules["NexusUI/Assets/init"] = function()
        local script = CreateMockScript("NexusUI/Assets/init")

        --[[
            NexusUI Assets Module
            Icons and asset management
        ]]

        --// Assets Module
        local Assets = {}

        Assets.Icons = NexusRequire("NexusUI/Assets/Icons")
        Assets.Images = NexusRequire("NexusUI/Assets/Images")
        Assets.Fonts = NexusRequire("NexusUI/Assets/Fonts")
        Assets.Sounds = NexusRequire("NexusUI/Assets/Sounds")
        Assets.Sprites = NexusRequire("NexusUI/Assets/Sprites")
        Assets.Loader = NexusRequire("NexusUI/Assets/Loader")
        Assets.Cache = NexusRequire("NexusUI/Assets/Cache")

        return Assets


    end


    -- ============================================================================
    -- Module: NexusUI/Builders/UI
    -- ============================================================================
    NexusUI_Modules["NexusUI/Builders/UI"] = function()
        local script = CreateMockScript("NexusUI/Builders/UI")

        --[[
            NexusUI UI Builder
            Fluent interface for building UI elements
        ]]

        --// UI Builder
        local UIBuilder = {}
        UIBuilder.__index = UIBuilder
        UIBuilder.ClassName = "UIBuilder"

        --// Constructor
        function UIBuilder.new(className)
            local self = setmetatable({}, UIBuilder)

            self._className = className or "Frame"
            self._properties = {}
            self._children = {}
            self._events = {}
            self._constraints = {}
            self._modifiers = {}

            return self
        end

        --// Static create methods
        function UIBuilder.Frame()
            return UIBuilder.new("Frame")
        end

        function UIBuilder.TextLabel()
            return UIBuilder.new("TextLabel")
        end

        function UIBuilder.TextButton()
            return UIBuilder.new("TextButton")
        end

        function UIBuilder.TextBox()
            return UIBuilder.new("TextBox")
        end

        function UIBuilder.ImageLabel()
            return UIBuilder.new("ImageLabel")
        end

        function UIBuilder.ImageButton()
            return UIBuilder.new("ImageButton")
        end

        function UIBuilder.ScrollingFrame()
            return UIBuilder.new("ScrollingFrame")
        end

        function UIBuilder.ViewportFrame()
            return UIBuilder.new("ViewportFrame")
        end

        function UIBuilder.CanvasGroup()
            return UIBuilder.new("CanvasGroup")
        end

        --// Set property
        function UIBuilder:Set(property, value)
            self._properties[property] = value
            return self
        end

        --// Common property setters
        function UIBuilder:Name(name)
            return self:Set("Name", name)
        end

        function UIBuilder:Size(width, height, widthScale, heightScale)
            if typeof(width) == "UDim2" then
                return self:Set("Size", width)
            end
            widthScale = widthScale or 0
            heightScale = heightScale or 0
            return self:Set("Size", UDim2.new(widthScale, width, heightScale, height))
        end

        function UIBuilder:Position(x, y, xScale, yScale)
            if typeof(x) == "UDim2" then
                return self:Set("Position", x)
            end
            xScale = xScale or 0
            yScale = yScale or 0
            return self:Set("Position", UDim2.new(xScale, x, yScale, y))
        end

        function UIBuilder:AnchorPoint(x, y)
            if typeof(x) == "Vector2" then
                return self:Set("AnchorPoint", x)
            end
            return self:Set("AnchorPoint", Vector2.new(x, y or 0))
        end

        function UIBuilder:BackgroundColor(color)
            return self:Set("BackgroundColor3", color)
        end

        function UIBuilder:BackgroundTransparency(value)
            return self:Set("BackgroundTransparency", value)
        end

        function UIBuilder:BorderSizePixel(size)
            return self:Set("BorderSizePixel", size)
        end

        function UIBuilder:ClipsDescendants(value)
            return self:Set("ClipsDescendants", value)
        end

        function UIBuilder:ZIndex(index)
            return self:Set("ZIndex", index)
        end

        function UIBuilder:Visible(value)
            return self:Set("Visible", value)
        end

        --// Text properties
        function UIBuilder:Text(text)
            return self:Set("Text", text)
        end

        function UIBuilder:TextColor(color)
            return self:Set("TextColor3", color)
        end

        function UIBuilder:TextSize(size)
            return self:Set("TextSize", size)
        end

        function UIBuilder:Font(font)
            return self:Set("Font", font)
        end

        function UIBuilder:TextXAlignment(alignment)
            return self:Set("TextXAlignment", alignment)
        end

        function UIBuilder:TextYAlignment(alignment)
            return self:Set("TextYAlignment", alignment)
        end

        function UIBuilder:TextWrapped(value)
            return self:Set("TextWrapped", value)
        end

        function UIBuilder:RichText(value)
            return self:Set("RichText", value)
        end

        --// Image properties
        function UIBuilder:Image(assetId)
            return self:Set("Image", assetId)
        end

        function UIBuilder:ImageColor(color)
            return self:Set("ImageColor3", color)
        end

        function UIBuilder:ImageTransparency(value)
            return self:Set("ImageTransparency", value)
        end

        function UIBuilder:ScaleType(scaleType)
            return self:Set("ScaleType", scaleType)
        end

        --// Add corner radius
        function UIBuilder:CornerRadius(radius)
            if typeof(radius) == "number" then
                radius = UDim.new(0, radius)
            end
            table.insert(self._constraints, {
                Type = "UICorner",
                Properties = { CornerRadius = radius }
            })
            return self
        end

        --// Add padding
        function UIBuilder:Padding(top, right, bottom, left)
            if typeof(top) == "number" then
                top = UDim.new(0, top)
            end
            if typeof(right) == "number" then
                right = UDim.new(0, right or top.Offset)
            elseif not right then
                right = top
            end
            if typeof(bottom) == "number" then
                bottom = UDim.new(0, bottom or top.Offset)
            elseif not bottom then
                bottom = top
            end
            if typeof(left) == "number" then
                left = UDim.new(0, left or right.Offset)
            elseif not left then
                left = right
            end

            table.insert(self._constraints, {
                Type = "UIPadding",
                Properties = {
                    PaddingTop = top,
                    PaddingRight = right,
                    PaddingBottom = bottom,
                    PaddingLeft = left
                }
            })
            return self
        end

        --// Add stroke
        function UIBuilder:Stroke(color, thickness, transparency)
            table.insert(self._constraints, {
                Type = "UIStroke",
                Properties = {
                    Color = color or Color3.fromRGB(255, 255, 255),
                    Thickness = thickness or 1,
                    Transparency = transparency or 0
                }
            })
            return self
        end

        --// Add gradient
        function UIBuilder:Gradient(colorSequence, rotation)
            table.insert(self._constraints, {
                Type = "UIGradient",
                Properties = {
                    Color = colorSequence,
                    Rotation = rotation or 0
                }
            })
            return self
        end

        --// Add list layout
        function UIBuilder:ListLayout(direction, padding, alignment)
            table.insert(self._constraints, {
                Type = "UIListLayout",
                Properties = {
                    FillDirection = direction or Enum.FillDirection.Vertical,
                    Padding = typeof(padding) == "number" and UDim.new(0, padding) or padding,
                    HorizontalAlignment = alignment or Enum.HorizontalAlignment.Left,
                    VerticalAlignment = alignment or Enum.VerticalAlignment.Top,
                    SortOrder = Enum.SortOrder.LayoutOrder
                }
            })
            return self
        end

        --// Add grid layout
        function UIBuilder:GridLayout(cellSize, padding)
            table.insert(self._constraints, {
                Type = "UIGridLayout",
                Properties = {
                    CellSize = cellSize or UDim2.new(0, 100, 0, 100),
                    CellPadding = typeof(padding) == "number" and UDim2.new(0, padding, 0, padding) or padding,
                    SortOrder = Enum.SortOrder.LayoutOrder
                }
            })
            return self
        end

        --// Add aspect ratio
        function UIBuilder:AspectRatio(ratio, type)
            table.insert(self._constraints, {
                Type = "UIAspectRatioConstraint",
                Properties = {
                    AspectRatio = ratio or 1,
                    AspectType = type or Enum.AspectType.FitWithinMaxSize
                }
            })
            return self
        end

        --// Add size constraint
        function UIBuilder:SizeConstraint(minSize, maxSize)
            table.insert(self._constraints, {
                Type = "UISizeConstraint",
                Properties = {
                    MinSize = minSize or Vector2.new(0, 0),
                    MaxSize = maxSize or Vector2.new(math.huge, math.huge)
                }
            })
            return self
        end

        --// Add child
        function UIBuilder:Child(child)
            table.insert(self._children, child)
            return self
        end

        --// Add multiple children
        function UIBuilder:Children(...)
            for _, child in ipairs({...}) do
                table.insert(self._children, child)
            end
            return self
        end

        --// Add event handler
        function UIBuilder:On(event, callback)
            self._events[event] = callback
            return self
        end

        --// Common events
        function UIBuilder:OnClick(callback)
            return self:On("MouseButton1Click", callback)
        end

        function UIBuilder:OnHover(enterCallback, leaveCallback)
            self:On("MouseEnter", enterCallback)
            if leaveCallback then
                self:On("MouseLeave", leaveCallback)
            end
            return self
        end

        function UIBuilder:OnFocusLost(callback)
            return self:On("FocusLost", callback)
        end

        --// Build the instance
        function UIBuilder:Build(parent)
            local instance = Instance.new(self._className)

            -- Apply properties
            for property, value in pairs(self._properties) do
                instance[property] = value
            end

            -- Apply constraints
            for _, constraint in ipairs(self._constraints) do
                local constraintInstance = Instance.new(constraint.Type)
                for property, value in pairs(constraint.Properties) do
                    constraintInstance[property] = value
                end
                constraintInstance.Parent = instance
            end

            -- Add children
            for _, child in ipairs(self._children) do
                if typeof(child) == "table" and child.Build then
                    child:Build(instance)
                elseif typeof(child) == "Instance" then
                    child.Parent = instance
                end
            end

            -- Connect events
            for event, callback in pairs(self._events) do
                if instance[event] then
                    instance[event]:Connect(callback)
                end
            end

            -- Set parent
            if parent then
                instance.Parent = parent
            end

            return instance
        end

        return UIBuilder


    end


    -- ============================================================================
    -- Module: NexusUI/Builders/Window
    -- ============================================================================
    NexusUI_Modules["NexusUI/Builders/Window"] = function()
        local script = CreateMockScript("NexusUI/Builders/Window")

        --[[
            NexusUI Window Builder
            Builder pattern for creating windows
        ]]

        --// Window Builder
        local WindowBuilder = {}
        WindowBuilder.__index = WindowBuilder
        WindowBuilder.ClassName = "WindowBuilder"

        --// Constructor
        function WindowBuilder.new()
            local self = setmetatable({}, WindowBuilder)

            self._config = {
                Title = "Window",
                Size = UDim2.new(0, 500, 0, 400),
                Position = UDim2.new(0.5, 0, 0.5, 0),
                AnchorPoint = Vector2.new(0.5, 0.5),
                Theme = nil,
                Draggable = true,
                Resizable = true,
                MinSize = Vector2.new(200, 150),
                MaxSize = Vector2.new(1920, 1080),
                Closeable = true,
                Minimizable = true,
                Maximizable = true,
                ShowTitleBar = true,
                ShowStatusBar = false,
                StatusText = "",
                Icon = nil,
                Tabs = {},
                OnClose = nil,
                OnMinimize = nil,
                OnMaximize = nil,
                OnResize = nil,
                OnDrag = nil,
            }

            return self
        end

        --// Static create
        function WindowBuilder.Create()
            return WindowBuilder.new()
        end

        --// Title
        function WindowBuilder:Title(title)
            self._config.Title = title
            return self
        end

        --// Size
        function WindowBuilder:Size(width, height)
            if typeof(width) == "UDim2" then
                self._config.Size = width
            else
                self._config.Size = UDim2.new(0, width, 0, height)
            end
            return self
        end

        --// Position
        function WindowBuilder:Position(x, y)
            if typeof(x) == "UDim2" then
                self._config.Position = x
            else
                self._config.Position = UDim2.new(0.5, x - self._config.Size.X.Offset / 2, 0.5, y - self._config.Size.Y.Offset / 2)
            end
            return self
        end

        --// Center
        function WindowBuilder:Center()
            self._config.Position = UDim2.new(0.5, 0, 0.5, 0)
            self._config.AnchorPoint = Vector2.new(0.5, 0.5)
            return self
        end

        --// Theme
        function WindowBuilder:Theme(theme)
            self._config.Theme = theme
            return self
        end

        --// Draggable
        function WindowBuilder:Draggable(value)
            self._config.Draggable = value
            return self
        end

        --// Resizable
        function WindowBuilder:Resizable(value)
            self._config.Resizable = value
            return self
        end

        --// Min/Max size
        function WindowBuilder:MinSize(width, height)
            self._config.MinSize = Vector2.new(width, height)
            return self
        end

        function WindowBuilder:MaxSize(width, height)
            self._config.MaxSize = Vector2.new(width, height)
            return self
        end

        --// Window controls
        function WindowBuilder:Closeable(value)
            self._config.Closeable = value
            return self
        end

        function WindowBuilder:Minimizable(value)
            self._config.Minimizable = value
            return self
        end

        function WindowBuilder:Maximizable(value)
            self._config.Maximizable = value
            return self
        end

        --// Title bar
        function WindowBuilder:ShowTitleBar(value)
            self._config.ShowTitleBar = value
            return self
        end

        --// Status bar
        function WindowBuilder:ShowStatusBar(value, text)
            self._config.ShowStatusBar = value
            if text then
                self._config.StatusText = text
            end
            return self
        end

        --// Icon
        function WindowBuilder:Icon(icon)
            self._config.Icon = icon
            return self
        end

        --// Add tab
        function WindowBuilder:AddTab(name, config)
            table.insert(self._config.Tabs, {
                Name = name,
                Config = config or {}
            })
            return self
        end

        --// Event handlers
        function WindowBuilder:OnClose(callback)
            self._config.OnClose = callback
            return self
        end

        function WindowBuilder:OnMinimize(callback)
            self._config.OnMinimize = callback
            return self
        end

        function WindowBuilder:OnMaximize(callback)
            self._config.OnMaximize = callback
            return self
        end

        function WindowBuilder:OnResize(callback)
            self._config.OnResize = callback
            return self
        end

        function WindowBuilder:OnDrag(callback)
            self._config.OnDrag = callback
            return self
        end

        --// Build the window
        function WindowBuilder:Build(parent)
            -- Try to get the Components module
            local success, Components = pcall(function()
                return NexusRequire("Components")
            end)

            if success and Components and Components.Window then
                local window = Components.Window.new(self._config)

                -- Add tabs
                for _, tabConfig in ipairs(self._config.Tabs) do
                    window:AddTab(tabConfig.Name, tabConfig.Config)
                end

                if parent then
                    window:Mount(parent)
                end

                return window
            end

            -- Fallback: create basic window frame
            local window = Instance.new("Frame")
            window.Name = "Window_" .. self._config.Title
            window.Size = self._config.Size
            window.Position = self._config.Position
            window.AnchorPoint = self._config.AnchorPoint
            window.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            window.BorderSizePixel = 0

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = window

            -- Title bar
            if self._config.ShowTitleBar then
                local titleBar = Instance.new("Frame")
                titleBar.Name = "TitleBar"
                titleBar.Size = UDim2.new(1, 0, 0, 32)
                titleBar.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
                titleBar.BorderSizePixel = 0
                titleBar.Parent = window

                local titleCorner = Instance.new("UICorner")
                titleCorner.CornerRadius = UDim.new(0, 8)
                titleCorner.Parent = titleBar

                local title = Instance.new("TextLabel")
                title.Name = "Title"
                title.Size = UDim2.new(1, -80, 1, 0)
                title.Position = UDim2.new(0, 10, 0, 0)
                title.BackgroundTransparency = 1
                title.Text = self._config.Title
                title.TextColor3 = Color3.fromRGB(255, 255, 255)
                title.TextSize = 14
                title.Font = Enum.Font.GothamMedium
                title.TextXAlignment = Enum.TextXAlignment.Left
                title.Parent = titleBar
            end

            -- Content area
            local content = Instance.new("Frame")
            content.Name = "Content"
            content.Size = UDim2.new(1, -16, 1, self._config.ShowTitleBar and -40 or -8)
            content.Position = UDim2.new(0, 8, 0, self._config.ShowTitleBar and 36 or 4)
            content.BackgroundTransparency = 1
            content.Parent = window

            if parent then
                window.Parent = parent
            end

            return window
        end

        return WindowBuilder


    end


    -- ============================================================================
    -- Module: NexusUI/Builders/Tab
    -- ============================================================================
    NexusUI_Modules["NexusUI/Builders/Tab"] = function()
        local script = CreateMockScript("NexusUI/Builders/Tab")

        --[[
            NexusUI Tab Builder
            Builder pattern for creating tab systems
        ]]

        --// Tab Builder
        local TabBuilder = {}
        TabBuilder.__index = TabBuilder
        TabBuilder.ClassName = "TabBuilder"

        --// Constructor
        function TabBuilder.new()
            local self = setmetatable({}, TabBuilder)

            self._config = {
                Position = "Top", -- Top, Bottom, Left, Right
                Style = "Default", -- Default, Pills, Underline, Vertical
                TabHeight = 32,
                TabWidth = nil, -- Auto if nil
                Padding = 4,
                Spacing = 4,
                ShowIcons = true,
                Animated = true,
                Theme = nil,
                DefaultTab = 1,
                OnTabChanged = nil,
            }

            self._tabs = {}

            return self
        end

        --// Static create
        function TabBuilder.Create()
            return TabBuilder.new()
        end

        --// Position
        function TabBuilder:Position(position)
            self._config.Position = position
            return self
        end

        --// Style
        function TabBuilder:Style(style)
            self._config.Style = style
            return self
        end

        --// Tab dimensions
        function TabBuilder:TabHeight(height)
            self._config.TabHeight = height
            return self
        end

        function TabBuilder:TabWidth(width)
            self._config.TabWidth = width
            return self
        end

        --// Spacing
        function TabBuilder:Padding(padding)
            self._config.Padding = padding
            return self
        end

        function TabBuilder:Spacing(spacing)
            self._config.Spacing = spacing
            return self
        end

        --// Show icons
        function TabBuilder:ShowIcons(value)
            self._config.ShowIcons = value
            return self
        end

        --// Animated
        function TabBuilder:Animated(value)
            self._config.Animated = value
            return self
        end

        --// Theme
        function TabBuilder:Theme(theme)
            self._config.Theme = theme
            return self
        end

        --// Default tab
        function TabBuilder:DefaultTab(index)
            self._config.DefaultTab = index
            return self
        end

        --// Event handler
        function TabBuilder:OnTabChanged(callback)
            self._config.OnTabChanged = callback
            return self
        end

        --// Add tab
        function TabBuilder:AddTab(name, config)
            config = config or {}
            table.insert(self._tabs, {
                Name = name,
                Icon = config.Icon,
                Content = config.Content,
                OnSelected = config.OnSelected,
                OnDeselected = config.OnDeselected,
                Disabled = config.Disabled or false,
            })
            return self
        end

        --// Build the tab system
        function TabBuilder:Build(parent)
            local isVertical = self._config.Position == "Left" or self._config.Position == "Right"

            -- Container
            local container = Instance.new("Frame")
            container.Name = "TabSystem"
            container.Size = UDim2.new(1, 0, 1, 0)
            container.BackgroundTransparency = 1

            -- Tab bar
            local tabBar = Instance.new("Frame")
            tabBar.Name = "TabBar"
            tabBar.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
            tabBar.BorderSizePixel = 0

            if isVertical then
                tabBar.Size = UDim2.new(0, 120, 1, 0)
                tabBar.Position = self._config.Position == "Left" and UDim2.new(0, 0, 0, 0) or UDim2.new(1, -120, 0, 0)
            else
                tabBar.Size = UDim2.new(1, 0, 0, self._config.TabHeight + self._config.Padding * 2)
                tabBar.Position = self._config.Position == "Top" and UDim2.new(0, 0, 0, 0) or UDim2.new(0, 0, 1, -(self._config.TabHeight + self._config.Padding * 2))
            end

            tabBar.Parent = container

            local tabBarCorner = Instance.new("UICorner")
            tabBarCorner.CornerRadius = UDim.new(0, 6)
            tabBarCorner.Parent = tabBar

            -- Tab layout
            local layout = Instance.new("UIListLayout")
            layout.FillDirection = isVertical and Enum.FillDirection.Vertical or Enum.FillDirection.Horizontal
            layout.Padding = UDim.new(0, self._config.Spacing)
            layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
            layout.VerticalAlignment = Enum.VerticalAlignment.Top
            layout.Parent = tabBar

            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, self._config.Padding)
            padding.PaddingBottom = UDim.new(0, self._config.Padding)
            padding.PaddingLeft = UDim.new(0, self._config.Padding)
            padding.PaddingRight = UDim.new(0, self._config.Padding)
            padding.Parent = tabBar

            -- Content area
            local contentArea = Instance.new("Frame")
            contentArea.Name = "ContentArea"
            contentArea.BackgroundTransparency = 1

            if isVertical then
                local barWidth = 120 + self._config.Padding
                if self._config.Position == "Left" then
                    contentArea.Size = UDim2.new(1, -barWidth, 1, 0)
                    contentArea.Position = UDim2.new(0, barWidth, 0, 0)
                else
                    contentArea.Size = UDim2.new(1, -barWidth, 1, 0)
                    contentArea.Position = UDim2.new(0, 0, 0, 0)
                end
            else
                local barHeight = self._config.TabHeight + self._config.Padding * 2
                if self._config.Position == "Top" then
                    contentArea.Size = UDim2.new(1, 0, 1, -barHeight)
                    contentArea.Position = UDim2.new(0, 0, 0, barHeight)
                else
                    contentArea.Size = UDim2.new(1, 0, 1, -barHeight)
                    contentArea.Position = UDim2.new(0, 0, 0, 0)
                end
            end

            contentArea.Parent = container

            -- Create tabs
            local tabButtons = {}
            local tabContents = {}
            local activeTab = nil

            local function selectTab(index)
                if activeTab == index then return end

                -- Deselect current
                if activeTab then
                    local oldButton = tabButtons[activeTab]
                    local oldContent = tabContents[activeTab]
                    if oldButton then
                        oldButton.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
                    end
                    if oldContent then
                        oldContent.Visible = false
                    end

                    local tabConfig = self._tabs[activeTab]
                    if tabConfig and tabConfig.OnDeselected then
                        tabConfig.OnDeselected()
                    end
                end

                -- Select new
                activeTab = index
                local newButton = tabButtons[index]
                local newContent = tabContents[index]

                if newButton then
                    newButton.BackgroundColor3 = Color3.fromRGB(60, 130, 255)
                end
                if newContent then
                    newContent.Visible = true
                end

                local tabConfig = self._tabs[index]
                if tabConfig and tabConfig.OnSelected then
                    tabConfig.OnSelected()
                end

                if self._config.OnTabChanged then
                    self._config.OnTabChanged(index, tabConfig.Name)
                end
            end

            for i, tabConfig in ipairs(self._tabs) do
                -- Tab button
                local button = Instance.new("TextButton")
                button.Name = "Tab_" .. tabConfig.Name
                button.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
                button.BorderSizePixel = 0
                button.Text = tabConfig.Name
                button.TextColor3 = Color3.fromRGB(255, 255, 255)
                button.TextSize = 12
                button.Font = Enum.Font.GothamMedium
                button.AutoButtonColor = false

                if isVertical then
                    button.Size = UDim2.new(1, 0, 0, self._config.TabHeight)
                else
                    local width = self._config.TabWidth or (string.len(tabConfig.Name) * 8 + 24)
                    button.Size = UDim2.new(0, width, 1, 0)
                end

                local buttonCorner = Instance.new("UICorner")
                buttonCorner.CornerRadius = UDim.new(0, 4)
                buttonCorner.Parent = button

                button.MouseButton1Click:Connect(function()
                    if not tabConfig.Disabled then
                        selectTab(i)
                    end
                end)

                button.Parent = tabBar
                tabButtons[i] = button

                -- Tab content
                local content = Instance.new("Frame")
                content.Name = "Content_" .. tabConfig.Name
                content.Size = UDim2.new(1, 0, 1, 0)
                content.BackgroundTransparency = 1
                content.Visible = false
                content.Parent = contentArea
                tabContents[i] = content
            end

            -- Select default tab
            selectTab(self._config.DefaultTab)

            if parent then
                container.Parent = parent
            end

            -- Return interface
            return {
                Instance = container,
                TabBar = tabBar,
                ContentArea = contentArea,
                TabButtons = tabButtons,
                TabContents = tabContents,
                SelectTab = selectTab,
                GetActiveTab = function() return activeTab end,
                GetTabContent = function(index) return tabContents[index] end,
            }
        end

        return TabBuilder


    end


    -- ============================================================================
    -- Module: NexusUI/Builders/Section
    -- ============================================================================
    NexusUI_Modules["NexusUI/Builders/Section"] = function()
        local script = CreateMockScript("NexusUI/Builders/Section")

        --[[
            NexusUI Section Builder
            Builder pattern for creating sections
        ]]

        --// Section Builder
        local SectionBuilder = {}
        SectionBuilder.__index = SectionBuilder
        SectionBuilder.ClassName = "SectionBuilder"

        --// Constructor
        function SectionBuilder.new()
            local self = setmetatable({}, SectionBuilder)

            self._config = {
                Title = "Section",
                Collapsible = true,
                Collapsed = false,
                Padding = 12,
                Spacing = 8,
                HeaderHeight = 32,
                ShowDivider = false,
                ShowIcon = false,
                Icon = nil,
                Theme = nil,
                OnToggle = nil,
            }

            self._elements = {}

            return self
        end

        --// Static create
        function SectionBuilder.Create()
            return SectionBuilder.new()
        end

        --// Title
        function SectionBuilder:Title(title)
            self._config.Title = title
            return self
        end

        --// Collapsible
        function SectionBuilder:Collapsible(value)
            self._config.Collapsible = value
            return self
        end

        --// Start collapsed
        function SectionBuilder:Collapsed(value)
            self._config.Collapsed = value
            return self
        end

        --// Padding
        function SectionBuilder:Padding(padding)
            self._config.Padding = padding
            return self
        end

        --// Spacing
        function SectionBuilder:Spacing(spacing)
            self._config.Spacing = spacing
            return self
        end

        --// Header height
        function SectionBuilder:HeaderHeight(height)
            self._config.HeaderHeight = height
            return self
        end

        --// Show divider
        function SectionBuilder:ShowDivider(value)
            self._config.ShowDivider = value
            return self
        end

        --// Icon
        function SectionBuilder:Icon(icon)
            self._config.ShowIcon = true
            self._config.Icon = icon
            return self
        end

        --// Theme
        function SectionBuilder:Theme(theme)
            self._config.Theme = theme
            return self
        end

        --// On toggle callback
        function SectionBuilder:OnToggle(callback)
            self._config.OnToggle = callback
            return self
        end

        --// Add element
        function SectionBuilder:AddElement(element)
            table.insert(self._elements, element)
            return self
        end

        --// Add label
        function SectionBuilder:AddLabel(text, config)
            table.insert(self._elements, {
                Type = "Label",
                Text = text,
                Config = config or {}
            })
            return self
        end

        --// Add button
        function SectionBuilder:AddButton(text, callback, config)
            table.insert(self._elements, {
                Type = "Button",
                Text = text,
                Callback = callback,
                Config = config or {}
            })
            return self
        end

        --// Add toggle
        function SectionBuilder:AddToggle(text, default, callback, config)
            table.insert(self._elements, {
                Type = "Toggle",
                Text = text,
                Default = default,
                Callback = callback,
                Config = config or {}
            })
            return self
        end

        --// Add slider
        function SectionBuilder:AddSlider(text, min, max, default, callback, config)
            table.insert(self._elements, {
                Type = "Slider",
                Text = text,
                Min = min,
                Max = max,
                Default = default,
                Callback = callback,
                Config = config or {}
            })
            return self
        end

        --// Add input
        function SectionBuilder:AddInput(placeholder, default, callback, config)
            table.insert(self._elements, {
                Type = "Input",
                Placeholder = placeholder,
                Default = default,
                Callback = callback,
                Config = config or {}
            })
            return self
        end

        --// Add dropdown
        function SectionBuilder:AddDropdown(text, options, default, callback, config)
            table.insert(self._elements, {
                Type = "Dropdown",
                Text = text,
                Options = options,
                Default = default,
                Callback = callback,
                Config = config or {}
            })
            return self
        end

        --// Add color picker
        function SectionBuilder:AddColorPicker(text, default, callback, config)
            table.insert(self._elements, {
                Type = "ColorPicker",
                Text = text,
                Default = default,
                Callback = callback,
                Config = config or {}
            })
            return self
        end

        --// Add keybind
        function SectionBuilder:AddKeybind(text, default, callback, config)
            table.insert(self._elements, {
                Type = "Keybind",
                Text = text,
                Default = default,
                Callback = callback,
                Config = config or {}
            })
            return self
        end

        --// Build the section
        function SectionBuilder:Build(parent)
            local isCollapsed = self._config.Collapsed

            -- Container
            local container = Instance.new("Frame")
            container.Name = "Section_" .. self._config.Title
            container.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
            container.BorderSizePixel = 0
            container.AutomaticSize = Enum.AutomaticSize.Y
            container.Size = UDim2.new(1, 0, 0, 0)

            local containerCorner = Instance.new("UICorner")
            containerCorner.CornerRadius = UDim.new(0, 8)
            containerCorner.Parent = container

            -- Header
            local header = Instance.new("TextButton")
            header.Name = "Header"
            header.Size = UDim2.new(1, 0, 0, self._config.HeaderHeight)
            header.BackgroundTransparency = 1
            header.Text = ""
            header.AutoButtonColor = false
            header.Parent = container

            -- Arrow icon
            local arrow = Instance.new("TextLabel")
            arrow.Name = "Arrow"
            arrow.Size = UDim2.new(0, 20, 0, 20)
            arrow.Position = UDim2.new(0, 8, 0.5, 0)
            arrow.AnchorPoint = Vector2.new(0, 0.5)
            arrow.BackgroundTransparency = 1
            arrow.Text = isCollapsed and "▶" or "▼"
            arrow.TextColor3 = Color3.fromRGB(150, 150, 150)
            arrow.TextSize = 10
            arrow.Font = Enum.Font.GothamBold
            arrow.Parent = header

            -- Title
            local title = Instance.new("TextLabel")
            title.Name = "Title"
            title.Size = UDim2.new(1, -40, 1, 0)
            title.Position = UDim2.new(0, 32, 0, 0)
            title.BackgroundTransparency = 1
            title.Text = self._config.Title
            title.TextColor3 = Color3.fromRGB(255, 255, 255)
            title.TextSize = 13
            title.Font = Enum.Font.GothamMedium
            title.TextXAlignment = Enum.TextXAlignment.Left
            title.Parent = header

            -- Content container
            local content = Instance.new("Frame")
            content.Name = "Content"
            content.Size = UDim2.new(1, 0, 0, 0)
            content.Position = UDim2.new(0, 0, 0, self._config.HeaderHeight)
            content.BackgroundTransparency = 1
            content.AutomaticSize = Enum.AutomaticSize.Y
            content.Visible = not isCollapsed
            content.Parent = container

            local contentLayout = Instance.new("UIListLayout")
            contentLayout.FillDirection = Enum.FillDirection.Vertical
            contentLayout.Padding = UDim.new(0, self._config.Spacing)
            contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
            contentLayout.Parent = content

            local contentPadding = Instance.new("UIPadding")
            contentPadding.PaddingTop = UDim.new(0, 4)
            contentPadding.PaddingBottom = UDim.new(0, self._config.Padding)
            contentPadding.PaddingLeft = UDim.new(0, self._config.Padding)
            contentPadding.PaddingRight = UDim.new(0, self._config.Padding)
            contentPadding.Parent = content

            -- Toggle function
            local function toggle()
                if not self._config.Collapsible then return end

                isCollapsed = not isCollapsed
                arrow.Text = isCollapsed and "▶" or "▼"
                content.Visible = not isCollapsed

                if self._config.OnToggle then
                    self._config.OnToggle(isCollapsed)
                end
            end

            header.MouseButton1Click:Connect(toggle)

            -- Create elements (simplified - actual implementation would use Components module)
            for i, element in ipairs(self._elements) do
                local elementFrame = Instance.new("Frame")
                elementFrame.Name = element.Type .. "_" .. i
                elementFrame.Size = UDim2.new(1, 0, 0, 32)
                elementFrame.BackgroundTransparency = 1
                elementFrame.LayoutOrder = i

                if element.Type == "Label" then
                    local label = Instance.new("TextLabel")
                    label.Size = UDim2.new(1, 0, 1, 0)
                    label.BackgroundTransparency = 1
                    label.Text = element.Text
                    label.TextColor3 = Color3.fromRGB(200, 200, 200)
                    label.TextSize = 12
                    label.Font = Enum.Font.Gotham
                    label.TextXAlignment = Enum.TextXAlignment.Left
                    label.Parent = elementFrame

                elseif element.Type == "Button" then
                    local button = Instance.new("TextButton")
                    button.Size = UDim2.new(1, 0, 1, 0)
                    button.BackgroundColor3 = Color3.fromRGB(60, 130, 255)
                    button.BorderSizePixel = 0
                    button.Text = element.Text
                    button.TextColor3 = Color3.fromRGB(255, 255, 255)
                    button.TextSize = 12
                    button.Font = Enum.Font.GothamMedium
                    button.AutoButtonColor = false
                    button.Parent = elementFrame

                    local btnCorner = Instance.new("UICorner")
                    btnCorner.CornerRadius = UDim.new(0, 4)
                    btnCorner.Parent = button

                    button.MouseButton1Click:Connect(function()
                        if element.Callback then
                            element.Callback()
                        end
                    end)
                end

                elementFrame.Parent = content
            end

            if parent then
                container.Parent = parent
            end

            -- Return interface
            return {
                Instance = container,
                Header = header,
                Content = content,
                Toggle = toggle,
                IsCollapsed = function() return isCollapsed end,
                SetCollapsed = function(collapsed)
                    if collapsed ~= isCollapsed then
                        toggle()
                    end
                end,
            }
        end

        return SectionBuilder


    end


    -- ============================================================================
    -- Module: NexusUI/Builders/Form
    -- ============================================================================
    NexusUI_Modules["NexusUI/Builders/Form"] = function()
        local script = CreateMockScript("NexusUI/Builders/Form")

        --[[
            NexusUI Form Builder
            Builder pattern for creating forms
        ]]

        --// Form Builder
        local FormBuilder = {}
        FormBuilder.__index = FormBuilder
        FormBuilder.ClassName = "FormBuilder"

        --// Constructor
        function FormBuilder.new()
            local self = setmetatable({}, FormBuilder)

            self._config = {
                Title = "Form",
                ShowTitle = true,
                Padding = 16,
                Spacing = 12,
                LabelWidth = 120,
                ShowSubmit = true,
                SubmitText = "Submit",
                ShowReset = false,
                ResetText = "Reset",
                ShowCancel = false,
                CancelText = "Cancel",
                Validation = true,
                Theme = nil,
                OnSubmit = nil,
                OnReset = nil,
                OnCancel = nil,
                OnChange = nil,
            }

            self._fields = {}

            return self
        end

        --// Static create
        function FormBuilder.Create()
            return FormBuilder.new()
        end

        --// Title
        function FormBuilder:Title(title)
            self._config.Title = title
            return self
        end

        --// Show title
        function FormBuilder:ShowTitle(value)
            self._config.ShowTitle = value
            return self
        end

        --// Padding
        function FormBuilder:Padding(padding)
            self._config.Padding = padding
            return self
        end

        --// Spacing
        function FormBuilder:Spacing(spacing)
            self._config.Spacing = spacing
            return self
        end

        --// Label width
        function FormBuilder:LabelWidth(width)
            self._config.LabelWidth = width
            return self
        end

        --// Submit button
        function FormBuilder:ShowSubmit(value, text)
            self._config.ShowSubmit = value
            if text then
                self._config.SubmitText = text
            end
            return self
        end

        --// Reset button
        function FormBuilder:ShowReset(value, text)
            self._config.ShowReset = value
            if text then
                self._config.ResetText = text
            end
            return self
        end

        --// Cancel button
        function FormBuilder:ShowCancel(value, text)
            self._config.ShowCancel = value
            if text then
                self._config.CancelText = text
            end
            return self
        end

        --// Validation
        function FormBuilder:Validation(value)
            self._config.Validation = value
            return self
        end

        --// Theme
        function FormBuilder:Theme(theme)
            self._config.Theme = theme
            return self
        end

        --// Event handlers
        function FormBuilder:OnSubmit(callback)
            self._config.OnSubmit = callback
            return self
        end

        function FormBuilder:OnReset(callback)
            self._config.OnReset = callback
            return self
        end

        function FormBuilder:OnCancel(callback)
            self._config.OnCancel = callback
            return self
        end

        function FormBuilder:OnChange(callback)
            self._config.OnChange = callback
            return self
        end

        --// Add field
        function FormBuilder:AddField(config)
            table.insert(self._fields, config)
            return self
        end

        --// Add text input
        function FormBuilder:AddTextInput(name, label, config)
            config = config or {}
            table.insert(self._fields, {
                Type = "TextInput",
                Name = name,
                Label = label,
                Placeholder = config.Placeholder or "",
                Default = config.Default or "",
                Required = config.Required or false,
                Validate = config.Validate,
                MaxLength = config.MaxLength,
                Password = config.Password or false,
            })
            return self
        end

        --// Add number input
        function FormBuilder:AddNumberInput(name, label, config)
            config = config or {}
            table.insert(self._fields, {
                Type = "NumberInput",
                Name = name,
                Label = label,
                Default = config.Default or 0,
                Min = config.Min,
                Max = config.Max,
                Step = config.Step or 1,
                Required = config.Required or false,
            })
            return self
        end

        --// Add checkbox
        function FormBuilder:AddCheckbox(name, label, config)
            config = config or {}
            table.insert(self._fields, {
                Type = "Checkbox",
                Name = name,
                Label = label,
                Default = config.Default or false,
            })
            return self
        end

        --// Add radio group
        function FormBuilder:AddRadioGroup(name, label, options, config)
            config = config or {}
            table.insert(self._fields, {
                Type = "RadioGroup",
                Name = name,
                Label = label,
                Options = options,
                Default = config.Default,
                Required = config.Required or false,
            })
            return self
        end

        --// Add select/dropdown
        function FormBuilder:AddSelect(name, label, options, config)
            config = config or {}
            table.insert(self._fields, {
                Type = "Select",
                Name = name,
                Label = label,
                Options = options,
                Default = config.Default,
                Multiple = config.Multiple or false,
                Required = config.Required or false,
            })
            return self
        end

        --// Add textarea
        function FormBuilder:AddTextArea(name, label, config)
            config = config or {}
            table.insert(self._fields, {
                Type = "TextArea",
                Name = name,
                Label = label,
                Placeholder = config.Placeholder or "",
                Default = config.Default or "",
                Rows = config.Rows or 4,
                Required = config.Required or false,
                MaxLength = config.MaxLength,
            })
            return self
        end

        --// Add slider
        function FormBuilder:AddSlider(name, label, min, max, config)
            config = config or {}
            table.insert(self._fields, {
                Type = "Slider",
                Name = name,
                Label = label,
                Min = min,
                Max = max,
                Default = config.Default or min,
                Step = config.Step or 1,
            })
            return self
        end

        --// Add color picker
        function FormBuilder:AddColorPicker(name, label, config)
            config = config or {}
            table.insert(self._fields, {
                Type = "ColorPicker",
                Name = name,
                Label = label,
                Default = config.Default or Color3.fromRGB(255, 255, 255),
            })
            return self
        end

        --// Add date picker
        function FormBuilder:AddDatePicker(name, label, config)
            config = config or {}
            table.insert(self._fields, {
                Type = "DatePicker",
                Name = name,
                Label = label,
                Default = config.Default,
                MinDate = config.MinDate,
                MaxDate = config.MaxDate,
                Required = config.Required or false,
            })
            return self
        end

        --// Add divider
        function FormBuilder:AddDivider()
            table.insert(self._fields, {
                Type = "Divider",
            })
            return self
        end

        --// Add spacer
        function FormBuilder:AddSpacer(height)
            table.insert(self._fields, {
                Type = "Spacer",
                Height = height or 16,
            })
            return self
        end

        --// Build the form
        function FormBuilder:Build(parent)
            local formValues = {}
            local fieldInstances = {}

            -- Container
            local container = Instance.new("Frame")
            container.Name = "Form_" .. self._config.Title
            container.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            container.BorderSizePixel = 0
            container.AutomaticSize = Enum.AutomaticSize.Y
            container.Size = UDim2.new(1, 0, 0, 0)

            local containerCorner = Instance.new("UICorner")
            containerCorner.CornerRadius = UDim.new(0, 8)
            containerCorner.Parent = container

            local containerPadding = Instance.new("UIPadding")
            containerPadding.PaddingTop = UDim.new(0, self._config.Padding)
            containerPadding.PaddingBottom = UDim.new(0, self._config.Padding)
            containerPadding.PaddingLeft = UDim.new(0, self._config.Padding)
            containerPadding.PaddingRight = UDim.new(0, self._config.Padding)
            containerPadding.Parent = container

            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Vertical
            layout.Padding = UDim.new(0, self._config.Spacing)
            layout.SortOrder = Enum.SortOrder.LayoutOrder
            layout.Parent = container

            -- Title
            if self._config.ShowTitle then
                local title = Instance.new("TextLabel")
                title.Name = "Title"
                title.Size = UDim2.new(1, 0, 0, 24)
                title.BackgroundTransparency = 1
                title.Text = self._config.Title
                title.TextColor3 = Color3.fromRGB(255, 255, 255)
                title.TextSize = 16
                title.Font = Enum.Font.GothamBold
                title.TextXAlignment = Enum.TextXAlignment.Left
                title.LayoutOrder = 0
                title.Parent = container
            end

            -- Create fields
            for i, field in ipairs(self._fields) do
                local fieldFrame = Instance.new("Frame")
                fieldFrame.Name = "Field_" .. (field.Name or i)
                fieldFrame.Size = UDim2.new(1, 0, 0, 32)
                fieldFrame.BackgroundTransparency = 1
                fieldFrame.LayoutOrder = i

                if field.Type == "Divider" then
                    fieldFrame.Size = UDim2.new(1, 0, 0, 1)
                    fieldFrame.BackgroundTransparency = 0
                    fieldFrame.BackgroundColor3 = Color3.fromRGB(60, 60, 70)

                elseif field.Type == "Spacer" then
                    fieldFrame.Size = UDim2.new(1, 0, 0, field.Height)

                elseif field.Type == "TextArea" then
                    fieldFrame.Size = UDim2.new(1, 0, 0, field.Rows * 20 + 16)

                    local label = Instance.new("TextLabel")
                    label.Size = UDim2.new(0, self._config.LabelWidth, 0, 20)
                    label.BackgroundTransparency = 1
                    label.Text = field.Label .. (field.Required and " *" or "")
                    label.TextColor3 = Color3.fromRGB(200, 200, 200)
                    label.TextSize = 12
                    label.Font = Enum.Font.Gotham
                    label.TextXAlignment = Enum.TextXAlignment.Left
                    label.Parent = fieldFrame

                    local input = Instance.new("TextBox")
                    input.Name = "Input"
                    input.Size = UDim2.new(1, -self._config.LabelWidth - 8, 1, 0)
                    input.Position = UDim2.new(0, self._config.LabelWidth + 8, 0, 0)
                    input.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
                    input.BorderSizePixel = 0
                    input.Text = field.Default or ""
                    input.PlaceholderText = field.Placeholder or ""
                    input.TextColor3 = Color3.fromRGB(255, 255, 255)
                    input.PlaceholderColor3 = Color3.fromRGB(120, 120, 120)
                    input.TextSize = 12
                    input.Font = Enum.Font.Gotham
                    input.TextXAlignment = Enum.TextXAlignment.Left
                    input.TextYAlignment = Enum.TextYAlignment.Top
                    input.MultiLine = true
                    input.TextWrapped = true
                    input.ClearTextOnFocus = false
                    input.Parent = fieldFrame

                    local inputCorner = Instance.new("UICorner")
                    inputCorner.CornerRadius = UDim.new(0, 4)
                    inputCorner.Parent = input

                    local inputPadding = Instance.new("UIPadding")
                    inputPadding.PaddingTop = UDim.new(0, 8)
                    inputPadding.PaddingLeft = UDim.new(0, 8)
                    inputPadding.Parent = input

                    formValues[field.Name] = field.Default or ""
                    fieldInstances[field.Name] = input

                    input:GetPropertyChangedSignal("Text"):Connect(function()
                        formValues[field.Name] = input.Text
                        if self._config.OnChange then
                            self._config.OnChange(field.Name, input.Text)
                        end
                    end)

                else
                    -- Generic field with label and input
                    if field.Label then
                        local label = Instance.new("TextLabel")
                        label.Size = UDim2.new(0, self._config.LabelWidth, 1, 0)
                        label.BackgroundTransparency = 1
                        label.Text = field.Label .. (field.Required and " *" or "")
                        label.TextColor3 = Color3.fromRGB(200, 200, 200)
                        label.TextSize = 12
                        label.Font = Enum.Font.Gotham
                        label.TextXAlignment = Enum.TextXAlignment.Left
                        label.Parent = fieldFrame
                    end

                    if field.Type == "TextInput" then
                        local input = Instance.new("TextBox")
                        input.Name = "Input"
                        input.Size = UDim2.new(1, -self._config.LabelWidth - 8, 0, 28)
                        input.Position = UDim2.new(0, self._config.LabelWidth + 8, 0.5, 0)
                        input.AnchorPoint = Vector2.new(0, 0.5)
                        input.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
                        input.BorderSizePixel = 0
                        input.Text = field.Default or ""
                        input.PlaceholderText = field.Placeholder or ""
                        input.TextColor3 = Color3.fromRGB(255, 255, 255)
                        input.PlaceholderColor3 = Color3.fromRGB(120, 120, 120)
                        input.TextSize = 12
                        input.Font = Enum.Font.Gotham
                        input.ClearTextOnFocus = false
                        input.Parent = fieldFrame

                        local inputCorner = Instance.new("UICorner")
                        inputCorner.CornerRadius = UDim.new(0, 4)
                        inputCorner.Parent = input

                        local inputPadding = Instance.new("UIPadding")
                        inputPadding.PaddingLeft = UDim.new(0, 8)
                        inputPadding.PaddingRight = UDim.new(0, 8)
                        inputPadding.Parent = input

                        formValues[field.Name] = field.Default or ""
                        fieldInstances[field.Name] = input

                        input:GetPropertyChangedSignal("Text"):Connect(function()
                            formValues[field.Name] = input.Text
                            if self._config.OnChange then
                                self._config.OnChange(field.Name, input.Text)
                            end
                        end)

                    elseif field.Type == "Checkbox" then
                        local checkbox = Instance.new("TextButton")
                        checkbox.Name = "Checkbox"
                        checkbox.Size = UDim2.new(0, 20, 0, 20)
                        checkbox.Position = UDim2.new(0, self._config.LabelWidth + 8, 0.5, 0)
                        checkbox.AnchorPoint = Vector2.new(0, 0.5)
                        checkbox.BackgroundColor3 = field.Default and Color3.fromRGB(60, 130, 255) or Color3.fromRGB(40, 40, 45)
                        checkbox.BorderSizePixel = 0
                        checkbox.Text = field.Default and "✓" or ""
                        checkbox.TextColor3 = Color3.fromRGB(255, 255, 255)
                        checkbox.TextSize = 14
                        checkbox.Font = Enum.Font.GothamBold
                        checkbox.AutoButtonColor = false
                        checkbox.Parent = fieldFrame

                        local checkboxCorner = Instance.new("UICorner")
                        checkboxCorner.CornerRadius = UDim.new(0, 4)
                        checkboxCorner.Parent = checkbox

                        formValues[field.Name] = field.Default or false
                        fieldInstances[field.Name] = checkbox

                        checkbox.MouseButton1Click:Connect(function()
                            formValues[field.Name] = not formValues[field.Name]
                            checkbox.Text = formValues[field.Name] and "✓" or ""
                            checkbox.BackgroundColor3 = formValues[field.Name] and Color3.fromRGB(60, 130, 255) or Color3.fromRGB(40, 40, 45)
                            if self._config.OnChange then
                                self._config.OnChange(field.Name, formValues[field.Name])
                            end
                        end)
                    end
                end

                fieldFrame.Parent = container
            end

            -- Buttons container
            if self._config.ShowSubmit or self._config.ShowReset or self._config.ShowCancel then
                local buttonsFrame = Instance.new("Frame")
                buttonsFrame.Name = "Buttons"
                buttonsFrame.Size = UDim2.new(1, 0, 0, 36)
                buttonsFrame.BackgroundTransparency = 1
                buttonsFrame.LayoutOrder = 9999
                buttonsFrame.Parent = container

                local buttonsLayout = Instance.new("UIListLayout")
                buttonsLayout.FillDirection = Enum.FillDirection.Horizontal
                buttonsLayout.Padding = UDim.new(0, 8)
                buttonsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
                buttonsLayout.VerticalAlignment = Enum.VerticalAlignment.Center
                buttonsLayout.Parent = buttonsFrame

                if self._config.ShowCancel then
                    local cancelBtn = Instance.new("TextButton")
                    cancelBtn.Name = "Cancel"
                    cancelBtn.Size = UDim2.new(0, 80, 0, 32)
                    cancelBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 55)
                    cancelBtn.BorderSizePixel = 0
                    cancelBtn.Text = self._config.CancelText
                    cancelBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
                    cancelBtn.TextSize = 12
                    cancelBtn.Font = Enum.Font.GothamMedium
                    cancelBtn.AutoButtonColor = false
                    cancelBtn.LayoutOrder = 1
                    cancelBtn.Parent = buttonsFrame

                    local cancelCorner = Instance.new("UICorner")
                    cancelCorner.CornerRadius = UDim.new(0, 4)
                    cancelCorner.Parent = cancelBtn

                    cancelBtn.MouseButton1Click:Connect(function()
                        if self._config.OnCancel then
                            self._config.OnCancel()
                        end
                    end)
                end

                if self._config.ShowReset then
                    local resetBtn = Instance.new("TextButton")
                    resetBtn.Name = "Reset"
                    resetBtn.Size = UDim2.new(0, 80, 0, 32)
                    resetBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 65)
                    resetBtn.BorderSizePixel = 0
                    resetBtn.Text = self._config.ResetText
                    resetBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
                    resetBtn.TextSize = 12
                    resetBtn.Font = Enum.Font.GothamMedium
                    resetBtn.AutoButtonColor = false
                    resetBtn.LayoutOrder = 2
                    resetBtn.Parent = buttonsFrame

                    local resetCorner = Instance.new("UICorner")
                    resetCorner.CornerRadius = UDim.new(0, 4)
                    resetCorner.Parent = resetBtn

                    resetBtn.MouseButton1Click:Connect(function()
                        -- Reset all fields
                        for _, field in ipairs(self._fields) do
                            if field.Name and field.Default ~= nil then
                                formValues[field.Name] = field.Default
                            end
                        end
                        if self._config.OnReset then
                            self._config.OnReset()
                        end
                    end)
                end

                if self._config.ShowSubmit then
                    local submitBtn = Instance.new("TextButton")
                    submitBtn.Name = "Submit"
                    submitBtn.Size = UDim2.new(0, 100, 0, 32)
                    submitBtn.BackgroundColor3 = Color3.fromRGB(60, 130, 255)
                    submitBtn.BorderSizePixel = 0
                    submitBtn.Text = self._config.SubmitText
                    submitBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
                    submitBtn.TextSize = 12
                    submitBtn.Font = Enum.Font.GothamMedium
                    submitBtn.AutoButtonColor = false
                    submitBtn.LayoutOrder = 3
                    submitBtn.Parent = buttonsFrame

                    local submitCorner = Instance.new("UICorner")
                    submitCorner.CornerRadius = UDim.new(0, 4)
                    submitCorner.Parent = submitBtn

                    submitBtn.MouseButton1Click:Connect(function()
                        if self._config.OnSubmit then
                            self._config.OnSubmit(formValues)
                        end
                    end)
                end
            end

            if parent then
                container.Parent = parent
            end

            -- Return interface
            return {
                Instance = container,
                GetValues = function() return formValues end,
                GetValue = function(name) return formValues[name] end,
                SetValue = function(name, value)
                    formValues[name] = value
                    -- Update UI if needed
                end,
                Reset = function()
                    for _, field in ipairs(self._fields) do
                        if field.Name and field.Default ~= nil then
                            formValues[field.Name] = field.Default
                        end
                    end
                end,
                Submit = function()
                    if self._config.OnSubmit then
                        self._config.OnSubmit(formValues)
                    end
                end,
            }
        end

        return FormBuilder


    end


    -- ============================================================================
    -- Module: NexusUI/Builders/Menu
    -- ============================================================================
    NexusUI_Modules["NexusUI/Builders/Menu"] = function()
        local script = CreateMockScript("NexusUI/Builders/Menu")

        --[[
            NexusUI Menu Builder
            Builder pattern for creating menus
        ]]

        --// Menu Builder
        local MenuBuilder = {}
        MenuBuilder.__index = MenuBuilder
        MenuBuilder.ClassName = "MenuBuilder"

        --// Constructor
        function MenuBuilder.new()
            local self = setmetatable({}, MenuBuilder)

            self._config = {
                Type = "Context", -- Context, Dropdown, Sidebar
                Width = 200,
                MaxHeight = 400,
                ShowIcons = true,
                ShowShortcuts = true,
                Animated = true,
                Theme = nil,
                OnClose = nil,
            }

            self._items = {}

            return self
        end

        --// Static create
        function MenuBuilder.Create()
            return MenuBuilder.new()
        end

        --// Context menu
        function MenuBuilder.Context()
            local builder = MenuBuilder.new()
            builder._config.Type = "Context"
            return builder
        end

        --// Dropdown menu
        function MenuBuilder.Dropdown()
            local builder = MenuBuilder.new()
            builder._config.Type = "Dropdown"
            return builder
        end

        --// Sidebar menu
        function MenuBuilder.Sidebar()
            local builder = MenuBuilder.new()
            builder._config.Type = "Sidebar"
            builder._config.Width = 250
            return builder
        end

        --// Width
        function MenuBuilder:Width(width)
            self._config.Width = width
            return self
        end

        --// Max height
        function MenuBuilder:MaxHeight(height)
            self._config.MaxHeight = height
            return self
        end

        --// Show icons
        function MenuBuilder:ShowIcons(value)
            self._config.ShowIcons = value
            return self
        end

        --// Show shortcuts
        function MenuBuilder:ShowShortcuts(value)
            self._config.ShowShortcuts = value
            return self
        end

        --// Animated
        function MenuBuilder:Animated(value)
            self._config.Animated = value
            return self
        end

        --// Theme
        function MenuBuilder:Theme(theme)
            self._config.Theme = theme
            return self
        end

        --// On close
        function MenuBuilder:OnClose(callback)
            self._config.OnClose = callback
            return self
        end

        --// Add item
        function MenuBuilder:AddItem(text, callback, config)
            config = config or {}
            table.insert(self._items, {
                Type = "Item",
                Text = text,
                Callback = callback,
                Icon = config.Icon,
                Shortcut = config.Shortcut,
                Disabled = config.Disabled or false,
            })
            return self
        end

        --// Add separator
        function MenuBuilder:AddSeparator()
            table.insert(self._items, {
                Type = "Separator"
            })
            return self
        end

        --// Add header
        function MenuBuilder:AddHeader(text)
            table.insert(self._items, {
                Type = "Header",
                Text = text
            })
            return self
        end

        --// Add submenu
        function MenuBuilder:AddSubmenu(text, items, config)
            config = config or {}
            table.insert(self._items, {
                Type = "Submenu",
                Text = text,
                Items = items,
                Icon = config.Icon,
            })
            return self
        end

        --// Add checkbox item
        function MenuBuilder:AddCheckbox(text, checked, callback, config)
            config = config or {}
            table.insert(self._items, {
                Type = "Checkbox",
                Text = text,
                Checked = checked,
                Callback = callback,
                Icon = config.Icon,
            })
            return self
        end

        --// Add radio item
        function MenuBuilder:AddRadio(text, group, selected, callback, config)
            config = config or {}
            table.insert(self._items, {
                Type = "Radio",
                Text = text,
                Group = group,
                Selected = selected,
                Callback = callback,
            })
            return self
        end

        --// Build the menu
        function MenuBuilder:Build(parent, position)
            local isOpen = false

            -- Container
            local container = Instance.new("Frame")
            container.Name = "Menu"
            container.Size = UDim2.new(0, self._config.Width, 0, 0)
            container.Position = position or UDim2.new(0, 0, 0, 0)
            container.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            container.BorderSizePixel = 0
            container.AutomaticSize = Enum.AutomaticSize.Y
            container.ClipsDescendants = true
            container.Visible = false
            container.ZIndex = 1000

            local containerCorner = Instance.new("UICorner")
            containerCorner.CornerRadius = UDim.new(0, 8)
            containerCorner.Parent = container

            local containerStroke = Instance.new("UIStroke")
            containerStroke.Color = Color3.fromRGB(60, 60, 70)
            containerStroke.Thickness = 1
            containerStroke.Parent = container

            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Vertical
            layout.Padding = UDim.new(0, 0)
            layout.SortOrder = Enum.SortOrder.LayoutOrder
            layout.Parent = container

            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, 4)
            padding.PaddingBottom = UDim.new(0, 4)
            padding.Parent = container

            -- Close function
            local function close()
                if not isOpen then return end
                isOpen = false
                container.Visible = false
                if self._config.OnClose then
                    self._config.OnClose()
                end
            end

            -- Create items
            for i, item in ipairs(self._items) do
                local itemFrame

                if item.Type == "Separator" then
                    itemFrame = Instance.new("Frame")
                    itemFrame.Name = "Separator"
                    itemFrame.Size = UDim2.new(1, -16, 0, 9)
                    itemFrame.BackgroundTransparency = 1
                    itemFrame.LayoutOrder = i

                    local line = Instance.new("Frame")
                    line.Size = UDim2.new(1, 0, 0, 1)
                    line.Position = UDim2.new(0, 0, 0.5, 0)
                    line.AnchorPoint = Vector2.new(0, 0.5)
                    line.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
                    line.BorderSizePixel = 0
                    line.Parent = itemFrame

                    local itemPadding = Instance.new("UIPadding")
                    itemPadding.PaddingLeft = UDim.new(0, 8)
                    itemPadding.PaddingRight = UDim.new(0, 8)
                    itemPadding.Parent = itemFrame

                elseif item.Type == "Header" then
                    itemFrame = Instance.new("Frame")
                    itemFrame.Name = "Header"
                    itemFrame.Size = UDim2.new(1, 0, 0, 24)
                    itemFrame.BackgroundTransparency = 1
                    itemFrame.LayoutOrder = i

                    local text = Instance.new("TextLabel")
                    text.Size = UDim2.new(1, -16, 1, 0)
                    text.Position = UDim2.new(0, 8, 0, 0)
                    text.BackgroundTransparency = 1
                    text.Text = item.Text
                    text.TextColor3 = Color3.fromRGB(120, 120, 130)
                    text.TextSize = 11
                    text.Font = Enum.Font.GothamMedium
                    text.TextXAlignment = Enum.TextXAlignment.Left
                    text.Parent = itemFrame

                else
                    itemFrame = Instance.new("TextButton")
                    itemFrame.Name = "Item_" .. item.Text
                    itemFrame.Size = UDim2.new(1, 0, 0, 32)
                    itemFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
                    itemFrame.BackgroundTransparency = 1
                    itemFrame.BorderSizePixel = 0
                    itemFrame.Text = ""
                    itemFrame.AutoButtonColor = false
                    itemFrame.LayoutOrder = i

                    local textLabel = Instance.new("TextLabel")
                    textLabel.Name = "Text"
                    textLabel.Size = UDim2.new(1, self._config.ShowIcons and -60 or -16, 1, 0)
                    textLabel.Position = UDim2.new(0, self._config.ShowIcons and 36 or 12, 0, 0)
                    textLabel.BackgroundTransparency = 1
                    textLabel.Text = item.Text
                    textLabel.TextColor3 = item.Disabled and Color3.fromRGB(100, 100, 100) or Color3.fromRGB(255, 255, 255)
                    textLabel.TextSize = 13
                    textLabel.Font = Enum.Font.Gotham
                    textLabel.TextXAlignment = Enum.TextXAlignment.Left
                    textLabel.Parent = itemFrame

                    -- Checkbox indicator
                    if item.Type == "Checkbox" then
                        local check = Instance.new("TextLabel")
                        check.Name = "Check"
                        check.Size = UDim2.new(0, 20, 0, 20)
                        check.Position = UDim2.new(0, 8, 0.5, 0)
                        check.AnchorPoint = Vector2.new(0, 0.5)
                        check.BackgroundTransparency = 1
                        check.Text = item.Checked and "✓" or ""
                        check.TextColor3 = Color3.fromRGB(60, 130, 255)
                        check.TextSize = 14
                        check.Font = Enum.Font.GothamBold
                        check.Parent = itemFrame
                    end

                    -- Shortcut
                    if item.Shortcut and self._config.ShowShortcuts then
                        local shortcut = Instance.new("TextLabel")
                        shortcut.Name = "Shortcut"
                        shortcut.Size = UDim2.new(0, 60, 1, 0)
                        shortcut.Position = UDim2.new(1, -68, 0, 0)
                        shortcut.BackgroundTransparency = 1
                        shortcut.Text = item.Shortcut
                        shortcut.TextColor3 = Color3.fromRGB(100, 100, 110)
                        shortcut.TextSize = 11
                        shortcut.Font = Enum.Font.Gotham
                        shortcut.TextXAlignment = Enum.TextXAlignment.Right
                        shortcut.Parent = itemFrame
                    end

                    -- Hover effect
                    itemFrame.MouseEnter:Connect(function()
                        if not item.Disabled then
                            itemFrame.BackgroundTransparency = 0
                            itemFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
                        end
                    end)

                    itemFrame.MouseLeave:Connect(function()
                        itemFrame.BackgroundTransparency = 1
                    end)

                    -- Click handler
                    itemFrame.MouseButton1Click:Connect(function()
                        if item.Disabled then return end

                        if item.Type == "Checkbox" then
                            item.Checked = not item.Checked
                            local check = itemFrame:FindFirstChild("Check")
                            if check then
                                check.Text = item.Checked and "✓" or ""
                            end
                            if item.Callback then
                                item.Callback(item.Checked)
                            end
                        else
                            if item.Callback then
                                item.Callback()
                            end
                            close()
                        end
                    end)
                end

                if itemFrame then
                    itemFrame.Parent = container
                end
            end

            if parent then
                container.Parent = parent
            end

            -- Return interface
            return {
                Instance = container,
                Open = function(pos)
                    if pos then
                        container.Position = pos
                    end
                    isOpen = true
                    container.Visible = true
                end,
                Close = close,
                IsOpen = function() return isOpen end,
                SetPosition = function(pos)
                    container.Position = pos
                end,
            }
        end

        return MenuBuilder


    end


    -- ============================================================================
    -- Module: NexusUI/Builders/Toolbar
    -- ============================================================================
    NexusUI_Modules["NexusUI/Builders/Toolbar"] = function()
        local script = CreateMockScript("NexusUI/Builders/Toolbar")

        --[[
            NexusUI Toolbar Builder
            Builder pattern for creating toolbars
        ]]

        --// Toolbar Builder
        local ToolbarBuilder = {}
        ToolbarBuilder.__index = ToolbarBuilder
        ToolbarBuilder.ClassName = "ToolbarBuilder"

        --// Constructor
        function ToolbarBuilder.new()
            local self = setmetatable({}, ToolbarBuilder)

            self._config = {
                Position = "Top", -- Top, Bottom, Left, Right
                Height = 40,
                Width = 50,
                Padding = 8,
                Spacing = 4,
                ShowLabels = false,
                IconSize = 20,
                Theme = nil,
            }

            self._items = {}

            return self
        end

        --// Static create
        function ToolbarBuilder.Create()
            return ToolbarBuilder.new()
        end

        --// Position
        function ToolbarBuilder:Position(position)
            self._config.Position = position
            return self
        end

        --// Height (for horizontal)
        function ToolbarBuilder:Height(height)
            self._config.Height = height
            return self
        end

        --// Width (for vertical)
        function ToolbarBuilder:Width(width)
            self._config.Width = width
            return self
        end

        --// Padding
        function ToolbarBuilder:Padding(padding)
            self._config.Padding = padding
            return self
        end

        --// Spacing
        function ToolbarBuilder:Spacing(spacing)
            self._config.Spacing = spacing
            return self
        end

        --// Show labels
        function ToolbarBuilder:ShowLabels(value)
            self._config.ShowLabels = value
            return self
        end

        --// Icon size
        function ToolbarBuilder:IconSize(size)
            self._config.IconSize = size
            return self
        end

        --// Theme
        function ToolbarBuilder:Theme(theme)
            self._config.Theme = theme
            return self
        end

        --// Add button
        function ToolbarBuilder:AddButton(id, config)
            config = config or {}
            table.insert(self._items, {
                Type = "Button",
                Id = id,
                Icon = config.Icon,
                Label = config.Label,
                Tooltip = config.Tooltip,
                Callback = config.Callback,
                Disabled = config.Disabled or false,
            })
            return self
        end

        --// Add toggle button
        function ToolbarBuilder:AddToggle(id, config)
            config = config or {}
            table.insert(self._items, {
                Type = "Toggle",
                Id = id,
                Icon = config.Icon,
                IconActive = config.IconActive or config.Icon,
                Label = config.Label,
                Tooltip = config.Tooltip,
                Active = config.Active or false,
                Callback = config.Callback,
            })
            return self
        end

        --// Add separator
        function ToolbarBuilder:AddSeparator()
            table.insert(self._items, {
                Type = "Separator"
            })
            return self
        end

        --// Add spacer
        function ToolbarBuilder:AddSpacer()
            table.insert(self._items, {
                Type = "Spacer"
            })
            return self
        end

        --// Add dropdown
        function ToolbarBuilder:AddDropdown(id, config)
            config = config or {}
            table.insert(self._items, {
                Type = "Dropdown",
                Id = id,
                Icon = config.Icon,
                Label = config.Label,
                Options = config.Options or {},
                Selected = config.Selected,
                Callback = config.Callback,
            })
            return self
        end

        --// Add group
        function ToolbarBuilder:AddGroup(items)
            table.insert(self._items, {
                Type = "Group",
                Items = items
            })
            return self
        end

        --// Build the toolbar
        function ToolbarBuilder:Build(parent)
            local isVertical = self._config.Position == "Left" or self._config.Position == "Right"
            local buttonStates = {}

            -- Container
            local container = Instance.new("Frame")
            container.Name = "Toolbar"
            container.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            container.BorderSizePixel = 0

            if isVertical then
                container.Size = UDim2.new(0, self._config.Width, 1, 0)
                if self._config.Position == "Right" then
                    container.Position = UDim2.new(1, -self._config.Width, 0, 0)
                end
            else
                container.Size = UDim2.new(1, 0, 0, self._config.Height)
                if self._config.Position == "Bottom" then
                    container.Position = UDim2.new(0, 0, 1, -self._config.Height)
                end
            end

            local layout = Instance.new("UIListLayout")
            layout.FillDirection = isVertical and Enum.FillDirection.Vertical or Enum.FillDirection.Horizontal
            layout.Padding = UDim.new(0, self._config.Spacing)
            layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.SortOrder = Enum.SortOrder.LayoutOrder
            layout.Parent = container

            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, self._config.Padding)
            padding.PaddingBottom = UDim.new(0, self._config.Padding)
            padding.PaddingLeft = UDim.new(0, self._config.Padding)
            padding.PaddingRight = UDim.new(0, self._config.Padding)
            padding.Parent = container

            -- Create items
            local buttons = {}

            for i, item in ipairs(self._items) do
                local itemFrame

                if item.Type == "Separator" then
                    itemFrame = Instance.new("Frame")
                    itemFrame.Name = "Separator"
                    if isVertical then
                        itemFrame.Size = UDim2.new(1, -8, 0, 1)
                    else
                        itemFrame.Size = UDim2.new(0, 1, 1, -8)
                    end
                    itemFrame.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
                    itemFrame.BorderSizePixel = 0
                    itemFrame.LayoutOrder = i

                elseif item.Type == "Spacer" then
                    itemFrame = Instance.new("Frame")
                    itemFrame.Name = "Spacer"
                    itemFrame.BackgroundTransparency = 1
                    itemFrame.LayoutOrder = i
                    -- Spacer will be sized by layout

                elseif item.Type == "Button" or item.Type == "Toggle" then
                    local buttonSize = self._config.Height - self._config.Padding * 2

                    itemFrame = Instance.new("TextButton")
                    itemFrame.Name = "Button_" .. (item.Id or i)
                    itemFrame.Size = UDim2.new(0, self._config.ShowLabels and 80 or buttonSize, 0, buttonSize)
                    itemFrame.BackgroundColor3 = (item.Type == "Toggle" and item.Active) and Color3.fromRGB(60, 130, 255) or Color3.fromRGB(40, 40, 45)
                    itemFrame.BorderSizePixel = 0
                    itemFrame.Text = ""
                    itemFrame.AutoButtonColor = false
                    itemFrame.LayoutOrder = i

                    local buttonCorner = Instance.new("UICorner")
                    buttonCorner.CornerRadius = UDim.new(0, 6)
                    buttonCorner.Parent = itemFrame

                    -- Icon placeholder (would use actual icon asset)
                    local icon = Instance.new("TextLabel")
                    icon.Name = "Icon"
                    icon.Size = UDim2.new(0, self._config.IconSize, 0, self._config.IconSize)
                    icon.Position = self._config.ShowLabels and UDim2.new(0, 8, 0.5, 0) or UDim2.new(0.5, 0, 0.5, 0)
                    icon.AnchorPoint = self._config.ShowLabels and Vector2.new(0, 0.5) or Vector2.new(0.5, 0.5)
                    icon.BackgroundTransparency = 1
                    icon.Text = item.Icon or "●"
                    icon.TextColor3 = Color3.fromRGB(255, 255, 255)
                    icon.TextSize = self._config.IconSize
                    icon.Font = Enum.Font.Gotham
                    icon.Parent = itemFrame

                    if self._config.ShowLabels and item.Label then
                        local label = Instance.new("TextLabel")
                        label.Name = "Label"
                        label.Size = UDim2.new(1, -36, 1, 0)
                        label.Position = UDim2.new(0, 32, 0, 0)
                        label.BackgroundTransparency = 1
                        label.Text = item.Label
                        label.TextColor3 = Color3.fromRGB(255, 255, 255)
                        label.TextSize = 11
                        label.Font = Enum.Font.Gotham
                        label.TextXAlignment = Enum.TextXAlignment.Left
                        label.Parent = itemFrame
                    end

                    -- Store state
                    if item.Type == "Toggle" then
                        buttonStates[item.Id] = item.Active
                    end

                    -- Hover effect
                    itemFrame.MouseEnter:Connect(function()
                        if not item.Disabled then
                            if item.Type == "Toggle" and buttonStates[item.Id] then
                                itemFrame.BackgroundColor3 = Color3.fromRGB(70, 140, 255)
                            else
                                itemFrame.BackgroundColor3 = Color3.fromRGB(55, 55, 60)
                            end
                        end
                    end)

                    itemFrame.MouseLeave:Connect(function()
                        if item.Type == "Toggle" and buttonStates[item.Id] then
                            itemFrame.BackgroundColor3 = Color3.fromRGB(60, 130, 255)
                        else
                            itemFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
                        end
                    end)

                    -- Click handler
                    itemFrame.MouseButton1Click:Connect(function()
                        if item.Disabled then return end

                        if item.Type == "Toggle" then
                            buttonStates[item.Id] = not buttonStates[item.Id]
                            itemFrame.BackgroundColor3 = buttonStates[item.Id] and Color3.fromRGB(60, 130, 255) or Color3.fromRGB(40, 40, 45)
                            if item.Callback then
                                item.Callback(buttonStates[item.Id])
                            end
                        else
                            if item.Callback then
                                item.Callback()
                            end
                        end
                    end)

                    buttons[item.Id] = itemFrame
                end

                if itemFrame then
                    itemFrame.Parent = container
                end
            end

            if parent then
                container.Parent = parent
            end

            -- Return interface
            return {
                Instance = container,
                Buttons = buttons,
                GetState = function(id) return buttonStates[id] end,
                SetState = function(id, state)
                    buttonStates[id] = state
                    local btn = buttons[id]
                    if btn then
                        btn.BackgroundColor3 = state and Color3.fromRGB(60, 130, 255) or Color3.fromRGB(40, 40, 45)
                    end
                end,
                EnableButton = function(id)
                    local item = nil
                    for _, it in ipairs(self._items) do
                        if it.Id == id then item = it break end
                    end
                    if item then item.Disabled = false end
                end,
                DisableButton = function(id)
                    local item = nil
                    for _, it in ipairs(self._items) do
                        if it.Id == id then item = it break end
                    end
                    if item then item.Disabled = true end
                end,
            }
        end

        return ToolbarBuilder


    end


    -- ============================================================================
    -- Module: NexusUI/Builders/Dialog
    -- ============================================================================
    NexusUI_Modules["NexusUI/Builders/Dialog"] = function()
        local script = CreateMockScript("NexusUI/Builders/Dialog")

        --[[
            NexusUI Dialog Builder
            Builder pattern for creating dialogs
        ]]

        --// Dialog Builder
        local DialogBuilder = {}
        DialogBuilder.__index = DialogBuilder
        DialogBuilder.ClassName = "DialogBuilder"

        --// Constructor
        function DialogBuilder.new()
            local self = setmetatable({}, DialogBuilder)

            self._config = {
                Title = "Dialog",
                Message = "",
                Type = "Default", -- Default, Alert, Confirm, Prompt, Custom
                Width = 400,
                ShowOverlay = true,
                OverlayDismiss = true,
                Animated = true,
                Icon = nil,
                Theme = nil,
                Buttons = {},
                OnClose = nil,
            }

            self._content = nil

            return self
        end

        --// Static create
        function DialogBuilder.Create()
            return DialogBuilder.new()
        end

        --// Alert dialog
        function DialogBuilder.Alert(title, message)
            local builder = DialogBuilder.new()
            builder._config.Type = "Alert"
            builder._config.Title = title
            builder._config.Message = message
            builder:AddButton("OK", nil, { Primary = true })
            return builder
        end

        --// Confirm dialog
        function DialogBuilder.Confirm(title, message)
            local builder = DialogBuilder.new()
            builder._config.Type = "Confirm"
            builder._config.Title = title
            builder._config.Message = message
            builder:AddButton("Cancel", nil)
            builder:AddButton("Confirm", nil, { Primary = true })
            return builder
        end

        --// Prompt dialog
        function DialogBuilder.Prompt(title, message, placeholder)
            local builder = DialogBuilder.new()
            builder._config.Type = "Prompt"
            builder._config.Title = title
            builder._config.Message = message
            builder._config.Placeholder = placeholder
            builder:AddButton("Cancel", nil)
            builder:AddButton("OK", nil, { Primary = true })
            return builder
        end

        --// Title
        function DialogBuilder:Title(title)
            self._config.Title = title
            return self
        end

        --// Message
        function DialogBuilder:Message(message)
            self._config.Message = message
            return self
        end

        --// Width
        function DialogBuilder:Width(width)
            self._config.Width = width
            return self
        end

        --// Show overlay
        function DialogBuilder:ShowOverlay(value)
            self._config.ShowOverlay = value
            return self
        end

        --// Overlay dismiss
        function DialogBuilder:OverlayDismiss(value)
            self._config.OverlayDismiss = value
            return self
        end

        --// Animated
        function DialogBuilder:Animated(value)
            self._config.Animated = value
            return self
        end

        --// Icon
        function DialogBuilder:Icon(icon)
            self._config.Icon = icon
            return self
        end

        --// Theme
        function DialogBuilder:Theme(theme)
            self._config.Theme = theme
            return self
        end

        --// On close
        function DialogBuilder:OnClose(callback)
            self._config.OnClose = callback
            return self
        end

        --// Add button
        function DialogBuilder:AddButton(text, callback, config)
            config = config or {}
            table.insert(self._config.Buttons, {
                Text = text,
                Callback = callback,
                Primary = config.Primary or false,
                Danger = config.Danger or false,
                Close = config.Close ~= false, -- Default true
            })
            return self
        end

        --// Set custom content
        function DialogBuilder:Content(builder)
            self._content = builder
            return self
        end

        --// Build the dialog
        function DialogBuilder:Build(parent)
            local isOpen = false
            local inputValue = ""
            local result = nil

            -- Overlay
            local overlay
            if self._config.ShowOverlay then
                overlay = Instance.new("Frame")
                overlay.Name = "DialogOverlay"
                overlay.Size = UDim2.new(1, 0, 1, 0)
                overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                overlay.BackgroundTransparency = 0.5
                overlay.BorderSizePixel = 0
                overlay.ZIndex = 999
                overlay.Visible = false

                if parent then
                    overlay.Parent = parent
                end
            end

            -- Dialog container
            local dialog = Instance.new("Frame")
            dialog.Name = "Dialog"
            dialog.Size = UDim2.new(0, self._config.Width, 0, 0)
            dialog.Position = UDim2.new(0.5, 0, 0.5, 0)
            dialog.AnchorPoint = Vector2.new(0.5, 0.5)
            dialog.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
            dialog.BorderSizePixel = 0
            dialog.AutomaticSize = Enum.AutomaticSize.Y
            dialog.ZIndex = 1000
            dialog.Visible = false

            local dialogCorner = Instance.new("UICorner")
            dialogCorner.CornerRadius = UDim.new(0, 12)
            dialogCorner.Parent = dialog

            local dialogPadding = Instance.new("UIPadding")
            dialogPadding.PaddingTop = UDim.new(0, 20)
            dialogPadding.PaddingBottom = UDim.new(0, 16)
            dialogPadding.PaddingLeft = UDim.new(0, 20)
            dialogPadding.PaddingRight = UDim.new(0, 20)
            dialogPadding.Parent = dialog

            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Vertical
            layout.Padding = UDim.new(0, 12)
            layout.SortOrder = Enum.SortOrder.LayoutOrder
            layout.Parent = dialog

            -- Title
            local title = Instance.new("TextLabel")
            title.Name = "Title"
            title.Size = UDim2.new(1, 0, 0, 24)
            title.BackgroundTransparency = 1
            title.Text = self._config.Title
            title.TextColor3 = Color3.fromRGB(255, 255, 255)
            title.TextSize = 18
            title.Font = Enum.Font.GothamBold
            title.TextXAlignment = Enum.TextXAlignment.Left
            title.LayoutOrder = 1
            title.Parent = dialog

            -- Message
            if self._config.Message and self._config.Message ~= "" then
                local message = Instance.new("TextLabel")
                message.Name = "Message"
                message.Size = UDim2.new(1, 0, 0, 0)
                message.BackgroundTransparency = 1
                message.Text = self._config.Message
                message.TextColor3 = Color3.fromRGB(180, 180, 180)
                message.TextSize = 14
                message.Font = Enum.Font.Gotham
                message.TextXAlignment = Enum.TextXAlignment.Left
                message.TextWrapped = true
                message.AutomaticSize = Enum.AutomaticSize.Y
                message.LayoutOrder = 2
                message.Parent = dialog
            end

            -- Prompt input
            local promptInput
            if self._config.Type == "Prompt" then
                promptInput = Instance.new("TextBox")
                promptInput.Name = "Input"
                promptInput.Size = UDim2.new(1, 0, 0, 36)
                promptInput.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
                promptInput.BorderSizePixel = 0
                promptInput.Text = ""
                promptInput.PlaceholderText = self._config.Placeholder or "Enter text..."
                promptInput.TextColor3 = Color3.fromRGB(255, 255, 255)
                promptInput.PlaceholderColor3 = Color3.fromRGB(120, 120, 120)
                promptInput.TextSize = 14
                promptInput.Font = Enum.Font.Gotham
                promptInput.ClearTextOnFocus = false
                promptInput.LayoutOrder = 3
                promptInput.Parent = dialog

                local inputCorner = Instance.new("UICorner")
                inputCorner.CornerRadius = UDim.new(0, 6)
                inputCorner.Parent = promptInput

                local inputPadding = Instance.new("UIPadding")
                inputPadding.PaddingLeft = UDim.new(0, 12)
                inputPadding.PaddingRight = UDim.new(0, 12)
                inputPadding.Parent = promptInput

                promptInput:GetPropertyChangedSignal("Text"):Connect(function()
                    inputValue = promptInput.Text
                end)
            end

            -- Custom content
            if self._content then
                local contentFrame = Instance.new("Frame")
                contentFrame.Name = "Content"
                contentFrame.Size = UDim2.new(1, 0, 0, 0)
                contentFrame.BackgroundTransparency = 1
                contentFrame.AutomaticSize = Enum.AutomaticSize.Y
                contentFrame.LayoutOrder = 4
                contentFrame.Parent = dialog

                if typeof(self._content) == "table" and self._content.Build then
                    self._content:Build(contentFrame)
                elseif typeof(self._content) == "Instance" then
                    self._content.Parent = contentFrame
                end
            end

            -- Close function
            local function close(buttonResult)
                if not isOpen then return end
                isOpen = false
                result = buttonResult

                dialog.Visible = false
                if overlay then
                    overlay.Visible = false
                end

                if self._config.OnClose then
                    self._config.OnClose(result, inputValue)
                end
            end

            -- Buttons
            if #self._config.Buttons > 0 then
                local buttonsFrame = Instance.new("Frame")
                buttonsFrame.Name = "Buttons"
                buttonsFrame.Size = UDim2.new(1, 0, 0, 36)
                buttonsFrame.BackgroundTransparency = 1
                buttonsFrame.LayoutOrder = 10
                buttonsFrame.Parent = dialog

                local buttonsLayout = Instance.new("UIListLayout")
                buttonsLayout.FillDirection = Enum.FillDirection.Horizontal
                buttonsLayout.Padding = UDim.new(0, 8)
                buttonsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
                buttonsLayout.VerticalAlignment = Enum.VerticalAlignment.Center
                buttonsLayout.Parent = buttonsFrame

                for i, btnConfig in ipairs(self._config.Buttons) do
                    local btn = Instance.new("TextButton")
                    btn.Name = "Button_" .. btnConfig.Text
                    btn.Size = UDim2.new(0, 90, 0, 34)
                    btn.BorderSizePixel = 0
                    btn.Text = btnConfig.Text
                    btn.TextColor3 = Color3.fromRGB(255, 255, 255)
                    btn.TextSize = 13
                    btn.Font = Enum.Font.GothamMedium
                    btn.AutoButtonColor = false
                    btn.LayoutOrder = i

                    if btnConfig.Primary then
                        btn.BackgroundColor3 = Color3.fromRGB(60, 130, 255)
                    elseif btnConfig.Danger then
                        btn.BackgroundColor3 = Color3.fromRGB(220, 60, 60)
                    else
                        btn.BackgroundColor3 = Color3.fromRGB(55, 55, 60)
                    end

                    local btnCorner = Instance.new("UICorner")
                    btnCorner.CornerRadius = UDim.new(0, 6)
                    btnCorner.Parent = btn

                    btn.MouseButton1Click:Connect(function()
                        if btnConfig.Callback then
                            btnConfig.Callback(inputValue)
                        end
                        if btnConfig.Close then
                            close(btnConfig.Text)
                        end
                    end)

                    btn.Parent = buttonsFrame
                end
            end

            -- Overlay click to dismiss
            if overlay and self._config.OverlayDismiss then
                local overlayBtn = Instance.new("TextButton")
                overlayBtn.Size = UDim2.new(1, 0, 1, 0)
                overlayBtn.BackgroundTransparency = 1
                overlayBtn.Text = ""
                overlayBtn.Parent = overlay

                overlayBtn.MouseButton1Click:Connect(function()
                    close(nil)
                end)
            end

            if parent then
                dialog.Parent = parent
            end

            -- Return interface
            return {
                Instance = dialog,
                Overlay = overlay,
                Show = function()
                    isOpen = true
                    result = nil
                    inputValue = ""
                    if promptInput then
                        promptInput.Text = ""
                    end
                    if overlay then
                        overlay.Visible = true
                    end
                    dialog.Visible = true
                end,
                Hide = function()
                    close(nil)
                end,
                IsOpen = function() return isOpen end,
                GetResult = function() return result end,
                GetInputValue = function() return inputValue end,
            }
        end

        return DialogBuilder


    end


    -- ============================================================================
    -- Module: NexusUI/Builders/Card
    -- ============================================================================
    NexusUI_Modules["NexusUI/Builders/Card"] = function()
        local script = CreateMockScript("NexusUI/Builders/Card")

        --[[
            NexusUI Card Builder
            Builder pattern for creating cards
        ]]

        --// Card Builder
        local CardBuilder = {}
        CardBuilder.__index = CardBuilder
        CardBuilder.ClassName = "CardBuilder"

        --// Constructor
        function CardBuilder.new()
            local self = setmetatable({}, CardBuilder)

            self._config = {
                Title = nil,
                Subtitle = nil,
                Image = nil,
                ImageHeight = 150,
                Content = nil,
                Footer = nil,
                Width = nil, -- Auto
                Padding = 16,
                Spacing = 12,
                Rounded = 12,
                Elevated = true,
                Clickable = false,
                Theme = nil,
                OnClick = nil,
                OnHover = nil,
            }

            self._actions = {}
            self._badges = {}

            return self
        end

        --// Static create
        function CardBuilder.Create()
            return CardBuilder.new()
        end

        --// Title
        function CardBuilder:Title(title)
            self._config.Title = title
            return self
        end

        --// Subtitle
        function CardBuilder:Subtitle(subtitle)
            self._config.Subtitle = subtitle
            return self
        end

        --// Image
        function CardBuilder:Image(imageId, height)
            self._config.Image = imageId
            if height then
                self._config.ImageHeight = height
            end
            return self
        end

        --// Content
        function CardBuilder:Content(content)
            self._config.Content = content
            return self
        end

        --// Footer
        function CardBuilder:Footer(footer)
            self._config.Footer = footer
            return self
        end

        --// Width
        function CardBuilder:Width(width)
            self._config.Width = width
            return self
        end

        --// Padding
        function CardBuilder:Padding(padding)
            self._config.Padding = padding
            return self
        end

        --// Spacing
        function CardBuilder:Spacing(spacing)
            self._config.Spacing = spacing
            return self
        end

        --// Rounded
        function CardBuilder:Rounded(radius)
            self._config.Rounded = radius
            return self
        end

        --// Elevated
        function CardBuilder:Elevated(value)
            self._config.Elevated = value
            return self
        end

        --// Clickable
        function CardBuilder:Clickable(value)
            self._config.Clickable = value
            return self
        end

        --// Theme
        function CardBuilder:Theme(theme)
            self._config.Theme = theme
            return self
        end

        --// On click
        function CardBuilder:OnClick(callback)
            self._config.OnClick = callback
            self._config.Clickable = true
            return self
        end

        --// On hover
        function CardBuilder:OnHover(callback)
            self._config.OnHover = callback
            return self
        end

        --// Add action button
        function CardBuilder:AddAction(text, callback, config)
            config = config or {}
            table.insert(self._actions, {
                Text = text,
                Callback = callback,
                Icon = config.Icon,
                Primary = config.Primary or false,
            })
            return self
        end

        --// Add badge
        function CardBuilder:AddBadge(text, config)
            config = config or {}
            table.insert(self._badges, {
                Text = text,
                Color = config.Color or Color3.fromRGB(60, 130, 255),
                TextColor = config.TextColor or Color3.fromRGB(255, 255, 255),
            })
            return self
        end

        --// Build the card
        function CardBuilder:Build(parent)
            -- Container
            local container
            if self._config.Clickable then
                container = Instance.new("TextButton")
                container.Text = ""
                container.AutoButtonColor = false
            else
                container = Instance.new("Frame")
            end

            container.Name = "Card"
            container.Size = self._config.Width and UDim2.new(0, self._config.Width, 0, 0) or UDim2.new(1, 0, 0, 0)
            container.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
            container.BorderSizePixel = 0
            container.AutomaticSize = Enum.AutomaticSize.Y

            local containerCorner = Instance.new("UICorner")
            containerCorner.CornerRadius = UDim.new(0, self._config.Rounded)
            containerCorner.Parent = container

            -- Shadow for elevated cards
            if self._config.Elevated then
                local shadow = Instance.new("ImageLabel")
                shadow.Name = "Shadow"
                shadow.Size = UDim2.new(1, 16, 1, 16)
                shadow.Position = UDim2.new(0.5, 0, 0.5, 4)
                shadow.AnchorPoint = Vector2.new(0.5, 0.5)
                shadow.BackgroundTransparency = 1
                shadow.Image = "rbxassetid://6015897843"
                shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
                shadow.ImageTransparency = 0.7
                shadow.ScaleType = Enum.ScaleType.Slice
                shadow.SliceCenter = Rect.new(49, 49, 450, 450)
                shadow.ZIndex = -1
                shadow.Parent = container
            end

            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Vertical
            layout.Padding = UDim.new(0, 0)
            layout.SortOrder = Enum.SortOrder.LayoutOrder
            layout.Parent = container

            local layoutOrder = 0

            -- Image
            if self._config.Image then
                local imageContainer = Instance.new("Frame")
                imageContainer.Name = "ImageContainer"
                imageContainer.Size = UDim2.new(1, 0, 0, self._config.ImageHeight)
                imageContainer.BackgroundTransparency = 1
                imageContainer.ClipsDescendants = true
                imageContainer.LayoutOrder = layoutOrder
                imageContainer.Parent = container
                layoutOrder = layoutOrder + 1

                local image = Instance.new("ImageLabel")
                image.Name = "Image"
                image.Size = UDim2.new(1, 0, 1, 0)
                image.BackgroundTransparency = 1
                image.Image = self._config.Image
                image.ScaleType = Enum.ScaleType.Crop
                image.Parent = imageContainer

                -- Rounded top corners
                local imageCorner = Instance.new("UICorner")
                imageCorner.CornerRadius = UDim.new(0, self._config.Rounded)
                imageCorner.Parent = imageContainer

                -- Badges overlay
                if #self._badges > 0 then
                    local badgesContainer = Instance.new("Frame")
                    badgesContainer.Name = "Badges"
                    badgesContainer.Size = UDim2.new(1, -16, 0, 0)
                    badgesContainer.Position = UDim2.new(0, 8, 0, 8)
                    badgesContainer.BackgroundTransparency = 1
                    badgesContainer.AutomaticSize = Enum.AutomaticSize.Y
                    badgesContainer.Parent = imageContainer

                    local badgesLayout = Instance.new("UIListLayout")
                    badgesLayout.FillDirection = Enum.FillDirection.Horizontal
                    badgesLayout.Padding = UDim.new(0, 4)
                    badgesLayout.Parent = badgesContainer

                    for _, badge in ipairs(self._badges) do
                        local badgeFrame = Instance.new("Frame")
                        badgeFrame.Size = UDim2.new(0, 0, 0, 22)
                        badgeFrame.BackgroundColor3 = badge.Color
                        badgeFrame.AutomaticSize = Enum.AutomaticSize.X

                        local badgeCorner = Instance.new("UICorner")
                        badgeCorner.CornerRadius = UDim.new(0, 4)
                        badgeCorner.Parent = badgeFrame

                        local badgePadding = Instance.new("UIPadding")
                        badgePadding.PaddingLeft = UDim.new(0, 8)
                        badgePadding.PaddingRight = UDim.new(0, 8)
                        badgePadding.Parent = badgeFrame

                        local badgeText = Instance.new("TextLabel")
                        badgeText.Size = UDim2.new(0, 0, 1, 0)
                        badgeText.BackgroundTransparency = 1
                        badgeText.Text = badge.Text
                        badgeText.TextColor3 = badge.TextColor
                        badgeText.TextSize = 11
                        badgeText.Font = Enum.Font.GothamMedium
                        badgeText.AutomaticSize = Enum.AutomaticSize.X
                        badgeText.Parent = badgeFrame

                        badgeFrame.Parent = badgesContainer
                    end
                end
            end

            -- Body container
            local body = Instance.new("Frame")
            body.Name = "Body"
            body.Size = UDim2.new(1, 0, 0, 0)
            body.BackgroundTransparency = 1
            body.AutomaticSize = Enum.AutomaticSize.Y
            body.LayoutOrder = layoutOrder
            body.Parent = container
            layoutOrder = layoutOrder + 1

            local bodyPadding = Instance.new("UIPadding")
            bodyPadding.PaddingTop = UDim.new(0, self._config.Padding)
            bodyPadding.PaddingBottom = UDim.new(0, self._config.Padding)
            bodyPadding.PaddingLeft = UDim.new(0, self._config.Padding)
            bodyPadding.PaddingRight = UDim.new(0, self._config.Padding)
            bodyPadding.Parent = body

            local bodyLayout = Instance.new("UIListLayout")
            bodyLayout.FillDirection = Enum.FillDirection.Vertical
            bodyLayout.Padding = UDim.new(0, self._config.Spacing)
            bodyLayout.SortOrder = Enum.SortOrder.LayoutOrder
            bodyLayout.Parent = body

            local bodyOrder = 0

            -- Title
            if self._config.Title then
                local title = Instance.new("TextLabel")
                title.Name = "Title"
                title.Size = UDim2.new(1, 0, 0, 0)
                title.BackgroundTransparency = 1
                title.Text = self._config.Title
                title.TextColor3 = Color3.fromRGB(255, 255, 255)
                title.TextSize = 16
                title.Font = Enum.Font.GothamBold
                title.TextXAlignment = Enum.TextXAlignment.Left
                title.TextWrapped = true
                title.AutomaticSize = Enum.AutomaticSize.Y
                title.LayoutOrder = bodyOrder
                title.Parent = body
                bodyOrder = bodyOrder + 1
            end

            -- Subtitle
            if self._config.Subtitle then
                local subtitle = Instance.new("TextLabel")
                subtitle.Name = "Subtitle"
                subtitle.Size = UDim2.new(1, 0, 0, 0)
                subtitle.BackgroundTransparency = 1
                subtitle.Text = self._config.Subtitle
                subtitle.TextColor3 = Color3.fromRGB(140, 140, 150)
                subtitle.TextSize = 12
                subtitle.Font = Enum.Font.Gotham
                subtitle.TextXAlignment = Enum.TextXAlignment.Left
                subtitle.TextWrapped = true
                subtitle.AutomaticSize = Enum.AutomaticSize.Y
                subtitle.LayoutOrder = bodyOrder
                subtitle.Parent = body
                bodyOrder = bodyOrder + 1
            end

            -- Content
            if self._config.Content then
                local content = Instance.new("TextLabel")
                content.Name = "Content"
                content.Size = UDim2.new(1, 0, 0, 0)
                content.BackgroundTransparency = 1
                content.Text = self._config.Content
                content.TextColor3 = Color3.fromRGB(180, 180, 180)
                content.TextSize = 13
                content.Font = Enum.Font.Gotham
                content.TextXAlignment = Enum.TextXAlignment.Left
                content.TextWrapped = true
                content.AutomaticSize = Enum.AutomaticSize.Y
                content.LayoutOrder = bodyOrder
                content.Parent = body
                bodyOrder = bodyOrder + 1
            end

            -- Actions
            if #self._actions > 0 then
                local actionsFrame = Instance.new("Frame")
                actionsFrame.Name = "Actions"
                actionsFrame.Size = UDim2.new(1, 0, 0, 32)
                actionsFrame.BackgroundTransparency = 1
                actionsFrame.LayoutOrder = bodyOrder
                actionsFrame.Parent = body

                local actionsLayout = Instance.new("UIListLayout")
                actionsLayout.FillDirection = Enum.FillDirection.Horizontal
                actionsLayout.Padding = UDim.new(0, 8)
                actionsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
                actionsLayout.Parent = actionsFrame

                for i, action in ipairs(self._actions) do
                    local btn = Instance.new("TextButton")
                    btn.Name = "Action_" .. action.Text
                    btn.Size = UDim2.new(0, 80, 0, 30)
                    btn.BackgroundColor3 = action.Primary and Color3.fromRGB(60, 130, 255) or Color3.fromRGB(50, 50, 55)
                    btn.BorderSizePixel = 0
                    btn.Text = action.Text
                    btn.TextColor3 = Color3.fromRGB(255, 255, 255)
                    btn.TextSize = 12
                    btn.Font = Enum.Font.GothamMedium
                    btn.AutoButtonColor = false
                    btn.LayoutOrder = i
                    btn.Parent = actionsFrame

                    local btnCorner = Instance.new("UICorner")
                    btnCorner.CornerRadius = UDim.new(0, 4)
                    btnCorner.Parent = btn

                    btn.MouseButton1Click:Connect(function()
                        if action.Callback then
                            action.Callback()
                        end
                    end)
                end
            end

            -- Footer
            if self._config.Footer then
                local footer = Instance.new("Frame")
                footer.Name = "Footer"
                footer.Size = UDim2.new(1, 0, 0, 40)
                footer.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
                footer.LayoutOrder = layoutOrder
                footer.Parent = container

                local footerPadding = Instance.new("UIPadding")
                footerPadding.PaddingLeft = UDim.new(0, self._config.Padding)
                footerPadding.PaddingRight = UDim.new(0, self._config.Padding)
                footerPadding.Parent = footer

                local footerText = Instance.new("TextLabel")
                footerText.Size = UDim2.new(1, 0, 1, 0)
                footerText.BackgroundTransparency = 1
                footerText.Text = self._config.Footer
                footerText.TextColor3 = Color3.fromRGB(120, 120, 130)
                footerText.TextSize = 11
                footerText.Font = Enum.Font.Gotham
                footerText.TextXAlignment = Enum.TextXAlignment.Left
                footerText.Parent = footer
            end

            -- Click handling
            if self._config.Clickable then
                container.MouseEnter:Connect(function()
                    container.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
                    if self._config.OnHover then
                        self._config.OnHover(true)
                    end
                end)

                container.MouseLeave:Connect(function()
                    container.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
                    if self._config.OnHover then
                        self._config.OnHover(false)
                    end
                end)

                container.MouseButton1Click:Connect(function()
                    if self._config.OnClick then
                        self._config.OnClick()
                    end
                end)
            end

            if parent then
                container.Parent = parent
            end

            return container
        end

        return CardBuilder


    end


    -- ============================================================================
    -- Module: NexusUI/Builders/List
    -- ============================================================================
    NexusUI_Modules["NexusUI/Builders/List"] = function()
        local script = CreateMockScript("NexusUI/Builders/List")

        --[[
            NexusUI List Builder
            Builder pattern for creating lists
        ]]

        --// List Builder
        local ListBuilder = {}
        ListBuilder.__index = ListBuilder
        ListBuilder.ClassName = "ListBuilder"

        --// Constructor
        function ListBuilder.new()
            local self = setmetatable({}, ListBuilder)

            self._config = {
                Type = "Default", -- Default, Ordered, Unordered, Checklist, Inline
                ItemHeight = 40,
                Padding = 8,
                Spacing = 4,
                ShowDividers = false,
                ShowIcons = false,
                Selectable = false,
                MultiSelect = false,
                Sortable = false,
                Searchable = false,
                Theme = nil,
                OnSelect = nil,
                OnCheck = nil,
                OnReorder = nil,
            }

            self._items = {}

            return self
        end

        --// Static create
        function ListBuilder.Create()
            return ListBuilder.new()
        end

        --// Type
        function ListBuilder:Type(listType)
            self._config.Type = listType
            return self
        end

        --// Item height
        function ListBuilder:ItemHeight(height)
            self._config.ItemHeight = height
            return self
        end

        --// Padding
        function ListBuilder:Padding(padding)
            self._config.Padding = padding
            return self
        end

        --// Spacing
        function ListBuilder:Spacing(spacing)
            self._config.Spacing = spacing
            return self
        end

        --// Show dividers
        function ListBuilder:ShowDividers(value)
            self._config.ShowDividers = value
            return self
        end

        --// Show icons
        function ListBuilder:ShowIcons(value)
            self._config.ShowIcons = value
            return self
        end

        --// Selectable
        function ListBuilder:Selectable(value)
            self._config.Selectable = value
            return self
        end

        --// Multi select
        function ListBuilder:MultiSelect(value)
            self._config.MultiSelect = value
            return self
        end

        --// Sortable
        function ListBuilder:Sortable(value)
            self._config.Sortable = value
            return self
        end

        --// Searchable
        function ListBuilder:Searchable(value)
            self._config.Searchable = value
            return self
        end

        --// Theme
        function ListBuilder:Theme(theme)
            self._config.Theme = theme
            return self
        end

        --// On select
        function ListBuilder:OnSelect(callback)
            self._config.OnSelect = callback
            return self
        end

        --// On check
        function ListBuilder:OnCheck(callback)
            self._config.OnCheck = callback
            return self
        end

        --// On reorder
        function ListBuilder:OnReorder(callback)
            self._config.OnReorder = callback
            return self
        end

        --// Add item
        function ListBuilder:AddItem(config)
            if type(config) == "string" then
                config = { Text = config }
            end
            table.insert(self._items, {
                Text = config.Text or "",
                Subtitle = config.Subtitle,
                Icon = config.Icon,
                Checked = config.Checked or false,
                Disabled = config.Disabled or false,
                Data = config.Data,
                OnClick = config.OnClick,
            })
            return self
        end

        --// Add items
        function ListBuilder:AddItems(items)
            for _, item in ipairs(items) do
                self:AddItem(item)
            end
            return self
        end

        --// Clear items
        function ListBuilder:Clear()
            self._items = {}
            return self
        end

        --// Build the list
        function ListBuilder:Build(parent)
            local selectedItems = {}
            local itemFrames = {}
            local searchFilter = ""

            -- Container
            local container = Instance.new("Frame")
            container.Name = "List"
            container.Size = UDim2.new(1, 0, 1, 0)
            container.BackgroundTransparency = 1

            local containerLayout = Instance.new("UIListLayout")
            containerLayout.FillDirection = Enum.FillDirection.Vertical
            containerLayout.Padding = UDim.new(0, 0)
            containerLayout.SortOrder = Enum.SortOrder.LayoutOrder
            containerLayout.Parent = container

            -- Search box
            local searchBox
            if self._config.Searchable then
                local searchFrame = Instance.new("Frame")
                searchFrame.Name = "SearchFrame"
                searchFrame.Size = UDim2.new(1, 0, 0, 36)
                searchFrame.BackgroundTransparency = 1
                searchFrame.LayoutOrder = 0
                searchFrame.Parent = container

                searchBox = Instance.new("TextBox")
                searchBox.Name = "SearchBox"
                searchBox.Size = UDim2.new(1, -16, 0, 32)
                searchBox.Position = UDim2.new(0, 8, 0.5, 0)
                searchBox.AnchorPoint = Vector2.new(0, 0.5)
                searchBox.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
                searchBox.BorderSizePixel = 0
                searchBox.Text = ""
                searchBox.PlaceholderText = "Search..."
                searchBox.TextColor3 = Color3.fromRGB(255, 255, 255)
                searchBox.PlaceholderColor3 = Color3.fromRGB(120, 120, 120)
                searchBox.TextSize = 13
                searchBox.Font = Enum.Font.Gotham
                searchBox.ClearTextOnFocus = false
                searchBox.Parent = searchFrame

                local searchCorner = Instance.new("UICorner")
                searchCorner.CornerRadius = UDim.new(0, 6)
                searchCorner.Parent = searchBox

                local searchPadding = Instance.new("UIPadding")
                searchPadding.PaddingLeft = UDim.new(0, 12)
                searchPadding.PaddingRight = UDim.new(0, 12)
                searchPadding.Parent = searchBox
            end

            -- Scrolling frame for items
            local scrollFrame = Instance.new("ScrollingFrame")
            scrollFrame.Name = "ItemsScroll"
            scrollFrame.Size = UDim2.new(1, 0, 1, self._config.Searchable and -40 or 0)
            scrollFrame.BackgroundTransparency = 1
            scrollFrame.BorderSizePixel = 0
            scrollFrame.ScrollBarThickness = 4
            scrollFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 110)
            scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
            scrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
            scrollFrame.LayoutOrder = 1
            scrollFrame.Parent = container

            local itemsLayout = Instance.new("UIListLayout")
            itemsLayout.FillDirection = Enum.FillDirection.Vertical
            itemsLayout.Padding = UDim.new(0, self._config.Spacing)
            itemsLayout.SortOrder = Enum.SortOrder.LayoutOrder
            itemsLayout.Parent = scrollFrame

            local itemsPadding = Instance.new("UIPadding")
            itemsPadding.PaddingTop = UDim.new(0, self._config.Padding)
            itemsPadding.PaddingBottom = UDim.new(0, self._config.Padding)
            itemsPadding.PaddingLeft = UDim.new(0, self._config.Padding)
            itemsPadding.PaddingRight = UDim.new(0, self._config.Padding)
            itemsPadding.Parent = scrollFrame

            -- Select function
            local function selectItem(index)
                if not self._config.Selectable then return end

                local item = self._items[index]
                if item.Disabled then return end

                if self._config.MultiSelect then
                    selectedItems[index] = not selectedItems[index]
                else
                    for i in pairs(selectedItems) do
                        selectedItems[i] = false
                    end
                    selectedItems[index] = true
                end

                -- Update visuals
                for i, frame in pairs(itemFrames) do
                    if selectedItems[i] then
                        frame.BackgroundColor3 = Color3.fromRGB(60, 130, 255)
                        frame.BackgroundTransparency = 0.8
                    else
                        frame.BackgroundTransparency = 1
                    end
                end

                if self._config.OnSelect then
                    local selected = {}
                    for i, isSelected in pairs(selectedItems) do
                        if isSelected then
                            table.insert(selected, i)
                        end
                    end
                    self._config.OnSelect(selected, index)
                end
            end

            -- Check function (for checklist)
            local function checkItem(index, checked)
                self._items[index].Checked = checked
                if self._config.OnCheck then
                    self._config.OnCheck(index, checked)
                end
            end

            -- Filter function
            local function filterItems()
                for i, frame in pairs(itemFrames) do
                    local item = self._items[i]
                    local visible = searchFilter == "" or string.find(string.lower(item.Text), string.lower(searchFilter))
                    frame.Visible = visible
                end
            end

            -- Create items
            for i, item in ipairs(self._items) do
                local itemFrame = Instance.new("TextButton")
                itemFrame.Name = "Item_" .. i
                itemFrame.Size = UDim2.new(1, 0, 0, self._config.ItemHeight)
                itemFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
                itemFrame.BackgroundTransparency = 1
                itemFrame.BorderSizePixel = 0
                itemFrame.Text = ""
                itemFrame.AutoButtonColor = false
                itemFrame.LayoutOrder = i

                -- Checklist checkbox
                if self._config.Type == "Checklist" then
                    local checkbox = Instance.new("TextButton")
                    checkbox.Name = "Checkbox"
                    checkbox.Size = UDim2.new(0, 20, 0, 20)
                    checkbox.Position = UDim2.new(0, 8, 0.5, 0)
                    checkbox.AnchorPoint = Vector2.new(0, 0.5)
                    checkbox.BackgroundColor3 = item.Checked and Color3.fromRGB(60, 130, 255) or Color3.fromRGB(50, 50, 55)
                    checkbox.BorderSizePixel = 0
                    checkbox.Text = item.Checked and "✓" or ""
                    checkbox.TextColor3 = Color3.fromRGB(255, 255, 255)
                    checkbox.TextSize = 14
                    checkbox.Font = Enum.Font.GothamBold
                    checkbox.AutoButtonColor = false
                    checkbox.Parent = itemFrame

                    local checkboxCorner = Instance.new("UICorner")
                    checkboxCorner.CornerRadius = UDim.new(0, 4)
                    checkboxCorner.Parent = checkbox

                    checkbox.MouseButton1Click:Connect(function()
                        item.Checked = not item.Checked
                        checkbox.Text = item.Checked and "✓" or ""
                        checkbox.BackgroundColor3 = item.Checked and Color3.fromRGB(60, 130, 255) or Color3.fromRGB(50, 50, 55)
                        checkItem(i, item.Checked)
                    end)
                end

                -- Ordered list number
                if self._config.Type == "Ordered" then
                    local number = Instance.new("TextLabel")
                    number.Name = "Number"
                    number.Size = UDim2.new(0, 24, 1, 0)
                    number.Position = UDim2.new(0, 8, 0, 0)
                    number.BackgroundTransparency = 1
                    number.Text = tostring(i) .. "."
                    number.TextColor3 = Color3.fromRGB(100, 100, 110)
                    number.TextSize = 13
                    number.Font = Enum.Font.GothamMedium
                    number.TextXAlignment = Enum.TextXAlignment.Left
                    number.Parent = itemFrame
                end

                -- Unordered list bullet
                if self._config.Type == "Unordered" then
                    local bullet = Instance.new("TextLabel")
                    bullet.Name = "Bullet"
                    bullet.Size = UDim2.new(0, 16, 1, 0)
                    bullet.Position = UDim2.new(0, 12, 0, 0)
                    bullet.BackgroundTransparency = 1
                    bullet.Text = "•"
                    bullet.TextColor3 = Color3.fromRGB(100, 100, 110)
                    bullet.TextSize = 16
                    bullet.Font = Enum.Font.Gotham
                    bullet.Parent = itemFrame
                end

                -- Text position offset
                local textOffset = 8
                if self._config.Type == "Checklist" then
                    textOffset = 36
                elseif self._config.Type == "Ordered" or self._config.Type == "Unordered" then
                    textOffset = 32
                end
                if self._config.ShowIcons and item.Icon then
                    textOffset = textOffset + 28
                end

                -- Icon
                if self._config.ShowIcons and item.Icon then
                    local iconLabel = Instance.new("TextLabel")
                    iconLabel.Name = "Icon"
                    iconLabel.Size = UDim2.new(0, 20, 0, 20)
                    iconLabel.Position = UDim2.new(0, textOffset - 28, 0.5, 0)
                    iconLabel.AnchorPoint = Vector2.new(0, 0.5)
                    iconLabel.BackgroundTransparency = 1
                    iconLabel.Text = item.Icon
                    iconLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
                    iconLabel.TextSize = 16
                    iconLabel.Font = Enum.Font.Gotham
                    iconLabel.Parent = itemFrame
                end

                -- Main text
                local text = Instance.new("TextLabel")
                text.Name = "Text"
                text.Size = UDim2.new(1, -textOffset - 8, item.Subtitle and 0.5 or 1, 0)
                text.Position = UDim2.new(0, textOffset, 0, item.Subtitle and 4 or 0)
                text.BackgroundTransparency = 1
                text.Text = item.Text
                text.TextColor3 = item.Disabled and Color3.fromRGB(100, 100, 100) or Color3.fromRGB(255, 255, 255)
                text.TextSize = 13
                text.Font = Enum.Font.Gotham
                text.TextXAlignment = Enum.TextXAlignment.Left
                text.TextYAlignment = item.Subtitle and Enum.TextYAlignment.Bottom or Enum.TextYAlignment.Center
                text.Parent = itemFrame

                -- Subtitle
                if item.Subtitle then
                    local subtitle = Instance.new("TextLabel")
                    subtitle.Name = "Subtitle"
                    subtitle.Size = UDim2.new(1, -textOffset - 8, 0.5, 0)
                    subtitle.Position = UDim2.new(0, textOffset, 0.5, -2)
                    subtitle.BackgroundTransparency = 1
                    subtitle.Text = item.Subtitle
                    subtitle.TextColor3 = Color3.fromRGB(120, 120, 130)
                    subtitle.TextSize = 11
                    subtitle.Font = Enum.Font.Gotham
                    subtitle.TextXAlignment = Enum.TextXAlignment.Left
                    subtitle.TextYAlignment = Enum.TextYAlignment.Top
                    subtitle.Parent = itemFrame
                end

                -- Divider
                if self._config.ShowDividers and i < #self._items then
                    local divider = Instance.new("Frame")
                    divider.Name = "Divider"
                    divider.Size = UDim2.new(1, -16, 0, 1)
                    divider.Position = UDim2.new(0, 8, 1, 0)
                    divider.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
                    divider.BorderSizePixel = 0
                    divider.Parent = itemFrame
                end

                -- Hover effect
                itemFrame.MouseEnter:Connect(function()
                    if not selectedItems[i] then
                        itemFrame.BackgroundTransparency = 0.9
                        itemFrame.BackgroundColor3 = Color3.fromRGB(55, 55, 60)
                    end
                end)

                itemFrame.MouseLeave:Connect(function()
                    if not selectedItems[i] then
                        itemFrame.BackgroundTransparency = 1
                    end
                end)

                -- Click handler
                itemFrame.MouseButton1Click:Connect(function()
                    if item.OnClick then
                        item.OnClick()
                    end
                    selectItem(i)
                end)

                itemFrame.Parent = scrollFrame
                itemFrames[i] = itemFrame
            end

            -- Search functionality
            if searchBox then
                searchBox:GetPropertyChangedSignal("Text"):Connect(function()
                    searchFilter = searchBox.Text
                    filterItems()
                end)
            end

            if parent then
                container.Parent = parent
            end

            -- Return interface
            return {
                Instance = container,
                ScrollFrame = scrollFrame,
                GetSelected = function()
                    local selected = {}
                    for i, isSelected in pairs(selectedItems) do
                        if isSelected then
                            table.insert(selected, i)
                        end
                    end
                    return selected
                end,
                ClearSelection = function()
                    selectedItems = {}
                    for _, frame in pairs(itemFrames) do
                        frame.BackgroundTransparency = 1
                    end
                end,
                GetChecked = function()
                    local checked = {}
                    for i, item in ipairs(self._items) do
                        if item.Checked then
                            table.insert(checked, i)
                        end
                    end
                    return checked
                end,
                SetSearch = function(text)
                    if searchBox then
                        searchBox.Text = text
                    end
                end,
                Refresh = function()
                    filterItems()
                end,
            }
        end

        return ListBuilder


    end


    -- ============================================================================
    -- Module: NexusUI/Builders/init
    -- ============================================================================
    NexusUI_Modules["NexusUI/Builders/init"] = function()
        local script = CreateMockScript("NexusUI/Builders/init")

        --[[
            NexusUI Builders Module
            Builder patterns for easy UI creation
        ]]

        --// Builders Module
        local Builders = {}

        Builders.UI = NexusRequire("NexusUI/Builders/UI")
        Builders.Window = NexusRequire("NexusUI/Builders/Window")
        Builders.Tab = NexusRequire("NexusUI/Builders/Tab")
        Builders.Section = NexusRequire("NexusUI/Builders/Section")
        Builders.Form = NexusRequire("NexusUI/Builders/Form")
        Builders.Menu = NexusRequire("NexusUI/Builders/Menu")
        Builders.Toolbar = NexusRequire("NexusUI/Builders/Toolbar")
        Builders.Dialog = NexusRequire("NexusUI/Builders/Dialog")
        Builders.Card = NexusRequire("NexusUI/Builders/Card")
        Builders.List = NexusRequire("NexusUI/Builders/List")

        return Builders


    end


    -- ============================================================================
    -- Module: NexusUI/Version
    -- ============================================================================
    NexusUI_Modules["NexusUI/Version"] = function()
        local script = CreateMockScript("NexusUI/Version")

        --[[
            NexusUI Version Information
        ]]

        local Version = {
            Major = 1,
            Minor = 0,
            Patch = 0,
            Build = "release",

            -- Full version string
            String = "1.0.0",

            -- Build info
            BuildDate = "2026-01-19",

            -- Feature flags
            Features = {
                LiquidGlass = true,
                Glassmorphism = true,
                Animations = true,
                Themes = true,
                Sounds = true,
                Hotkeys = true,
                ConfigSystem = true,
                CloudSync = true,
                ESP = true,
                PerformanceMonitor = true,
                Visualizers = true,
                Builders = true,
            },

            -- Statistics
            Stats = {
                TotalFiles = 200,
                TotalThemes = 25,
                TotalComponents = 50,
                TotalEffects = 8,
                TotalVisualizers = 13,
            },

            -- Changelog
            Changelog = {
                ["1.0.0"] = {
                    "Initial release",
                    "25 built-in themes",
                    "Liquid glass and glassmorphism effects",
                    "Comprehensive component library",
                    "Animation engine with springs and easing",
                    "Performance monitoring system",
                    "ESP and executor-specific components",
                    "Builder patterns for easy UI creation",
                    "Sound system with presets",
                    "Configuration save/load with cloud sync",
                    "Global hotkey management",
                },
            },
        }

        function Version.GetFull()
            return string.format("%d.%d.%d-%s", 
                Version.Major, 
                Version.Minor, 
                Version.Patch, 
                Version.Build
            )
        end

        function Version.Compare(other)
            local otherMajor, otherMinor, otherPatch = other:match("(%d+)%.(%d+)%.(%d+)")
            otherMajor = tonumber(otherMajor) or 0
            otherMinor = tonumber(otherMinor) or 0
            otherPatch = tonumber(otherPatch) or 0

            if Version.Major > otherMajor then return 1 end
            if Version.Major < otherMajor then return -1 end
            if Version.Minor > otherMinor then return 1 end
            if Version.Minor < otherMinor then return -1 end
            if Version.Patch > otherPatch then return 1 end
            if Version.Patch < otherPatch then return -1 end
            return 0
        end

        function Version.IsNewerThan(other)
            return Version.Compare(other) > 0
        end

        function Version.IsOlderThan(other)
            return Version.Compare(other) < 0
        end

        return Version


    end


    -- ============================================================================
    -- Module: NexusUI/Debug
    -- ============================================================================
    NexusUI_Modules["NexusUI/Debug"] = function()
        local script = CreateMockScript("NexusUI/Debug")

        --[[
            NexusUI Debug Module
            Debugging utilities and development tools
        ]]

        local Debug = {}
        Debug.__index = Debug

        --// Configuration
        Debug.Enabled = false
        Debug.LogLevel = "INFO" -- DEBUG, INFO, WARN, ERROR
        Debug.ShowTimestamp = true
        Debug.MaxLogHistory = 500

        --// Internal state
        local _logs = {}
        local _breakpoints = {}
        local _watches = {}
        local _startTime = os.clock()

        --// Log levels
        local LogLevels = {
            DEBUG = 1,
            INFO = 2,
            WARN = 3,
            ERROR = 4,
        }

        --// Get current log level value
        local function GetLogLevelValue(level)
            return LogLevels[level] or 2
        end

        --// Format timestamp
        local function FormatTimestamp()
            local elapsed = os.clock() - _startTime
            return string.format("[%07.3f]", elapsed)
        end

        --// Internal log function
        local function InternalLog(level, message, ...)
            if not Debug.Enabled then return end
            if GetLogLevelValue(level) < GetLogLevelValue(Debug.LogLevel) then return end

            local formattedMessage = string.format(message, ...)
            local timestamp = Debug.ShowTimestamp and FormatTimestamp() or ""
            local fullMessage = string.format("%s [%s] %s", timestamp, level, formattedMessage)

            -- Store in history
            table.insert(_logs, {
                Level = level,
                Message = formattedMessage,
                Timestamp = os.clock() - _startTime,
                FullMessage = fullMessage,
            })

            -- Trim history
            while #_logs > Debug.MaxLogHistory do
                table.remove(_logs, 1)
            end

            -- Output
            if level == "ERROR" then
                warn("[NexusUI]", fullMessage)
            else
                print("[NexusUI]", fullMessage)
            end
        end

        --// Public logging functions
        function Debug.Log(message, ...)
            InternalLog("DEBUG", message, ...)
        end

        function Debug.Info(message, ...)
            InternalLog("INFO", message, ...)
        end

        function Debug.Warn(message, ...)
            InternalLog("WARN", message, ...)
        end

        function Debug.Error(message, ...)
            InternalLog("ERROR", message, ...)
        end

        --// Enable/disable debugging
        function Debug.Enable()
            Debug.Enabled = true
            Debug.Info("Debug mode enabled")
        end

        function Debug.Disable()
            Debug.Info("Debug mode disabled")
            Debug.Enabled = false
        end

        --// Set log level
        function Debug.SetLogLevel(level)
            if LogLevels[level] then
                Debug.LogLevel = level
                Debug.Info("Log level set to %s", level)
            end
        end

        --// Get log history
        function Debug.GetLogs(level)
            if not level then
                return _logs
            end

            local filtered = {}
            for _, log in ipairs(_logs) do
                if log.Level == level then
                    table.insert(filtered, log)
                end
            end
            return filtered
        end

        --// Clear logs
        function Debug.ClearLogs()
            _logs = {}
            Debug.Info("Log history cleared")
        end

        --// Performance timing
        local _timers = {}

        function Debug.StartTimer(name)
            _timers[name] = os.clock()
        end

        function Debug.EndTimer(name)
            local startTime = _timers[name]
            if startTime then
                local elapsed = (os.clock() - startTime) * 1000
                Debug.Info("Timer [%s]: %.2f ms", name, elapsed)
                _timers[name] = nil
                return elapsed
            end
            return 0
        end

        --// Memory tracking
        function Debug.GetMemoryUsage()
            return collectgarbage("count")
        end

        function Debug.LogMemory(label)
            local kb = Debug.GetMemoryUsage()
            Debug.Info("Memory [%s]: %.2f KB (%.2f MB)", label or "current", kb, kb / 1024)
        end

        --// Instance counting
        function Debug.CountInstances(parent, className)
            local count = 0
            for _, child in ipairs(parent:GetDescendants()) do
                if not className or child.ClassName == className then
                    count = count + 1
                end
            end
            return count
        end

        --// Watch values (call each frame to track changes)
        function Debug.Watch(name, getValue)
            _watches[name] = {
                GetValue = getValue,
                LastValue = nil,
                ChangeCount = 0,
            }
        end

        function Debug.Unwatch(name)
            _watches[name] = nil
        end

        function Debug.UpdateWatches()
            for name, watch in pairs(_watches) do
                local newValue = watch.GetValue()
                if newValue ~= watch.LastValue then
                    watch.ChangeCount = watch.ChangeCount + 1
                    Debug.Log("Watch [%s] changed: %s -> %s", name, tostring(watch.LastValue), tostring(newValue))
                    watch.LastValue = newValue
                end
            end
        end

        function Debug.GetWatches()
            local result = {}
            for name, watch in pairs(_watches) do
                result[name] = {
                    Value = watch.LastValue,
                    ChangeCount = watch.ChangeCount,
                }
            end
            return result
        end

        --// Assertion helper
        function Debug.Assert(condition, message, ...)
            if not condition then
                Debug.Error("Assertion failed: " .. (message and string.format(message, ...) or "no message"))
                error("NexusUI Assertion Failed")
            end
        end

        --// Stack trace
        function Debug.PrintStack(message)
            Debug.Warn("%s\n%s", message or "Stack trace:", debug.traceback())
        end

        --// Inspect table
        function Debug.Inspect(tbl, name, depth)
            depth = depth or 3
            name = name or "table"

            local function inspect(t, indent, currentDepth)
                if currentDepth > depth then
                    return "..."
                end

                if type(t) ~= "table" then
                    return tostring(t)
                end

                local lines = {"{"}
                for k, v in pairs(t) do
                    local key = type(k) == "string" and k or string.format("[%s]", tostring(k))
                    local value = type(v) == "table" and inspect(v, indent .. "  ", currentDepth + 1) or tostring(v)
                    table.insert(lines, string.format("%s%s = %s,", indent .. "  ", key, value))
                end
                table.insert(lines, indent .. "}")
                return table.concat(lines, "\n")
            end

            Debug.Log("%s = %s", name, inspect(tbl, "", 1))
        end

        --// Performance profiler
        local _profiles = {}

        function Debug.Profile(name, func)
            return function(...)
                local start = os.clock()
                local results = {func(...)}
                local elapsed = (os.clock() - start) * 1000

                if not _profiles[name] then
                    _profiles[name] = {
                        Calls = 0,
                        TotalTime = 0,
                        MinTime = math.huge,
                        MaxTime = 0,
                    }
                end

                local profile = _profiles[name]
                profile.Calls = profile.Calls + 1
                profile.TotalTime = profile.TotalTime + elapsed
                profile.MinTime = math.min(profile.MinTime, elapsed)
                profile.MaxTime = math.max(profile.MaxTime, elapsed)

                return unpack(results)
            end
        end

        function Debug.GetProfiles()
            local result = {}
            for name, profile in pairs(_profiles) do
                result[name] = {
                    Calls = profile.Calls,
                    TotalTime = profile.TotalTime,
                    AvgTime = profile.TotalTime / profile.Calls,
                    MinTime = profile.MinTime,
                    MaxTime = profile.MaxTime,
                }
            end
            return result
        end

        function Debug.PrintProfiles()
            Debug.Info("=== Performance Profiles ===")
            for name, profile in pairs(_profiles) do
                Debug.Info("%s: %d calls, avg %.2f ms, total %.2f ms", 
                    name, 
                    profile.Calls, 
                    profile.TotalTime / profile.Calls,
                    profile.TotalTime
                )
            end
        end

        function Debug.ClearProfiles()
            _profiles = {}
        end

        return Debug


    end


    -- ============================================================================
    -- Module: NexusUI/init
    -- ============================================================================
    NexusUI_Modules["NexusUI/init"] = function()
        local script = CreateMockScript("NexusUI/init")

        --[[
            NexusUI - Ultimate Roblox Executor UI Library
            Version: 1.0.0

            A premium 80,000+ line UI library featuring:
            - Liquid glass effects and glassmorphism
            - 25+ beautiful themes
            - Advanced animation engine with spring physics
            - Comprehensive component system
            - FPS monitoring and performance tools
            - Config save/load system
            - Sound effects
            - And much more!

            Usage:
                local NexusUI = loadstring(game:HttpGet("..."))()
                local Window = NexusUI:CreateWindow({
                    Title = "My App",
                    Theme = "LiquidGlass"
                })
        ]]

        --// Services
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local UserInputService = game:GetService("UserInputService")
        local TweenService = game:GetService("TweenService")
        local HttpService = game:GetService("HttpService")
        local CoreGui = game:GetService("CoreGui")
        local TextService = game:GetService("TextService")
        local ContentProvider = game:GetService("ContentProvider")
        local MarketplaceService = game:GetService("MarketplaceService")
        local SoundService = game:GetService("SoundService")
        local GuiService = game:GetService("GuiService")
        local StarterGui = game:GetService("StarterGui")
        local Lighting = game:GetService("Lighting")
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Workspace = game:GetService("Workspace")

        --// Constants
        local LIBRARY_NAME = "NexusUI"
        local LIBRARY_VERSION = "1.0.0"
        local LIBRARY_BUILD = 1000
        local DEBUG_MODE = false
        local PERFORMANCE_MODE = false

        --// Local Player
        local LocalPlayer = Players.LocalPlayer
        local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
        local Mouse = LocalPlayer:GetMouse()

        --// Module References (lazy loaded)
        local Core = nil
        local Animation = nil
        local Themes = nil
        local Components = nil
        local Features = nil
        local Layout = nil
        local Assets = nil
        local Builders = nil

        --// Library State
        local LibraryState = {
            Initialized = false,
            Windows = {},
            ActiveWindow = nil,
            GlobalTheme = "Midnight",
            GlobalSoundPack = "Default",
            GlobalConfig = {},
            Connections = {},
            Instances = {},
            FPSEnabled = false,
            SoundsEnabled = true,
            AnimationsEnabled = true,
            PerformanceMode = false,
            LastFrameTime = 0,
            FrameCount = 0,
            CurrentFPS = 60,
            AverageFPS = 60,
            PeakFPS = 60,
            LowFPS = 60,
            MemoryUsage = 0,
            NetworkPing = 0,
            StartTime = os.clock(),
            SessionId = HttpService:GenerateGUID(false),
            ErrorLog = {},
            WarningLog = {},
            InfoLog = {},
        }

        --// Utility Functions
        local function Log(level, message, ...)
            local formattedMessage = string.format(message, ...)
            local timestamp = os.date("%H:%M:%S")
            local logEntry = {
                Level = level,
                Message = formattedMessage,
                Timestamp = timestamp,
                Time = os.clock()
            }

            if level == "ERROR" then
                table.insert(LibraryState.ErrorLog, logEntry)
                if DEBUG_MODE then
                    warn(string.format("[%s] [ERROR] %s: %s", LIBRARY_NAME, timestamp, formattedMessage))
                end
            elseif level == "WARN" then
                table.insert(LibraryState.WarningLog, logEntry)
                if DEBUG_MODE then
                    warn(string.format("[%s] [WARN] %s: %s", LIBRARY_NAME, timestamp, formattedMessage))
                end
            elseif level == "INFO" then
                table.insert(LibraryState.InfoLog, logEntry)
                if DEBUG_MODE then
                    print(string.format("[%s] [INFO] %s: %s", LIBRARY_NAME, timestamp, formattedMessage))
                end
            end

            return logEntry
        end

        local function SafeCall(func, ...)
            local success, result = pcall(func, ...)
            if not success then
                Log("ERROR", "SafeCall failed: %s", tostring(result))
                return nil, result
            end
            return result, nil
        end

        local function DeepCopy(original, copies)
            copies = copies or {}
            local originalType = type(original)
            local copy

            if originalType == "table" then
                if copies[original] then
                    copy = copies[original]
                else
                    copy = {}
                    copies[original] = copy
                    for originalKey, originalValue in next, original, nil do
                        copy[DeepCopy(originalKey, copies)] = DeepCopy(originalValue, copies)
                    end
                    setmetatable(copy, DeepCopy(getmetatable(original), copies))
                end
            else
                copy = original
            end

            return copy
        end

        local function MergeTables(base, override)
            local result = DeepCopy(base)

            for key, value in pairs(override) do
                if type(value) == "table" and type(result[key]) == "table" then
                    result[key] = MergeTables(result[key], value)
                else
                    result[key] = value
                end
            end

            return result
        end

        local function GenerateUID(prefix)
            prefix = prefix or "nexus"
            local chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
            local uid = prefix .. "_"

            for i = 1, 16 do
                local randomIndex = math.random(1, #chars)
                uid = uid .. chars:sub(randomIndex, randomIndex)
            end

            return uid .. "_" .. tostring(os.clock()):gsub("%.", "")
        end

        local function Lerp(a, b, t)
            return a + (b - a) * t
        end

        local function LerpColor3(c1, c2, t)
            return Color3.new(
                Lerp(c1.R, c2.R, t),
                Lerp(c1.G, c2.G, t),
                Lerp(c1.B, c2.B, t)
            )
        end

        local function LerpUDim2(u1, u2, t)
            return UDim2.new(
                Lerp(u1.X.Scale, u2.X.Scale, t),
                Lerp(u1.X.Offset, u2.X.Offset, t),
                Lerp(u1.Y.Scale, u2.Y.Scale, t),
                Lerp(u1.Y.Offset, u2.Y.Offset, t)
            )
        end

        local function Clamp(value, min, max)
            return math.max(min, math.min(max, value))
        end

        local function Round(value, decimals)
            decimals = decimals or 0
            local mult = 10 ^ decimals
            return math.floor(value * mult + 0.5) / mult
        end

        local function Map(value, inMin, inMax, outMin, outMax)
            return outMin + (value - inMin) * (outMax - outMin) / (inMax - inMin)
        end

        local function Debounce(func, delay)
            local lastCall = 0
            return function(...)
                local now = os.clock()
                if now - lastCall >= delay then
                    lastCall = now
                    return func(...)
                end
            end
        end

        local function Throttle(func, delay)
            local lastCall = 0
            local scheduled = false
            local args = nil

            return function(...)
                args = {...}
                local now = os.clock()

                if now - lastCall >= delay then
                    lastCall = now
                    return func(unpack(args))
                elseif not scheduled then
                    scheduled = true
                    task.delay(delay - (now - lastCall), function()
                        scheduled = false
                        lastCall = os.clock()
                        func(unpack(args))
                    end)
                end
            end
        end

        local function IsValidInstance(instance)
            if instance == nil then return false end
            local success, result = pcall(function()
                return instance.Parent ~= nil or instance.ClassName ~= nil
            end)
            return success and result ~= nil
        end

        local function SafeDestroy(instance)
            if IsValidInstance(instance) then
                pcall(function()
                    instance:Destroy()
                end)
            end
        end

        local function WaitForChild(parent, childName, timeout)
            timeout = timeout or 5
            local child = parent:FindFirstChild(childName)

            if child then
                return child
            end

            local startTime = os.clock()
            while os.clock() - startTime < timeout do
                child = parent:FindFirstChild(childName)
                if child then
                    return child
                end
                task.wait()
            end

            return nil
        end

        local function CreateInstance(className, properties)
            local instance = Instance.new(className)

            for property, value in pairs(properties or {}) do
                if property ~= "Parent" then
                    pcall(function()
                        instance[property] = value
                    end)
                end
            end

            if properties and properties.Parent then
                instance.Parent = properties.Parent
            end

            return instance
        end

        local function GetScreenSize()
            local viewport = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize
            if viewport then
                return viewport.X, viewport.Y
            end
            return 1920, 1080
        end

        local function GetMousePosition()
            return UserInputService:GetMouseLocation()
        end

        local function IsMouseOver(guiObject)
            if not IsValidInstance(guiObject) then return false end

            local mousePos = GetMousePosition()
            local objPos = guiObject.AbsolutePosition
            local objSize = guiObject.AbsoluteSize

            return mousePos.X >= objPos.X and 
                   mousePos.X <= objPos.X + objSize.X and
                   mousePos.Y >= objPos.Y and 
                   mousePos.Y <= objPos.Y + objSize.Y
        end

        local function GetTextSize(text, fontSize, font, maxWidth)
            maxWidth = maxWidth or math.huge
            local textSize = TextService:GetTextSize(
                text,
                fontSize,
                font,
                Vector2.new(maxWidth, math.huge)
            )
            return textSize.X, textSize.Y
        end

        local function TruncateText(text, maxLength, suffix)
            suffix = suffix or "..."
            if #text <= maxLength then
                return text
            end
            return text:sub(1, maxLength - #suffix) .. suffix
        end

        local function FormatNumber(num, decimals)
            decimals = decimals or 0

            if num >= 1e9 then
                return Round(num / 1e9, decimals) .. "B"
            elseif num >= 1e6 then
                return Round(num / 1e6, decimals) .. "M"
            elseif num >= 1e3 then
                return Round(num / 1e3, decimals) .. "K"
            else
                return Round(num, decimals)
            end
        end

        local function FormatTime(seconds)
            local hours = math.floor(seconds / 3600)
            local minutes = math.floor((seconds % 3600) / 60)
            local secs = math.floor(seconds % 60)

            if hours > 0 then
                return string.format("%02d:%02d:%02d", hours, minutes, secs)
            else
                return string.format("%02d:%02d", minutes, secs)
            end
        end

        local function HSVToRGB(h, s, v)
            local r, g, b
            local i = math.floor(h * 6)
            local f = h * 6 - i
            local p = v * (1 - s)
            local q = v * (1 - f * s)
            local t = v * (1 - (1 - f) * s)

            i = i % 6

            if i == 0 then r, g, b = v, t, p
            elseif i == 1 then r, g, b = q, v, p
            elseif i == 2 then r, g, b = p, v, t
            elseif i == 3 then r, g, b = p, q, v
            elseif i == 4 then r, g, b = t, p, v
            elseif i == 5 then r, g, b = v, p, q
            end

            return Color3.new(r, g, b)
        end

        local function RGBToHSV(color)
            local r, g, b = color.R, color.G, color.B
            local max = math.max(r, g, b)
            local min = math.min(r, g, b)
            local h, s, v

            v = max
            local d = max - min

            if max == 0 then
                s = 0
            else
                s = d / max
            end

            if max == min then
                h = 0
            else
                if max == r then
                    h = (g - b) / d
                    if g < b then h = h + 6 end
                elseif max == g then
                    h = (b - r) / d + 2
                else
                    h = (r - g) / d + 4
                end
                h = h / 6
            end

            return h, s, v
        end

        local function HexToRGB(hex)
            hex = hex:gsub("#", "")

            if #hex == 3 then
                hex = hex:sub(1, 1):rep(2) .. hex:sub(2, 2):rep(2) .. hex:sub(3, 3):rep(2)
            end

            local r = tonumber(hex:sub(1, 2), 16) / 255
            local g = tonumber(hex:sub(3, 4), 16) / 255
            local b = tonumber(hex:sub(5, 6), 16) / 255

            return Color3.new(r, g, b)
        end

        local function RGBToHex(color)
            return string.format("#%02X%02X%02X",
                math.floor(color.R * 255 + 0.5),
                math.floor(color.G * 255 + 0.5),
                math.floor(color.B * 255 + 0.5)
            )
        end

        local function Lighten(color, amount)
            amount = amount or 0.1
            local h, s, v = RGBToHSV(color)
            v = math.min(1, v + amount)
            return HSVToRGB(h, s, v)
        end

        local function Darken(color, amount)
            amount = amount or 0.1
            local h, s, v = RGBToHSV(color)
            v = math.max(0, v - amount)
            return HSVToRGB(h, s, v)
        end

        local function Saturate(color, amount)
            amount = amount or 0.1
            local h, s, v = RGBToHSV(color)
            s = math.min(1, s + amount)
            return HSVToRGB(h, s, v)
        end

        local function Desaturate(color, amount)
            amount = amount or 0.1
            local h, s, v = RGBToHSV(color)
            s = math.max(0, s - amount)
            return HSVToRGB(h, s, v)
        end

        local function GetContrastColor(backgroundColor)
            local luminance = 0.299 * backgroundColor.R + 0.587 * backgroundColor.G + 0.114 * backgroundColor.B
            return luminance > 0.5 and Color3.new(0, 0, 0) or Color3.new(1, 1, 1)
        end

        local function BlendColors(color1, color2, mode, amount)
            amount = amount or 0.5
            mode = mode or "normal"

            if mode == "normal" then
                return LerpColor3(color1, color2, amount)
            elseif mode == "multiply" then
                return Color3.new(
                    color1.R * color2.R,
                    color1.G * color2.G,
                    color1.B * color2.B
                )
            elseif mode == "screen" then
                return Color3.new(
                    1 - (1 - color1.R) * (1 - color2.R),
                    1 - (1 - color1.G) * (1 - color2.G),
                    1 - (1 - color1.B) * (1 - color2.B)
                )
            elseif mode == "overlay" then
                local function overlay(base, blend)
                    if base < 0.5 then
                        return 2 * base * blend
                    else
                        return 1 - 2 * (1 - base) * (1 - blend)
                    end
                end
                return Color3.new(
                    overlay(color1.R, color2.R),
                    overlay(color1.G, color2.G),
                    overlay(color1.B, color2.B)
                )
            elseif mode == "add" then
                return Color3.new(
                    math.min(1, color1.R + color2.R * amount),
                    math.min(1, color1.G + color2.G * amount),
                    math.min(1, color1.B + color2.B * amount)
                )
            end

            return LerpColor3(color1, color2, amount)
        end

        --// NexusUI Main Class
        local NexusUI = {}
        NexusUI.__index = NexusUI
        NexusUI.Version = LIBRARY_VERSION
        NexusUI.Build = LIBRARY_BUILD
        NexusUI.Name = LIBRARY_NAME

        -- Internal state access
        NexusUI._State = LibraryState
        NexusUI._Utility = {
            Log = Log,
            SafeCall = SafeCall,
            DeepCopy = DeepCopy,
            MergeTables = MergeTables,
            GenerateUID = GenerateUID,
            Lerp = Lerp,
            LerpColor3 = LerpColor3,
            LerpUDim2 = LerpUDim2,
            Clamp = Clamp,
            Round = Round,
            Map = Map,
            Debounce = Debounce,
            Throttle = Throttle,
            IsValidInstance = IsValidInstance,
            SafeDestroy = SafeDestroy,
            WaitForChild = WaitForChild,
            CreateInstance = CreateInstance,
            GetScreenSize = GetScreenSize,
            GetMousePosition = GetMousePosition,
            IsMouseOver = IsMouseOver,
            GetTextSize = GetTextSize,
            TruncateText = TruncateText,
            FormatNumber = FormatNumber,
            FormatTime = FormatTime,
            HSVToRGB = HSVToRGB,
            RGBToHSV = RGBToHSV,
            HexToRGB = HexToRGB,
            RGBToHex = RGBToHex,
            Lighten = Lighten,
            Darken = Darken,
            Saturate = Saturate,
            Desaturate = Desaturate,
            GetContrastColor = GetContrastColor,
            BlendColors = BlendColors,
        }

        --// Module Loading
        local function LoadModule(moduleName)
            local modulePath = script:FindFirstChild(moduleName, true)
            if modulePath then
                local success, result = pcall(require, modulePath)
                if success then
                    return result
                else
                    Log("ERROR", "Failed to load module %s: %s", moduleName, tostring(result))
                end
            else
                Log("WARN", "Module not found: %s", moduleName)
            end
            return nil
        end

        local function InitializeModules()
            Log("INFO", "Initializing NexusUI modules...")

            -- Load Core modules
            Core = LoadModule("Core") or {}
            Core.Services = LoadModule("Services") or {}
            Core.StateManager = LoadModule("StateManager") or {}
            Core.EventSystem = LoadModule("EventSystem") or {}
            Core.SignalClass = LoadModule("SignalClass") or {}
            Core.Maid = LoadModule("Maid") or {}
            Core.Promise = LoadModule("Promise") or {}
            Core.Types = LoadModule("Types") or {}
            Core.Constants = LoadModule("Constants") or {}
            Core.InstancePool = LoadModule("InstancePool") or {}
            Core.ScreenGui = LoadModule("ScreenGui") or {}
            Core.Utility = LoadModule("Utility") or {}

            -- Load Animation modules
            Animation = LoadModule("Animation") or {}

            -- Load Theme modules
            Themes = LoadModule("Themes") or {}

            -- Load Component modules
            Components = LoadModule("Components") or {}

            -- Load Feature modules
            Features = LoadModule("Features") or {}

            -- Load Layout modules
            Layout = LoadModule("Layout") or {}

            -- Load Asset modules
            Assets = LoadModule("Assets") or {}

            -- Load Builder modules
            Builders = LoadModule("Builders") or {}

            Log("INFO", "Module initialization complete")
        end

        --// Library Initialization
        function NexusUI:Initialize(config)
            if LibraryState.Initialized then
                Log("WARN", "NexusUI already initialized")
                return self
            end

            config = config or {}

            -- Apply configuration
            LibraryState.GlobalTheme = config.Theme or "Midnight"
            LibraryState.GlobalSoundPack = config.SoundPack or "Default"
            LibraryState.SoundsEnabled = config.SoundsEnabled ~= false
            LibraryState.AnimationsEnabled = config.AnimationsEnabled ~= false
            LibraryState.PerformanceMode = config.PerformanceMode or false
            DEBUG_MODE = config.DebugMode or false
            PERFORMANCE_MODE = config.PerformanceMode or false

            -- Initialize modules
            InitializeModules()

            -- Create main ScreenGui
            self:CreateScreenGui()

            -- Start performance monitoring
            self:StartPerformanceMonitor()

            -- Mark as initialized
            LibraryState.Initialized = true
            LibraryState.StartTime = os.clock()

            Log("INFO", "NexusUI v%s initialized successfully", LIBRARY_VERSION)

            return self
        end

        --// ScreenGui Management
        function NexusUI:CreateScreenGui()
            -- Destroy existing ScreenGui if present
            local existingGui = CoreGui:FindFirstChild(LIBRARY_NAME)
            if existingGui then
                existingGui:Destroy()
            end

            -- Also check PlayerGui as fallback
            local existingPlayerGui = PlayerGui:FindFirstChild(LIBRARY_NAME)
            if existingPlayerGui then
                existingPlayerGui:Destroy()
            end

            -- Create new ScreenGui
            local screenGui = CreateInstance("ScreenGui", {
                Name = LIBRARY_NAME,
                DisplayOrder = 999999,
                IgnoreGuiInset = true,
                ResetOnSpawn = false,
                ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
            })

            -- Try to parent to CoreGui, fallback to PlayerGui
            local success = pcall(function()
                screenGui.Parent = CoreGui
            end)

            if not success then
                screenGui.Parent = PlayerGui
            end

            LibraryState.ScreenGui = screenGui

            -- Create container frames
            self:CreateContainerFrames()

            return screenGui
        end

        function NexusUI:CreateContainerFrames()
            local screenGui = LibraryState.ScreenGui

            -- Main container for windows
            local windowContainer = CreateInstance("Frame", {
                Name = "WindowContainer",
                BackgroundTransparency = 1,
                Size = UDim2.fromScale(1, 1),
                Parent = screenGui
            })
            LibraryState.WindowContainer = windowContainer

            -- Container for notifications
            local notificationContainer = CreateInstance("Frame", {
                Name = "NotificationContainer",
                BackgroundTransparency = 1,
                Size = UDim2.fromScale(1, 1),
                Parent = screenGui
            })
            LibraryState.NotificationContainer = notificationContainer

            -- Container for modals/overlays
            local modalContainer = CreateInstance("Frame", {
                Name = "ModalContainer",
                BackgroundTransparency = 1,
                Size = UDim2.fromScale(1, 1),
                Visible = false,
                Parent = screenGui
            })
            LibraryState.ModalContainer = modalContainer

            -- Container for tooltips
            local tooltipContainer = CreateInstance("Frame", {
                Name = "TooltipContainer",
                BackgroundTransparency = 1,
                Size = UDim2.fromScale(1, 1),
                Parent = screenGui
            })
            LibraryState.TooltipContainer = tooltipContainer

            -- Container for context menus
            local contextMenuContainer = CreateInstance("Frame", {
                Name = "ContextMenuContainer",
                BackgroundTransparency = 1,
                Size = UDim2.fromScale(1, 1),
                Parent = screenGui
            })
            LibraryState.ContextMenuContainer = contextMenuContainer

            -- Container for FPS/performance overlay
            local performanceContainer = CreateInstance("Frame", {
                Name = "PerformanceContainer",
                BackgroundTransparency = 1,
                Size = UDim2.fromScale(1, 1),
                Parent = screenGui
            })
            LibraryState.PerformanceContainer = performanceContainer

            -- Container for watermarks
            local watermarkContainer = CreateInstance("Frame", {
                Name = "WatermarkContainer",
                BackgroundTransparency = 1,
                Size = UDim2.fromScale(1, 1),
                Parent = screenGui
            })
            LibraryState.WatermarkContainer = watermarkContainer

            -- Container for ESP elements
            local espContainer = CreateInstance("Frame", {
                Name = "ESPContainer",
                BackgroundTransparency = 1,
                Size = UDim2.fromScale(1, 1),
                Parent = screenGui
            })
            LibraryState.ESPContainer = espContainer
        end

        --// Performance Monitoring
        function NexusUI:StartPerformanceMonitor()
            local lastTime = os.clock()
            local frameCount = 0
            local fpsHistory = {}
            local maxHistorySize = 60

            local connection = RunService.Heartbeat:Connect(function(deltaTime)
                frameCount = frameCount + 1
                local currentTime = os.clock()
                local elapsed = currentTime - lastTime

                if elapsed >= 1 then
                    local fps = frameCount / elapsed
                    LibraryState.CurrentFPS = Round(fps, 1)

                    -- Update history
                    table.insert(fpsHistory, fps)
                    if #fpsHistory > maxHistorySize then
                        table.remove(fpsHistory, 1)
                    end

                    -- Calculate statistics
                    local total = 0
                    local peak = 0
                    local low = math.huge

                    for _, v in ipairs(fpsHistory) do
                        total = total + v
                        peak = math.max(peak, v)
                        low = math.min(low, v)
                    end

                    LibraryState.AverageFPS = Round(total / #fpsHistory, 1)
                    LibraryState.PeakFPS = Round(peak, 1)
                    LibraryState.LowFPS = Round(low, 1)

                    -- Memory usage
                    LibraryState.MemoryUsage = Round(collectgarbage("count") / 1024, 2)

                    -- Reset counters
                    frameCount = 0
                    lastTime = currentTime
                end

                LibraryState.LastFrameTime = deltaTime
            end)

            table.insert(LibraryState.Connections, connection)

            -- Network ping monitoring (simplified)
            local pingConnection = RunService.Heartbeat:Connect(Throttle(function()
                local stats = Players.LocalPlayer:FindFirstChild("PlayerScripts")
                if stats then
                    local ping = Players.LocalPlayer:GetNetworkPing()
                    LibraryState.NetworkPing = Round(ping * 1000, 0)
                end
            end, 1))

            table.insert(LibraryState.Connections, pingConnection)
        end

        --// Window Creation
        function NexusUI:CreateWindow(config)
            config = config or {}

            -- Initialize if not already done
            if not LibraryState.Initialized then
                self:Initialize()
            end

            -- Load window builder
            local WindowBuilder = Builders.WindowBuilder or NexusRequire("NexusUI/Builders/WindowBuilder")

            local window = WindowBuilder.new({
                Title = config.Title or "NexusUI Window",
                Subtitle = config.Subtitle or "",
                Theme = config.Theme or LibraryState.GlobalTheme,
                Size = config.Size or UDim2.fromOffset(600, 450),
                Position = config.Position or UDim2.fromScale(0.5, 0.5),
                AnchorPoint = config.AnchorPoint or Vector2.new(0.5, 0.5),
                MinSize = config.MinSize or Vector2.new(400, 300),
                MaxSize = config.MaxSize or Vector2.new(1200, 900),
                Resizable = config.Resizable ~= false,
                Draggable = config.Draggable ~= false,
                Closeable = config.Closeable ~= false,
                Minimizable = config.Minimizable ~= false,
                EnableFPS = config.EnableFPS or false,
                SoundPack = config.SoundPack or LibraryState.GlobalSoundPack,
                Icon = config.Icon or nil,
                ShowIcon = config.ShowIcon ~= false,
                Keybind = config.Keybind or Enum.KeyCode.RightControl,
                SavePosition = config.SavePosition ~= false,
                LoadPosition = config.LoadPosition ~= false,
                CloseCallback = config.CloseCallback or nil,
                MinimizeCallback = config.MinimizeCallback or nil,
                FocusCallback = config.FocusCallback or nil,
                Parent = LibraryState.WindowContainer
            })

            table.insert(LibraryState.Windows, window)
            LibraryState.ActiveWindow = window

            Log("INFO", "Created window: %s", config.Title or "NexusUI Window")

            return window
        end

        --// Theme Management
        function NexusUI:SetTheme(themeName)
            LibraryState.GlobalTheme = themeName

            -- Apply theme to all windows
            for _, window in ipairs(LibraryState.Windows) do
                if window and window.SetTheme then
                    window:SetTheme(themeName)
                end
            end

            Log("INFO", "Theme changed to: %s", themeName)
        end

        function NexusUI:GetTheme()
            return LibraryState.GlobalTheme
        end

        function NexusUI:GetAvailableThemes()
            return Themes and Themes:GetAvailableThemes() or {
                "Midnight", "Obsidian", "Carbon", "Dracula", "OneDark", "TokyoNight",
                "Snow", "Cream", "Paper", "Daylight",
                "Neon", "Cyberpunk", "Vaporwave", "Synthwave", "Sunset",
                "LiquidGlass", "FrostedGlass", "AcrylicBlue", "MicaDark",
                "RGB", "Matrix", "Hacker", "MinimalGaming", "Retro"
            }
        end

        --// Sound Management
        function NexusUI:SetSoundPack(soundPackName)
            LibraryState.GlobalSoundPack = soundPackName

            -- Apply sound pack to all windows
            for _, window in ipairs(LibraryState.Windows) do
                if window and window.SetSoundPack then
                    window:SetSoundPack(soundPackName)
                end
            end

            Log("INFO", "Sound pack changed to: %s", soundPackName)
        end

        function NexusUI:EnableSounds(enabled)
            LibraryState.SoundsEnabled = enabled
        end

        function NexusUI:PlaySound(soundName)
            if not LibraryState.SoundsEnabled then return end

            if Features and Features.Sound and Features.Sound.Play then
                Features.Sound:Play(soundName, LibraryState.GlobalSoundPack)
            end
        end

        --// Configuration Management
        function NexusUI:SaveConfig(configName)
            configName = configName or "Default"

            local configData = {
                Theme = LibraryState.GlobalTheme,
                SoundPack = LibraryState.GlobalSoundPack,
                SoundsEnabled = LibraryState.SoundsEnabled,
                AnimationsEnabled = LibraryState.AnimationsEnabled,
                Windows = {},
                Components = {}
            }

            -- Collect window configurations
            for i, window in ipairs(LibraryState.Windows) do
                if window and window.GetConfig then
                    configData.Windows[i] = window:GetConfig()
                end
            end

            -- Save to file
            if Features and Features.Config and Features.Config.Save then
                Features.Config:Save(configName, configData)
            else
                -- Fallback: Use writefile if available
                local success, err = pcall(function()
                    if writefile then
                        local json = HttpService:JSONEncode(configData)
                        writefile("NexusUI/Configs/" .. configName .. ".json", json)
                    end
                end)

                if not success then
                    Log("ERROR", "Failed to save config: %s", tostring(err))
                end
            end

            Log("INFO", "Config saved: %s", configName)
        end

        function NexusUI:LoadConfig(configName)
            configName = configName or "Default"

            local configData = nil

            if Features and Features.Config and Features.Config.Load then
                configData = Features.Config:Load(configName)
            else
                -- Fallback: Use readfile if available
                local success, result = pcall(function()
                    if readfile and isfile then
                        local path = "NexusUI/Configs/" .. configName .. ".json"
                        if isfile(path) then
                            local json = readfile(path)
                            return HttpService:JSONDecode(json)
                        end
                    end
                    return nil
                end)

                if success then
                    configData = result
                else
                    Log("ERROR", "Failed to load config: %s", tostring(result))
                end
            end

            if configData then
                -- Apply configuration
                if configData.Theme then
                    self:SetTheme(configData.Theme)
                end
                if configData.SoundPack then
                    self:SetSoundPack(configData.SoundPack)
                end
                if configData.SoundsEnabled ~= nil then
                    LibraryState.SoundsEnabled = configData.SoundsEnabled
                end
                if configData.AnimationsEnabled ~= nil then
                    LibraryState.AnimationsEnabled = configData.AnimationsEnabled
                end

                -- Apply window configurations
                for i, windowConfig in pairs(configData.Windows or {}) do
                    local window = LibraryState.Windows[i]
                    if window and window.SetConfig then
                        window:SetConfig(windowConfig)
                    end
                end

                Log("INFO", "Config loaded: %s", configName)
                return true
            end

            return false
        end

        function NexusUI:DeleteConfig(configName)
            configName = configName or "Default"

            local success = pcall(function()
                if delfile and isfile then
                    local path = "NexusUI/Configs/" .. configName .. ".json"
                    if isfile(path) then
                        delfile(path)
                    end
                end
            end)

            if success then
                Log("INFO", "Config deleted: %s", configName)
            end

            return success
        end

        function NexusUI:GetConfigs()
            local configs = {}

            local success = pcall(function()
                if listfiles and isfolder then
                    local path = "NexusUI/Configs"
                    if isfolder(path) then
                        for _, file in ipairs(listfiles(path)) do
                            local name = file:match("([^/\\]+)%.json$")
                            if name then
                                table.insert(configs, name)
                            end
                        end
                    end
                end
            end)

            return configs
        end

        --// Notification System
        function NexusUI:Notify(config)
            config = config or {}

            local notification = {
                Title = config.Title or "Notification",
                Content = config.Content or config.Message or "",
                Type = config.Type or "Info", -- Info, Success, Warning, Error
                Duration = config.Duration or 5,
                Icon = config.Icon or nil,
                Callback = config.Callback or nil,
                Actions = config.Actions or nil
            }

            if Components and Components.Notifications and Components.Notifications.Toast then
                return Components.Notifications.Toast:Show(notification)
            end

            Log("INFO", "Notification: [%s] %s - %s", notification.Type, notification.Title, notification.Content)
        end

        function NexusUI:Alert(config)
            config = config or {}

            if Components and Components.Notifications and Components.Notifications.Alert then
                return Components.Notifications.Alert:Show(config)
            end
        end

        function NexusUI:Confirm(config)
            config = config or {}

            if Components and Components.Notifications and Components.Notifications.Confirm then
                return Components.Notifications.Confirm:Show(config)
            end
        end

        function NexusUI:Prompt(config)
            config = config or {}

            if Components and Components.Notifications and Components.Notifications.Prompt then
                return Components.Notifications.Prompt:Show(config)
            end
        end

        --// Performance Info
        function NexusUI:GetFPS()
            return LibraryState.CurrentFPS
        end

        function NexusUI:GetAverageFPS()
            return LibraryState.AverageFPS
        end

        function NexusUI:GetPing()
            return LibraryState.NetworkPing
        end

        function NexusUI:GetMemoryUsage()
            return LibraryState.MemoryUsage
        end

        function NexusUI:GetPerformanceStats()
            return {
                FPS = LibraryState.CurrentFPS,
                AverageFPS = LibraryState.AverageFPS,
                PeakFPS = LibraryState.PeakFPS,
                LowFPS = LibraryState.LowFPS,
                Ping = LibraryState.NetworkPing,
                Memory = LibraryState.MemoryUsage,
                FrameTime = LibraryState.LastFrameTime * 1000,
                Uptime = os.clock() - LibraryState.StartTime
            }
        end

        --// Cleanup
        function NexusUI:Destroy()
            Log("INFO", "Destroying NexusUI...")

            -- Disconnect all connections
            for _, connection in ipairs(LibraryState.Connections) do
                if connection and connection.Connected then
                    connection:Disconnect()
                end
            end
            LibraryState.Connections = {}

            -- Destroy all windows
            for _, window in ipairs(LibraryState.Windows) do
                if window and window.Destroy then
                    window:Destroy()
                end
            end
            LibraryState.Windows = {}

            -- Destroy ScreenGui
            if LibraryState.ScreenGui then
                SafeDestroy(LibraryState.ScreenGui)
            end

            -- Reset state
            LibraryState.Initialized = false
            LibraryState.ActiveWindow = nil

            Log("INFO", "NexusUI destroyed")
        end

        --// Toggle Visibility
        function NexusUI:Toggle()
            if LibraryState.ScreenGui then
                LibraryState.ScreenGui.Enabled = not LibraryState.ScreenGui.Enabled
            end
        end

        function NexusUI:Show()
            if LibraryState.ScreenGui then
                LibraryState.ScreenGui.Enabled = true
            end
        end

        function NexusUI:Hide()
            if LibraryState.ScreenGui then
                LibraryState.ScreenGui.Enabled = false
            end
        end

        function NexusUI:IsVisible()
            return LibraryState.ScreenGui and LibraryState.ScreenGui.Enabled or false
        end

        --// Debug Utilities
        function NexusUI:EnableDebugMode(enabled)
            DEBUG_MODE = enabled
        end

        function NexusUI:GetErrorLog()
            return DeepCopy(LibraryState.ErrorLog)
        end

        function NexusUI:GetWarningLog()
            return DeepCopy(LibraryState.WarningLog)
        end

        function NexusUI:GetInfoLog()
            return DeepCopy(LibraryState.InfoLog)
        end

        function NexusUI:ClearLogs()
            LibraryState.ErrorLog = {}
            LibraryState.WarningLog = {}
            LibraryState.InfoLog = {}
        end

        --// Module Accessors
        function NexusUI:GetCore()
            return Core
        end

        function NexusUI:GetAnimation()
            return Animation
        end

        function NexusUI:GetThemes()
            return Themes
        end

        function NexusUI:GetComponents()
            return Components
        end

        function NexusUI:GetFeatures()
            return Features
        end

        function NexusUI:GetLayout()
            return Layout
        end

        function NexusUI:GetAssets()
            return Assets
        end

        function NexusUI:GetBuilders()
            return Builders
        end

        --// Global Input Handling
        local function SetupGlobalInput()
            local connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                if gameProcessed then return end

                -- Handle global keybinds
                if input.KeyCode then
                    -- Toggle visibility keybind
                    for _, window in ipairs(LibraryState.Windows) do
                        if window and window.Keybind and input.KeyCode == window.Keybind then
                            if window.Toggle then
                                window:Toggle()
                            end
                        end
                    end

                    -- Close on Escape (if enabled)
                    if input.KeyCode == Enum.KeyCode.Escape then
                        -- Close any open modals or context menus
                        if LibraryState.ModalContainer and LibraryState.ModalContainer.Visible then
                            LibraryState.ModalContainer.Visible = false
                        end
                    end
                end
            end)

            table.insert(LibraryState.Connections, connection)
        end

        SetupGlobalInput()

        --// Auto-cleanup on player leaving
        Players.PlayerRemoving:Connect(function(player)
            if player == LocalPlayer then
                NexusUI:Destroy()
            end
        end)

        --// Finalize and return
        Log("INFO", "NexusUI v%s loaded", LIBRARY_VERSION)

        return NexusUI


    end


    -- ============================================================================
    -- Module: NexusUI/API
    -- ============================================================================
    NexusUI_Modules["NexusUI/API"] = function()
        local script = CreateMockScript("NexusUI/API")

        --[[
            NexusUI API Reference
            Complete API documentation and type definitions
        ]]

        --[[
        =============================================================================
                                    NexusUI API Reference
        =============================================================================

        This file provides comprehensive documentation for the NexusUI library API.
        All public methods, properties, and types are documented here.

        =============================================================================
                                      MAIN LIBRARY
        =============================================================================

        NexusUI:CreateWindow(config)
            Creates a new window instance.

            Parameters:
                config (table):
                    Title (string): Window title
                    Theme (string): Theme name (default: "Dark")
                    Size (UDim2): Window size
                    Position (UDim2): Window position
                    Draggable (boolean): Allow dragging
                    Resizable (boolean): Allow resizing
                    Minimizable (boolean): Show minimize button
                    Closeable (boolean): Show close button

            Returns: Window instance

            Example:
                local Window = NexusUI:CreateWindow({
                    Title = "My Script",
                    Theme = "LiquidGlass",
                    Size = UDim2.new(0, 500, 0, 400)
                })

        -----------------------------------------------------------------------------

        NexusUI:SetTheme(themeName)
            Changes the current theme.

            Parameters:
                themeName (string): Name of theme to apply

            Example:
                NexusUI:SetTheme("Ocean")

        -----------------------------------------------------------------------------

        NexusUI:CreateTheme(name, colors)
            Creates a custom theme.

            Parameters:
                name (string): Theme name
                colors (table): Color definitions

            Example:
                NexusUI:CreateTheme("MyTheme", {
                    Primary = Color3.fromRGB(100, 150, 255),
                    Background = Color3.fromRGB(20, 20, 30)
                })

        -----------------------------------------------------------------------------

        NexusUI:Notify(config)
            Shows a notification toast.

            Parameters:
                config (table):
                    Title (string): Notification title
                    Content (string): Notification message
                    Type (string): "Info", "Success", "Warning", "Error"
                    Duration (number): Seconds to show (default: 5)
                    Icon (string): Optional icon name

            Example:
                NexusUI:Notify({
                    Title = "Success",
                    Content = "Operation completed!",
                    Type = "Success"
                })

        -----------------------------------------------------------------------------

        NexusUI:SaveConfig(name, data)
            Saves configuration data.

            Parameters:
                name (string): Config name
                data (table): Data to save

            Example:
                NexusUI:SaveConfig("Settings", { Enabled = true })

        -----------------------------------------------------------------------------

        NexusUI:LoadConfig(name)
            Loads configuration data.

            Parameters:
                name (string): Config name

            Returns: table or nil

            Example:
                local config = NexusUI:LoadConfig("Settings")

        -----------------------------------------------------------------------------

        NexusUI:RegisterHotkey(name, key, callback)
            Registers a global hotkey.

            Parameters:
                name (string): Hotkey identifier
                key (Enum.KeyCode): Key to bind
                callback (function): Function to call when pressed

            Example:
                NexusUI:RegisterHotkey("Toggle", Enum.KeyCode.RightControl, function()
                    Window:Toggle()
                end)

        -----------------------------------------------------------------------------

        NexusUI:PlaySound(soundName, volume)
            Plays a UI sound.

            Parameters:
                soundName (string): Sound name
                volume (number): Volume (0-1)

            Example:
                NexusUI:PlaySound("Click", 0.5)

        -----------------------------------------------------------------------------

        NexusUI:EnableFPSMonitor(config)
            Enables the FPS monitor overlay.

            Parameters:
                config (table):
                    Position (string): "TopLeft", "TopRight", etc.
                    ShowGraph (boolean): Show FPS graph
                    ShowMemory (boolean): Show memory usage
                    ShowPing (boolean): Show network ping

            Example:
                NexusUI:EnableFPSMonitor({ Position = "TopRight" })

        -----------------------------------------------------------------------------

        NexusUI:Destroy()
            Destroys the UI and cleans up resources.

        =============================================================================
                                      WINDOW
        =============================================================================

        Window:AddTab(config)
            Adds a tab to the window.

            Parameters:
                config (table):
                    Name (string): Tab name
                    Icon (string): Tab icon

            Returns: Tab instance

            Example:
                local Tab = Window:AddTab({ Name = "Main", Icon = "Home" })

        -----------------------------------------------------------------------------

        Window:Show()
            Shows the window.

        Window:Hide()
            Hides the window.

        Window:Toggle()
            Toggles window visibility.

        Window:SetTitle(title)
            Sets the window title.

        Window:Minimize()
            Minimizes the window.

        Window:Maximize()
            Maximizes the window.

        Window:Close()
            Closes and destroys the window.

        Window:AutoSaveConfig(name)
            Enables auto-saving of UI state.

        =============================================================================
                                      TAB
        =============================================================================

        Tab:AddButton(config)
            Adds a button to the tab.

            Parameters:
                config (table):
                    Text (string): Button text
                    Callback (function): Click handler
                    Icon (string): Optional icon

            Returns: Button instance

        -----------------------------------------------------------------------------

        Tab:AddToggle(config)
            Adds a toggle to the tab.

            Parameters:
                config (table):
                    Text (string): Toggle label
                    Default (boolean): Initial value
                    Callback (function): Change handler

            Returns: Toggle instance

        -----------------------------------------------------------------------------

        Tab:AddSlider(config)
            Adds a slider to the tab.

            Parameters:
                config (table):
                    Text (string): Slider label
                    Min (number): Minimum value
                    Max (number): Maximum value
                    Default (number): Initial value
                    Step (number): Value step
                    Callback (function): Change handler

            Returns: Slider instance

        -----------------------------------------------------------------------------

        Tab:AddInput(config)
            Adds a text input to the tab.

            Parameters:
                config (table):
                    Text (string): Input label
                    Placeholder (string): Placeholder text
                    Default (string): Initial value
                    Callback (function): Change handler

            Returns: Input instance

        -----------------------------------------------------------------------------

        Tab:AddDropdown(config)
            Adds a dropdown to the tab.

            Parameters:
                config (table):
                    Text (string): Dropdown label
                    Options (table): Array of options
                    Default (string): Initial selection
                    Multi (boolean): Allow multiple selection
                    Callback (function): Change handler

            Returns: Dropdown instance

        -----------------------------------------------------------------------------

        Tab:AddColorPicker(config)
            Adds a color picker to the tab.

            Parameters:
                config (table):
                    Text (string): Picker label
                    Default (Color3): Initial color
                    Callback (function): Change handler

            Returns: ColorPicker instance

        -----------------------------------------------------------------------------

        Tab:AddKeybind(config)
            Adds a keybind input to the tab.

            Parameters:
                config (table):
                    Text (string): Keybind label
                    Default (Enum.KeyCode): Initial key
                    Callback (function): Handler when key pressed
                    ChangedCallback (function): Handler when keybind changed

            Returns: Keybind instance

        -----------------------------------------------------------------------------

        Tab:AddSection(name)
            Adds a visual section divider.

            Parameters:
                name (string): Section title

            Returns: Section instance

        -----------------------------------------------------------------------------

        Tab:AddLabel(text)
            Adds a text label.

            Parameters:
                text (string): Label text

            Returns: Label instance

        Tab:AddParagraph(title, content)
            Adds a paragraph with title and content.

            Returns: Paragraph instance

        =============================================================================
                                   COMPONENTS
        =============================================================================

        Button:SetText(text)
            Sets button text.

        Button:SetCallback(callback)
            Sets click handler.

        Button:Fire()
            Programmatically clicks the button.

        -----------------------------------------------------------------------------

        Toggle:SetValue(value)
            Sets toggle state.

        Toggle:GetValue()
            Gets current toggle state.

        Toggle:OnChanged(callback)
            Sets change handler.

        -----------------------------------------------------------------------------

        Slider:SetValue(value)
            Sets slider value.

        Slider:GetValue()
            Gets current slider value.

        Slider:SetMin(min)
            Sets minimum value.

        Slider:SetMax(max)
            Sets maximum value.

        -----------------------------------------------------------------------------

        Input:SetValue(text)
            Sets input text.

        Input:GetValue()
            Gets current input text.

        Input:SetPlaceholder(text)
            Sets placeholder text.

        -----------------------------------------------------------------------------

        Dropdown:SetOptions(options)
            Sets available options.

        Dropdown:AddOption(option)
            Adds an option.

        Dropdown:RemoveOption(option)
            Removes an option.

        Dropdown:SetValue(value)
            Sets selected value(s).

        Dropdown:GetValue()
            Gets current selection.

        -----------------------------------------------------------------------------

        ColorPicker:SetColor(color)
            Sets current color.

        ColorPicker:GetColor()
            Gets current color.

        -----------------------------------------------------------------------------

        Keybind:SetKey(key)
            Sets bound key.

        Keybind:GetKey()
            Gets current bound key.

        =============================================================================
                                   BUILDERS
        =============================================================================

        WindowBuilder.Create()
            Creates a new window builder.

            Example:
                local window = NexusUI.Builders.Window.Create()
                    :Title("My Window")
                    :Size(500, 400)
                    :Theme("Ocean")
                    :Draggable(true)
                    :Build(parent)

        -----------------------------------------------------------------------------

        FormBuilder.Create()
            Creates a new form builder.

            Example:
                local form = NexusUI.Builders.Form.Create()
                    :Title("Login")
                    :AddTextInput("username", "Username")
                    :AddTextInput("password", "Password", { Password = true })
                    :OnSubmit(function(values) end)
                    :Build(parent)

        -----------------------------------------------------------------------------

        MenuBuilder.Context()
            Creates a context menu builder.

        MenuBuilder.Dropdown()
            Creates a dropdown menu builder.

        -----------------------------------------------------------------------------

        CardBuilder.Create()
            Creates a card builder.

        ListBuilder.Create()
            Creates a list builder.

        =============================================================================
                                   THEMES
        =============================================================================

        Available Themes:
            - Dark
            - Light
            - LiquidGlass
            - Ocean
            - Forest
            - Sunset
            - Midnight
            - Neon
            - Cyberpunk
            - Dracula
            - Nord
            - Monokai
            - Synthwave
            - Material
            - Catppuccin
            - Rose
            - Aqua
            - Crimson
            - Emerald
            - Obsidian
            - Lavender
            - Amber
            - Slate
            - Cherry
            - Coffee

        Theme Colors:
            - Primary: Main accent color
            - Secondary: Secondary accent
            - Background: Main background
            - Surface: Card/panel backgrounds
            - Text: Primary text color
            - TextSecondary: Secondary text
            - Border: Border color
            - Success: Success state
            - Warning: Warning state
            - Error: Error state
            - Info: Info state

        =============================================================================
                                   EFFECTS
        =============================================================================

        NexusUI.Effects.LiquidGlass
            Creates liquid glass effect with blur and refraction.

        NexusUI.Effects.Glassmorphism
            Creates frosted glass effect.

        NexusUI.Effects.Blur
            Applies blur effect to element.

        NexusUI.Effects.Glow
            Adds glow effect.

        NexusUI.Effects.Shadow
            Adds drop shadow.

        NexusUI.Effects.Gradient
            Creates gradient background.

        NexusUI.Effects.Particles
            Adds particle effects.

        NexusUI.Effects.Ripple
            Adds ripple click effect.

        =============================================================================
                                   VISUALIZERS
        =============================================================================

        LineChart:SetData(data)
        BarChart:SetData(data)
        PieChart:SetData(data)
        Gauge:SetValue(value)
        FPSGraph:Enable()
        MemoryGraph:Enable()
        NetworkGraph:Enable()
        PerformancePanel:Show()

        =============================================================================
                                   SPECIAL
        =============================================================================

        Console:Log(message)
        Console:Error(message)
        Console:Clear()

        CodeEditor:SetCode(code)
        CodeEditor:GetCode()

        ESP:Enable()
        ESP:Disable()
        ESP:Configure(config)

        Watermark:SetText(text)
        Watermark:Show()
        Watermark:Hide()

        =============================================================================
        ]]

        return {
            Version = "1.0.0",
            Documentation = "See comments above for full API reference"
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Compiler
    -- ============================================================================
    NexusUI_Modules["NexusUI/Compiler"] = function()
        local script = CreateMockScript("NexusUI/Compiler")

        --[[
            NexusUI Compiler
            Utility to compile the library into a single file for executor distribution

            Usage: Run this script in Roblox Studio to generate a compiled single-file version
        ]]

        local Compiler = {}

        --// Configuration
        Compiler.Config = {
            OutputFileName = "NexusUI_Compiled.lua",
            Minify = false, -- Set true for production
            IncludeComments = true,
            BundleAssets = true,
        }

        --// Module order for compilation (dependencies first)
        Compiler.ModuleOrder = {
            -- Core
            "NexusUI/Core/Services",
            "NexusUI/Core/SignalClass",
            "NexusUI/Core/Maid",
            "NexusUI/Core/Promise",
            "NexusUI/Core/EventSystem",
            "NexusUI/Core/StateManager",
            "NexusUI/Core/Types",
            "NexusUI/Core/Constants",
            "NexusUI/Core/InstancePool",
            "NexusUI/Core/ScreenGui",
            "NexusUI/Core/Utility/Math",
            "NexusUI/Core/Utility/String",
            "NexusUI/Core/Utility/Table",
            "NexusUI/Core/Utility/Color",
            "NexusUI/Core/Utility/Bezier",
            "NexusUI/Core/Utility/UUID",
            "NexusUI/Core/Utility/Debounce",
            "NexusUI/Core/Utility/DeepCopy",
            "NexusUI/Core/Utility/Lerp",
            "NexusUI/Core/Utility/Validate",
            "NexusUI/Core/Utility/init",
            "NexusUI/Core/Initialization",
            "NexusUI/Core/init",

            -- Animation
            "NexusUI/Animation/SpringPhysics",
            "NexusUI/Animation/EasingFunctions",
            "NexusUI/Animation/Sequence",
            "NexusUI/Animation/Timeline",
            "NexusUI/Animation/Keyframes",
            "NexusUI/Animation/Tween",
            "NexusUI/Animation/Parallel",
            "NexusUI/Animation/Morph",
            "NexusUI/Animation/Transition",
            "NexusUI/Animation/Controller",
            "NexusUI/Animation/Effects",
            "NexusUI/Animation/Stagger",
            "NexusUI/Animation/Interpolate",
            "NexusUI/Animation/init",

            -- Themes
            "NexusUI/Themes/Palette",
            "NexusUI/Themes/Effects",
            "NexusUI/Themes/Builder",
            "NexusUI/Themes/Presets/Dark",
            "NexusUI/Themes/Presets/Light",
            -- ... all other theme presets
            "NexusUI/Themes/Manager",
            "NexusUI/Themes/init",

            -- Effects
            "NexusUI/Effects/LiquidGlass",
            "NexusUI/Effects/Glassmorphism",
            "NexusUI/Effects/Blur",
            "NexusUI/Effects/Glow",
            "NexusUI/Effects/Shadow",
            "NexusUI/Effects/Gradient",
            "NexusUI/Effects/Particles",
            "NexusUI/Effects/Ripple",
            "NexusUI/Effects/init",

            -- Components (base first, then all others)
            "NexusUI/Components/Base",
            "NexusUI/Components/Container",
            -- ... all components
            "NexusUI/Components/init",

            -- Features
            "NexusUI/Features/Sound",
            "NexusUI/Features/Config",
            "NexusUI/Features/Hotkey",
            "NexusUI/Features/DragDrop",
            "NexusUI/Features/init",

            -- Layout
            "NexusUI/Layout/Flex",
            "NexusUI/Layout/Grid",
            "NexusUI/Layout/Stack",
            "NexusUI/Layout/Center",
            "NexusUI/Layout/Spacer",
            "NexusUI/Layout/Responsive",
            "NexusUI/Layout/Container",
            "NexusUI/Layout/Utils",
            "NexusUI/Layout/init",

            -- Assets
            "NexusUI/Assets/Icons",
            "NexusUI/Assets/Images",
            "NexusUI/Assets/Fonts",
            "NexusUI/Assets/Sounds",
            "NexusUI/Assets/Sprites",
            "NexusUI/Assets/Loader",
            "NexusUI/Assets/Cache",
            "NexusUI/Assets/init",

            -- Builders
            "NexusUI/Builders/UI",
            "NexusUI/Builders/Window",
            "NexusUI/Builders/Tab",
            "NexusUI/Builders/Section",
            "NexusUI/Builders/Form",
            "NexusUI/Builders/Menu",
            "NexusUI/Builders/Toolbar",
            "NexusUI/Builders/Dialog",
            "NexusUI/Builders/Card",
            "NexusUI/Builders/List",
            "NexusUI/Builders/init",

            -- Notifications
            "NexusUI/Notifications/Toast",
            "NexusUI/Notifications/Notification",
            "NexusUI/Notifications/Alert",
            "NexusUI/Notifications/Manager",
            "NexusUI/Notifications/Banner",
            "NexusUI/Notifications/Snackbar",
            "NexusUI/Notifications/init",

            -- Visualizers
            "NexusUI/Visualizers/LineChart",
            "NexusUI/Visualizers/BarChart",
            "NexusUI/Visualizers/PieChart",
            "NexusUI/Visualizers/AreaChart",
            "NexusUI/Visualizers/RadarChart",
            "NexusUI/Visualizers/DonutChart",
            "NexusUI/Visualizers/Sparkline",
            "NexusUI/Visualizers/Gauge",
            "NexusUI/Visualizers/Heatmap",
            "NexusUI/Visualizers/FPSGraph",
            "NexusUI/Visualizers/MemoryGraph",
            "NexusUI/Visualizers/NetworkGraph",
            "NexusUI/Visualizers/PerformancePanel",
            "NexusUI/Visualizers/init",

            -- Special
            "NexusUI/Special/Console",
            "NexusUI/Special/CodeEditor",
            "NexusUI/Special/Terminal",
            "NexusUI/Special/ESP",
            "NexusUI/Special/Watermark",
            "NexusUI/Special/Crosshair",
            "NexusUI/Special/Aimbot",
            "NexusUI/Special/Playerlist",
            "NexusUI/Special/Killfeed",
            "NexusUI/Special/Minimap",
            "NexusUI/Special/Spectate",
            "NexusUI/Special/init",

            -- Main
            "NexusUI/init",
        }

        --// Generate header
        function Compiler.GenerateHeader()
            return [[
        --[[
            ╔═══════════════════════════════════════════════════════════════╗
            ║                         NexusUI                                ║
            ║              Premium UI Library for Roblox                     ║
            ╠═══════════════════════════════════════════════════════════════╣
            ║  Version: 1.0.0                                                ║
            ║  Author: NexusUI Team                                          ║
            ║  License: MIT                                                  ║
            ╚═══════════════════════════════════════════════════════════════╝

            Features:
            • 25+ Beautiful Themes with Liquid Glass Effects
            • Advanced Animation Engine with Springs & Easing
            • Comprehensive Component Library
            • Performance Monitoring (FPS, Memory, Network)
            • ESP, Aimbot, and Executor Components
            • Builder Patterns for Easy UI Creation
            • Sound System & Hotkey Management
            • Config Save/Load with Cloud Sync

            Usage:
                local NexusUI = loadstring(game:HttpGet("URL_HERE"))()
                local Window = NexusUI:CreateWindow({
                    Title = "My Script",
                    Theme = "LiquidGlass"
                })
        --]]

        ]]
        end

        --// Generate module wrapper
        function Compiler.WrapModule(moduleName, moduleCode)
            return string.format([[
        -- Module: %s
        _G.NexusUI_Modules["%s"] = (function()
        %s
        end)()

        ]], moduleName, moduleName, moduleCode)
        end

        --// Generate runtime require replacement
        function Compiler.GenerateRuntime()
            return [[
        -- Runtime module system
        _G.NexusUI_Modules = _G.NexusUI_Modules or {}

        local function NexusRequire(modulePath)
            if _G.NexusUI_Modules[modulePath] then
                return _G.NexusUI_Modules[modulePath]
            end
            warn("[NexusUI] Module not found:", modulePath)
            return nil
        end

        -- Replace script.Parent references
        local script = {
            Parent = { Parent = { Parent = nil } }
        }

        ]]
        end

        --// Generate footer
        function Compiler.GenerateFooter()
            return [[

        -- Return the library
        return _G.NexusUI_Modules["NexusUI/init"]
        ]]
        end

        --// Main compile function (for use in Roblox Studio)
        function Compiler.Compile()
            local output = {}

            -- Add header
            table.insert(output, Compiler.GenerateHeader())
            table.insert(output, Compiler.GenerateRuntime())

            -- Add modules (this would read actual module source in Studio)
            for _, modulePath in ipairs(Compiler.ModuleOrder) do
                -- In actual use, this would read the module source
                local moduleCode = "-- Module code would be inserted here"
                table.insert(output, Compiler.WrapModule(modulePath, moduleCode))
            end

            -- Add footer
            table.insert(output, Compiler.GenerateFooter())

            return table.concat(output, "\n")
        end

        --// Export for CLI usage
        function Compiler.ExportToFile(filePath)
            local compiled = Compiler.Compile()
            -- Would write to file system
            print("[Compiler] Would export to:", filePath)
            print("[Compiler] Total size:", #compiled, "characters")
            return compiled
        end

        return Compiler


    end


    -- ============================================================================
    -- Module: NexusUI/Animation/TweenEngine
    -- ============================================================================
    NexusUI_Modules["NexusUI/Animation/TweenEngine"] = function()
        local script = CreateMockScript("NexusUI/Animation/TweenEngine")

        --[[
            NexusUI Tween Engine
            Custom high-performance tweening system

            Features:
            - Multi-property tweening
            - Custom easing support
            - Tween grouping
            - Batched updates
            - Memory-efficient pooling
            - Callback system
        ]]

        --// Services
        local RunService = game:GetService("RunService")
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local EasingFunctions = nil

        --// Tween Engine
        local TweenEngine = {}
        TweenEngine.__index = TweenEngine
        TweenEngine.ClassName = "TweenEngine"

        --// Configuration
        local Config = {
            UseNativeTween = false, -- Use Roblox TweenService when possible
            DefaultDuration = 0.3,
            DefaultEasing = "QuadOut",
            PoolSize = 100,
            BatchUpdates = true,
        }

        --// Tween Pool
        local TweenPool = {}
        local ActiveTweens = {}
        local TweenIdCounter = 0

        --// Tween State
        local TweenState = {
            Pending = "Pending",
            Playing = "Playing",
            Paused = "Paused",
            Completed = "Completed",
            Cancelled = "Cancelled",
        }

        --// Generate Tween ID
        local function GenerateTweenId()
            TweenIdCounter = TweenIdCounter + 1
            return "tween_" .. TweenIdCounter
        end

        --// Get or Load Easing Module
        local function GetEasing(name)
            if not EasingFunctions then
                EasingFunctions = script.Parent:FindFirstChild("EasingFunctions")
                if EasingFunctions then
                    EasingFunctions = require(EasingFunctions)
                end
            end

            if EasingFunctions and EasingFunctions[name] then
                return EasingFunctions[name]
            end

            -- Fallback easings
            local fallback = {
                Linear = function(t) return t end,
                QuadIn = function(t) return t * t end,
                QuadOut = function(t) return 1 - (1 - t) * (1 - t) end,
                QuadInOut = function(t)
                    return t < 0.5 and 2 * t * t or 1 - (-2 * t + 2) ^ 2 / 2
                end,
            }

            return fallback[name] or fallback.Linear
        end

        --// Value Interpolation
        local function LerpValue(startValue, endValue, t)
            local valueType = typeof(startValue)

            if valueType == "number" then
                return startValue + (endValue - startValue) * t
            elseif valueType == "Color3" then
                return Color3.new(
                    startValue.R + (endValue.R - startValue.R) * t,
                    startValue.G + (endValue.G - startValue.G) * t,
                    startValue.B + (endValue.B - startValue.B) * t
                )
            elseif valueType == "Vector2" then
                return Vector2.new(
                    startValue.X + (endValue.X - startValue.X) * t,
                    startValue.Y + (endValue.Y - startValue.Y) * t
                )
            elseif valueType == "Vector3" then
                return Vector3.new(
                    startValue.X + (endValue.X - startValue.X) * t,
                    startValue.Y + (endValue.Y - startValue.Y) * t,
                    startValue.Z + (endValue.Z - startValue.Z) * t
                )
            elseif valueType == "UDim" then
                return UDim.new(
                    startValue.Scale + (endValue.Scale - startValue.Scale) * t,
                    startValue.Offset + (endValue.Offset - startValue.Offset) * t
                )
            elseif valueType == "UDim2" then
                return UDim2.new(
                    startValue.X.Scale + (endValue.X.Scale - startValue.X.Scale) * t,
                    startValue.X.Offset + (endValue.X.Offset - startValue.X.Offset) * t,
                    startValue.Y.Scale + (endValue.Y.Scale - startValue.Y.Scale) * t,
                    startValue.Y.Offset + (endValue.Y.Offset - startValue.Y.Offset) * t
                )
            elseif valueType == "CFrame" then
                return startValue:Lerp(endValue, t)
            elseif valueType == "NumberRange" then
                return NumberRange.new(
                    startValue.Min + (endValue.Min - startValue.Min) * t,
                    startValue.Max + (endValue.Max - startValue.Max) * t
                )
            elseif valueType == "Rect" then
                return Rect.new(
                    startValue.Min.X + (endValue.Min.X - startValue.Min.X) * t,
                    startValue.Min.Y + (endValue.Min.Y - startValue.Min.Y) * t,
                    startValue.Max.X + (endValue.Max.X - startValue.Max.X) * t,
                    startValue.Max.Y + (endValue.Max.Y - startValue.Max.Y) * t
                )
            elseif valueType == "NumberSequence" then
                -- Interpolate keypoints
                local keypoints = {}
                local startKeypoints = startValue.Keypoints
                local endKeypoints = endValue.Keypoints

                for i, startKp in ipairs(startKeypoints) do
                    local endKp = endKeypoints[i] or startKp
                    table.insert(keypoints, NumberSequenceKeypoint.new(
                        startKp.Time,
                        startKp.Value + (endKp.Value - startKp.Value) * t,
                        startKp.Envelope + (endKp.Envelope - startKp.Envelope) * t
                    ))
                end

                return NumberSequence.new(keypoints)
            elseif valueType == "ColorSequence" then
                -- Interpolate keypoints
                local keypoints = {}
                local startKeypoints = startValue.Keypoints
                local endKeypoints = endValue.Keypoints

                for i, startKp in ipairs(startKeypoints) do
                    local endKp = endKeypoints[i] or startKp
                    table.insert(keypoints, ColorSequenceKeypoint.new(
                        startKp.Time,
                        Color3.new(
                            startKp.Value.R + (endKp.Value.R - startKp.Value.R) * t,
                            startKp.Value.G + (endKp.Value.G - startKp.Value.G) * t,
                            startKp.Value.B + (endKp.Value.B - startKp.Value.B) * t
                        )
                    ))
                end

                return ColorSequence.new(keypoints)
            end

            -- Default: return end value at halfway point
            return t >= 0.5 and endValue or startValue
        end

        --// Tween Object
        local Tween = {}
        Tween.__index = Tween

        function Tween.new(config)
            local self = setmetatable({}, Tween)

            self.Id = GenerateTweenId()
            self.Target = config.Target
            self.Properties = config.Properties or {}
            self.Duration = config.Duration or Config.DefaultDuration
            self.Easing = config.Easing or Config.DefaultEasing
            self.Delay = config.Delay or 0
            self.RepeatCount = config.RepeatCount or 0
            self.Reverse = config.Reverse or false
            self.Yoyo = config.Yoyo or false

            -- Callbacks
            self.OnStart = config.OnStart
            self.OnUpdate = config.OnUpdate
            self.OnComplete = config.OnComplete
            self.OnRepeat = config.OnRepeat

            -- State
            self.State = TweenState.Pending
            self.ElapsedTime = 0
            self.DelayRemaining = self.Delay
            self.RepeatsDone = 0
            self.Direction = 1 -- 1 = forward, -1 = backward

            -- Store start values
            self.StartValues = {}
            self.EndValues = {}

            return self
        end

        function Tween:_captureStartValues()
            if not self.Target then return end

            for property, endValue in pairs(self.Properties) do
                local success, startValue = pcall(function()
                    return self.Target[property]
                end)

                if success then
                    self.StartValues[property] = startValue
                    self.EndValues[property] = endValue
                end
            end
        end

        function Tween:Play()
            if self.State == TweenState.Playing then
                return self
            end

            self:_captureStartValues()

            self.State = TweenState.Playing
            self.ElapsedTime = 0
            self.DelayRemaining = self.Delay
            self.RepeatsDone = 0
            self.Direction = 1

            if self.OnStart then
                pcall(self.OnStart, self)
            end

            ActiveTweens[self.Id] = self

            return self
        end

        function Tween:Pause()
            if self.State == TweenState.Playing then
                self.State = TweenState.Paused
            end
            return self
        end

        function Tween:Resume()
            if self.State == TweenState.Paused then
                self.State = TweenState.Playing
            end
            return self
        end

        function Tween:Stop()
            self.State = TweenState.Cancelled
            ActiveTweens[self.Id] = nil
            return self
        end

        function Tween:Cancel()
            return self:Stop()
        end

        function Tween:Restart()
            self:Stop()
            self:Play()
            return self
        end

        function Tween:Reset()
            if not self.Target then return self end

            for property, startValue in pairs(self.StartValues) do
                pcall(function()
                    self.Target[property] = startValue
                end)
            end

            return self
        end

        function Tween:Complete()
            if not self.Target then return self end

            for property, endValue in pairs(self.EndValues) do
                pcall(function()
                    self.Target[property] = endValue
                end)
            end

            self.State = TweenState.Completed
            ActiveTweens[self.Id] = nil

            if self.OnComplete then
                pcall(self.OnComplete, self)
            end

            return self
        end

        function Tween:Update(deltaTime)
            if self.State ~= TweenState.Playing then
                return self.State == TweenState.Completed or self.State == TweenState.Cancelled
            end

            -- Handle delay
            if self.DelayRemaining > 0 then
                self.DelayRemaining = self.DelayRemaining - deltaTime
                return false
            end

            -- Update elapsed time
            self.ElapsedTime = self.ElapsedTime + deltaTime

            -- Calculate progress
            local rawProgress = math.min(self.ElapsedTime / self.Duration, 1)
            local progress = self.Direction == 1 and rawProgress or (1 - rawProgress)

            -- Apply easing
            local easingFunc = GetEasing(self.Easing)
            local easedProgress = easingFunc(progress)

            -- Apply values to target
            if self.Target then
                for property, endValue in pairs(self.EndValues) do
                    local startValue = self.StartValues[property]

                    if startValue ~= nil then
                        local currentValue = LerpValue(startValue, endValue, easedProgress)

                        pcall(function()
                            self.Target[property] = currentValue
                        end)
                    end
                end
            end

            -- Callback
            if self.OnUpdate then
                pcall(self.OnUpdate, easedProgress, self)
            end

            -- Check completion
            if rawProgress >= 1 then
                -- Handle repeating
                if self.RepeatCount == -1 or self.RepeatsDone < self.RepeatCount then
                    self.RepeatsDone = self.RepeatsDone + 1
                    self.ElapsedTime = 0

                    if self.Yoyo then
                        self.Direction = self.Direction * -1
                    end

                    if self.OnRepeat then
                        pcall(self.OnRepeat, self.RepeatsDone, self)
                    end

                    return false
                end

                self.State = TweenState.Completed

                if self.OnComplete then
                    pcall(self.OnComplete, self)
                end

                return true
            end

            return false
        end

        function Tween:SetEasing(easing)
            self.Easing = easing
            return self
        end

        function Tween:SetDuration(duration)
            self.Duration = duration
            return self
        end

        function Tween:SetDelay(delay)
            self.Delay = delay
            self.DelayRemaining = delay
            return self
        end

        function Tween:SetRepeat(count)
            self.RepeatCount = count
            return self
        end

        function Tween:SetYoyo(yoyo)
            self.Yoyo = yoyo
            return self
        end

        function Tween:Then(callback)
            local originalOnComplete = self.OnComplete

            self.OnComplete = function(tween)
                if originalOnComplete then
                    originalOnComplete(tween)
                end
                callback(tween)
            end

            return self
        end

        function Tween:Await()
            while self.State == TweenState.Playing or self.State == TweenState.Paused do
                task.wait()
            end
            return self
        end

        function Tween:GetProgress()
            if self.Duration == 0 then return 1 end
            return math.min(self.ElapsedTime / self.Duration, 1)
        end

        function Tween:GetState()
            return self.State
        end

        function Tween:IsPlaying()
            return self.State == TweenState.Playing
        end

        function Tween:IsPaused()
            return self.State == TweenState.Paused
        end

        function Tween:IsComplete()
            return self.State == TweenState.Completed
        end

        --// Tween Engine API
        function TweenEngine.Create(target, properties, duration, easing, options)
            options = options or {}

            -- Check if we can use native tween
            if Config.UseNativeTween and typeof(target) == "Instance" then
                local tweenInfo = TweenInfo.new(
                    duration or Config.DefaultDuration,
                    Enum.EasingStyle.Quad,
                    Enum.EasingDirection.Out,
                    options.RepeatCount or 0,
                    options.Reverse or false,
                    options.Delay or 0
                )

                return TweenService:Create(target, tweenInfo, properties)
            end

            return Tween.new({
                Target = target,
                Properties = properties,
                Duration = duration or Config.DefaultDuration,
                Easing = easing or Config.DefaultEasing,
                Delay = options.Delay,
                RepeatCount = options.RepeatCount,
                Reverse = options.Reverse,
                Yoyo = options.Yoyo,
                OnStart = options.OnStart,
                OnUpdate = options.OnUpdate,
                OnComplete = options.OnComplete,
                OnRepeat = options.OnRepeat,
            })
        end

        function TweenEngine.To(target, duration, properties, easing)
            return TweenEngine.Create(target, properties, duration, easing):Play()
        end

        function TweenEngine.From(target, duration, properties, easing)
            if not target then return nil end

            -- Swap start and end values
            local endValues = {}

            for property, startValue in pairs(properties) do
                local success, currentValue = pcall(function()
                    return target[property]
                end)

                if success then
                    endValues[property] = currentValue

                    pcall(function()
                        target[property] = startValue
                    end)
                end
            end

            return TweenEngine.Create(target, endValues, duration, easing):Play()
        end

        function TweenEngine.FromTo(target, duration, fromProperties, toProperties, easing)
            if not target then return nil end

            -- Set starting values
            for property, value in pairs(fromProperties) do
                pcall(function()
                    target[property] = value
                end)
            end

            return TweenEngine.Create(target, toProperties, duration, easing):Play()
        end

        --// Batch Operations
        function TweenEngine.StaggerTo(targets, duration, properties, staggerDelay, easing)
            staggerDelay = staggerDelay or 0.1
            local tweens = {}

            for i, target in ipairs(targets) do
                local tween = TweenEngine.Create(target, properties, duration, easing, {
                    Delay = (i - 1) * staggerDelay
                })
                table.insert(tweens, tween)
            end

            for _, tween in ipairs(tweens) do
                tween:Play()
            end

            return tweens
        end

        function TweenEngine.KillAll()
            for id, tween in pairs(ActiveTweens) do
                tween:Cancel()
            end
            ActiveTweens = {}
        end

        function TweenEngine.KillTweensOf(target)
            for id, tween in pairs(ActiveTweens) do
                if tween.Target == target then
                    tween:Cancel()
                    ActiveTweens[id] = nil
                end
            end
        end

        function TweenEngine.GetTweensOf(target)
            local tweens = {}
            for id, tween in pairs(ActiveTweens) do
                if tween.Target == target then
                    table.insert(tweens, tween)
                end
            end
            return tweens
        end

        function TweenEngine.GetActiveCount()
            local count = 0
            for _ in pairs(ActiveTweens) do
                count = count + 1
            end
            return count
        end

        --// Update Loop (called from Animation module)
        function TweenEngine.Update(deltaTime)
            local toRemove = {}

            for id, tween in pairs(ActiveTweens) do
                local completed = tween:Update(deltaTime)

                if completed then
                    table.insert(toRemove, id)
                end
            end

            for _, id in ipairs(toRemove) do
                ActiveTweens[id] = nil
            end
        end

        --// Configuration
        function TweenEngine.SetConfig(key, value)
            if Config[key] ~= nil then
                Config[key] = value
            end
        end

        function TweenEngine.GetConfig(key)
            return Config[key]
        end

        --// Export State
        TweenEngine.State = TweenState

        return TweenEngine


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Keybind
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Keybind"] = function()
        local script = CreateMockScript("NexusUI/Components/Keybind")

        --[[
            NexusUI Keybind Component
            Keyboard binding input
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")
        local UserInputService = game:GetService("UserInputService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Keybind Component Module
        local Keybind = setmetatable({}, { __index = Base })
        Keybind.__index = Keybind
        Keybind.ClassName = "Keybind"

        --// Key display names
        local KeyNames = {
            [Enum.KeyCode.LeftShift] = "L Shift",
            [Enum.KeyCode.RightShift] = "R Shift",
            [Enum.KeyCode.LeftControl] = "L Ctrl",
            [Enum.KeyCode.RightControl] = "R Ctrl",
            [Enum.KeyCode.LeftAlt] = "L Alt",
            [Enum.KeyCode.RightAlt] = "R Alt",
            [Enum.KeyCode.CapsLock] = "Caps",
            [Enum.KeyCode.Tab] = "Tab",
            [Enum.KeyCode.Space] = "Space",
            [Enum.KeyCode.Return] = "Enter",
            [Enum.KeyCode.Backspace] = "Backspace",
            [Enum.KeyCode.Delete] = "Delete",
            [Enum.KeyCode.Insert] = "Insert",
            [Enum.KeyCode.Home] = "Home",
            [Enum.KeyCode.End] = "End",
            [Enum.KeyCode.PageUp] = "Page Up",
            [Enum.KeyCode.PageDown] = "Page Down",
            [Enum.KeyCode.Up] = "↑",
            [Enum.KeyCode.Down] = "↓",
            [Enum.KeyCode.Left] = "←",
            [Enum.KeyCode.Right] = "→",
            [Enum.KeyCode.Escape] = "Esc",
            [Enum.KeyCode.Tilde] = "~",
            [Enum.KeyCode.Minus] = "-",
            [Enum.KeyCode.Equals] = "=",
            [Enum.KeyCode.LeftBracket] = "[",
            [Enum.KeyCode.RightBracket] = "]",
            [Enum.KeyCode.Backslash] = "\\",
            [Enum.KeyCode.Semicolon] = ";",
            [Enum.KeyCode.Quote] = "'",
            [Enum.KeyCode.Comma] = ",",
            [Enum.KeyCode.Period] = ".",
            [Enum.KeyCode.Slash] = "/",
        }

        --// Constructor
        function Keybind.new(config)
            local self = setmetatable(Base.new(config), Keybind)

            config = config or {}

            self.Key = config.Key or Enum.KeyCode.Unknown
            self.Label = config.Label
            self.AllowModifiers = config.AllowModifiers or false
            self.BlacklistedKeys = config.BlacklistedKeys or {
                Enum.KeyCode.Escape,
                Enum.KeyCode.W, Enum.KeyCode.A, Enum.KeyCode.S, Enum.KeyCode.D, -- Movement
            }

            -- Callbacks
            self.OnKeyChanged = config.OnKeyChanged
            self.OnKeyPressed = config.OnKeyPressed

            -- State
            self._isListening = false
            self._inputConnection = nil

            return self
        end

        --// Get key display name
        function Keybind:_getKeyName(keyCode)
            if keyCode == Enum.KeyCode.Unknown then
                return "None"
            end

            return KeyNames[keyCode] or string.upper(keyCode.Name)
        end

        --// Create keybind
        function Keybind:Create(parent)
            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(1, 0, 0, 36)
            container.BackgroundTransparency = 1

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Layout
            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Horizontal
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.HorizontalAlignment = Enum.HorizontalAlignment.SpaceBetween
            layout.Parent = container

            -- Label
            if self.Label then
                local label = Instance.new("TextLabel")
                label.Name = "Label"
                label.Size = UDim2.new(0.5, 0, 1, 0)
                label.BackgroundTransparency = 1
                label.Font = Enum.Font.Gotham
                label.Text = self.Label
                label.TextColor3 = Color3.fromRGB(250, 250, 250)
                label.TextSize = 14
                label.TextXAlignment = Enum.TextXAlignment.Left
                label.LayoutOrder = 1
                label.Parent = container
                self._label = label
            end

            -- Keybind button
            local keyButton = Instance.new("TextButton")
            keyButton.Name = "KeyButton"
            keyButton.Size = UDim2.new(0, 100, 0, 30)
            keyButton.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
            keyButton.BorderSizePixel = 0
            keyButton.Font = Enum.Font.GothamMedium
            keyButton.Text = self:_getKeyName(self.Key)
            keyButton.TextColor3 = Color3.fromRGB(250, 250, 250)
            keyButton.TextSize = 13
            keyButton.AutoButtonColor = false
            keyButton.LayoutOrder = 2
            keyButton.Parent = container
            self._keyButton = keyButton

            -- Corner
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 6)
            corner.Parent = keyButton

            -- Border
            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(63, 63, 70)
            stroke.Thickness = 1
            stroke.Parent = keyButton
            self._stroke = stroke

            -- Setup interactions
            self:_setupInteractions()

            -- Start listening for key presses (for callbacks)
            self:_startKeyListener()

            return self
        end

        --// Setup interactions
        function Keybind:_setupInteractions()
            local keyButton = self._keyButton

            -- Click to start listening
            self:_connect(keyButton.MouseButton1Click, function()
                if self._isListening then
                    self:_stopListening()
                else
                    self:_startListening()
                end
            end)

            -- Hover
            self:_connect(keyButton.MouseEnter, function()
                if not self._isListening then
                    TweenService:Create(self._stroke, TweenInfo.new(0.15), {
                        Color = Color3.fromRGB(82, 82, 91),
                    }):Play()
                end
            end)

            self:_connect(keyButton.MouseLeave, function()
                if not self._isListening then
                    TweenService:Create(self._stroke, TweenInfo.new(0.15), {
                        Color = Color3.fromRGB(63, 63, 70),
                    }):Play()
                end
            end)
        end

        --// Start listening for new keybind
        function Keybind:_startListening()
            self._isListening = true

            self._keyButton.Text = "..."
            self._keyButton.BackgroundColor3 = Color3.fromRGB(99, 102, 241)
            self._stroke.Color = Color3.fromRGB(99, 102, 241)

            -- Listen for input
            if self._listenConnection then
                self._listenConnection:Disconnect()
            end

            self._listenConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                if input.UserInputType == Enum.UserInputType.Keyboard then
                    -- Check blacklist
                    for _, key in ipairs(self.BlacklistedKeys) do
                        if input.KeyCode == key then
                            return
                        end
                    end

                    -- Set new key
                    self:SetKey(input.KeyCode)
                    self:_stopListening()
                elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
                    -- Cancel on click outside
                    task.defer(function()
                        self:_stopListening()
                    end)
                end
            end)
        end

        --// Stop listening
        function Keybind:_stopListening()
            self._isListening = false

            if self._listenConnection then
                self._listenConnection:Disconnect()
                self._listenConnection = nil
            end

            self._keyButton.Text = self:_getKeyName(self.Key)

            TweenService:Create(self._keyButton, TweenInfo.new(0.15), {
                BackgroundColor3 = Color3.fromRGB(39, 39, 42),
            }):Play()

            TweenService:Create(self._stroke, TweenInfo.new(0.15), {
                Color = Color3.fromRGB(63, 63, 70),
            }):Play()
        end

        --// Start key listener (for callbacks)
        function Keybind:_startKeyListener()
            self._inputConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                if gameProcessed then return end

                if input.UserInputType == Enum.UserInputType.Keyboard then
                    if input.KeyCode == self.Key then
                        if self.OnKeyPressed then
                            self.OnKeyPressed()
                        end

                        self:_fire("KeyPressed")
                    end
                end
            end)
        end

        --// Set key
        function Keybind:SetKey(keyCode)
            local oldKey = self.Key
            self.Key = keyCode

            if self._keyButton then
                self._keyButton.Text = self:_getKeyName(keyCode)
            end

            if self.OnKeyChanged then
                self.OnKeyChanged(keyCode, oldKey)
            end

            self:_fire("KeyChanged", keyCode, oldKey)

            return self
        end

        --// Get key
        function Keybind:GetKey()
            return self.Key
        end

        --// Clear key
        function Keybind:ClearKey()
            return self:SetKey(Enum.KeyCode.Unknown)
        end

        --// Destroy override
        function Keybind:Destroy()
            if self._listenConnection then
                self._listenConnection:Disconnect()
            end

            if self._inputConnection then
                self._inputConnection:Disconnect()
            end

            Base.Destroy(self)
        end

        return Keybind


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Tabs
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Tabs"] = function()
        local script = CreateMockScript("NexusUI/Components/Tabs")

        --[[
            NexusUI Tabs Component
            Tabbed content navigation
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Tabs Component Module
        local Tabs = setmetatable({}, { __index = Base })
        Tabs.__index = Tabs
        Tabs.ClassName = "Tabs"

        --// Tab Variants
        Tabs.Variant = {
            Default = "Default",
            Pills = "Pills",
            Underline = "Underline",
            Bordered = "Bordered",
        }

        --// Constructor
        function Tabs.new(config)
            local self = setmetatable(Base.new(config), Tabs)

            config = config or {}

            self.TabItems = config.Tabs or {} -- Array of {Id, Text, Icon, Disabled, Content}
            self.SelectedIndex = config.SelectedIndex or 1
            self.Variant = config.Variant or Tabs.Variant.Default
            self.FullWidth = config.FullWidth or false

            -- Callbacks
            self.OnTabChange = config.OnTabChange

            -- State
            self._tabButtons = {}
            self._contentFrames = {}

            return self
        end

        --// Create tabs
        function Tabs:Create(parent)
            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(1, 0, 1, 0)
            container.BackgroundTransparency = 1

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Tab header
            local header = Instance.new("Frame")
            header.Name = "Header"
            header.Size = UDim2.new(1, 0, 0, 40)
            header.BackgroundTransparency = 1
            header.Parent = container
            self._header = header

            if self.Variant == Tabs.Variant.Bordered then
                header.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
                header.BackgroundTransparency = 0

                local headerCorner = Instance.new("UICorner")
                headerCorner.CornerRadius = UDim.new(0, 8)
                headerCorner.Parent = header

                local headerStroke = Instance.new("UIStroke")
                headerStroke.Color = Color3.fromRGB(63, 63, 70)
                headerStroke.Thickness = 1
                headerStroke.Parent = header
            end

            local headerPadding = Instance.new("UIPadding")
            headerPadding.PaddingLeft = UDim.new(0, 4)
            headerPadding.PaddingRight = UDim.new(0, 4)
            headerPadding.Parent = header

            local headerLayout = Instance.new("UIListLayout")
            headerLayout.FillDirection = Enum.FillDirection.Horizontal
            headerLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            headerLayout.Padding = UDim.new(0, 4)
            headerLayout.Parent = header

            -- Underline indicator
            if self.Variant == Tabs.Variant.Underline then
                local underline = Instance.new("Frame")
                underline.Name = "Underline"
                underline.Size = UDim2.new(0, 50, 0, 2)
                underline.Position = UDim2.new(0, 0, 1, -2)
                underline.BackgroundColor3 = Color3.fromRGB(99, 102, 241)
                underline.BorderSizePixel = 0
                underline.ZIndex = 10
                underline.Parent = header
                self._underline = underline

                -- Bottom line
                local bottomLine = Instance.new("Frame")
                bottomLine.Size = UDim2.new(1, 0, 0, 1)
                bottomLine.Position = UDim2.new(0, 0, 1, -1)
                bottomLine.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
                bottomLine.BorderSizePixel = 0
                bottomLine.Parent = header
            end

            -- Content container
            local content = Instance.new("Frame")
            content.Name = "Content"
            content.Size = UDim2.new(1, 0, 1, -48)
            content.Position = UDim2.new(0, 0, 0, 48)
            content.BackgroundTransparency = 1
            content.Parent = container
            self._content = content

            -- Create tabs
            self:_createTabs()

            return self
        end

        --// Create tabs
        function Tabs:_createTabs()
            -- Clear existing
            for _, btn in ipairs(self._tabButtons) do
                btn:Destroy()
            end
            self._tabButtons = {}

            for _, frame in ipairs(self._contentFrames) do
                frame:Destroy()
            end
            self._contentFrames = {}

            for i, tab in ipairs(self.TabItems) do
                local isSelected = i == self.SelectedIndex
                local isDisabled = tab.Disabled

                -- Tab button
                local btn = Instance.new("TextButton")
                btn.Name = "Tab" .. i
                btn.Size = self.FullWidth and UDim2.new(1 / #self.TabItems, -8, 0, 32) or UDim2.new(0, 0, 0, 32)
                btn.AutomaticSize = not self.FullWidth and Enum.AutomaticSize.X or Enum.AutomaticSize.None
                btn.BorderSizePixel = 0
                btn.Text = ""
                btn.AutoButtonColor = false
                btn.LayoutOrder = i
                btn.Parent = self._header

                -- Style based on variant
                if self.Variant == Tabs.Variant.Pills then
                    btn.BackgroundColor3 = isSelected and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(39, 39, 42)
                    btn.BackgroundTransparency = isSelected and 0 or 1

                    local btnCorner = Instance.new("UICorner")
                    btnCorner.CornerRadius = UDim.new(0, 6)
                    btnCorner.Parent = btn
                elseif self.Variant == Tabs.Variant.Underline then
                    btn.BackgroundTransparency = 1
                elseif self.Variant == Tabs.Variant.Bordered then
                    btn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
                    btn.BackgroundTransparency = isSelected and 0 or 1

                    local btnCorner = Instance.new("UICorner")
                    btnCorner.CornerRadius = UDim.new(0, 6)
                    btnCorner.Parent = btn
                else -- Default
                    btn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
                    btn.BackgroundTransparency = isSelected and 0 or 1

                    local btnCorner = Instance.new("UICorner")
                    btnCorner.CornerRadius = UDim.new(0, 6)
                    btnCorner.Parent = btn
                end

                local btnPadding = Instance.new("UIPadding")
                btnPadding.PaddingLeft = UDim.new(0, 12)
                btnPadding.PaddingRight = UDim.new(0, 12)
                btnPadding.Parent = btn

                local btnLayout = Instance.new("UIListLayout")
                btnLayout.FillDirection = Enum.FillDirection.Horizontal
                btnLayout.VerticalAlignment = Enum.VerticalAlignment.Center
                btnLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
                btnLayout.Padding = UDim.new(0, 6)
                btnLayout.Parent = btn

                -- Icon
                if tab.Icon then
                    local icon = Instance.new("ImageLabel")
                    icon.Size = UDim2.new(0, 14, 0, 14)
                    icon.BackgroundTransparency = 1
                    icon.Image = tab.Icon
                    icon.ImageColor3 = isSelected and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(161, 161, 170)
                    icon.ImageTransparency = isDisabled and 0.5 or 0
                    icon.LayoutOrder = 1
                    icon.Parent = btn
                end

                -- Text
                local text = Instance.new("TextLabel")
                text.Size = UDim2.new(0, 0, 0, 0)
                text.AutomaticSize = Enum.AutomaticSize.XY
                text.BackgroundTransparency = 1
                text.Font = Enum.Font.GothamMedium
                text.Text = tab.Text
                text.TextColor3 = isSelected and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(161, 161, 170)
                text.TextSize = 13
                text.TextTransparency = isDisabled and 0.5 or 0
                text.LayoutOrder = 2
                text.Parent = btn

                -- Interactions
                if not isDisabled then
                    self:_connect(btn.MouseButton1Click, function()
                        self:SetSelectedIndex(i)
                    end)

                    self:_connect(btn.MouseEnter, function()
                        if i ~= self.SelectedIndex then
                            TweenService:Create(btn, TweenInfo.new(0.1), {
                                BackgroundTransparency = self.Variant == Tabs.Variant.Underline and 1 or 0.7,
                            }):Play()
                        end
                    end)

                    self:_connect(btn.MouseLeave, function()
                        if i ~= self.SelectedIndex then
                            TweenService:Create(btn, TweenInfo.new(0.1), {
                                BackgroundTransparency = 1,
                            }):Play()
                        end
                    end)
                end

                table.insert(self._tabButtons, btn)

                -- Content frame
                local contentFrame = Instance.new("Frame")
                contentFrame.Name = "TabContent" .. i
                contentFrame.Size = UDim2.new(1, 0, 1, 0)
                contentFrame.BackgroundTransparency = 1
                contentFrame.Visible = isSelected
                contentFrame.Parent = self._content

                table.insert(self._contentFrames, contentFrame)
            end

            -- Update underline position
            if self.Variant == Tabs.Variant.Underline then
                self:_updateUnderline(false)
            end
        end

        --// Update underline
        function Tabs:_updateUnderline(animate)
            if not self._underline then return end

            local btn = self._tabButtons[self.SelectedIndex]
            if not btn then return end

            local duration = animate ~= false and 0.2 or 0

            TweenService:Create(self._underline, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                Size = UDim2.new(0, btn.AbsoluteSize.X, 0, 2),
                Position = UDim2.new(0, btn.AbsolutePosition.X - self._header.AbsolutePosition.X, 1, -2),
            }):Play()
        end

        --// Set selected index
        function Tabs:SetSelectedIndex(index)
            if index == self.SelectedIndex then return self end
            if index < 1 or index > #self.TabItems then return self end

            local tab = self.TabItems[index]
            if tab.Disabled then return self end

            local oldIndex = self.SelectedIndex
            self.SelectedIndex = index

            -- Update tab buttons
            for i, btn in ipairs(self._tabButtons) do
                local isSelected = i == index

                if self.Variant == Tabs.Variant.Underline then
                    local text = btn:FindFirstChild("TextLabel") or btn:FindFirstChildWhichIsA("TextLabel")
                    if text then
                        TweenService:Create(text, TweenInfo.new(0.15), {
                            TextColor3 = isSelected and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(161, 161, 170),
                        }):Play()
                    end
                else
                    TweenService:Create(btn, TweenInfo.new(0.15), {
                        BackgroundTransparency = isSelected and 0 or 1,
                    }):Play()

                    -- Update text and icon colors
                    for _, child in ipairs(btn:GetChildren()) do
                        if child:IsA("TextLabel") then
                            TweenService:Create(child, TweenInfo.new(0.15), {
                                TextColor3 = isSelected and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(161, 161, 170),
                            }):Play()
                        elseif child:IsA("ImageLabel") then
                            TweenService:Create(child, TweenInfo.new(0.15), {
                                ImageColor3 = isSelected and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(161, 161, 170),
                            }):Play()
                        end
                    end
                end
            end

            -- Update content visibility
            for i, frame in ipairs(self._contentFrames) do
                frame.Visible = i == index
            end

            -- Update underline
            if self.Variant == Tabs.Variant.Underline then
                self:_updateUnderline(true)
            end

            if self.OnTabChange then
                self.OnTabChange(index, tab, oldIndex)
            end

            self:_fire("TabChange", index, tab, oldIndex)

            return self
        end

        --// Get content frame
        function Tabs:GetContentFrame(index)
            return self._contentFrames[index or self.SelectedIndex]
        end

        --// Set tabs
        function Tabs:SetTabs(tabs)
            self.TabItems = tabs
            self.SelectedIndex = 1
            self:_createTabs()
            return self
        end

        --// Add tab
        function Tabs:AddTab(tab)
            table.insert(self.TabItems, tab)
            self:_createTabs()
            return self
        end

        --// Remove tab
        function Tabs:RemoveTab(index)
            table.remove(self.TabItems, index)

            if self.SelectedIndex >= index then
                self.SelectedIndex = math.max(1, self.SelectedIndex - 1)
            end

            self:_createTabs()
            return self
        end

        return Tabs


    end


    -- ============================================================================
    -- Module: NexusUI/Components/TopBar
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/TopBar"] = function()
        local script = CreateMockScript("NexusUI/Components/TopBar")

        --[[
            NexusUI TopBar Component
            Application top bar/header
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// TopBar Component Module
        local TopBar = setmetatable({}, { __index = Base })
        TopBar.__index = TopBar
        TopBar.ClassName = "TopBar"

        --// Constructor
        function TopBar.new(config)
            local self = setmetatable(Base.new(config), TopBar)

            config = config or {}

            self.Title = config.Title
            self.Logo = config.Logo
            self.Height = config.Height or 50
            self.LeftItems = config.LeftItems or {} -- Array of {Type, ...props}
            self.RightItems = config.RightItems or {}
            self.CenterItems = config.CenterItems or {}

            return self
        end

        --// Create top bar
        function TopBar:Create(parent)
            -- Container
            local topBar = Instance.new("Frame")
            topBar.Name = self.Name
            topBar.Size = UDim2.new(1, 0, 0, self.Height)
            topBar.BackgroundColor3 = Color3.fromRGB(24, 24, 27)
            topBar.BorderSizePixel = 0

            if parent then
                topBar.Parent = parent
            end

            self.Instance = topBar

            -- Border bottom
            local border = Instance.new("Frame")
            border.Size = UDim2.new(1, 0, 0, 1)
            border.Position = UDim2.new(0, 0, 1, -1)
            border.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
            border.BorderSizePixel = 0
            border.Parent = topBar

            local padding = Instance.new("UIPadding")
            padding.PaddingLeft = UDim.new(0, 16)
            padding.PaddingRight = UDim.new(0, 16)
            padding.Parent = topBar

            -- Layout
            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Horizontal
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.HorizontalAlignment = Enum.HorizontalAlignment.SpaceBetween
            layout.Parent = topBar

            -- Left section
            local leftSection = Instance.new("Frame")
            leftSection.Name = "Left"
            leftSection.Size = UDim2.new(0, 0, 1, 0)
            leftSection.AutomaticSize = Enum.AutomaticSize.X
            leftSection.BackgroundTransparency = 1
            leftSection.LayoutOrder = 1
            leftSection.Parent = topBar
            self._leftSection = leftSection

            local leftLayout = Instance.new("UIListLayout")
            leftLayout.FillDirection = Enum.FillDirection.Horizontal
            leftLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            leftLayout.Padding = UDim.new(0, 12)
            leftLayout.Parent = leftSection

            -- Logo
            if self.Logo then
                local logo = Instance.new("ImageLabel")
                logo.Size = UDim2.new(0, 28, 0, 28)
                logo.BackgroundTransparency = 1
                logo.Image = self.Logo
                logo.LayoutOrder = 1
                logo.Parent = leftSection
            end

            -- Title
            if self.Title then
                local title = Instance.new("TextLabel")
                title.Size = UDim2.new(0, 0, 1, 0)
                title.AutomaticSize = Enum.AutomaticSize.X
                title.BackgroundTransparency = 1
                title.Font = Enum.Font.GothamBold
                title.Text = self.Title
                title.TextColor3 = Color3.fromRGB(250, 250, 250)
                title.TextSize = 16
                title.LayoutOrder = 2
                title.Parent = leftSection
                self._title = title
            end

            -- Left items
            for i, itemConfig in ipairs(self.LeftItems) do
                self:_createItem(itemConfig, leftSection, i + 10)
            end

            -- Center section
            local centerSection = Instance.new("Frame")
            centerSection.Name = "Center"
            centerSection.Size = UDim2.new(0, 0, 1, 0)
            centerSection.AutomaticSize = Enum.AutomaticSize.X
            centerSection.BackgroundTransparency = 1
            centerSection.LayoutOrder = 2
            centerSection.Parent = topBar
            self._centerSection = centerSection

            local centerLayout = Instance.new("UIListLayout")
            centerLayout.FillDirection = Enum.FillDirection.Horizontal
            centerLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            centerLayout.Padding = UDim.new(0, 8)
            centerLayout.Parent = centerSection

            for i, itemConfig in ipairs(self.CenterItems) do
                self:_createItem(itemConfig, centerSection, i)
            end

            -- Right section
            local rightSection = Instance.new("Frame")
            rightSection.Name = "Right"
            rightSection.Size = UDim2.new(0, 0, 1, 0)
            rightSection.AutomaticSize = Enum.AutomaticSize.X
            rightSection.BackgroundTransparency = 1
            rightSection.LayoutOrder = 3
            rightSection.Parent = topBar
            self._rightSection = rightSection

            local rightLayout = Instance.new("UIListLayout")
            rightLayout.FillDirection = Enum.FillDirection.Horizontal
            rightLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            rightLayout.Padding = UDim.new(0, 8)
            rightLayout.Parent = rightSection

            for i, itemConfig in ipairs(self.RightItems) do
                self:_createItem(itemConfig, rightSection, i)
            end

            return self
        end

        --// Create item
        function TopBar:_createItem(config, parent, order)
            if config.Type == "Button" then
                local btn = Instance.new("TextButton")
                btn.Size = UDim2.new(0, 0, 0, 32)
                btn.AutomaticSize = Enum.AutomaticSize.X
                btn.BackgroundColor3 = config.Primary and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(63, 63, 70)
                btn.BackgroundTransparency = config.Primary and 0 or 1
                btn.BorderSizePixel = 0
                btn.Font = Enum.Font.GothamMedium
                btn.Text = config.Text or ""
                btn.TextColor3 = Color3.fromRGB(250, 250, 250)
                btn.TextSize = 13
                btn.AutoButtonColor = false
                btn.LayoutOrder = order
                btn.Parent = parent

                local corner = Instance.new("UICorner")
                corner.CornerRadius = UDim.new(0, 6)
                corner.Parent = btn

                local padding = Instance.new("UIPadding")
                padding.PaddingLeft = UDim.new(0, 12)
                padding.PaddingRight = UDim.new(0, 12)
                padding.Parent = btn

                if config.OnClick then
                    self:_connect(btn.MouseButton1Click, config.OnClick)
                end

                self:_connect(btn.MouseEnter, function()
                    TweenService:Create(btn, TweenInfo.new(0.1), {
                        BackgroundTransparency = 0,
                    }):Play()
                end)

                self:_connect(btn.MouseLeave, function()
                    TweenService:Create(btn, TweenInfo.new(0.1), {
                        BackgroundTransparency = config.Primary and 0 or 1,
                    }):Play()
                end)

                return btn

            elseif config.Type == "IconButton" then
                local btn = Instance.new("ImageButton")
                btn.Size = UDim2.new(0, 32, 0, 32)
                btn.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
                btn.BackgroundTransparency = 1
                btn.BorderSizePixel = 0
                btn.Image = config.Icon
                btn.ImageColor3 = Color3.fromRGB(161, 161, 170)
                btn.AutoButtonColor = false
                btn.LayoutOrder = order
                btn.Parent = parent

                local corner = Instance.new("UICorner")
                corner.CornerRadius = UDim.new(0, 6)
                corner.Parent = btn

                if config.OnClick then
                    self:_connect(btn.MouseButton1Click, config.OnClick)
                end

                self:_connect(btn.MouseEnter, function()
                    TweenService:Create(btn, TweenInfo.new(0.1), {
                        BackgroundTransparency = 0,
                        ImageColor3 = Color3.fromRGB(250, 250, 250),
                    }):Play()
                end)

                self:_connect(btn.MouseLeave, function()
                    TweenService:Create(btn, TweenInfo.new(0.1), {
                        BackgroundTransparency = 1,
                        ImageColor3 = Color3.fromRGB(161, 161, 170),
                    }):Play()
                end)

                return btn

            elseif config.Type == "Divider" then
                local divider = Instance.new("Frame")
                divider.Size = UDim2.new(0, 1, 0.6, 0)
                divider.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
                divider.BorderSizePixel = 0
                divider.LayoutOrder = order
                divider.Parent = parent

                return divider

            elseif config.Type == "Custom" and config.Create then
                local element = config.Create()
                if element then
                    element.LayoutOrder = order
                    element.Parent = parent
                end
                return element
            end
        end

        --// Set title
        function TopBar:SetTitle(title)
            self.Title = title
            if self._title then
                self._title.Text = title
            end
            return self
        end

        --// Get section
        function TopBar:GetLeftSection()
            return self._leftSection
        end

        function TopBar:GetCenterSection()
            return self._centerSection
        end

        function TopBar:GetRightSection()
            return self._rightSection
        end

        return TopBar


    end


    -- ============================================================================
    -- Module: NexusUI/Components/ScrollView
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/ScrollView"] = function()
        local script = CreateMockScript("NexusUI/Components/ScrollView")

        --[[
            NexusUI ScrollView Component
            Scrollable content container
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// ScrollView Component Module
        local ScrollView = setmetatable({}, { __index = Base })
        ScrollView.__index = ScrollView
        ScrollView.ClassName = "ScrollView"

        --// Scroll Direction
        ScrollView.Direction = {
            Vertical = "Vertical",
            Horizontal = "Horizontal",
            Both = "Both",
        }

        --// Constructor
        function ScrollView.new(config)
            local self = setmetatable(Base.new(config), ScrollView)

            config = config or {}

            self.ScrollDirection = config.Direction or ScrollView.Direction.Vertical
            self.ShowScrollBar = config.ShowScrollBar ~= false
            self.ScrollBarWidth = config.ScrollBarWidth or 6
            self.ScrollBarColor = config.ScrollBarColor or Color3.fromRGB(82, 82, 91)
            self.Padding = config.Padding or 0
            self.AutoLayout = config.AutoLayout or false
            self.LayoutPadding = config.LayoutPadding or 8

            -- Callbacks
            self.OnScroll = config.OnScroll

            return self
        end

        --// Create scroll view
        function ScrollView:Create(parent)
            -- Container
            local container = Instance.new("ScrollingFrame")
            container.Name = self.Name
            container.Size = UDim2.new(1, 0, 1, 0)
            container.BackgroundTransparency = 1
            container.BorderSizePixel = 0
            container.ScrollBarThickness = self.ShowScrollBar and self.ScrollBarWidth or 0
            container.ScrollBarImageColor3 = self.ScrollBarColor
            container.CanvasSize = UDim2.new(0, 0, 0, 0)
            container.AutomaticCanvasSize = self:_getAutoCanvasSize()
            container.ScrollingDirection = self:_getScrollingDirection()

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Padding
            if self.Padding > 0 then
                local padding = Instance.new("UIPadding")
                padding.PaddingTop = UDim.new(0, self.Padding)
                padding.PaddingBottom = UDim.new(0, self.Padding)
                padding.PaddingLeft = UDim.new(0, self.Padding)
                padding.PaddingRight = UDim.new(0, self.Padding)
                padding.Parent = container
            end

            -- Auto layout
            if self.AutoLayout then
                local layout = Instance.new("UIListLayout")
                layout.SortOrder = Enum.SortOrder.LayoutOrder
                layout.Padding = UDim.new(0, self.LayoutPadding)

                if self.ScrollDirection == ScrollView.Direction.Horizontal then
                    layout.FillDirection = Enum.FillDirection.Horizontal
                    layout.VerticalAlignment = Enum.VerticalAlignment.Center
                else
                    layout.FillDirection = Enum.FillDirection.Vertical
                end

                layout.Parent = container
                self._layout = layout
            end

            -- Scroll callback
            if self.OnScroll then
                self:_connect(container:GetPropertyChangedSignal("CanvasPosition"), function()
                    self.OnScroll(container.CanvasPosition)
                end)
            end

            return self
        end

        --// Get auto canvas size
        function ScrollView:_getAutoCanvasSize()
            if self.ScrollDirection == ScrollView.Direction.Vertical then
                return Enum.AutomaticSize.Y
            elseif self.ScrollDirection == ScrollView.Direction.Horizontal then
                return Enum.AutomaticSize.X
            else
                return Enum.AutomaticSize.XY
            end
        end

        --// Get scrolling direction
        function ScrollView:_getScrollingDirection()
            if self.ScrollDirection == ScrollView.Direction.Vertical then
                return Enum.ScrollingDirection.Y
            elseif self.ScrollDirection == ScrollView.Direction.Horizontal then
                return Enum.ScrollingDirection.X
            else
                return Enum.ScrollingDirection.XY
            end
        end

        --// Scroll to position
        function ScrollView:ScrollTo(position, animate)
            if animate ~= false then
                TweenService:Create(self.Instance, TweenInfo.new(0.3), {
                    CanvasPosition = position,
                }):Play()
            else
                self.Instance.CanvasPosition = position
            end
            return self
        end

        --// Scroll to top
        function ScrollView:ScrollToTop(animate)
            return self:ScrollTo(Vector2.new(self.Instance.CanvasPosition.X, 0), animate)
        end

        --// Scroll to bottom
        function ScrollView:ScrollToBottom(animate)
            local maxY = self.Instance.AbsoluteCanvasSize.Y - self.Instance.AbsoluteSize.Y
            return self:ScrollTo(Vector2.new(self.Instance.CanvasPosition.X, maxY), animate)
        end

        --// Scroll to element
        function ScrollView:ScrollToElement(element, animate)
            if not element or not element:IsDescendantOf(self.Instance) then return self end

            local elementPos = element.AbsolutePosition
            local containerPos = self.Instance.AbsolutePosition
            local relativePos = elementPos - containerPos + self.Instance.CanvasPosition

            return self:ScrollTo(relativePos, animate)
        end

        --// Get scroll position
        function ScrollView:GetScrollPosition()
            return self.Instance.CanvasPosition
        end

        --// Get scroll percentage
        function ScrollView:GetScrollPercentage()
            local canvasSize = self.Instance.AbsoluteCanvasSize
            local viewSize = self.Instance.AbsoluteSize
            local position = self.Instance.CanvasPosition

            local percentX = canvasSize.X > viewSize.X and position.X / (canvasSize.X - viewSize.X) or 0
            local percentY = canvasSize.Y > viewSize.Y and position.Y / (canvasSize.Y - viewSize.Y) or 0

            return Vector2.new(percentX, percentY)
        end

        --// Set canvas size
        function ScrollView:SetCanvasSize(size)
            self.Instance.CanvasSize = size
            return self
        end

        return ScrollView


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Section
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Section"] = function()
        local script = CreateMockScript("NexusUI/Components/Section")

        --[[
            NexusUI Section Component
            Collapsible content section
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Section Component Module
        local Section = setmetatable({}, { __index = Base })
        Section.__index = Section
        Section.ClassName = "Section"

        --// Constructor
        function Section.new(config)
            local self = setmetatable(Base.new(config), Section)

            config = config or {}

            self.Title = config.Title or "Section"
            self.Collapsible = config.Collapsible ~= false
            self.DefaultExpanded = config.DefaultExpanded ~= false
            self.Padding = config.Padding or 12
            self.ShowBorder = config.ShowBorder or false

            -- Callbacks
            self.OnExpand = config.OnExpand
            self.OnCollapse = config.OnCollapse

            -- State
            self._isExpanded = self.DefaultExpanded

            return self
        end

        --// Create section
        function Section:Create(parent)
            -- Container
            local section = Instance.new("Frame")
            section.Name = self.Name
            section.Size = UDim2.new(1, 0, 0, 0)
            section.AutomaticSize = Enum.AutomaticSize.Y
            section.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            section.BorderSizePixel = 0

            if parent then
                section.Parent = parent
            end

            self.Instance = section

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = section

            if self.ShowBorder then
                local stroke = Instance.new("UIStroke")
                stroke.Color = Color3.fromRGB(63, 63, 70)
                stroke.Thickness = 1
                stroke.Parent = section
            end

            -- Header
            local header
            if self.Collapsible then
                header = Instance.new("TextButton")
                header.Text = ""
                header.AutoButtonColor = false
            else
                header = Instance.new("Frame")
            end

            header.Name = "Header"
            header.Size = UDim2.new(1, 0, 0, 40)
            header.BackgroundTransparency = 1
            header.Parent = section
            self._header = header

            local headerPadding = Instance.new("UIPadding")
            headerPadding.PaddingLeft = UDim.new(0, self.Padding)
            headerPadding.PaddingRight = UDim.new(0, self.Padding)
            headerPadding.Parent = header

            local headerLayout = Instance.new("UIListLayout")
            headerLayout.FillDirection = Enum.FillDirection.Horizontal
            headerLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            headerLayout.HorizontalAlignment = Enum.HorizontalAlignment.SpaceBetween
            headerLayout.Parent = header

            -- Title
            local title = Instance.new("TextLabel")
            title.Name = "Title"
            title.Size = UDim2.new(1, -30, 1, 0)
            title.BackgroundTransparency = 1
            title.Font = Enum.Font.GothamMedium
            title.Text = self.Title
            title.TextColor3 = Color3.fromRGB(250, 250, 250)
            title.TextSize = 14
            title.TextXAlignment = Enum.TextXAlignment.Left
            title.LayoutOrder = 1
            title.Parent = header
            self._title = title

            -- Arrow (if collapsible)
            if self.Collapsible then
                local arrow = Instance.new("ImageLabel")
                arrow.Name = "Arrow"
                arrow.Size = UDim2.new(0, 16, 0, 16)
                arrow.BackgroundTransparency = 1
                arrow.Image = "rbxassetid://7072706223"
                arrow.ImageColor3 = Color3.fromRGB(161, 161, 170)
                arrow.Rotation = self._isExpanded and 180 or 0
                arrow.LayoutOrder = 2
                arrow.Parent = header
                self._arrow = arrow

                self:_connect(header.MouseButton1Click, function()
                    self:Toggle()
                end)

                self:_connect(header.MouseEnter, function()
                    TweenService:Create(arrow, TweenInfo.new(0.15), {
                        ImageColor3 = Color3.fromRGB(250, 250, 250),
                    }):Play()
                end)

                self:_connect(header.MouseLeave, function()
                    TweenService:Create(arrow, TweenInfo.new(0.15), {
                        ImageColor3 = Color3.fromRGB(161, 161, 170),
                    }):Play()
                end)
            end

            -- Content
            local content = Instance.new("Frame")
            content.Name = "Content"
            content.Size = UDim2.new(1, 0, 0, 0)
            content.AutomaticSize = self._isExpanded and Enum.AutomaticSize.Y or Enum.AutomaticSize.None
            content.Position = UDim2.new(0, 0, 0, 40)
            content.BackgroundTransparency = 1
            content.ClipsDescendants = true
            content.Parent = section
            self._content = content

            local contentPadding = Instance.new("UIPadding")
            contentPadding.PaddingLeft = UDim.new(0, self.Padding)
            contentPadding.PaddingRight = UDim.new(0, self.Padding)
            contentPadding.PaddingBottom = self._isExpanded and UDim.new(0, self.Padding) or UDim.new(0, 0)
            contentPadding.Parent = content
            self._contentPadding = contentPadding

            return self
        end

        --// Expand
        function Section:Expand(animate)
            if self._isExpanded then return self end

            self._isExpanded = true
            animate = animate ~= false

            if animate then
                TweenService:Create(self._arrow, TweenInfo.new(0.2), {
                    Rotation = 180,
                }):Play()
            else
                self._arrow.Rotation = 180
            end

            self._contentPadding.PaddingBottom = UDim.new(0, self.Padding)
            self._content.AutomaticSize = Enum.AutomaticSize.Y

            if self.OnExpand then
                self.OnExpand()
            end

            self:_fire("Expand")

            return self
        end

        --// Collapse
        function Section:Collapse(animate)
            if not self._isExpanded then return self end

            self._isExpanded = false
            animate = animate ~= false

            if animate then
                TweenService:Create(self._arrow, TweenInfo.new(0.2), {
                    Rotation = 0,
                }):Play()
            else
                self._arrow.Rotation = 0
            end

            self._contentPadding.PaddingBottom = UDim.new(0, 0)
            self._content.AutomaticSize = Enum.AutomaticSize.None
            self._content.Size = UDim2.new(1, 0, 0, 0)

            if self.OnCollapse then
                self.OnCollapse()
            end

            self:_fire("Collapse")

            return self
        end

        --// Toggle
        function Section:Toggle()
            if self._isExpanded then
                self:Collapse()
            else
                self:Expand()
            end
            return self
        end

        --// Is expanded
        function Section:IsExpanded()
            return self._isExpanded
        end

        --// Set title
        function Section:SetTitle(title)
            self.Title = title
            if self._title then
                self._title.Text = title
            end
            return self
        end

        --// Get content
        function Section:GetContent()
            return self._content
        end

        return Section


    end


    -- ============================================================================
    -- Module: NexusUI/Components/List
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/List"] = function()
        local script = CreateMockScript("NexusUI/Components/List")

        --[[
            NexusUI List Component
            Scrollable list with items
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// List Component Module
        local List = setmetatable({}, { __index = Base })
        List.__index = List
        List.ClassName = "List"

        --// Constructor
        function List.new(config)
            local self = setmetatable(Base.new(config), List)

            config = config or {}

            self.Items = config.Items or {}
            self.Selectable = config.Selectable or false
            self.MultiSelect = config.MultiSelect or false
            self.ItemHeight = config.ItemHeight or 40
            self.Dividers = config.Dividers or false
            self.HoverEffect = config.HoverEffect ~= false

            -- Callbacks
            self.OnItemClick = config.OnItemClick
            self.OnSelectionChange = config.OnSelectionChange
            self.RenderItem = config.RenderItem -- Custom render function

            -- State
            self._selectedItems = {}
            self._itemElements = {}

            return self
        end

        --// Create list
        function List:Create(parent)
            -- Container
            local container = Instance.new("ScrollingFrame")
            container.Name = self.Name
            container.Size = UDim2.new(1, 0, 0, 300)
            container.BackgroundColor3 = Color3.fromRGB(24, 24, 27)
            container.BorderSizePixel = 0
            container.ScrollBarThickness = 4
            container.ScrollBarImageColor3 = Color3.fromRGB(82, 82, 91)
            container.CanvasSize = UDim2.new(0, 0, 0, 0)
            container.AutomaticCanvasSize = Enum.AutomaticSize.Y

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = container

            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, 4)
            padding.PaddingBottom = UDim.new(0, 4)
            padding.PaddingLeft = UDim.new(0, 4)
            padding.PaddingRight = UDim.new(0, 4)
            padding.Parent = container

            local layout = Instance.new("UIListLayout")
            layout.SortOrder = Enum.SortOrder.LayoutOrder
            layout.Padding = UDim.new(0, self.Dividers and 1 or 2)
            layout.Parent = container

            -- Build items
            self:_buildItems()

            return self
        end

        --// Build items
        function List:_buildItems()
            -- Clear existing
            for _, element in pairs(self._itemElements) do
                element:Destroy()
            end
            self._itemElements = {}

            for i, item in ipairs(self.Items) do
                local itemData = type(item) == "table" and item or { Text = item }
                local isSelected = table.find(self._selectedItems, i) ~= nil

                local itemFrame = Instance.new("TextButton")
                itemFrame.Name = "Item" .. i
                itemFrame.Size = UDim2.new(1, 0, 0, self.ItemHeight)
                itemFrame.BackgroundColor3 = isSelected and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(30, 30, 35)
                itemFrame.BackgroundTransparency = isSelected and 0.8 or (self.HoverEffect and 1 or 0)
                itemFrame.BorderSizePixel = 0
                itemFrame.Text = ""
                itemFrame.AutoButtonColor = false
                itemFrame.LayoutOrder = i
                itemFrame.Parent = self.Instance

                local itemCorner = Instance.new("UICorner")
                itemCorner.CornerRadius = UDim.new(0, 6)
                itemCorner.Parent = itemFrame

                local itemPadding = Instance.new("UIPadding")
                itemPadding.PaddingLeft = UDim.new(0, 12)
                itemPadding.PaddingRight = UDim.new(0, 12)
                itemPadding.Parent = itemFrame

                if self.RenderItem then
                    -- Custom render
                    self.RenderItem(itemFrame, itemData, i, isSelected)
                else
                    -- Default render
                    local itemLayout = Instance.new("UIListLayout")
                    itemLayout.FillDirection = Enum.FillDirection.Horizontal
                    itemLayout.VerticalAlignment = Enum.VerticalAlignment.Center
                    itemLayout.Padding = UDim.new(0, 10)
                    itemLayout.Parent = itemFrame

                    -- Icon
                    if itemData.Icon then
                        local icon = Instance.new("ImageLabel")
                        icon.Size = UDim2.new(0, 18, 0, 18)
                        icon.BackgroundTransparency = 1
                        icon.Image = itemData.Icon
                        icon.ImageColor3 = Color3.fromRGB(161, 161, 170)
                        icon.LayoutOrder = 1
                        icon.Parent = itemFrame
                    end

                    -- Text container
                    local textContainer = Instance.new("Frame")
                    textContainer.Size = UDim2.new(1, itemData.Icon and -28 or 0, 1, 0)
                    textContainer.BackgroundTransparency = 1
                    textContainer.LayoutOrder = 2
                    textContainer.Parent = itemFrame

                    local textLayout = Instance.new("UIListLayout")
                    textLayout.FillDirection = Enum.FillDirection.Vertical
                    textLayout.VerticalAlignment = Enum.VerticalAlignment.Center
                    textLayout.Padding = UDim.new(0, 2)
                    textLayout.Parent = textContainer

                    -- Primary text
                    local text = Instance.new("TextLabel")
                    text.Size = UDim2.new(1, 0, 0, 0)
                    text.AutomaticSize = Enum.AutomaticSize.Y
                    text.BackgroundTransparency = 1
                    text.Font = Enum.Font.Gotham
                    text.Text = itemData.Text or ""
                    text.TextColor3 = Color3.fromRGB(250, 250, 250)
                    text.TextSize = 13
                    text.TextXAlignment = Enum.TextXAlignment.Left
                    text.TextTruncate = Enum.TextTruncate.AtEnd
                    text.LayoutOrder = 1
                    text.Parent = textContainer

                    -- Secondary text
                    if itemData.SecondaryText then
                        local secondaryText = Instance.new("TextLabel")
                        secondaryText.Size = UDim2.new(1, 0, 0, 0)
                        secondaryText.AutomaticSize = Enum.AutomaticSize.Y
                        secondaryText.BackgroundTransparency = 1
                        secondaryText.Font = Enum.Font.Gotham
                        secondaryText.Text = itemData.SecondaryText
                        secondaryText.TextColor3 = Color3.fromRGB(113, 113, 122)
                        secondaryText.TextSize = 11
                        secondaryText.TextXAlignment = Enum.TextXAlignment.Left
                        secondaryText.LayoutOrder = 2
                        secondaryText.Parent = textContainer
                    end

                    -- Trailing content
                    if itemData.Trailing then
                        local trailing = Instance.new("TextLabel")
                        trailing.Size = UDim2.new(0, 0, 0, 0)
                        trailing.AutomaticSize = Enum.AutomaticSize.XY
                        trailing.Position = UDim2.new(1, -12, 0.5, 0)
                        trailing.AnchorPoint = Vector2.new(1, 0.5)
                        trailing.BackgroundTransparency = 1
                        trailing.Font = Enum.Font.Gotham
                        trailing.Text = itemData.Trailing
                        trailing.TextColor3 = Color3.fromRGB(113, 113, 122)
                        trailing.TextSize = 12
                        trailing.Parent = itemFrame
                    end
                end

                -- Interactions
                self:_connect(itemFrame.MouseButton1Click, function()
                    if self.Selectable then
                        self:_toggleSelection(i)
                    end

                    if self.OnItemClick then
                        self.OnItemClick(i, itemData)
                    end

                    self:_fire("ItemClick", i, itemData)
                end)

                if self.HoverEffect then
                    self:_connect(itemFrame.MouseEnter, function()
                        if not isSelected then
                            TweenService:Create(itemFrame, TweenInfo.new(0.1), {
                                BackgroundTransparency = 0.8,
                            }):Play()
                        end
                    end)

                    self:_connect(itemFrame.MouseLeave, function()
                        if not isSelected then
                            TweenService:Create(itemFrame, TweenInfo.new(0.1), {
                                BackgroundTransparency = 1,
                            }):Play()
                        end
                    end)
                end

                self._itemElements[i] = itemFrame

                -- Divider
                if self.Dividers and i < #self.Items then
                    local divider = Instance.new("Frame")
                    divider.Name = "Divider" .. i
                    divider.Size = UDim2.new(1, -24, 0, 1)
                    divider.Position = UDim2.new(0.5, 0, 0, 0)
                    divider.AnchorPoint = Vector2.new(0.5, 0)
                    divider.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
                    divider.BorderSizePixel = 0
                    divider.LayoutOrder = i * 2
                    divider.Parent = self.Instance
                end
            end
        end

        --// Toggle selection
        function List:_toggleSelection(index)
            local existingPos = table.find(self._selectedItems, index)

            if existingPos then
                table.remove(self._selectedItems, existingPos)
            else
                if self.MultiSelect then
                    table.insert(self._selectedItems, index)
                else
                    self._selectedItems = { index }
                end
            end

            self:_buildItems()

            if self.OnSelectionChange then
                self.OnSelectionChange(self._selectedItems)
            end

            self:_fire("SelectionChange", self._selectedItems)
        end

        --// Set items
        function List:SetItems(items)
            self.Items = items
            self._selectedItems = {}
            self:_buildItems()
            return self
        end

        --// Add item
        function List:AddItem(item)
            table.insert(self.Items, item)
            self:_buildItems()
            return self
        end

        --// Remove item
        function List:RemoveItem(index)
            table.remove(self.Items, index)

            for i, selectedIndex in ipairs(self._selectedItems) do
                if selectedIndex == index then
                    table.remove(self._selectedItems, i)
                elseif selectedIndex > index then
                    self._selectedItems[i] = selectedIndex - 1
                end
            end

            self:_buildItems()
            return self
        end

        --// Get selected items
        function List:GetSelectedItems()
            local items = {}
            for _, index in ipairs(self._selectedItems) do
                table.insert(items, self.Items[index])
            end
            return items
        end

        --// Clear selection
        function List:ClearSelection()
            self._selectedItems = {}
            self:_buildItems()
            return self
        end

        return List


    end


    -- ============================================================================
    -- Module: NexusUI/Components/VirtualList
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/VirtualList"] = function()
        local script = CreateMockScript("NexusUI/Components/VirtualList")

        --[[
            NexusUI VirtualList Component
            Virtualized list for large datasets
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")
        local RunService = game:GetService("RunService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// VirtualList Component Module
        local VirtualList = setmetatable({}, { __index = Base })
        VirtualList.__index = VirtualList
        VirtualList.ClassName = "VirtualList"

        --// Constructor
        function VirtualList.new(config)
            local self = setmetatable(Base.new(config), VirtualList)

            config = config or {}

            self.ItemCount = config.ItemCount or 0
            self.ItemHeight = config.ItemHeight or 40
            self.OverscanCount = config.OverscanCount or 3
            self.RenderItem = config.RenderItem -- Required: function(frame, index) -> void

            -- Callbacks
            self.OnScroll = config.OnScroll
            self.OnItemClick = config.OnItemClick

            -- State
            self._visibleItems = {}
            self._scrollPos = 0
            self._containerHeight = 0

            return self
        end

        --// Create virtual list
        function VirtualList:Create(parent)
            -- Container
            local container = Instance.new("ScrollingFrame")
            container.Name = self.Name
            container.Size = UDim2.new(1, 0, 1, 0)
            container.BackgroundColor3 = Color3.fromRGB(24, 24, 27)
            container.BorderSizePixel = 0
            container.ScrollBarThickness = 6
            container.ScrollBarImageColor3 = Color3.fromRGB(82, 82, 91)
            container.CanvasSize = UDim2.new(0, 0, 0, self.ItemCount * self.ItemHeight)
            container.ScrollingDirection = Enum.ScrollingDirection.Y

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = container

            -- Inner container for items
            local inner = Instance.new("Frame")
            inner.Name = "Inner"
            inner.Size = UDim2.new(1, -12, 1, 0)
            inner.Position = UDim2.new(0, 0, 0, 0)
            inner.BackgroundTransparency = 1
            inner.Parent = container
            self._inner = inner

            -- Track scroll position
            self:_connect(container:GetPropertyChangedSignal("CanvasPosition"), function()
                self._scrollPos = container.CanvasPosition.Y
                self:_updateVisibleItems()

                if self.OnScroll then
                    self.OnScroll(self._scrollPos)
                end
            end)

            -- Track size changes
            self:_connect(container:GetPropertyChangedSignal("AbsoluteSize"), function()
                self._containerHeight = container.AbsoluteSize.Y
                self:_updateVisibleItems()
            end)

            -- Initial render
            task.defer(function()
                self._containerHeight = container.AbsoluteSize.Y
                self:_updateVisibleItems()
            end)

            return self
        end

        --// Update visible items
        function VirtualList:_updateVisibleItems()
            if not self.RenderItem then return end

            -- Calculate visible range
            local startIndex = math.floor(self._scrollPos / self.ItemHeight) - self.OverscanCount
            startIndex = math.max(1, startIndex)

            local visibleCount = math.ceil(self._containerHeight / self.ItemHeight) + self.OverscanCount * 2
            local endIndex = math.min(self.ItemCount, startIndex + visibleCount)

            -- Track which indices need items
            local neededIndices = {}
            for i = startIndex, endIndex do
                neededIndices[i] = true
            end

            -- Remove items that are no longer visible
            for index, itemFrame in pairs(self._visibleItems) do
                if not neededIndices[index] then
                    itemFrame:Destroy()
                    self._visibleItems[index] = nil
                end
            end

            -- Add new items
            for index, _ in pairs(neededIndices) do
                if not self._visibleItems[index] then
                    self:_createItem(index)
                end
            end
        end

        --// Create item
        function VirtualList:_createItem(index)
            local itemFrame = Instance.new("TextButton")
            itemFrame.Name = "Item" .. index
            itemFrame.Size = UDim2.new(1, 0, 0, self.ItemHeight)
            itemFrame.Position = UDim2.new(0, 0, 0, (index - 1) * self.ItemHeight)
            itemFrame.BackgroundTransparency = 1
            itemFrame.BorderSizePixel = 0
            itemFrame.Text = ""
            itemFrame.AutoButtonColor = false
            itemFrame.Parent = self._inner

            -- Call render function
            self.RenderItem(itemFrame, index)

            -- Click handler
            self:_connect(itemFrame.MouseButton1Click, function()
                if self.OnItemClick then
                    self.OnItemClick(index)
                end

                self:_fire("ItemClick", index)
            end)

            self._visibleItems[index] = itemFrame
        end

        --// Set item count
        function VirtualList:SetItemCount(count)
            self.ItemCount = count
            self.Instance.CanvasSize = UDim2.new(0, 0, 0, count * self.ItemHeight)

            -- Clear and re-render
            for _, itemFrame in pairs(self._visibleItems) do
                itemFrame:Destroy()
            end
            self._visibleItems = {}

            self:_updateVisibleItems()
            return self
        end

        --// Scroll to index
        function VirtualList:ScrollToIndex(index, animate)
            local targetPos = (index - 1) * self.ItemHeight

            if animate ~= false then
                TweenService:Create(self.Instance, TweenInfo.new(0.3), {
                    CanvasPosition = Vector2.new(0, targetPos),
                }):Play()
            else
                self.Instance.CanvasPosition = Vector2.new(0, targetPos)
            end

            return self
        end

        --// Scroll to top
        function VirtualList:ScrollToTop(animate)
            return self:ScrollToIndex(1, animate)
        end

        --// Scroll to bottom
        function VirtualList:ScrollToBottom(animate)
            return self:ScrollToIndex(self.ItemCount, animate)
        end

        --// Refresh all items
        function VirtualList:Refresh()
            for index, itemFrame in pairs(self._visibleItems) do
                -- Clear children
                for _, child in ipairs(itemFrame:GetChildren()) do
                    child:Destroy()
                end

                -- Re-render
                self.RenderItem(itemFrame, index)
            end

            return self
        end

        --// Refresh specific item
        function VirtualList:RefreshItem(index)
            local itemFrame = self._visibleItems[index]
            if itemFrame then
                -- Clear children
                for _, child in ipairs(itemFrame:GetChildren()) do
                    child:Destroy()
                end

                -- Re-render
                self.RenderItem(itemFrame, index)
            end

            return self
        end

        --// Get visible range
        function VirtualList:GetVisibleRange()
            local startIndex = math.floor(self._scrollPos / self.ItemHeight) + 1
            local endIndex = math.ceil((self._scrollPos + self._containerHeight) / self.ItemHeight)
            return startIndex, math.min(endIndex, self.ItemCount)
        end

        return VirtualList


    end


    -- ============================================================================
    -- Module: NexusUI/Components/RangeSlider
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/RangeSlider"] = function()
        local script = CreateMockScript("NexusUI/Components/RangeSlider")

        --[[
            NexusUI RangeSlider Component
            Dual-handle range selection slider
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")
        local UserInputService = game:GetService("UserInputService")
        local RunService = game:GetService("RunService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// RangeSlider Component Module
        local RangeSlider = setmetatable({}, { __index = Base })
        RangeSlider.__index = RangeSlider
        RangeSlider.ClassName = "RangeSlider"

        --// Constructor
        function RangeSlider.new(config)
            local self = setmetatable(Base.new(config), RangeSlider)

            config = config or {}

            self.MinValue = config.MinValue or config.Min or 0
            self.MaxValue = config.MaxValue or config.Max or 100
            self.StartValue = config.StartValue or self.MinValue
            self.EndValue = config.EndValue or self.MaxValue
            self.Step = config.Step or 1
            self.Label = config.Label
            self.ShowValues = config.ShowValues ~= false
            self.ValueFormat = config.ValueFormat or "%.0f"
            self.TrackColor = config.TrackColor or Color3.fromRGB(63, 63, 70)
            self.FillColor = config.FillColor or Color3.fromRGB(99, 102, 241)
            self.KnobColor = config.KnobColor or Color3.fromRGB(255, 255, 255)

            -- Callbacks
            self.OnRangeChange = config.OnRangeChange
            self.OnDragStart = config.OnDragStart
            self.OnDragEnd = config.OnDragEnd

            -- State
            self._draggingKnob = nil -- "start" or "end"

            return self
        end

        --// Create range slider
        function RangeSlider:Create(parent)
            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(1, 0, 0, 50)
            container.BackgroundTransparency = 1

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Header
            if self.Label or self.ShowValues then
                local header = Instance.new("Frame")
                header.Name = "Header"
                header.Size = UDim2.new(1, 0, 0, 20)
                header.BackgroundTransparency = 1
                header.Parent = container

                if self.Label then
                    local label = Instance.new("TextLabel")
                    label.Size = UDim2.new(0.5, 0, 1, 0)
                    label.BackgroundTransparency = 1
                    label.Font = Enum.Font.Gotham
                    label.Text = self.Label
                    label.TextColor3 = Color3.fromRGB(250, 250, 250)
                    label.TextSize = 14
                    label.TextXAlignment = Enum.TextXAlignment.Left
                    label.Parent = header
                end

                if self.ShowValues then
                    local valuesLabel = Instance.new("TextLabel")
                    valuesLabel.Name = "Values"
                    valuesLabel.Size = UDim2.new(0.5, 0, 1, 0)
                    valuesLabel.Position = UDim2.new(0.5, 0, 0, 0)
                    valuesLabel.BackgroundTransparency = 1
                    valuesLabel.Font = Enum.Font.GothamMedium
                    valuesLabel.TextColor3 = Color3.fromRGB(161, 161, 170)
                    valuesLabel.TextSize = 14
                    valuesLabel.TextXAlignment = Enum.TextXAlignment.Right
                    valuesLabel.Parent = header
                    self._valuesLabel = valuesLabel

                    self:_updateValuesLabel()
                end
            end

            -- Track container
            local trackContainer = Instance.new("Frame")
            trackContainer.Name = "TrackContainer"
            trackContainer.Size = UDim2.new(1, 0, 0, 20)
            trackContainer.Position = UDim2.new(0, 0, 1, -20)
            trackContainer.BackgroundTransparency = 1
            trackContainer.Parent = container

            -- Track
            local track = Instance.new("Frame")
            track.Name = "Track"
            track.Size = UDim2.new(1, 0, 0, 6)
            track.Position = UDim2.new(0, 0, 0.5, 0)
            track.AnchorPoint = Vector2.new(0, 0.5)
            track.BackgroundColor3 = self.TrackColor
            track.BorderSizePixel = 0
            track.Parent = trackContainer
            self._track = track

            local trackCorner = Instance.new("UICorner")
            trackCorner.CornerRadius = UDim.new(1, 0)
            trackCorner.Parent = track

            -- Fill (range indicator)
            local fill = Instance.new("Frame")
            fill.Name = "Fill"
            fill.BackgroundColor3 = self.FillColor
            fill.BorderSizePixel = 0
            fill.Parent = track
            self._fill = fill

            local fillCorner = Instance.new("UICorner")
            fillCorner.CornerRadius = UDim.new(1, 0)
            fillCorner.Parent = fill

            -- Start knob
            local startKnob = self:_createKnob("StartKnob", trackContainer)
            self._startKnob = startKnob

            -- End knob
            local endKnob = self:_createKnob("EndKnob", trackContainer)
            self._endKnob = endKnob

            -- Click area
            local clickArea = Instance.new("TextButton")
            clickArea.Name = "ClickArea"
            clickArea.Size = UDim2.new(1, 0, 1, 0)
            clickArea.BackgroundTransparency = 1
            clickArea.Text = ""
            clickArea.ZIndex = 3
            clickArea.Parent = trackContainer
            self._clickArea = clickArea

            -- Setup interactions
            self:_setupInteractions()

            -- Initial update
            self:_updateVisuals()

            return self
        end

        --// Create knob
        function RangeSlider:_createKnob(name, parent)
            local knob = Instance.new("Frame")
            knob.Name = name
            knob.Size = UDim2.new(0, 18, 0, 18)
            knob.AnchorPoint = Vector2.new(0.5, 0.5)
            knob.BackgroundColor3 = self.KnobColor
            knob.BorderSizePixel = 0
            knob.ZIndex = 5
            knob.Parent = parent

            local knobCorner = Instance.new("UICorner")
            knobCorner.CornerRadius = UDim.new(1, 0)
            knobCorner.Parent = knob

            -- Shadow
            local shadow = Instance.new("ImageLabel")
            shadow.Size = UDim2.new(1, 12, 1, 12)
            shadow.Position = UDim2.new(0.5, 0, 0.5, 2)
            shadow.AnchorPoint = Vector2.new(0.5, 0.5)
            shadow.BackgroundTransparency = 1
            shadow.Image = "rbxassetid://6015897843"
            shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
            shadow.ImageTransparency = 0.6
            shadow.ScaleType = Enum.ScaleType.Slice
            shadow.SliceCenter = Rect.new(49, 49, 450, 450)
            shadow.ZIndex = 4
            shadow.Parent = knob

            return knob
        end

        --// Update values label
        function RangeSlider:_updateValuesLabel()
            if self._valuesLabel then
                local startText = string.format(self.ValueFormat, self.StartValue)
                local endText = string.format(self.ValueFormat, self.EndValue)
                self._valuesLabel.Text = startText .. " - " .. endText
            end
        end

        --// Update visuals
        function RangeSlider:_updateVisuals()
            local range = self.MaxValue - self.MinValue
            local startProgress = (self.StartValue - self.MinValue) / range
            local endProgress = (self.EndValue - self.MinValue) / range

            -- Update fill
            self._fill.Position = UDim2.new(startProgress, 0, 0, 0)
            self._fill.Size = UDim2.new(endProgress - startProgress, 0, 1, 0)

            -- Update knobs
            self._startKnob.Position = UDim2.new(startProgress, 0, 0.5, 0)
            self._endKnob.Position = UDim2.new(endProgress, 0, 0.5, 0)

            self:_updateValuesLabel()
        end

        --// Setup interactions
        function RangeSlider:_setupInteractions()
            local function getValueFromMouse()
                local mousePos = UserInputService:GetMouseLocation()
                local trackPos = self._track.AbsolutePosition
                local trackSize = self._track.AbsoluteSize

                local relativeX = mousePos.X - trackPos.X
                local progress = math.clamp(relativeX / trackSize.X, 0, 1)
                local rawValue = self.MinValue + (self.MaxValue - self.MinValue) * progress

                -- Apply step
                if self.Step > 0 then
                    rawValue = math.floor(rawValue / self.Step + 0.5) * self.Step
                end

                return math.clamp(rawValue, self.MinValue, self.MaxValue)
            end

            local function updateDrag()
                local value = getValueFromMouse()

                if self._draggingKnob == "start" then
                    self.StartValue = math.min(value, self.EndValue - self.Step)
                elseif self._draggingKnob == "end" then
                    self.EndValue = math.max(value, self.StartValue + self.Step)
                end

                self:_updateVisuals()
            end

            -- Click on track
            self:_connect(self._clickArea.MouseButton1Down, function()
                local value = getValueFromMouse()

                -- Determine which knob is closer
                local startDist = math.abs(value - self.StartValue)
                local endDist = math.abs(value - self.EndValue)

                if startDist < endDist then
                    self._draggingKnob = "start"
                    self.StartValue = math.min(value, self.EndValue - self.Step)
                else
                    self._draggingKnob = "end"
                    self.EndValue = math.max(value, self.StartValue + self.Step)
                end

                self:_updateVisuals()

                if self.OnDragStart then
                    self.OnDragStart()
                end
            end)

            -- Mouse move
            local moveConnection
            self:_connect(self._clickArea.MouseButton1Down, function()
                if moveConnection then
                    moveConnection:Disconnect()
                end

                moveConnection = RunService.Heartbeat:Connect(function()
                    if self._draggingKnob then
                        updateDrag()
                    end
                end)
            end)

            -- Mouse up
            self:_connect(UserInputService.InputEnded, function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 and self._draggingKnob then
                    self._draggingKnob = nil

                    if moveConnection then
                        moveConnection:Disconnect()
                        moveConnection = nil
                    end

                    if self.OnRangeChange then
                        self.OnRangeChange(self.StartValue, self.EndValue)
                    end

                    if self.OnDragEnd then
                        self.OnDragEnd()
                    end

                    self:_fire("RangeChange", self.StartValue, self.EndValue)
                end
            end)

            -- Knob hover effects
            for _, knob in ipairs({self._startKnob, self._endKnob}) do
                -- Create invisible button for interaction
                local btn = Instance.new("TextButton")
                btn.Size = UDim2.new(1, 6, 1, 6)
                btn.Position = UDim2.new(0.5, 0, 0.5, 0)
                btn.AnchorPoint = Vector2.new(0.5, 0.5)
                btn.BackgroundTransparency = 1
                btn.Text = ""
                btn.ZIndex = 6
                btn.Parent = knob

                self:_connect(btn.MouseEnter, function()
                    TweenService:Create(knob, TweenInfo.new(0.15), {
                        Size = UDim2.new(0, 22, 0, 22),
                    }):Play()
                end)

                self:_connect(btn.MouseLeave, function()
                    if not self._draggingKnob then
                        TweenService:Create(knob, TweenInfo.new(0.15), {
                            Size = UDim2.new(0, 18, 0, 18),
                        }):Play()
                    end
                end)
            end
        end

        --// Set range
        function RangeSlider:SetRange(startValue, endValue)
            self.StartValue = math.clamp(startValue, self.MinValue, self.MaxValue)
            self.EndValue = math.clamp(endValue, self.MinValue, self.MaxValue)

            if self.StartValue > self.EndValue then
                self.StartValue, self.EndValue = self.EndValue, self.StartValue
            end

            self:_updateVisuals()
            return self
        end

        --// Get range
        function RangeSlider:GetRange()
            return self.StartValue, self.EndValue
        end

        --// Set min/max
        function RangeSlider:SetBounds(min, max)
            self.MinValue = min
            self.MaxValue = max

            self.StartValue = math.clamp(self.StartValue, min, max)
            self.EndValue = math.clamp(self.EndValue, min, max)

            self:_updateVisuals()
            return self
        end

        return RangeSlider


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Switch
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Switch"] = function()
        local script = CreateMockScript("NexusUI/Components/Switch")

        --[[
            NexusUI Switch Component
            iOS-style switch with labels
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Switch Component Module
        local Switch = setmetatable({}, { __index = Base })
        Switch.__index = Switch
        Switch.ClassName = "Switch"

        --// Constructor
        function Switch.new(config)
            local self = setmetatable(Base.new(config), Switch)

            config = config or {}

            self.Value = config.Value or false
            self.Label = config.Label
            self.Description = config.Description
            self.OnLabel = config.OnLabel or "On"
            self.OffLabel = config.OffLabel or "Off"
            self.ShowLabels = config.ShowLabels or false
            self.ColorOn = config.ColorOn or Color3.fromRGB(34, 197, 94)
            self.ColorOff = config.ColorOff or Color3.fromRGB(63, 63, 70)

            -- Callbacks
            self.OnChange = config.OnChange

            return self
        end

        --// Create switch
        function Switch:Create(parent)
            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(1, 0, 0, self.Description and 50 or 36)
            container.BackgroundTransparency = 1

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Main layout
            local mainLayout = Instance.new("UIListLayout")
            mainLayout.FillDirection = Enum.FillDirection.Horizontal
            mainLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            mainLayout.HorizontalAlignment = Enum.HorizontalAlignment.SpaceBetween
            mainLayout.Parent = container

            -- Text container (label + description)
            local textContainer = Instance.new("Frame")
            textContainer.Name = "TextContainer"
            textContainer.Size = UDim2.new(1, -70, 1, 0)
            textContainer.BackgroundTransparency = 1
            textContainer.LayoutOrder = 1
            textContainer.Parent = container

            local textLayout = Instance.new("UIListLayout")
            textLayout.FillDirection = Enum.FillDirection.Vertical
            textLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            textLayout.Padding = UDim.new(0, 4)
            textLayout.Parent = textContainer

            -- Label
            if self.Label then
                local label = Instance.new("TextLabel")
                label.Name = "Label"
                label.Size = UDim2.new(1, 0, 0, 0)
                label.AutomaticSize = Enum.AutomaticSize.Y
                label.BackgroundTransparency = 1
                label.Font = Enum.Font.GothamMedium
                label.Text = self.Label
                label.TextColor3 = Color3.fromRGB(250, 250, 250)
                label.TextSize = 14
                label.TextXAlignment = Enum.TextXAlignment.Left
                label.TextWrapped = true
                label.LayoutOrder = 1
                label.Parent = textContainer
                self._label = label
            end

            -- Description
            if self.Description then
                local description = Instance.new("TextLabel")
                description.Name = "Description"
                description.Size = UDim2.new(1, 0, 0, 0)
                description.AutomaticSize = Enum.AutomaticSize.Y
                description.BackgroundTransparency = 1
                description.Font = Enum.Font.Gotham
                description.Text = self.Description
                description.TextColor3 = Color3.fromRGB(113, 113, 122)
                description.TextSize = 12
                description.TextXAlignment = Enum.TextXAlignment.Left
                description.TextWrapped = true
                description.LayoutOrder = 2
                description.Parent = textContainer
                self._description = description
            end

            -- Switch container
            local switchContainer = Instance.new("Frame")
            switchContainer.Name = "SwitchContainer"
            switchContainer.Size = UDim2.new(0, 0, 0, 26)
            switchContainer.AutomaticSize = Enum.AutomaticSize.X
            switchContainer.BackgroundTransparency = 1
            switchContainer.LayoutOrder = 2
            switchContainer.Parent = container

            local switchLayout = Instance.new("UIListLayout")
            switchLayout.FillDirection = Enum.FillDirection.Horizontal
            switchLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            switchLayout.Padding = UDim.new(0, 8)
            switchLayout.Parent = switchContainer

            -- Off label (if shown)
            if self.ShowLabels then
                local offLabel = Instance.new("TextLabel")
                offLabel.Name = "OffLabel"
                offLabel.Size = UDim2.new(0, 0, 0, 0)
                offLabel.AutomaticSize = Enum.AutomaticSize.XY
                offLabel.BackgroundTransparency = 1
                offLabel.Font = Enum.Font.Gotham
                offLabel.Text = self.OffLabel
                offLabel.TextColor3 = self.Value and Color3.fromRGB(113, 113, 122) or Color3.fromRGB(250, 250, 250)
                offLabel.TextSize = 12
                offLabel.LayoutOrder = 1
                offLabel.Parent = switchContainer
                self._offLabel = offLabel
            end

            -- Switch track
            local track = Instance.new("TextButton")
            track.Name = "Track"
            track.Size = UDim2.new(0, 48, 0, 26)
            track.BackgroundColor3 = self.Value and self.ColorOn or self.ColorOff
            track.BorderSizePixel = 0
            track.Text = ""
            track.AutoButtonColor = false
            track.LayoutOrder = 2
            track.Parent = switchContainer
            self._track = track

            local trackCorner = Instance.new("UICorner")
            trackCorner.CornerRadius = UDim.new(1, 0)
            trackCorner.Parent = track

            -- Knob
            local knob = Instance.new("Frame")
            knob.Name = "Knob"
            knob.Size = UDim2.new(0, 22, 0, 22)
            knob.Position = self.Value and UDim2.new(1, -24, 0.5, 0) or UDim2.new(0, 2, 0.5, 0)
            knob.AnchorPoint = Vector2.new(0, 0.5)
            knob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            knob.BorderSizePixel = 0
            knob.Parent = track
            self._knob = knob

            local knobCorner = Instance.new("UICorner")
            knobCorner.CornerRadius = UDim.new(1, 0)
            knobCorner.Parent = knob

            -- Knob shadow
            local shadow = Instance.new("ImageLabel")
            shadow.Name = "Shadow"
            shadow.Size = UDim2.new(1, 8, 1, 8)
            shadow.Position = UDim2.new(0.5, 0, 0.5, 2)
            shadow.AnchorPoint = Vector2.new(0.5, 0.5)
            shadow.BackgroundTransparency = 1
            shadow.Image = "rbxassetid://6015897843"
            shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
            shadow.ImageTransparency = 0.7
            shadow.ScaleType = Enum.ScaleType.Slice
            shadow.SliceCenter = Rect.new(49, 49, 450, 450)
            shadow.ZIndex = knob.ZIndex - 1
            shadow.Parent = knob

            -- On label (if shown)
            if self.ShowLabels then
                local onLabel = Instance.new("TextLabel")
                onLabel.Name = "OnLabel"
                onLabel.Size = UDim2.new(0, 0, 0, 0)
                onLabel.AutomaticSize = Enum.AutomaticSize.XY
                onLabel.BackgroundTransparency = 1
                onLabel.Font = Enum.Font.Gotham
                onLabel.Text = self.OnLabel
                onLabel.TextColor3 = self.Value and Color3.fromRGB(250, 250, 250) or Color3.fromRGB(113, 113, 122)
                onLabel.TextSize = 12
                onLabel.LayoutOrder = 3
                onLabel.Parent = switchContainer
                self._onLabel = onLabel
            end

            -- Setup interactions
            self:_setupInteractions()

            return self
        end

        --// Setup interactions
        function Switch:_setupInteractions()
            local track = self._track

            -- Click
            self:_connect(track.MouseButton1Click, function()
                if not self.IsEnabled then return end
                self:Toggle()
            end)

            -- Hover
            self:_connect(track.MouseEnter, function()
                if not self.IsEnabled then return end

                TweenService:Create(self._knob, TweenInfo.new(0.15), {
                    Size = UDim2.new(0, 24, 0, 24),
                }):Play()
            end)

            self:_connect(track.MouseLeave, function()
                TweenService:Create(self._knob, TweenInfo.new(0.15), {
                    Size = UDim2.new(0, 22, 0, 22),
                }):Play()
            end)
        end

        --// Toggle
        function Switch:Toggle()
            self:SetValue(not self.Value)
            return self
        end

        --// Set value
        function Switch:SetValue(value, animate)
            if self.Value == value then return self end

            local oldValue = self.Value
            self.Value = value
            animate = animate ~= false

            local duration = animate and 0.2 or 0

            -- Animate track
            TweenService:Create(self._track, TweenInfo.new(duration), {
                BackgroundColor3 = value and self.ColorOn or self.ColorOff,
            }):Play()

            -- Animate knob
            TweenService:Create(self._knob, TweenInfo.new(duration, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                Position = value and UDim2.new(1, -24, 0.5, 0) or UDim2.new(0, 2, 0.5, 0),
            }):Play()

            -- Update labels
            if self.ShowLabels then
                if self._onLabel then
                    TweenService:Create(self._onLabel, TweenInfo.new(duration), {
                        TextColor3 = value and Color3.fromRGB(250, 250, 250) or Color3.fromRGB(113, 113, 122),
                    }):Play()
                end

                if self._offLabel then
                    TweenService:Create(self._offLabel, TweenInfo.new(duration), {
                        TextColor3 = value and Color3.fromRGB(113, 113, 122) or Color3.fromRGB(250, 250, 250),
                    }):Play()
                end
            end

            -- Callback
            if self.OnChange then
                self.OnChange(value, oldValue)
            end

            self:_fire("Change", value, oldValue)

            return self
        end

        --// Get value
        function Switch:GetValue()
            return self.Value
        end

        return Switch


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Calendar
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Calendar"] = function()
        local script = CreateMockScript("NexusUI/Components/Calendar")

        --[[
            NexusUI Calendar Component
            Date selection calendar
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Calendar Component Module
        local Calendar = setmetatable({}, { __index = Base })
        Calendar.__index = Calendar
        Calendar.ClassName = "Calendar"

        --// Month names
        local MONTHS = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"}
        local DAYS = {"Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"}

        --// Constructor
        function Calendar.new(config)
            local self = setmetatable(Base.new(config), Calendar)

            config = config or {}

            local now = os.date("*t")
            self.SelectedDate = config.SelectedDate
            self.ViewMonth = config.ViewMonth or now.month
            self.ViewYear = config.ViewYear or now.year
            self.MinDate = config.MinDate
            self.MaxDate = config.MaxDate
            self.DisabledDates = config.DisabledDates or {}

            -- Callbacks
            self.OnDateSelect = config.OnDateSelect
            self.OnMonthChange = config.OnMonthChange

            -- State
            self._dayButtons = {}

            return self
        end

        --// Get days in month
        function Calendar:_getDaysInMonth(month, year)
            local days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}

            -- Leap year
            if month == 2 and ((year % 4 == 0 and year % 100 ~= 0) or year % 400 == 0) then
                return 29
            end

            return days[month]
        end

        --// Get first day of month (0 = Sunday)
        function Calendar:_getFirstDayOfMonth(month, year)
            local t = os.time({year = year, month = month, day = 1})
            return tonumber(os.date("%w", t))
        end

        --// Check if date is disabled
        function Calendar:_isDateDisabled(day, month, year)
            local timestamp = os.time({year = year, month = month, day = day})

            if self.MinDate and timestamp < self.MinDate then
                return true
            end

            if self.MaxDate and timestamp > self.MaxDate then
                return true
            end

            for _, disabled in ipairs(self.DisabledDates) do
                if disabled.day == day and disabled.month == month and disabled.year == year then
                    return true
                end
            end

            return false
        end

        --// Create calendar
        function Calendar:Create(parent)
            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(0, 280, 0, 320)
            container.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            container.BorderSizePixel = 0

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 10)
            corner.Parent = container

            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(63, 63, 70)
            stroke.Thickness = 1
            stroke.Parent = container

            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, 12)
            padding.PaddingBottom = UDim.new(0, 12)
            padding.PaddingLeft = UDim.new(0, 12)
            padding.PaddingRight = UDim.new(0, 12)
            padding.Parent = container

            -- Header
            local header = Instance.new("Frame")
            header.Name = "Header"
            header.Size = UDim2.new(1, 0, 0, 36)
            header.BackgroundTransparency = 1
            header.Parent = container

            -- Previous button
            local prevBtn = Instance.new("TextButton")
            prevBtn.Name = "PrevBtn"
            prevBtn.Size = UDim2.new(0, 32, 0, 32)
            prevBtn.Position = UDim2.new(0, 0, 0.5, 0)
            prevBtn.AnchorPoint = Vector2.new(0, 0.5)
            prevBtn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
            prevBtn.BackgroundTransparency = 1
            prevBtn.BorderSizePixel = 0
            prevBtn.Font = Enum.Font.GothamBold
            prevBtn.Text = "‹"
            prevBtn.TextColor3 = Color3.fromRGB(250, 250, 250)
            prevBtn.TextSize = 20
            prevBtn.AutoButtonColor = false
            prevBtn.Parent = header

            local prevCorner = Instance.new("UICorner")
            prevCorner.CornerRadius = UDim.new(0, 6)
            prevCorner.Parent = prevBtn

            self:_connect(prevBtn.MouseButton1Click, function()
                self:PrevMonth()
            end)

            self:_connect(prevBtn.MouseEnter, function()
                TweenService:Create(prevBtn, TweenInfo.new(0.1), {
                    BackgroundTransparency = 0,
                }):Play()
            end)

            self:_connect(prevBtn.MouseLeave, function()
                TweenService:Create(prevBtn, TweenInfo.new(0.1), {
                    BackgroundTransparency = 1,
                }):Play()
            end)

            -- Next button
            local nextBtn = Instance.new("TextButton")
            nextBtn.Name = "NextBtn"
            nextBtn.Size = UDim2.new(0, 32, 0, 32)
            nextBtn.Position = UDim2.new(1, 0, 0.5, 0)
            nextBtn.AnchorPoint = Vector2.new(1, 0.5)
            nextBtn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
            nextBtn.BackgroundTransparency = 1
            nextBtn.BorderSizePixel = 0
            nextBtn.Font = Enum.Font.GothamBold
            nextBtn.Text = "›"
            nextBtn.TextColor3 = Color3.fromRGB(250, 250, 250)
            nextBtn.TextSize = 20
            nextBtn.AutoButtonColor = false
            nextBtn.Parent = header

            local nextCorner = Instance.new("UICorner")
            nextCorner.CornerRadius = UDim.new(0, 6)
            nextCorner.Parent = nextBtn

            self:_connect(nextBtn.MouseButton1Click, function()
                self:NextMonth()
            end)

            self:_connect(nextBtn.MouseEnter, function()
                TweenService:Create(nextBtn, TweenInfo.new(0.1), {
                    BackgroundTransparency = 0,
                }):Play()
            end)

            self:_connect(nextBtn.MouseLeave, function()
                TweenService:Create(nextBtn, TweenInfo.new(0.1), {
                    BackgroundTransparency = 1,
                }):Play()
            end)

            -- Month/Year label
            local monthLabel = Instance.new("TextLabel")
            monthLabel.Name = "MonthLabel"
            monthLabel.Size = UDim2.new(1, -80, 1, 0)
            monthLabel.Position = UDim2.new(0.5, 0, 0, 0)
            monthLabel.AnchorPoint = Vector2.new(0.5, 0)
            monthLabel.BackgroundTransparency = 1
            monthLabel.Font = Enum.Font.GothamBold
            monthLabel.TextColor3 = Color3.fromRGB(250, 250, 250)
            monthLabel.TextSize = 16
            monthLabel.Parent = header
            self._monthLabel = monthLabel

            -- Day headers
            local dayHeaders = Instance.new("Frame")
            dayHeaders.Name = "DayHeaders"
            dayHeaders.Size = UDim2.new(1, 0, 0, 30)
            dayHeaders.Position = UDim2.new(0, 0, 0, 44)
            dayHeaders.BackgroundTransparency = 1
            dayHeaders.Parent = container

            local dayHeaderLayout = Instance.new("UIListLayout")
            dayHeaderLayout.FillDirection = Enum.FillDirection.Horizontal
            dayHeaderLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            dayHeaderLayout.Parent = dayHeaders

            for i, day in ipairs(DAYS) do
                local dayLabel = Instance.new("TextLabel")
                dayLabel.Size = UDim2.new(0, 36, 1, 0)
                dayLabel.BackgroundTransparency = 1
                dayLabel.Font = Enum.Font.GothamMedium
                dayLabel.Text = day
                dayLabel.TextColor3 = Color3.fromRGB(113, 113, 122)
                dayLabel.TextSize = 12
                dayLabel.LayoutOrder = i
                dayLabel.Parent = dayHeaders
            end

            -- Days grid
            local daysGrid = Instance.new("Frame")
            daysGrid.Name = "DaysGrid"
            daysGrid.Size = UDim2.new(1, 0, 0, 216)
            daysGrid.Position = UDim2.new(0, 0, 0, 78)
            daysGrid.BackgroundTransparency = 1
            daysGrid.Parent = container
            self._daysGrid = daysGrid

            local gridLayout = Instance.new("UIGridLayout")
            gridLayout.CellSize = UDim2.new(0, 36, 0, 36)
            gridLayout.CellPadding = UDim2.new(0, 0, 0, 0)
            gridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            gridLayout.SortOrder = Enum.SortOrder.LayoutOrder
            gridLayout.Parent = daysGrid

            -- Build calendar
            self:_buildCalendar()

            return self
        end

        --// Build calendar
        function Calendar:_buildCalendar()
            -- Clear existing
            for _, btn in ipairs(self._dayButtons) do
                btn:Destroy()
            end
            self._dayButtons = {}

            -- Update month label
            self._monthLabel.Text = MONTHS[self.ViewMonth] .. " " .. self.ViewYear

            local daysInMonth = self:_getDaysInMonth(self.ViewMonth, self.ViewYear)
            local firstDay = self:_getFirstDayOfMonth(self.ViewMonth, self.ViewYear)

            local today = os.date("*t")
            local layoutOrder = 0

            -- Empty cells before first day
            for i = 1, firstDay do
                layoutOrder = layoutOrder + 1
                local empty = Instance.new("Frame")
                empty.Size = UDim2.new(0, 36, 0, 36)
                empty.BackgroundTransparency = 1
                empty.LayoutOrder = layoutOrder
                empty.Parent = self._daysGrid
                table.insert(self._dayButtons, empty)
            end

            -- Day buttons
            for day = 1, daysInMonth do
                layoutOrder = layoutOrder + 1

                local isToday = day == today.day and self.ViewMonth == today.month and self.ViewYear == today.year
                local isSelected = self.SelectedDate and 
                    day == self.SelectedDate.day and 
                    self.ViewMonth == self.SelectedDate.month and 
                    self.ViewYear == self.SelectedDate.year
                local isDisabled = self:_isDateDisabled(day, self.ViewMonth, self.ViewYear)

                local btn = Instance.new("TextButton")
                btn.Name = "Day" .. day
                btn.Size = UDim2.new(0, 36, 0, 36)
                btn.BackgroundColor3 = isSelected and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(39, 39, 42)
                btn.BackgroundTransparency = isSelected and 0 or 1
                btn.BorderSizePixel = 0
                btn.Font = isToday and Enum.Font.GothamBold or Enum.Font.Gotham
                btn.Text = tostring(day)
                btn.TextColor3 = isDisabled and Color3.fromRGB(63, 63, 70) or 
                    (isSelected and Color3.fromRGB(255, 255, 255) or 
                    (isToday and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(250, 250, 250)))
                btn.TextSize = 13
                btn.AutoButtonColor = false
                btn.LayoutOrder = layoutOrder
                btn.Parent = self._daysGrid

                local btnCorner = Instance.new("UICorner")
                btnCorner.CornerRadius = UDim.new(0, 6)
                btnCorner.Parent = btn

                -- Today indicator
                if isToday and not isSelected then
                    local indicator = Instance.new("Frame")
                    indicator.Size = UDim2.new(0, 4, 0, 4)
                    indicator.Position = UDim2.new(0.5, 0, 1, -6)
                    indicator.AnchorPoint = Vector2.new(0.5, 0)
                    indicator.BackgroundColor3 = Color3.fromRGB(99, 102, 241)
                    indicator.BorderSizePixel = 0
                    indicator.Parent = btn

                    local indicatorCorner = Instance.new("UICorner")
                    indicatorCorner.CornerRadius = UDim.new(1, 0)
                    indicatorCorner.Parent = indicator
                end

                if not isDisabled then
                    self:_connect(btn.MouseButton1Click, function()
                        self:SelectDate(day, self.ViewMonth, self.ViewYear)
                    end)

                    self:_connect(btn.MouseEnter, function()
                        if not isSelected then
                            TweenService:Create(btn, TweenInfo.new(0.1), {
                                BackgroundTransparency = 0.5,
                            }):Play()
                        end
                    end)

                    self:_connect(btn.MouseLeave, function()
                        if not isSelected then
                            TweenService:Create(btn, TweenInfo.new(0.1), {
                                BackgroundTransparency = 1,
                            }):Play()
                        end
                    end)
                end

                table.insert(self._dayButtons, btn)
            end
        end

        --// Select date
        function Calendar:SelectDate(day, month, year)
            self.SelectedDate = { day = day, month = month, year = year }
            self:_buildCalendar()

            if self.OnDateSelect then
                self.OnDateSelect(self.SelectedDate)
            end

            self:_fire("DateSelect", self.SelectedDate)

            return self
        end

        --// Next month
        function Calendar:NextMonth()
            self.ViewMonth = self.ViewMonth + 1
            if self.ViewMonth > 12 then
                self.ViewMonth = 1
                self.ViewYear = self.ViewYear + 1
            end

            self:_buildCalendar()

            if self.OnMonthChange then
                self.OnMonthChange(self.ViewMonth, self.ViewYear)
            end

            return self
        end

        --// Previous month
        function Calendar:PrevMonth()
            self.ViewMonth = self.ViewMonth - 1
            if self.ViewMonth < 1 then
                self.ViewMonth = 12
                self.ViewYear = self.ViewYear - 1
            end

            self:_buildCalendar()

            if self.OnMonthChange then
                self.OnMonthChange(self.ViewMonth, self.ViewYear)
            end

            return self
        end

        --// Go to today
        function Calendar:GoToToday()
            local now = os.date("*t")
            self.ViewMonth = now.month
            self.ViewYear = now.year
            self:SelectDate(now.day, now.month, now.year)
            return self
        end

        --// Get selected date
        function Calendar:GetSelectedDate()
            return self.SelectedDate
        end

        return Calendar


    end


    -- ============================================================================
    -- Module: NexusUI/Components/TreeView
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/TreeView"] = function()
        local script = CreateMockScript("NexusUI/Components/TreeView")

        --[[
            NexusUI TreeView Component
            Hierarchical tree structure display
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// TreeView Component Module
        local TreeView = setmetatable({}, { __index = Base })
        TreeView.__index = TreeView
        TreeView.ClassName = "TreeView"

        --// Constructor
        function TreeView.new(config)
            local self = setmetatable(Base.new(config), TreeView)

            config = config or {}

            self.Nodes = config.Nodes or {} -- Array of {Id, Text, Icon, Children, Expanded, Data}
            self.Selectable = config.Selectable ~= false
            self.MultiSelect = config.MultiSelect or false
            self.ShowLines = config.ShowLines or false
            self.IndentSize = config.IndentSize or 20

            -- Callbacks
            self.OnNodeClick = config.OnNodeClick
            self.OnNodeExpand = config.OnNodeExpand
            self.OnNodeCollapse = config.OnNodeCollapse
            self.OnSelectionChange = config.OnSelectionChange

            -- State
            self._selectedNodes = {}
            self._expandedNodes = {}
            self._nodeElements = {}

            return self
        end

        --// Create tree view
        function TreeView:Create(parent)
            -- Container
            local container = Instance.new("ScrollingFrame")
            container.Name = self.Name
            container.Size = UDim2.new(1, 0, 0, 300)
            container.BackgroundColor3 = Color3.fromRGB(24, 24, 27)
            container.BorderSizePixel = 0
            container.ScrollBarThickness = 4
            container.ScrollBarImageColor3 = Color3.fromRGB(82, 82, 91)
            container.CanvasSize = UDim2.new(0, 0, 0, 0)
            container.AutomaticCanvasSize = Enum.AutomaticSize.Y

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = container

            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, 4)
            padding.PaddingBottom = UDim.new(0, 4)
            padding.PaddingLeft = UDim.new(0, 4)
            padding.PaddingRight = UDim.new(0, 4)
            padding.Parent = container

            local layout = Instance.new("UIListLayout")
            layout.SortOrder = Enum.SortOrder.LayoutOrder
            layout.Padding = UDim.new(0, 1)
            layout.Parent = container

            -- Build tree
            self:_buildTree()

            return self
        end

        --// Build tree
        function TreeView:_buildTree()
            -- Clear existing
            for _, element in pairs(self._nodeElements) do
                if element.Instance then
                    element.Instance:Destroy()
                end
            end
            self._nodeElements = {}

            local layoutOrder = 0

            local function buildNode(node, depth)
                layoutOrder = layoutOrder + 1
                local hasChildren = node.Children and #node.Children > 0
                local isExpanded = self._expandedNodes[node.Id]
                local isSelected = table.find(self._selectedNodes, node.Id) ~= nil

                local nodeFrame = Instance.new("TextButton")
                nodeFrame.Name = "Node_" .. node.Id
                nodeFrame.Size = UDim2.new(1, 0, 0, 28)
                nodeFrame.BackgroundColor3 = isSelected and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(39, 39, 42)
                nodeFrame.BackgroundTransparency = isSelected and 0.8 or 1
                nodeFrame.BorderSizePixel = 0
                nodeFrame.Text = ""
                nodeFrame.AutoButtonColor = false
                nodeFrame.LayoutOrder = layoutOrder
                nodeFrame.Parent = self.Instance

                local nodeCorner = Instance.new("UICorner")
                nodeCorner.CornerRadius = UDim.new(0, 4)
                nodeCorner.Parent = nodeFrame

                local nodePadding = Instance.new("UIPadding")
                nodePadding.PaddingLeft = UDim.new(0, depth * self.IndentSize + 4)
                nodePadding.PaddingRight = UDim.new(0, 4)
                nodePadding.Parent = nodeFrame

                local nodeLayout = Instance.new("UIListLayout")
                nodeLayout.FillDirection = Enum.FillDirection.Horizontal
                nodeLayout.VerticalAlignment = Enum.VerticalAlignment.Center
                nodeLayout.Padding = UDim.new(0, 6)
                nodeLayout.Parent = nodeFrame

                -- Expand/collapse arrow
                if hasChildren then
                    local arrow = Instance.new("ImageButton")
                    arrow.Name = "Arrow"
                    arrow.Size = UDim2.new(0, 14, 0, 14)
                    arrow.BackgroundTransparency = 1
                    arrow.Image = "rbxassetid://7072706620"
                    arrow.ImageColor3 = Color3.fromRGB(161, 161, 170)
                    arrow.Rotation = isExpanded and 90 or 0
                    arrow.LayoutOrder = 1
                    arrow.Parent = nodeFrame

                    self:_connect(arrow.MouseButton1Click, function()
                        self:_toggleNode(node.Id)
                    end)
                else
                    -- Spacer
                    local spacer = Instance.new("Frame")
                    spacer.Size = UDim2.new(0, 14, 0, 14)
                    spacer.BackgroundTransparency = 1
                    spacer.LayoutOrder = 1
                    spacer.Parent = nodeFrame
                end

                -- Icon
                if node.Icon then
                    local icon = Instance.new("ImageLabel")
                    icon.Size = UDim2.new(0, 16, 0, 16)
                    icon.BackgroundTransparency = 1
                    icon.Image = node.Icon
                    icon.ImageColor3 = Color3.fromRGB(161, 161, 170)
                    icon.LayoutOrder = 2
                    icon.Parent = nodeFrame
                end

                -- Text
                local text = Instance.new("TextLabel")
                text.Size = UDim2.new(1, -40, 1, 0)
                text.BackgroundTransparency = 1
                text.Font = Enum.Font.Gotham
                text.Text = node.Text
                text.TextColor3 = Color3.fromRGB(250, 250, 250)
                text.TextSize = 13
                text.TextXAlignment = Enum.TextXAlignment.Left
                text.TextTruncate = Enum.TextTruncate.AtEnd
                text.LayoutOrder = 3
                text.Parent = nodeFrame

                -- Interactions
                self:_connect(nodeFrame.MouseButton1Click, function()
                    if self.Selectable then
                        self:_selectNode(node.Id)
                    end

                    if self.OnNodeClick then
                        self.OnNodeClick(node)
                    end

                    self:_fire("NodeClick", node)
                end)

                self:_connect(nodeFrame.MouseEnter, function()
                    if not isSelected then
                        TweenService:Create(nodeFrame, TweenInfo.new(0.1), {
                            BackgroundTransparency = 0.8,
                        }):Play()
                    end
                end)

                self:_connect(nodeFrame.MouseLeave, function()
                    if not isSelected then
                        TweenService:Create(nodeFrame, TweenInfo.new(0.1), {
                            BackgroundTransparency = 1,
                        }):Play()
                    end
                end)

                self._nodeElements[node.Id] = {
                    Instance = nodeFrame,
                    Node = node,
                    Depth = depth,
                }

                -- Build children if expanded
                if hasChildren and isExpanded then
                    for _, child in ipairs(node.Children) do
                        buildNode(child, depth + 1)
                    end
                end
            end

            for _, node in ipairs(self.Nodes) do
                buildNode(node, 0)
            end
        end

        --// Toggle node expansion
        function TreeView:_toggleNode(nodeId)
            if self._expandedNodes[nodeId] then
                self._expandedNodes[nodeId] = nil

                local element = self._nodeElements[nodeId]
                if element and self.OnNodeCollapse then
                    self.OnNodeCollapse(element.Node)
                end

                self:_fire("NodeCollapse", element and element.Node)
            else
                self._expandedNodes[nodeId] = true

                local element = self._nodeElements[nodeId]
                if element and self.OnNodeExpand then
                    self.OnNodeExpand(element.Node)
                end

                self:_fire("NodeExpand", element and element.Node)
            end

            self:_buildTree()
        end

        --// Select node
        function TreeView:_selectNode(nodeId)
            local existingPos = table.find(self._selectedNodes, nodeId)

            if existingPos then
                if self.MultiSelect then
                    table.remove(self._selectedNodes, existingPos)
                end
            else
                if self.MultiSelect then
                    table.insert(self._selectedNodes, nodeId)
                else
                    self._selectedNodes = { nodeId }
                end
            end

            self:_buildTree()

            if self.OnSelectionChange then
                self.OnSelectionChange(self._selectedNodes)
            end

            self:_fire("SelectionChange", self._selectedNodes)
        end

        --// Expand all
        function TreeView:ExpandAll()
            local function expand(nodes)
                for _, node in ipairs(nodes) do
                    self._expandedNodes[node.Id] = true
                    if node.Children then
                        expand(node.Children)
                    end
                end
            end

            expand(self.Nodes)
            self:_buildTree()
            return self
        end

        --// Collapse all
        function TreeView:CollapseAll()
            self._expandedNodes = {}
            self:_buildTree()
            return self
        end

        --// Set nodes
        function TreeView:SetNodes(nodes)
            self.Nodes = nodes
            self._selectedNodes = {}
            self._expandedNodes = {}
            self:_buildTree()
            return self
        end

        --// Get selected nodes
        function TreeView:GetSelectedNodes()
            local nodes = {}
            for _, nodeId in ipairs(self._selectedNodes) do
                local element = self._nodeElements[nodeId]
                if element then
                    table.insert(nodes, element.Node)
                end
            end
            return nodes
        end

        --// Expand node
        function TreeView:ExpandNode(nodeId)
            self._expandedNodes[nodeId] = true
            self:_buildTree()
            return self
        end

        --// Collapse node
        function TreeView:CollapseNode(nodeId)
            self._expandedNodes[nodeId] = nil
            self:_buildTree()
            return self
        end

        return TreeView


    end


    -- ============================================================================
    -- Module: NexusUI/Components/RadioButton
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/RadioButton"] = function()
        local script = CreateMockScript("NexusUI/Components/RadioButton")

        --[[
            NexusUI RadioButton Component
            Radio button for single selection from group
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// RadioButton Component Module
        local RadioButton = setmetatable({}, { __index = Base })
        RadioButton.__index = RadioButton
        RadioButton.ClassName = "RadioButton"

        --// Radio Groups (shared state)
        local _radioGroups = {}

        --// Constructor
        function RadioButton.new(config)
            local self = setmetatable(Base.new(config), RadioButton)

            config = config or {}

            self.Value = config.Value
            self.Selected = config.Selected or false
            self.Group = config.Group or "default"
            self.Label = config.Label
            self.LabelPosition = config.LabelPosition or "Right"
            self.Size = config.Size or 20
            self.ColorSelected = config.ColorSelected or Color3.fromRGB(99, 102, 241)
            self.ColorUnselected = config.ColorUnselected or Color3.fromRGB(63, 63, 70)

            -- Callbacks
            self.OnSelect = config.OnSelect

            -- Register in group
            if not _radioGroups[self.Group] then
                _radioGroups[self.Group] = {}
            end
            table.insert(_radioGroups[self.Group], self)

            return self
        end

        --// Create radio button
        function RadioButton:Create(parent)
            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(0, 0, 0, self.Size)
            container.AutomaticSize = Enum.AutomaticSize.X
            container.BackgroundTransparency = 1

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Layout
            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Horizontal
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.Padding = UDim.new(0, 8)
            layout.SortOrder = Enum.SortOrder.LayoutOrder
            layout.Parent = container

            -- Label (left)
            if self.Label and self.LabelPosition == "Left" then
                local label = Instance.new("TextLabel")
                label.Name = "Label"
                label.Size = UDim2.new(0, 0, 0, self.Size)
                label.AutomaticSize = Enum.AutomaticSize.X
                label.BackgroundTransparency = 1
                label.Font = Enum.Font.Gotham
                label.Text = self.Label
                label.TextColor3 = Color3.fromRGB(250, 250, 250)
                label.TextSize = 14
                label.LayoutOrder = 1
                label.Parent = container
                self._label = label
            end

            -- Radio circle
            local circle = Instance.new("TextButton")
            circle.Name = "Circle"
            circle.Size = UDim2.new(0, self.Size, 0, self.Size)
            circle.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            circle.BorderSizePixel = 0
            circle.Text = ""
            circle.AutoButtonColor = false
            circle.LayoutOrder = 2
            circle.Parent = container
            self._circle = circle

            -- Circle corner
            local circleCorner = Instance.new("UICorner")
            circleCorner.CornerRadius = UDim.new(1, 0)
            circleCorner.Parent = circle

            -- Border
            local stroke = Instance.new("UIStroke")
            stroke.Color = self.Selected and self.ColorSelected or Color3.fromRGB(82, 82, 91)
            stroke.Thickness = 2
            stroke.Parent = circle
            self._stroke = stroke

            -- Inner dot (selection indicator)
            local dot = Instance.new("Frame")
            dot.Name = "Dot"
            dot.Size = self.Selected and UDim2.new(0.5, 0, 0.5, 0) or UDim2.new(0, 0, 0, 0)
            dot.Position = UDim2.new(0.5, 0, 0.5, 0)
            dot.AnchorPoint = Vector2.new(0.5, 0.5)
            dot.BackgroundColor3 = self.ColorSelected
            dot.BorderSizePixel = 0
            dot.Parent = circle
            self._dot = dot

            local dotCorner = Instance.new("UICorner")
            dotCorner.CornerRadius = UDim.new(1, 0)
            dotCorner.Parent = dot

            -- Label (right)
            if self.Label and self.LabelPosition == "Right" then
                local label = Instance.new("TextLabel")
                label.Name = "Label"
                label.Size = UDim2.new(0, 0, 0, self.Size)
                label.AutomaticSize = Enum.AutomaticSize.X
                label.BackgroundTransparency = 1
                label.Font = Enum.Font.Gotham
                label.Text = self.Label
                label.TextColor3 = Color3.fromRGB(250, 250, 250)
                label.TextSize = 14
                label.LayoutOrder = 3
                label.Parent = container
                self._label = label
            end

            -- Setup interactions
            self:_setupInteractions()

            -- Set initial state if selected
            if self.Selected then
                self:Select(false)
            end

            return self
        end

        --// Setup interactions
        function RadioButton:_setupInteractions()
            local circle = self._circle

            -- Click
            self:_connect(circle.MouseButton1Click, function()
                if not self.IsEnabled or self.Selected then return end
                self:Select()
            end)

            -- Hover
            self:_connect(circle.MouseEnter, function()
                if not self.IsEnabled then return end

                TweenService:Create(self._stroke, TweenInfo.new(0.15), {
                    Color = self.Selected and self.ColorSelected or Color3.fromRGB(113, 113, 122),
                }):Play()

                TweenService:Create(circle, TweenInfo.new(0.15), {
                    Size = UDim2.new(0, self.Size + 2, 0, self.Size + 2),
                }):Play()
            end)

            self:_connect(circle.MouseLeave, function()
                TweenService:Create(self._stroke, TweenInfo.new(0.15), {
                    Color = self.Selected and self.ColorSelected or Color3.fromRGB(82, 82, 91),
                }):Play()

                TweenService:Create(circle, TweenInfo.new(0.15), {
                    Size = UDim2.new(0, self.Size, 0, self.Size),
                }):Play()
            end)
        end

        --// Select
        function RadioButton:Select(animate)
            if self.Selected then return self end

            animate = animate ~= false

            -- Deselect others in group
            local group = _radioGroups[self.Group]
            if group then
                for _, radio in ipairs(group) do
                    if radio ~= self and radio.Selected then
                        radio:Deselect(animate)
                    end
                end
            end

            self.Selected = true

            local duration = animate and 0.2 or 0

            -- Animate dot
            TweenService:Create(self._dot, TweenInfo.new(duration, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                Size = UDim2.new(0.5, 0, 0.5, 0),
            }):Play()

            TweenService:Create(self._stroke, TweenInfo.new(duration * 0.5), {
                Color = self.ColorSelected,
            }):Play()

            -- Callback
            if self.OnSelect then
                self.OnSelect(self.Value)
            end

            self:_fire("Select", self.Value)

            return self
        end

        --// Deselect
        function RadioButton:Deselect(animate)
            if not self.Selected then return self end

            self.Selected = false
            animate = animate ~= false

            local duration = animate and 0.15 or 0

            TweenService:Create(self._dot, TweenInfo.new(duration), {
                Size = UDim2.new(0, 0, 0, 0),
            }):Play()

            TweenService:Create(self._stroke, TweenInfo.new(duration), {
                Color = Color3.fromRGB(82, 82, 91),
            }):Play()

            return self
        end

        --// Get selected value from group
        function RadioButton.GetGroupValue(groupName)
            local group = _radioGroups[groupName]
            if group then
                for _, radio in ipairs(group) do
                    if radio.Selected then
                        return radio.Value
                    end
                end
            end
            return nil
        end

        --// Set group value
        function RadioButton.SetGroupValue(groupName, value)
            local group = _radioGroups[groupName]
            if group then
                for _, radio in ipairs(group) do
                    if radio.Value == value then
                        radio:Select()
                        return
                    end
                end
            end
        end

        --// Destroy override
        function RadioButton:Destroy()
            -- Remove from group
            local group = _radioGroups[self.Group]
            if group then
                for i, radio in ipairs(group) do
                    if radio == self then
                        table.remove(group, i)
                        break
                    end
                end
            end

            Base.Destroy(self)
        end

        return RadioButton


    end


    -- ============================================================================
    -- Module: NexusUI/Components/ContextMenu
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/ContextMenu"] = function()
        local script = CreateMockScript("NexusUI/Components/ContextMenu")

        --[[
            NexusUI ContextMenu Component
            Right-click context menu
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")
        local UserInputService = game:GetService("UserInputService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// ContextMenu Component Module
        local ContextMenu = setmetatable({}, { __index = Base })
        ContextMenu.__index = ContextMenu
        ContextMenu.ClassName = "ContextMenu"

        --// Constructor
        function ContextMenu.new(config)
            local self = setmetatable(Base.new(config), ContextMenu)

            config = config or {}

            self.Items = config.Items or {} -- Array of {Text, Icon, Shortcut, Disabled, Separator, SubItems, OnClick}
            self.Target = config.Target
            self.Width = config.Width or 180

            -- Callbacks
            self.OnItemClick = config.OnItemClick
            self.OnOpen = config.OnOpen
            self.OnClose = config.OnClose

            -- State
            self._isOpen = false

            return self
        end

        --// Create context menu
        function ContextMenu:Create(parent)
            -- Get screen gui
            local screenGui = parent
            while screenGui and not screenGui:IsA("ScreenGui") do
                screenGui = screenGui.Parent
            end

            if not screenGui then
                screenGui = Instance.new("ScreenGui")
                screenGui.Parent = game:GetService("CoreGui")
            end

            -- Menu container
            local menu = Instance.new("Frame")
            menu.Name = self.Name
            menu.Size = UDim2.new(0, self.Width, 0, 0)
            menu.AutomaticSize = Enum.AutomaticSize.Y
            menu.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            menu.BorderSizePixel = 0
            menu.Visible = false
            menu.ZIndex = 9999
            menu.Parent = screenGui
            self.Instance = menu

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = menu

            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(63, 63, 70)
            stroke.Thickness = 1
            stroke.Parent = menu

            -- Shadow
            local shadow = Instance.new("ImageLabel")
            shadow.Size = UDim2.new(1, 20, 1, 20)
            shadow.Position = UDim2.new(0.5, 0, 0.5, 6)
            shadow.AnchorPoint = Vector2.new(0.5, 0.5)
            shadow.BackgroundTransparency = 1
            shadow.Image = "rbxassetid://6015897843"
            shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
            shadow.ImageTransparency = 0.4
            shadow.ScaleType = Enum.ScaleType.Slice
            shadow.SliceCenter = Rect.new(49, 49, 450, 450)
            shadow.ZIndex = menu.ZIndex - 1
            shadow.Parent = menu

            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, 4)
            padding.PaddingBottom = UDim.new(0, 4)
            padding.PaddingLeft = UDim.new(0, 4)
            padding.PaddingRight = UDim.new(0, 4)
            padding.Parent = menu

            local layout = Instance.new("UIListLayout")
            layout.SortOrder = Enum.SortOrder.LayoutOrder
            layout.Padding = UDim.new(0, 1)
            layout.Parent = menu

            -- Build items
            self:_buildItems()

            -- Bind to target
            if self.Target then
                self:BindTo(self.Target)
            end

            -- Global click to close
            self:_connect(UserInputService.InputBegan, function(input)
                if self._isOpen and input.UserInputType == Enum.UserInputType.MouseButton1 then
                    -- Check if click is outside menu
                    local mousePos = UserInputService:GetMouseLocation()
                    local menuPos = menu.AbsolutePosition
                    local menuSize = menu.AbsoluteSize

                    if mousePos.X < menuPos.X or mousePos.X > menuPos.X + menuSize.X or
                       mousePos.Y < menuPos.Y or mousePos.Y > menuPos.Y + menuSize.Y then
                        task.defer(function()
                            self:Close()
                        end)
                    end
                end
            end)

            return self
        end

        --// Build items
        function ContextMenu:_buildItems()
            -- Clear existing items
            for _, child in ipairs(self.Instance:GetChildren()) do
                if child:IsA("TextButton") or child:IsA("Frame") and child.Name ~= "Shadow" then
                    if not child:IsA("UICorner") and not child:IsA("UIStroke") and not child:IsA("UIPadding") and not child:IsA("UIListLayout") then
                        child:Destroy()
                    end
                end
            end

            for i, item in ipairs(self.Items) do
                if item.Separator then
                    -- Separator
                    local separator = Instance.new("Frame")
                    separator.Name = "Separator" .. i
                    separator.Size = UDim2.new(1, -8, 0, 1)
                    separator.Position = UDim2.new(0.5, 0, 0, 0)
                    separator.AnchorPoint = Vector2.new(0.5, 0)
                    separator.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
                    separator.BorderSizePixel = 0
                    separator.LayoutOrder = i
                    separator.Parent = self.Instance

                    local sepPadding = Instance.new("Frame")
                    sepPadding.Size = UDim2.new(1, 0, 0, 8)
                    sepPadding.BackgroundTransparency = 1
                    sepPadding.LayoutOrder = i
                    sepPadding.Parent = self.Instance
                else
                    local btn = Instance.new("TextButton")
                    btn.Name = "Item" .. i
                    btn.Size = UDim2.new(1, 0, 0, 32)
                    btn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
                    btn.BackgroundTransparency = 1
                    btn.BorderSizePixel = 0
                    btn.Text = ""
                    btn.AutoButtonColor = false
                    btn.LayoutOrder = i
                    btn.ZIndex = self.Instance.ZIndex
                    btn.Parent = self.Instance

                    local btnCorner = Instance.new("UICorner")
                    btnCorner.CornerRadius = UDim.new(0, 4)
                    btnCorner.Parent = btn

                    local btnPadding = Instance.new("UIPadding")
                    btnPadding.PaddingLeft = UDim.new(0, 8)
                    btnPadding.PaddingRight = UDim.new(0, 8)
                    btnPadding.Parent = btn

                    local btnLayout = Instance.new("UIListLayout")
                    btnLayout.FillDirection = Enum.FillDirection.Horizontal
                    btnLayout.VerticalAlignment = Enum.VerticalAlignment.Center
                    btnLayout.Padding = UDim.new(0, 8)
                    btnLayout.Parent = btn

                    -- Icon
                    if item.Icon then
                        local icon = Instance.new("ImageLabel")
                        icon.Size = UDim2.new(0, 14, 0, 14)
                        icon.BackgroundTransparency = 1
                        icon.Image = item.Icon
                        icon.ImageColor3 = item.Disabled and Color3.fromRGB(82, 82, 91) or Color3.fromRGB(161, 161, 170)
                        icon.ZIndex = btn.ZIndex
                        icon.LayoutOrder = 1
                        icon.Parent = btn
                    end

                    -- Text
                    local text = Instance.new("TextLabel")
                    text.Size = UDim2.new(1, -40, 1, 0)
                    text.BackgroundTransparency = 1
                    text.Font = Enum.Font.Gotham
                    text.Text = item.Text
                    text.TextColor3 = item.Disabled and Color3.fromRGB(82, 82, 91) or Color3.fromRGB(250, 250, 250)
                    text.TextSize = 13
                    text.TextXAlignment = Enum.TextXAlignment.Left
                    text.ZIndex = btn.ZIndex
                    text.LayoutOrder = 2
                    text.Parent = btn

                    -- Shortcut
                    if item.Shortcut then
                        local shortcut = Instance.new("TextLabel")
                        shortcut.Size = UDim2.new(0, 0, 0, 0)
                        shortcut.AutomaticSize = Enum.AutomaticSize.XY
                        shortcut.Position = UDim2.new(1, -8, 0.5, 0)
                        shortcut.AnchorPoint = Vector2.new(1, 0.5)
                        shortcut.BackgroundTransparency = 1
                        shortcut.Font = Enum.Font.Gotham
                        shortcut.Text = item.Shortcut
                        shortcut.TextColor3 = Color3.fromRGB(82, 82, 91)
                        shortcut.TextSize = 11
                        shortcut.ZIndex = btn.ZIndex
                        shortcut.Parent = btn
                    end

                    -- SubItems indicator
                    if item.SubItems and #item.SubItems > 0 then
                        local arrow = Instance.new("ImageLabel")
                        arrow.Size = UDim2.new(0, 10, 0, 10)
                        arrow.Position = UDim2.new(1, -8, 0.5, 0)
                        arrow.AnchorPoint = Vector2.new(1, 0.5)
                        arrow.BackgroundTransparency = 1
                        arrow.Image = "rbxassetid://7072706620"
                        arrow.ImageColor3 = Color3.fromRGB(113, 113, 122)
                        arrow.Rotation = 180
                        arrow.ZIndex = btn.ZIndex
                        arrow.Parent = btn
                    end

                    -- Interactions
                    if not item.Disabled then
                        self:_connect(btn.MouseButton1Click, function()
                            if item.OnClick then
                                item.OnClick()
                            end

                            if self.OnItemClick then
                                self.OnItemClick(i, item)
                            end

                            self:_fire("ItemClick", i, item)
                            self:Close()
                        end)

                        self:_connect(btn.MouseEnter, function()
                            TweenService:Create(btn, TweenInfo.new(0.1), {
                                BackgroundTransparency = 0,
                            }):Play()
                        end)

                        self:_connect(btn.MouseLeave, function()
                            TweenService:Create(btn, TweenInfo.new(0.1), {
                                BackgroundTransparency = 1,
                            }):Play()
                        end)
                    end
                end
            end
        end

        --// Bind to target
        function ContextMenu:BindTo(target)
            self.Target = target

            self:_connect(target.MouseButton2Click, function()
                local mousePos = UserInputService:GetMouseLocation()
                self:Show(mousePos.X, mousePos.Y)
            end)

            return self
        end

        --// Show at position
        function ContextMenu:Show(x, y)
            self._isOpen = true
            self.Instance.Visible = true

            -- Position menu
            local viewportSize = workspace.CurrentCamera.ViewportSize
            local menuSize = self.Instance.AbsoluteSize

            -- Adjust if going off screen
            if x + menuSize.X > viewportSize.X then
                x = viewportSize.X - menuSize.X - 4
            end

            if y + menuSize.Y > viewportSize.Y then
                y = viewportSize.Y - menuSize.Y - 4
            end

            self.Instance.Position = UDim2.new(0, x, 0, y)

            -- Animate in
            self.Instance.BackgroundTransparency = 1
            TweenService:Create(self.Instance, TweenInfo.new(0.1), {
                BackgroundTransparency = 0,
            }):Play()

            if self.OnOpen then
                self.OnOpen()
            end

            self:_fire("Open")

            return self
        end

        --// Close
        function ContextMenu:Close()
            if not self._isOpen then return self end

            self._isOpen = false

            TweenService:Create(self.Instance, TweenInfo.new(0.1), {
                BackgroundTransparency = 1,
            }):Play()

            task.delay(0.1, function()
                if not self._isOpen then
                    self.Instance.Visible = false
                end
            end)

            if self.OnClose then
                self.OnClose()
            end

            self:_fire("Close")

            return self
        end

        --// Set items
        function ContextMenu:SetItems(items)
            self.Items = items
            self:_buildItems()
            return self
        end

        return ContextMenu


    end


    -- ============================================================================
    -- Module: NexusUI/Components/SegmentedControl
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/SegmentedControl"] = function()
        local script = CreateMockScript("NexusUI/Components/SegmentedControl")

        --[[
            NexusUI SegmentedControl Component
            Tab-like segmented button group
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// SegmentedControl Component Module
        local SegmentedControl = setmetatable({}, { __index = Base })
        SegmentedControl.__index = SegmentedControl
        SegmentedControl.ClassName = "SegmentedControl"

        --// Constructor
        function SegmentedControl.new(config)
            local self = setmetatable(Base.new(config), SegmentedControl)

            config = config or {}

            self.Segments = config.Segments or {} -- Array of {Text = "", Value = "", Icon = ""}
            self.SelectedIndex = config.SelectedIndex or 1
            self.FullWidth = config.FullWidth or false

            -- Callbacks
            self.OnChange = config.OnChange

            -- Internal
            self._segmentButtons = {}

            return self
        end

        --// Create segmented control
        function SegmentedControl:Create(parent)
            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = self.FullWidth and UDim2.new(1, 0, 0, 36) or UDim2.new(0, 0, 0, 36)
            container.AutomaticSize = not self.FullWidth and Enum.AutomaticSize.X or Enum.AutomaticSize.None
            container.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            container.BorderSizePixel = 0

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Corner
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = container

            -- Border
            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(63, 63, 70)
            stroke.Thickness = 1
            stroke.Parent = container

            -- Padding
            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, 3)
            padding.PaddingBottom = UDim.new(0, 3)
            padding.PaddingLeft = UDim.new(0, 3)
            padding.PaddingRight = UDim.new(0, 3)
            padding.Parent = container

            -- Layout
            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Horizontal
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.Padding = UDim.new(0, 2)
            layout.Parent = container

            -- Create segments
            for i, segment in ipairs(self.Segments) do
                self:_createSegment(i, segment)
            end

            -- Update selection
            self:_updateSelection(false)

            return self
        end

        --// Create segment button
        function SegmentedControl:_createSegment(index, segment)
            local button = Instance.new("TextButton")
            button.Name = "Segment" .. index
            button.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
            button.BackgroundTransparency = 1
            button.BorderSizePixel = 0
            button.AutoButtonColor = false
            button.LayoutOrder = index
            button.Parent = self.Instance

            if self.FullWidth then
                button.Size = UDim2.new(1 / #self.Segments, -4, 1, 0)
            else
                button.Size = UDim2.new(0, 0, 1, 0)
                button.AutomaticSize = Enum.AutomaticSize.X
            end

            -- Corner
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 6)
            corner.Parent = button

            -- Padding
            local padding = Instance.new("UIPadding")
            padding.PaddingLeft = UDim.new(0, 12)
            padding.PaddingRight = UDim.new(0, 12)
            padding.Parent = button

            -- Content layout
            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Horizontal
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            layout.Padding = UDim.new(0, 6)
            layout.Parent = button

            -- Icon (if provided)
            if segment.Icon then
                local icon = Instance.new("ImageLabel")
                icon.Name = "Icon"
                icon.Size = UDim2.new(0, 14, 0, 14)
                icon.BackgroundTransparency = 1
                icon.Image = segment.Icon
                icon.ImageColor3 = Color3.fromRGB(161, 161, 170)
                icon.LayoutOrder = 1
                icon.Parent = button
            end

            -- Text
            local text = Instance.new("TextLabel")
            text.Name = "Text"
            text.Size = UDim2.new(0, 0, 0, 0)
            text.AutomaticSize = Enum.AutomaticSize.XY
            text.BackgroundTransparency = 1
            text.Font = Enum.Font.GothamMedium
            text.Text = segment.Text or ""
            text.TextColor3 = Color3.fromRGB(161, 161, 170)
            text.TextSize = 13
            text.LayoutOrder = 2
            text.Parent = button

            -- Invisible click label
            local clickLabel = Instance.new("TextLabel")
            clickLabel.Name = "ClickLabel"
            clickLabel.Size = UDim2.new(1, 0, 1, 0)
            clickLabel.BackgroundTransparency = 1
            clickLabel.Text = ""
            clickLabel.Parent = button

            -- Click handler
            self:_connect(button.MouseButton1Click, function()
                self:SetSelectedIndex(index)
            end)

            -- Hover
            self:_connect(button.MouseEnter, function()
                if index ~= self.SelectedIndex then
                    TweenService:Create(button, TweenInfo.new(0.15), {
                        BackgroundTransparency = 0.7,
                    }):Play()
                end
            end)

            self:_connect(button.MouseLeave, function()
                if index ~= self.SelectedIndex then
                    TweenService:Create(button, TweenInfo.new(0.15), {
                        BackgroundTransparency = 1,
                    }):Play()
                end
            end)

            self._segmentButtons[index] = button
        end

        --// Update selection visual
        function SegmentedControl:_updateSelection(animate)
            animate = animate ~= false
            local duration = animate and 0.2 or 0

            for i, button in ipairs(self._segmentButtons) do
                local isSelected = i == self.SelectedIndex

                TweenService:Create(button, TweenInfo.new(duration), {
                    BackgroundTransparency = isSelected and 0 or 1,
                }):Play()

                -- Update text color
                local text = button:FindFirstChild("Text")
                if text then
                    TweenService:Create(text, TweenInfo.new(duration), {
                        TextColor3 = isSelected and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(161, 161, 170),
                    }):Play()
                end

                -- Update icon color
                local icon = button:FindFirstChild("Icon")
                if icon then
                    TweenService:Create(icon, TweenInfo.new(duration), {
                        ImageColor3 = isSelected and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(161, 161, 170),
                    }):Play()
                end
            end
        end

        --// Set selected index
        function SegmentedControl:SetSelectedIndex(index)
            if index < 1 or index > #self.Segments then return self end
            if index == self.SelectedIndex then return self end

            local oldIndex = self.SelectedIndex
            self.SelectedIndex = index

            self:_updateSelection(true)

            local segment = self.Segments[index]

            if self.OnChange then
                self.OnChange(index, segment.Value or segment.Text, oldIndex)
            end

            self:_fire("Change", index, segment.Value or segment.Text, oldIndex)

            return self
        end

        --// Get selected index
        function SegmentedControl:GetSelectedIndex()
            return self.SelectedIndex
        end

        --// Get selected value
        function SegmentedControl:GetSelectedValue()
            local segment = self.Segments[self.SelectedIndex]
            return segment and (segment.Value or segment.Text)
        end

        --// Set segments
        function SegmentedControl:SetSegments(segments)
            -- Clear existing
            for _, button in ipairs(self._segmentButtons) do
                button:Destroy()
            end
            self._segmentButtons = {}

            self.Segments = segments
            self.SelectedIndex = 1

            -- Create new segments
            for i, segment in ipairs(segments) do
                self:_createSegment(i, segment)
            end

            self:_updateSelection(false)

            return self
        end

        return SegmentedControl


    end


    -- ============================================================================
    -- Module: NexusUI/Components/TextArea
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/TextArea"] = function()
        local script = CreateMockScript("NexusUI/Components/TextArea")

        --[[
            NexusUI TextArea Component
            Multi-line text input
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// TextArea Component Module
        local TextArea = setmetatable({}, { __index = Base })
        TextArea.__index = TextArea
        TextArea.ClassName = "TextArea"

        --// Constructor
        function TextArea.new(config)
            local self = setmetatable(Base.new(config), TextArea)

            config = config or {}

            self.Text = config.Text or ""
            self.Placeholder = config.Placeholder or "Enter text..."
            self.MaxLength = config.MaxLength or -1
            self.MinLines = config.MinLines or 3
            self.MaxLines = config.MaxLines or 10
            self.ResizableY = config.ResizableY or false
            self.ShowCharCount = config.ShowCharCount or false
            self.ReadOnly = config.ReadOnly or false

            -- Callbacks
            self.OnTextChanged = config.OnTextChanged
            self.OnFocus = config.OnFocus
            self.OnFocusLost = config.OnFocusLost

            -- State
            self._isFocused = false

            return self
        end

        --// Create text area
        function TextArea:Create(parent)
            -- Calculate height based on min lines
            local lineHeight = 20
            local padding = 24
            local height = self.MinLines * lineHeight + padding

            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(1, 0, 0, height)
            container.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            container.BorderSizePixel = 0
            container.ClipsDescendants = true

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Corner
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = container

            -- Border
            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(63, 63, 70)
            stroke.Thickness = 1
            stroke.Parent = container
            self._stroke = stroke

            -- Padding
            local uiPadding = Instance.new("UIPadding")
            uiPadding.PaddingTop = UDim.new(0, 12)
            uiPadding.PaddingBottom = UDim.new(0, 12)
            uiPadding.PaddingLeft = UDim.new(0, 12)
            uiPadding.PaddingRight = UDim.new(0, 12)
            uiPadding.Parent = container

            -- Scrolling frame for text
            local scrollFrame = Instance.new("ScrollingFrame")
            scrollFrame.Name = "Scroll"
            scrollFrame.Size = UDim2.new(1, 0, 1, self.ShowCharCount and -20 or 0)
            scrollFrame.BackgroundTransparency = 1
            scrollFrame.BorderSizePixel = 0
            scrollFrame.ScrollBarThickness = 4
            scrollFrame.ScrollBarImageColor3 = Color3.fromRGB(82, 82, 91)
            scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
            scrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
            scrollFrame.Parent = container
            self._scrollFrame = scrollFrame

            -- Text box
            local textBox = Instance.new("TextBox")
            textBox.Name = "Input"
            textBox.Size = UDim2.new(1, -8, 0, 0)
            textBox.AutomaticSize = Enum.AutomaticSize.Y
            textBox.BackgroundTransparency = 1
            textBox.Font = Enum.Font.Gotham
            textBox.Text = self.Text
            textBox.PlaceholderText = self.Placeholder
            textBox.PlaceholderColor3 = Color3.fromRGB(113, 113, 122)
            textBox.TextColor3 = Color3.fromRGB(250, 250, 250)
            textBox.TextSize = 14
            textBox.TextXAlignment = Enum.TextXAlignment.Left
            textBox.TextYAlignment = Enum.TextYAlignment.Top
            textBox.TextWrapped = true
            textBox.MultiLine = true
            textBox.ClearTextOnFocus = false
            textBox.TextEditable = not self.ReadOnly
            textBox.Parent = scrollFrame
            self._textBox = textBox

            -- Character count
            if self.ShowCharCount then
                local charCount = Instance.new("TextLabel")
                charCount.Name = "CharCount"
                charCount.Size = UDim2.new(1, 0, 0, 16)
                charCount.Position = UDim2.new(0, 0, 1, -16)
                charCount.BackgroundTransparency = 1
                charCount.Font = Enum.Font.Gotham
                charCount.TextColor3 = Color3.fromRGB(113, 113, 122)
                charCount.TextSize = 11
                charCount.TextXAlignment = Enum.TextXAlignment.Right
                charCount.Parent = container
                self._charCount = charCount

                self:_updateCharCount()
            end

            -- Resize handle (if resizable)
            if self.ResizableY then
                local handle = Instance.new("Frame")
                handle.Name = "ResizeHandle"
                handle.Size = UDim2.new(1, 0, 0, 8)
                handle.Position = UDim2.new(0, 0, 1, 0)
                handle.AnchorPoint = Vector2.new(0, 1)
                handle.BackgroundTransparency = 1
                handle.Parent = container
                self._resizeHandle = handle

                -- Resize grip
                local grip = Instance.new("Frame")
                grip.Size = UDim2.new(0, 30, 0, 3)
                grip.Position = UDim2.new(0.5, 0, 0.5, 0)
                grip.AnchorPoint = Vector2.new(0.5, 0.5)
                grip.BackgroundColor3 = Color3.fromRGB(82, 82, 91)
                grip.BorderSizePixel = 0
                grip.Parent = handle

                local gripCorner = Instance.new("UICorner")
                gripCorner.CornerRadius = UDim.new(1, 0)
                gripCorner.Parent = grip
            end

            -- Setup interactions
            self:_setupInteractions()

            return self
        end

        --// Update character count
        function TextArea:_updateCharCount()
            if not self._charCount then return end

            local len = #self.Text

            if self.MaxLength > 0 then
                self._charCount.Text = len .. "/" .. self.MaxLength
                self._charCount.TextColor3 = len >= self.MaxLength and 
                    Color3.fromRGB(239, 68, 68) or Color3.fromRGB(113, 113, 122)
            else
                self._charCount.Text = tostring(len)
            end
        end

        --// Setup interactions
        function TextArea:_setupInteractions()
            local textBox = self._textBox
            local stroke = self._stroke

            -- Focus
            self:_connect(textBox.Focused, function()
                self._isFocused = true

                TweenService:Create(stroke, TweenInfo.new(0.15), {
                    Color = Color3.fromRGB(99, 102, 241),
                }):Play()

                TweenService:Create(self.Instance, TweenInfo.new(0.15), {
                    BackgroundColor3 = Color3.fromRGB(35, 35, 42),
                }):Play()

                if self.OnFocus then
                    self.OnFocus()
                end

                self:_fire("Focus")
            end)

            -- Focus lost
            self:_connect(textBox.FocusLost, function(enterPressed)
                self._isFocused = false

                TweenService:Create(stroke, TweenInfo.new(0.15), {
                    Color = Color3.fromRGB(63, 63, 70),
                }):Play()

                TweenService:Create(self.Instance, TweenInfo.new(0.15), {
                    BackgroundColor3 = Color3.fromRGB(30, 30, 35),
                }):Play()

                if self.OnFocusLost then
                    self.OnFocusLost(enterPressed)
                end

                self:_fire("FocusLost", enterPressed)
            end)

            -- Text changed
            self:_connect(textBox:GetPropertyChangedSignal("Text"), function()
                local text = textBox.Text

                -- Max length
                if self.MaxLength > 0 and #text > self.MaxLength then
                    textBox.Text = string.sub(text, 1, self.MaxLength)
                    return
                end

                self.Text = text
                self:_updateCharCount()

                if self.OnTextChanged then
                    self.OnTextChanged(text)
                end

                self:_fire("TextChanged", text)
            end)

            -- Hover
            self:_connect(self.Instance.MouseEnter, function()
                if not self._isFocused then
                    TweenService:Create(stroke, TweenInfo.new(0.15), {
                        Color = Color3.fromRGB(82, 82, 91),
                    }):Play()
                end
            end)

            self:_connect(self.Instance.MouseLeave, function()
                if not self._isFocused then
                    TweenService:Create(stroke, TweenInfo.new(0.15), {
                        Color = Color3.fromRGB(63, 63, 70),
                    }):Play()
                end
            end)
        end

        --// Set text
        function TextArea:SetText(text)
            self.Text = text

            if self._textBox then
                self._textBox.Text = text
            end

            self:_updateCharCount()

            return self
        end

        --// Get text
        function TextArea:GetText()
            return self.Text
        end

        --// Set placeholder
        function TextArea:SetPlaceholder(placeholder)
            self.Placeholder = placeholder

            if self._textBox then
                self._textBox.PlaceholderText = placeholder
            end

            return self
        end

        --// Focus
        function TextArea:Focus()
            if self._textBox then
                self._textBox:CaptureFocus()
            end
            return self
        end

        --// Clear
        function TextArea:Clear()
            return self:SetText("")
        end

        --// Set read only
        function TextArea:SetReadOnly(readOnly)
            self.ReadOnly = readOnly

            if self._textBox then
                self._textBox.TextEditable = not readOnly
            end

            return self
        end

        --// Get line count
        function TextArea:GetLineCount()
            local _, count = string.gsub(self.Text, "\n", "\n")
            return count + 1
        end

        return TextArea


    end


    -- ============================================================================
    -- Module: NexusUI/Components/SearchInput
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/SearchInput"] = function()
        local script = CreateMockScript("NexusUI/Components/SearchInput")

        --[[
            NexusUI SearchInput Component
            Search input with icon and clear button
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// SearchInput Component Module
        local SearchInput = setmetatable({}, { __index = Base })
        SearchInput.__index = SearchInput
        SearchInput.ClassName = "SearchInput"

        --// Constructor
        function SearchInput.new(config)
            local self = setmetatable(Base.new(config), SearchInput)

            config = config or {}

            self.Text = config.Text or ""
            self.Placeholder = config.Placeholder or "Search..."
            self.DebounceTime = config.DebounceTime or 0.3
            self.ClearButton = config.ClearButton ~= false

            -- Callbacks
            self.OnSearch = config.OnSearch
            self.OnTextChanged = config.OnTextChanged
            self.OnClear = config.OnClear

            -- State
            self._debounceThread = nil

            return self
        end

        --// Create search input
        function SearchInput:Create(parent)
            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(1, 0, 0, 36)
            container.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            container.BorderSizePixel = 0

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Corner
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = container

            -- Border
            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(63, 63, 70)
            stroke.Thickness = 1
            stroke.Parent = container
            self._stroke = stroke

            -- Padding
            local padding = Instance.new("UIPadding")
            padding.PaddingLeft = UDim.new(0, 12)
            padding.PaddingRight = UDim.new(0, 12)
            padding.Parent = container

            -- Layout
            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Horizontal
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.Padding = UDim.new(0, 8)
            layout.Parent = container

            -- Search icon
            local searchIcon = Instance.new("ImageLabel")
            searchIcon.Name = "SearchIcon"
            searchIcon.Size = UDim2.new(0, 16, 0, 16)
            searchIcon.BackgroundTransparency = 1
            searchIcon.Image = "rbxassetid://7072718929"
            searchIcon.ImageColor3 = Color3.fromRGB(113, 113, 122)
            searchIcon.LayoutOrder = 1
            searchIcon.Parent = container
            self._searchIcon = searchIcon

            -- Text box
            local textBox = Instance.new("TextBox")
            textBox.Name = "Input"
            textBox.Size = UDim2.new(1, -50, 1, 0)
            textBox.BackgroundTransparency = 1
            textBox.Font = Enum.Font.Gotham
            textBox.Text = self.Text
            textBox.PlaceholderText = self.Placeholder
            textBox.PlaceholderColor3 = Color3.fromRGB(113, 113, 122)
            textBox.TextColor3 = Color3.fromRGB(250, 250, 250)
            textBox.TextSize = 14
            textBox.TextXAlignment = Enum.TextXAlignment.Left
            textBox.ClearTextOnFocus = false
            textBox.LayoutOrder = 2
            textBox.Parent = container
            self._textBox = textBox

            -- Clear button
            if self.ClearButton then
                local clearBtn = Instance.new("ImageButton")
                clearBtn.Name = "ClearButton"
                clearBtn.Size = UDim2.new(0, 16, 0, 16)
                clearBtn.BackgroundTransparency = 1
                clearBtn.Image = "rbxassetid://7072725342"
                clearBtn.ImageColor3 = Color3.fromRGB(113, 113, 122)
                clearBtn.Visible = #self.Text > 0
                clearBtn.LayoutOrder = 3
                clearBtn.Parent = container
                self._clearButton = clearBtn

                self:_connect(clearBtn.MouseButton1Click, function()
                    self:Clear()
                    textBox:CaptureFocus()
                end)

                self:_connect(clearBtn.MouseEnter, function()
                    TweenService:Create(clearBtn, TweenInfo.new(0.1), {
                        ImageColor3 = Color3.fromRGB(250, 250, 250),
                    }):Play()
                end)

                self:_connect(clearBtn.MouseLeave, function()
                    TweenService:Create(clearBtn, TweenInfo.new(0.1), {
                        ImageColor3 = Color3.fromRGB(113, 113, 122),
                    }):Play()
                end)
            end

            -- Loading spinner (hidden by default)
            local spinner = Instance.new("ImageLabel")
            spinner.Name = "Spinner"
            spinner.Size = UDim2.new(0, 16, 0, 16)
            spinner.BackgroundTransparency = 1
            spinner.Image = "rbxassetid://6034818372"
            spinner.ImageColor3 = Color3.fromRGB(99, 102, 241)
            spinner.Visible = false
            spinner.LayoutOrder = 4
            spinner.Parent = container
            self._spinner = spinner

            -- Setup interactions
            self:_setupInteractions()

            return self
        end

        --// Setup interactions
        function SearchInput:_setupInteractions()
            local textBox = self._textBox
            local stroke = self._stroke

            -- Focus
            self:_connect(textBox.Focused, function()
                TweenService:Create(stroke, TweenInfo.new(0.15), {
                    Color = Color3.fromRGB(99, 102, 241),
                }):Play()

                TweenService:Create(self._searchIcon, TweenInfo.new(0.15), {
                    ImageColor3 = Color3.fromRGB(99, 102, 241),
                }):Play()
            end)

            -- Focus lost
            self:_connect(textBox.FocusLost, function(enterPressed)
                TweenService:Create(stroke, TweenInfo.new(0.15), {
                    Color = Color3.fromRGB(63, 63, 70),
                }):Play()

                TweenService:Create(self._searchIcon, TweenInfo.new(0.15), {
                    ImageColor3 = Color3.fromRGB(113, 113, 122),
                }):Play()

                -- Trigger search on enter
                if enterPressed and self.OnSearch then
                    self.OnSearch(self.Text)
                end
            end)

            -- Text changed
            self:_connect(textBox:GetPropertyChangedSignal("Text"), function()
                local text = textBox.Text
                self.Text = text

                -- Update clear button
                if self._clearButton then
                    self._clearButton.Visible = #text > 0
                end

                -- Callback
                if self.OnTextChanged then
                    self.OnTextChanged(text)
                end

                -- Debounced search
                if self._debounceThread then
                    task.cancel(self._debounceThread)
                end

                if self.OnSearch and #text > 0 then
                    self._debounceThread = task.delay(self.DebounceTime, function()
                        self.OnSearch(text)
                    end)
                end

                self:_fire("TextChanged", text)
            end)

            -- Hover
            self:_connect(self.Instance.MouseEnter, function()
                TweenService:Create(stroke, TweenInfo.new(0.15), {
                    Color = Color3.fromRGB(82, 82, 91),
                }):Play()
            end)

            self:_connect(self.Instance.MouseLeave, function()
                if not textBox:IsFocused() then
                    TweenService:Create(stroke, TweenInfo.new(0.15), {
                        Color = Color3.fromRGB(63, 63, 70),
                    }):Play()
                end
            end)
        end

        --// Set text
        function SearchInput:SetText(text)
            self.Text = text

            if self._textBox then
                self._textBox.Text = text
            end

            return self
        end

        --// Get text
        function SearchInput:GetText()
            return self.Text
        end

        --// Clear
        function SearchInput:Clear()
            self.Text = ""

            if self._textBox then
                self._textBox.Text = ""
            end

            if self.OnClear then
                self.OnClear()
            end

            self:_fire("Clear")

            return self
        end

        --// Show loading
        function SearchInput:ShowLoading(show)
            if self._spinner then
                self._spinner.Visible = show

                if show then
                    -- Spin animation
                    task.spawn(function()
                        while self._spinner and self._spinner.Visible do
                            self._spinner.Rotation = self._spinner.Rotation + 10
                            task.wait(0.02)
                        end
                    end)
                end
            end

            return self
        end

        --// Focus
        function SearchInput:Focus()
            if self._textBox then
                self._textBox:CaptureFocus()
            end
            return self
        end

        --// Destroy override
        function SearchInput:Destroy()
            if self._debounceThread then
                task.cancel(self._debounceThread)
            end

            Base.Destroy(self)
        end

        return SearchInput


    end


    -- ============================================================================
    -- Module: NexusUI/Components/Sidebar
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/Sidebar"] = function()
        local script = CreateMockScript("NexusUI/Components/Sidebar")

        --[[
            NexusUI Sidebar Component
            Navigation sidebar with items
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// Sidebar Component Module
        local Sidebar = setmetatable({}, { __index = Base })
        Sidebar.__index = Sidebar
        Sidebar.ClassName = "Sidebar"

        --// Constructor
        function Sidebar.new(config)
            local self = setmetatable(Base.new(config), Sidebar)

            config = config or {}

            self.Items = config.Items or {} -- Array of {Id, Text, Icon, Badge, Disabled, SubItems}
            self.SelectedId = config.SelectedId
            self.Width = config.Width or 240
            self.Collapsible = config.Collapsible or false
            self.IsCollapsed = config.IsCollapsed or false
            self.CollapsedWidth = config.CollapsedWidth or 60
            self.Header = config.Header -- {Title, Logo}
            self.Footer = config.Footer -- Content for footer

            -- Callbacks
            self.OnItemSelect = config.OnItemSelect
            self.OnCollapse = config.OnCollapse

            -- State
            self._itemButtons = {}

            return self
        end

        --// Create sidebar
        function Sidebar:Create(parent)
            -- Container
            local sidebar = Instance.new("Frame")
            sidebar.Name = self.Name
            sidebar.Size = UDim2.new(0, self.IsCollapsed and self.CollapsedWidth or self.Width, 1, 0)
            sidebar.BackgroundColor3 = Color3.fromRGB(24, 24, 27)
            sidebar.BorderSizePixel = 0
            sidebar.ClipsDescendants = true

            if parent then
                sidebar.Parent = parent
            end

            self.Instance = sidebar

            -- Border
            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(63, 63, 70)
            stroke.Thickness = 1
            stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
            stroke.Parent = sidebar

            -- Header
            if self.Header then
                local header = Instance.new("Frame")
                header.Name = "Header"
                header.Size = UDim2.new(1, 0, 0, 60)
                header.BackgroundTransparency = 1
                header.Parent = sidebar

                local headerPadding = Instance.new("UIPadding")
                headerPadding.PaddingLeft = UDim.new(0, 16)
                headerPadding.PaddingRight = UDim.new(0, 16)
                headerPadding.Parent = header

                local headerLayout = Instance.new("UIListLayout")
                headerLayout.FillDirection = Enum.FillDirection.Horizontal
                headerLayout.VerticalAlignment = Enum.VerticalAlignment.Center
                headerLayout.Padding = UDim.new(0, 12)
                headerLayout.Parent = header

                if self.Header.Logo then
                    local logo = Instance.new("ImageLabel")
                    logo.Size = UDim2.new(0, 28, 0, 28)
                    logo.BackgroundTransparency = 1
                    logo.Image = self.Header.Logo
                    logo.LayoutOrder = 1
                    logo.Parent = header
                    self._logo = logo
                end

                if self.Header.Title then
                    local title = Instance.new("TextLabel")
                    title.Name = "Title"
                    title.Size = UDim2.new(1, -40, 1, 0)
                    title.BackgroundTransparency = 1
                    title.Font = Enum.Font.GothamBold
                    title.Text = self.Header.Title
                    title.TextColor3 = Color3.fromRGB(250, 250, 250)
                    title.TextSize = 16
                    title.TextXAlignment = Enum.TextXAlignment.Left
                    title.TextTruncate = Enum.TextTruncate.AtEnd
                    title.LayoutOrder = 2
                    title.Visible = not self.IsCollapsed
                    title.Parent = header
                    self._title = title
                end

                -- Divider
                local divider = Instance.new("Frame")
                divider.Size = UDim2.new(1, -32, 0, 1)
                divider.Position = UDim2.new(0.5, 0, 0, 60)
                divider.AnchorPoint = Vector2.new(0.5, 0)
                divider.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
                divider.BorderSizePixel = 0
                divider.Parent = sidebar
            end

            -- Items container
            local itemsContainer = Instance.new("ScrollingFrame")
            itemsContainer.Name = "Items"
            itemsContainer.Size = UDim2.new(1, 0, 1, self.Header and -70 or -10)
            itemsContainer.Position = UDim2.new(0, 0, 0, self.Header and 70 or 10)
            itemsContainer.BackgroundTransparency = 1
            itemsContainer.BorderSizePixel = 0
            itemsContainer.ScrollBarThickness = 4
            itemsContainer.ScrollBarImageColor3 = Color3.fromRGB(82, 82, 91)
            itemsContainer.CanvasSize = UDim2.new(0, 0, 0, 0)
            itemsContainer.AutomaticCanvasSize = Enum.AutomaticSize.Y
            itemsContainer.Parent = sidebar
            self._itemsContainer = itemsContainer

            local itemsPadding = Instance.new("UIPadding")
            itemsPadding.PaddingTop = UDim.new(0, 4)
            itemsPadding.PaddingBottom = UDim.new(0, 4)
            itemsPadding.PaddingLeft = UDim.new(0, 8)
            itemsPadding.PaddingRight = UDim.new(0, 8)
            itemsPadding.Parent = itemsContainer

            local itemsLayout = Instance.new("UIListLayout")
            itemsLayout.Padding = UDim.new(0, 2)
            itemsLayout.SortOrder = Enum.SortOrder.LayoutOrder
            itemsLayout.Parent = itemsContainer

            -- Build items
            self:_buildItems()

            -- Collapse button
            if self.Collapsible then
                local collapseBtn = Instance.new("TextButton")
                collapseBtn.Name = "CollapseBtn"
                collapseBtn.Size = UDim2.new(0, 32, 0, 32)
                collapseBtn.Position = UDim2.new(1, -40, 0, 14)
                collapseBtn.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
                collapseBtn.BackgroundTransparency = 1
                collapseBtn.BorderSizePixel = 0
                collapseBtn.Font = Enum.Font.GothamBold
                collapseBtn.Text = self.IsCollapsed and "›" or "‹"
                collapseBtn.TextColor3 = Color3.fromRGB(161, 161, 170)
                collapseBtn.TextSize = 18
                collapseBtn.AutoButtonColor = false
                collapseBtn.Parent = sidebar
                self._collapseBtn = collapseBtn

                local collapseBtnCorner = Instance.new("UICorner")
                collapseBtnCorner.CornerRadius = UDim.new(0, 6)
                collapseBtnCorner.Parent = collapseBtn

                self:_connect(collapseBtn.MouseButton1Click, function()
                    self:ToggleCollapse()
                end)

                self:_connect(collapseBtn.MouseEnter, function()
                    TweenService:Create(collapseBtn, TweenInfo.new(0.1), {
                        BackgroundTransparency = 0,
                    }):Play()
                end)

                self:_connect(collapseBtn.MouseLeave, function()
                    TweenService:Create(collapseBtn, TweenInfo.new(0.1), {
                        BackgroundTransparency = 1,
                    }):Play()
                end)
            end

            return self
        end

        --// Build items
        function Sidebar:_buildItems()
            -- Clear existing
            for _, btn in ipairs(self._itemButtons) do
                btn:Destroy()
            end
            self._itemButtons = {}

            local function createItem(item, layoutOrder, depth)
                local isSelected = item.Id == self.SelectedId
                local isDisabled = item.Disabled

                local btn = Instance.new("TextButton")
                btn.Name = "Item_" .. item.Id
                btn.Size = UDim2.new(1, 0, 0, 40)
                btn.BackgroundColor3 = isSelected and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(39, 39, 42)
                btn.BackgroundTransparency = isSelected and 0.9 or 1
                btn.BorderSizePixel = 0
                btn.Text = ""
                btn.AutoButtonColor = false
                btn.LayoutOrder = layoutOrder
                btn.Parent = self._itemsContainer

                local btnCorner = Instance.new("UICorner")
                btnCorner.CornerRadius = UDim.new(0, 6)
                btnCorner.Parent = btn

                local btnPadding = Instance.new("UIPadding")
                btnPadding.PaddingLeft = UDim.new(0, 12 + depth * 16)
                btnPadding.PaddingRight = UDim.new(0, 12)
                btnPadding.Parent = btn

                local btnLayout = Instance.new("UIListLayout")
                btnLayout.FillDirection = Enum.FillDirection.Horizontal
                btnLayout.VerticalAlignment = Enum.VerticalAlignment.Center
                btnLayout.Padding = UDim.new(0, 10)
                btnLayout.Parent = btn

                -- Icon
                if item.Icon then
                    local icon = Instance.new("ImageLabel")
                    icon.Size = UDim2.new(0, 18, 0, 18)
                    icon.BackgroundTransparency = 1
                    icon.Image = item.Icon
                    icon.ImageColor3 = isSelected and Color3.fromRGB(99, 102, 241) or 
                        (isDisabled and Color3.fromRGB(82, 82, 91) or Color3.fromRGB(161, 161, 170))
                    icon.LayoutOrder = 1
                    icon.Parent = btn
                end

                -- Text
                if not self.IsCollapsed then
                    local text = Instance.new("TextLabel")
                    text.Size = UDim2.new(1, item.Badge and -46 or -18, 1, 0)
                    text.BackgroundTransparency = 1
                    text.Font = Enum.Font.GothamMedium
                    text.Text = item.Text
                    text.TextColor3 = isSelected and Color3.fromRGB(99, 102, 241) or 
                        (isDisabled and Color3.fromRGB(82, 82, 91) or Color3.fromRGB(250, 250, 250))
                    text.TextSize = 13
                    text.TextXAlignment = Enum.TextXAlignment.Left
                    text.TextTruncate = Enum.TextTruncate.AtEnd
                    text.LayoutOrder = 2
                    text.Parent = btn

                    -- Badge
                    if item.Badge then
                        local badge = Instance.new("Frame")
                        badge.Size = UDim2.new(0, 0, 0, 18)
                        badge.AutomaticSize = Enum.AutomaticSize.X
                        badge.BackgroundColor3 = Color3.fromRGB(239, 68, 68)
                        badge.BorderSizePixel = 0
                        badge.LayoutOrder = 3
                        badge.Parent = btn

                        local badgeCorner = Instance.new("UICorner")
                        badgeCorner.CornerRadius = UDim.new(1, 0)
                        badgeCorner.Parent = badge

                        local badgePadding = Instance.new("UIPadding")
                        badgePadding.PaddingLeft = UDim.new(0, 6)
                        badgePadding.PaddingRight = UDim.new(0, 6)
                        badgePadding.Parent = badge

                        local badgeText = Instance.new("TextLabel")
                        badgeText.Size = UDim2.new(0, 0, 1, 0)
                        badgeText.AutomaticSize = Enum.AutomaticSize.X
                        badgeText.BackgroundTransparency = 1
                        badgeText.Font = Enum.Font.GothamBold
                        badgeText.Text = tostring(item.Badge)
                        badgeText.TextColor3 = Color3.fromRGB(255, 255, 255)
                        badgeText.TextSize = 10
                        badgeText.Parent = badge
                    end
                end

                -- Interactions
                if not isDisabled then
                    self:_connect(btn.MouseButton1Click, function()
                        self:SelectItem(item.Id)
                    end)

                    self:_connect(btn.MouseEnter, function()
                        if not isSelected then
                            TweenService:Create(btn, TweenInfo.new(0.1), {
                                BackgroundTransparency = 0.8,
                            }):Play()
                        end
                    end)

                    self:_connect(btn.MouseLeave, function()
                        if not isSelected then
                            TweenService:Create(btn, TweenInfo.new(0.1), {
                                BackgroundTransparency = 1,
                            }):Play()
                        end
                    end)
                end

                table.insert(self._itemButtons, btn)

                return layoutOrder + 1
            end

            local layoutOrder = 0
            for _, item in ipairs(self.Items) do
                layoutOrder = createItem(item, layoutOrder, 0)

                -- Sub items
                if item.SubItems then
                    for _, subItem in ipairs(item.SubItems) do
                        layoutOrder = createItem(subItem, layoutOrder, 1)
                    end
                end
            end
        end

        --// Select item
        function Sidebar:SelectItem(itemId)
            if itemId == self.SelectedId then return self end

            local oldId = self.SelectedId
            self.SelectedId = itemId

            self:_buildItems()

            -- Find item data
            local itemData
            for _, item in ipairs(self.Items) do
                if item.Id == itemId then
                    itemData = item
                    break
                end
                if item.SubItems then
                    for _, subItem in ipairs(item.SubItems) do
                        if subItem.Id == itemId then
                            itemData = subItem
                            break
                        end
                    end
                end
            end

            if self.OnItemSelect then
                self.OnItemSelect(itemId, itemData, oldId)
            end

            self:_fire("ItemSelect", itemId, itemData, oldId)

            return self
        end

        --// Toggle collapse
        function Sidebar:ToggleCollapse()
            self.IsCollapsed = not self.IsCollapsed

            local targetWidth = self.IsCollapsed and self.CollapsedWidth or self.Width

            TweenService:Create(self.Instance, TweenInfo.new(0.2), {
                Size = UDim2.new(0, targetWidth, 1, 0),
            }):Play()

            if self._title then
                self._title.Visible = not self.IsCollapsed
            end

            if self._collapseBtn then
                self._collapseBtn.Text = self.IsCollapsed and "›" or "‹"
            end

            self:_buildItems()

            if self.OnCollapse then
                self.OnCollapse(self.IsCollapsed)
            end

            self:_fire("Collapse", self.IsCollapsed)

            return self
        end

        --// Set items
        function Sidebar:SetItems(items)
            self.Items = items
            self:_buildItems()
            return self
        end

        return Sidebar


    end


    -- ============================================================================
    -- Module: NexusUI/Components/NumberInput
    -- ============================================================================
    NexusUI_Modules["NexusUI/Components/NumberInput"] = function()
        local script = CreateMockScript("NexusUI/Components/NumberInput")

        --[[
            NexusUI NumberInput Component
            Number input with increment/decrement buttons
        ]]

        --// Services
        local TweenService = game:GetService("TweenService")

        --// Dependencies
        local Base = NexusRequire("NexusUI/Base")

        --// NumberInput Component Module
        local NumberInput = setmetatable({}, { __index = Base })
        NumberInput.__index = NumberInput
        NumberInput.ClassName = "NumberInput"

        --// Constructor
        function NumberInput.new(config)
            local self = setmetatable(Base.new(config), NumberInput)

            config = config or {}

            self.Value = config.Value or 0
            self.Min = config.Min or -math.huge
            self.Max = config.Max or math.huge
            self.Step = config.Step or 1
            self.Precision = config.Precision or 0 -- Decimal places
            self.Label = config.Label
            self.Prefix = config.Prefix or ""
            self.Suffix = config.Suffix or ""
            self.ShowButtons = config.ShowButtons ~= false

            -- Callbacks
            self.OnValueChanged = config.OnValueChanged

            -- State
            self._holdThread = nil

            return self
        end

        --// Format value
        function NumberInput:_formatValue(value)
            local formatted = string.format("%." .. self.Precision .. "f", value)
            return self.Prefix .. formatted .. self.Suffix
        end

        --// Create number input
        function NumberInput:Create(parent)
            -- Container
            local container = Instance.new("Frame")
            container.Name = self.Name
            container.Size = UDim2.new(1, 0, 0, 40)
            container.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            container.BorderSizePixel = 0

            if parent then
                container.Parent = parent
            end

            self.Instance = container

            -- Corner
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 8)
            corner.Parent = container

            -- Border
            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(63, 63, 70)
            stroke.Thickness = 1
            stroke.Parent = container
            self._stroke = stroke

            -- Layout
            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Horizontal
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.Parent = container

            -- Decrement button
            if self.ShowButtons then
                local decrementBtn = Instance.new("TextButton")
                decrementBtn.Name = "Decrement"
                decrementBtn.Size = UDim2.new(0, 40, 1, 0)
                decrementBtn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
                decrementBtn.BorderSizePixel = 0
                decrementBtn.Font = Enum.Font.GothamBold
                decrementBtn.Text = "-"
                decrementBtn.TextColor3 = Color3.fromRGB(250, 250, 250)
                decrementBtn.TextSize = 18
                decrementBtn.AutoButtonColor = false
                decrementBtn.LayoutOrder = 1
                decrementBtn.Parent = container
                self._decrementBtn = decrementBtn

                local decCorner = Instance.new("UICorner")
                decCorner.CornerRadius = UDim.new(0, 8)
                decCorner.Parent = decrementBtn

                -- Only round left corners
                local decFix = Instance.new("Frame")
                decFix.Size = UDim2.new(0.5, 0, 1, 0)
                decFix.Position = UDim2.new(0.5, 0, 0, 0)
                decFix.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
                decFix.BorderSizePixel = 0
                decFix.ZIndex = decrementBtn.ZIndex - 1
                decFix.Parent = decrementBtn
            end

            -- Text input
            local textBox = Instance.new("TextBox")
            textBox.Name = "Input"
            textBox.Size = self.ShowButtons and UDim2.new(1, -80, 1, 0) or UDim2.new(1, 0, 1, 0)
            textBox.BackgroundTransparency = 1
            textBox.Font = Enum.Font.GothamMedium
            textBox.Text = self:_formatValue(self.Value)
            textBox.TextColor3 = Color3.fromRGB(250, 250, 250)
            textBox.TextSize = 14
            textBox.ClearTextOnFocus = false
            textBox.LayoutOrder = 2
            textBox.Parent = container
            self._textBox = textBox

            -- Increment button
            if self.ShowButtons then
                local incrementBtn = Instance.new("TextButton")
                incrementBtn.Name = "Increment"
                incrementBtn.Size = UDim2.new(0, 40, 1, 0)
                incrementBtn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
                incrementBtn.BorderSizePixel = 0
                incrementBtn.Font = Enum.Font.GothamBold
                incrementBtn.Text = "+"
                incrementBtn.TextColor3 = Color3.fromRGB(250, 250, 250)
                incrementBtn.TextSize = 18
                incrementBtn.AutoButtonColor = false
                incrementBtn.LayoutOrder = 3
                incrementBtn.Parent = container
                self._incrementBtn = incrementBtn

                local incCorner = Instance.new("UICorner")
                incCorner.CornerRadius = UDim.new(0, 8)
                incCorner.Parent = incrementBtn

                -- Only round right corners
                local incFix = Instance.new("Frame")
                incFix.Size = UDim2.new(0.5, 0, 1, 0)
                incFix.Position = UDim2.new(0, 0, 0, 0)
                incFix.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
                incFix.BorderSizePixel = 0
                incFix.ZIndex = incrementBtn.ZIndex - 1
                incFix.Parent = incrementBtn
            end

            -- Setup interactions
            self:_setupInteractions()

            return self
        end

        --// Setup interactions
        function NumberInput:_setupInteractions()
            local textBox = self._textBox

            -- Text box focus lost
            self:_connect(textBox.FocusLost, function(enterPressed)
                local text = textBox.Text

                -- Remove prefix/suffix and parse
                text = string.gsub(text, "^" .. self.Prefix, "")
                text = string.gsub(text, self.Suffix .. "$", "")

                local num = tonumber(text)
                if num then
                    self:SetValue(num)
                else
                    textBox.Text = self:_formatValue(self.Value)
                end
            end)

            -- Button interactions
            if self.ShowButtons then
                -- Decrement
                self:_connect(self._decrementBtn.MouseButton1Click, function()
                    self:Decrement()
                end)

                self:_connect(self._decrementBtn.MouseButton1Down, function()
                    self:_startHold(-1)
                end)

                self:_connect(self._decrementBtn.MouseButton1Up, function()
                    self:_stopHold()
                end)

                self:_connect(self._decrementBtn.MouseLeave, function()
                    self:_stopHold()
                end)

                -- Increment
                self:_connect(self._incrementBtn.MouseButton1Click, function()
                    self:Increment()
                end)

                self:_connect(self._incrementBtn.MouseButton1Down, function()
                    self:_startHold(1)
                end)

                self:_connect(self._incrementBtn.MouseButton1Up, function()
                    self:_stopHold()
                end)

                self:_connect(self._incrementBtn.MouseLeave, function()
                    self:_stopHold()
                end)

                -- Hover effects
                local function setupButtonHover(btn)
                    self:_connect(btn.MouseEnter, function()
                        TweenService:Create(btn, TweenInfo.new(0.15), {
                            BackgroundColor3 = Color3.fromRGB(52, 52, 58),
                        }):Play()
                    end)

                    self:_connect(btn.MouseLeave, function()
                        TweenService:Create(btn, TweenInfo.new(0.15), {
                            BackgroundColor3 = Color3.fromRGB(39, 39, 42),
                        }):Play()
                    end)
                end

                setupButtonHover(self._decrementBtn)
                setupButtonHover(self._incrementBtn)
            end
        end

        --// Start hold (for continuous increment/decrement)
        function NumberInput:_startHold(direction)
            self:_stopHold()

            self._holdThread = task.spawn(function()
                task.wait(0.5) -- Initial delay

                while self._holdThread do
                    if direction > 0 then
                        self:Increment()
                    else
                        self:Decrement()
                    end
                    task.wait(0.1) -- Repeat rate
                end
            end)
        end

        --// Stop hold
        function NumberInput:_stopHold()
            if self._holdThread then
                task.cancel(self._holdThread)
                self._holdThread = nil
            end
        end

        --// Set value
        function NumberInput:SetValue(value, animate)
            value = math.clamp(value, self.Min, self.Max)

            -- Round to precision
            local multiplier = 10 ^ self.Precision
            value = math.round(value * multiplier) / multiplier

            if self.Value == value then return self end

            local oldValue = self.Value
            self.Value = value

            if self._textBox then
                self._textBox.Text = self:_formatValue(value)
            end

            if self.OnValueChanged then
                self.OnValueChanged(value, oldValue)
            end

            self:_fire("ValueChanged", value, oldValue)

            return self
        end

        --// Get value
        function NumberInput:GetValue()
            return self.Value
        end

        --// Increment
        function NumberInput:Increment(amount)
            return self:SetValue(self.Value + (amount or self.Step))
        end

        --// Decrement
        function NumberInput:Decrement(amount)
            return self:SetValue(self.Value - (amount or self.Step))
        end

        --// Set range
        function NumberInput:SetRange(min, max)
            self.Min = min
            self.Max = max
            self:SetValue(math.clamp(self.Value, min, max))
            return self
        end

        --// Destroy override
        function NumberInput:Destroy()
            self:_stopHold()
            Base.Destroy(self)
        end

        return NumberInput


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/init
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/init"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/init")

        --[[
            NexusUI Theme Presets
            25+ beautiful pre-built themes
        ]]

        --// Presets Module
        local Presets = {}

        -- Load all preset themes
        Presets.Dark = NexusRequire("NexusUI/Themes/Presets/Dark")
        Presets.Light = NexusRequire("NexusUI/Themes/Presets/Light")
        Presets.Midnight = NexusRequire("NexusUI/Themes/Presets/Midnight")
        Presets.Ocean = NexusRequire("NexusUI/Themes/Presets/Ocean")
        Presets.Forest = NexusRequire("NexusUI/Themes/Presets/Forest")
        Presets.Sunset = NexusRequire("NexusUI/Themes/Presets/Sunset")
        Presets.Neon = NexusRequire("NexusUI/Themes/Presets/Neon")
        Presets.Cyberpunk = NexusRequire("NexusUI/Themes/Presets/Cyberpunk")
        Presets.Synthwave = NexusRequire("NexusUI/Themes/Presets/Synthwave")
        Presets.Nord = NexusRequire("NexusUI/Themes/Presets/Nord")
        Presets.Dracula = NexusRequire("NexusUI/Themes/Presets/Dracula")
        Presets.Monokai = NexusRequire("NexusUI/Themes/Presets/Monokai")
        Presets.Gruvbox = NexusRequire("NexusUI/Themes/Presets/Gruvbox")
        Presets.TokyoNight = NexusRequire("NexusUI/Themes/Presets/TokyoNight")
        Presets.OneDark = NexusRequire("NexusUI/Themes/Presets/OneDark")
        Presets.Catppuccin = NexusRequire("NexusUI/Themes/Presets/Catppuccin")
        Presets.Rose = NexusRequire("NexusUI/Themes/Presets/Rose")
        Presets.Lavender = NexusRequire("NexusUI/Themes/Presets/Lavender")
        Presets.Mint = NexusRequire("NexusUI/Themes/Presets/Mint")
        Presets.Coral = NexusRequire("NexusUI/Themes/Presets/Coral")
        Presets.Golden = NexusRequire("NexusUI/Themes/Presets/Golden")
        Presets.Crimson = NexusRequire("NexusUI/Themes/Presets/Crimson")
        Presets.Arctic = NexusRequire("NexusUI/Themes/Presets/Arctic")
        Presets.Volcanic = NexusRequire("NexusUI/Themes/Presets/Volcanic")
        Presets.Matrix = NexusRequire("NexusUI/Themes/Presets/Matrix")

        -- Register all themes with manager
        function Presets.RegisterAll()
            local Manager = NexusRequire("NexusUI/Themes/Manager")

            for name, theme in pairs(Presets) do
                if type(theme) == "table" and theme.Name then
                    Manager.RegisterTheme(theme)
                end
            end
        end

        -- Get all preset names
        function Presets.GetNames()
            local names = {}

            for name, theme in pairs(Presets) do
                if type(theme) == "table" and theme.Name then
                    table.insert(names, name)
                end
            end

            return names
        end

        -- Get preset by name
        function Presets.Get(name)
            return Presets[name]
        end

        return Presets


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Gruvbox
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Gruvbox"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Gruvbox")

        --[[
            NexusUI Gruvbox Theme
            Retro groove color scheme
        ]]

        return {
            Name = "Gruvbox",

            Colors = {
                Primary = Color3.fromRGB(215, 153, 33),
                PrimaryHover = Color3.fromRGB(250, 189, 47),
                PrimaryPressed = Color3.fromRGB(180, 125, 25),
                PrimaryFaded = Color3.fromRGB(102, 92, 84),

                Secondary = Color3.fromRGB(146, 131, 116),
                SecondaryHover = Color3.fromRGB(168, 153, 132),
                SecondaryPressed = Color3.fromRGB(124, 111, 100),

                Accent = Color3.fromRGB(211, 134, 155),
                AccentHover = Color3.fromRGB(230, 165, 185),
                AccentPressed = Color3.fromRGB(177, 98, 134),

                Background = Color3.fromRGB(40, 40, 40),
                BackgroundAlt = Color3.fromRGB(50, 48, 47),
                BackgroundElevated = Color3.fromRGB(60, 56, 54),
                BackgroundFloating = Color3.fromRGB(80, 73, 69),

                Surface = Color3.fromRGB(50, 48, 47),
                SurfaceHover = Color3.fromRGB(80, 73, 69),
                SurfaceActive = Color3.fromRGB(102, 92, 84),

                Border = Color3.fromRGB(80, 73, 69),
                BorderFocused = Color3.fromRGB(215, 153, 33),
                BorderError = Color3.fromRGB(204, 36, 29),

                Text = Color3.fromRGB(235, 219, 178),
                TextSecondary = Color3.fromRGB(189, 174, 147),
                TextMuted = Color3.fromRGB(146, 131, 116),
                TextInverse = Color3.fromRGB(40, 40, 40),

                Success = Color3.fromRGB(152, 151, 26),
                SuccessHover = Color3.fromRGB(184, 187, 38),
                Warning = Color3.fromRGB(215, 153, 33),
                WarningHover = Color3.fromRGB(250, 189, 47),
                Error = Color3.fromRGB(204, 36, 29),
                ErrorHover = Color3.fromRGB(251, 73, 52),
                Info = Color3.fromRGB(69, 133, 136),
                InfoHover = Color3.fromRGB(131, 165, 152),

                Overlay = Color3.fromRGB(28, 28, 28),
                OverlayTransparency = 0.4,
                Shadow = Color3.fromRGB(28, 28, 28),
                ShadowTransparency = 0.5,
                Glow = Color3.fromRGB(215, 153, 33),
                GlowTransparency = 0.7,

                ScrollbarTrack = Color3.fromRGB(60, 56, 54),
                ScrollbarThumb = Color3.fromRGB(215, 153, 33),
                ScrollbarThumbHover = Color3.fromRGB(250, 189, 47),
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Golden
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Golden"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Golden")

        --[[
            NexusUI Golden Theme
            Luxurious gold and black theme
        ]]

        return {
            Name = "Golden",

            Colors = {
                Primary = Color3.fromRGB(245, 158, 11),
                PrimaryHover = Color3.fromRGB(251, 191, 36),
                PrimaryPressed = Color3.fromRGB(217, 119, 6),
                PrimaryFaded = Color3.fromRGB(120, 53, 15),

                Secondary = Color3.fromRGB(113, 113, 122),
                SecondaryHover = Color3.fromRGB(161, 161, 170),
                SecondaryPressed = Color3.fromRGB(82, 82, 91),

                Accent = Color3.fromRGB(252, 211, 77),
                AccentHover = Color3.fromRGB(253, 224, 71),
                AccentPressed = Color3.fromRGB(234, 179, 8),

                Background = Color3.fromRGB(12, 10, 8),
                BackgroundAlt = Color3.fromRGB(22, 18, 14),
                BackgroundElevated = Color3.fromRGB(32, 26, 20),
                BackgroundFloating = Color3.fromRGB(44, 36, 28),

                Surface = Color3.fromRGB(22, 18, 14),
                SurfaceHover = Color3.fromRGB(44, 36, 28),
                SurfaceActive = Color3.fromRGB(60, 50, 38),

                Border = Color3.fromRGB(80, 65, 50),
                BorderFocused = Color3.fromRGB(245, 158, 11),
                BorderError = Color3.fromRGB(239, 68, 68),

                Text = Color3.fromRGB(255, 251, 235),
                TextSecondary = Color3.fromRGB(254, 243, 199),
                TextMuted = Color3.fromRGB(253, 230, 138),
                TextInverse = Color3.fromRGB(12, 10, 8),

                Success = Color3.fromRGB(34, 197, 94),
                SuccessHover = Color3.fromRGB(74, 222, 128),
                Warning = Color3.fromRGB(245, 158, 11),
                WarningHover = Color3.fromRGB(251, 191, 36),
                Error = Color3.fromRGB(239, 68, 68),
                ErrorHover = Color3.fromRGB(248, 113, 113),
                Info = Color3.fromRGB(59, 130, 246),
                InfoHover = Color3.fromRGB(96, 165, 250),

                Overlay = Color3.fromRGB(6, 5, 4),
                OverlayTransparency = 0.5,
                Shadow = Color3.fromRGB(6, 5, 4),
                ShadowTransparency = 0.4,
                Glow = Color3.fromRGB(245, 158, 11),
                GlowTransparency = 0.5,

                ScrollbarTrack = Color3.fromRGB(44, 36, 28),
                ScrollbarThumb = Color3.fromRGB(245, 158, 11),
                ScrollbarThumbHover = Color3.fromRGB(251, 191, 36),
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Mint
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Mint"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Mint")

        --[[
            NexusUI Mint Theme
            Fresh mint green theme
        ]]

        return {
            Name = "Mint",

            Colors = {
                Primary = Color3.fromRGB(52, 211, 153),
                PrimaryHover = Color3.fromRGB(110, 231, 183),
                PrimaryPressed = Color3.fromRGB(16, 185, 129),
                PrimaryFaded = Color3.fromRGB(6, 95, 70),

                Secondary = Color3.fromRGB(100, 116, 139),
                SecondaryHover = Color3.fromRGB(148, 163, 184),
                SecondaryPressed = Color3.fromRGB(71, 85, 105),

                Accent = Color3.fromRGB(45, 212, 191),
                AccentHover = Color3.fromRGB(94, 234, 212),
                AccentPressed = Color3.fromRGB(20, 184, 166),

                Background = Color3.fromRGB(12, 20, 18),
                BackgroundAlt = Color3.fromRGB(18, 32, 28),
                BackgroundElevated = Color3.fromRGB(24, 44, 38),
                BackgroundFloating = Color3.fromRGB(32, 58, 50),

                Surface = Color3.fromRGB(18, 32, 28),
                SurfaceHover = Color3.fromRGB(32, 58, 50),
                SurfaceActive = Color3.fromRGB(45, 75, 65),

                Border = Color3.fromRGB(55, 90, 78),
                BorderFocused = Color3.fromRGB(52, 211, 153),
                BorderError = Color3.fromRGB(239, 68, 68),

                Text = Color3.fromRGB(236, 253, 245),
                TextSecondary = Color3.fromRGB(167, 243, 208),
                TextMuted = Color3.fromRGB(110, 231, 183),
                TextInverse = Color3.fromRGB(12, 20, 18),

                Success = Color3.fromRGB(52, 211, 153),
                SuccessHover = Color3.fromRGB(110, 231, 183),
                Warning = Color3.fromRGB(234, 179, 8),
                WarningHover = Color3.fromRGB(250, 204, 21),
                Error = Color3.fromRGB(239, 68, 68),
                ErrorHover = Color3.fromRGB(248, 113, 113),
                Info = Color3.fromRGB(59, 130, 246),
                InfoHover = Color3.fromRGB(96, 165, 250),

                Overlay = Color3.fromRGB(6, 10, 9),
                OverlayTransparency = 0.5,
                Shadow = Color3.fromRGB(6, 10, 9),
                ShadowTransparency = 0.4,
                Glow = Color3.fromRGB(52, 211, 153),
                GlowTransparency = 0.6,

                ScrollbarTrack = Color3.fromRGB(32, 58, 50),
                ScrollbarThumb = Color3.fromRGB(52, 211, 153),
                ScrollbarThumbHover = Color3.fromRGB(110, 231, 183),
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/OneDark
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/OneDark"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/OneDark")

        --[[
            NexusUI One Dark Theme
            Atom's iconic dark color scheme
        ]]

        return {
            Name = "OneDark",

            Colors = {
                Primary = Color3.fromRGB(97, 175, 239),
                PrimaryHover = Color3.fromRGB(135, 200, 255),
                PrimaryPressed = Color3.fromRGB(70, 145, 210),
                PrimaryFaded = Color3.fromRGB(50, 90, 130),

                Secondary = Color3.fromRGB(92, 99, 112),
                SecondaryHover = Color3.fromRGB(125, 135, 150),
                SecondaryPressed = Color3.fromRGB(70, 75, 85),

                Accent = Color3.fromRGB(198, 120, 221),
                AccentHover = Color3.fromRGB(220, 160, 245),
                AccentPressed = Color3.fromRGB(165, 90, 185),

                Background = Color3.fromRGB(40, 44, 52),
                BackgroundAlt = Color3.fromRGB(49, 54, 64),
                BackgroundElevated = Color3.fromRGB(56, 62, 73),
                BackgroundFloating = Color3.fromRGB(66, 72, 85),

                Surface = Color3.fromRGB(49, 54, 64),
                SurfaceHover = Color3.fromRGB(66, 72, 85),
                SurfaceActive = Color3.fromRGB(80, 88, 102),

                Border = Color3.fromRGB(66, 72, 85),
                BorderFocused = Color3.fromRGB(97, 175, 239),
                BorderError = Color3.fromRGB(224, 108, 117),

                Text = Color3.fromRGB(171, 178, 191),
                TextSecondary = Color3.fromRGB(152, 159, 172),
                TextMuted = Color3.fromRGB(92, 99, 112),
                TextInverse = Color3.fromRGB(40, 44, 52),

                Success = Color3.fromRGB(152, 195, 121),
                SuccessHover = Color3.fromRGB(180, 215, 155),
                Warning = Color3.fromRGB(229, 192, 123),
                WarningHover = Color3.fromRGB(245, 215, 160),
                Error = Color3.fromRGB(224, 108, 117),
                ErrorHover = Color3.fromRGB(245, 145, 155),
                Info = Color3.fromRGB(86, 182, 194),
                InfoHover = Color3.fromRGB(125, 205, 215),

                Overlay = Color3.fromRGB(28, 31, 37),
                OverlayTransparency = 0.4,
                Shadow = Color3.fromRGB(28, 31, 37),
                ShadowTransparency = 0.5,
                Glow = Color3.fromRGB(97, 175, 239),
                GlowTransparency = 0.7,

                ScrollbarTrack = Color3.fromRGB(56, 62, 73),
                ScrollbarThumb = Color3.fromRGB(97, 175, 239),
                ScrollbarThumbHover = Color3.fromRGB(198, 120, 221),
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Matrix
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Matrix"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Matrix")

        --[[
            NexusUI Matrix Theme
            Iconic green-on-black matrix aesthetic
        ]]

        return {
            Name = "Matrix",

            Colors = {
                Primary = Color3.fromRGB(0, 255, 65),
                PrimaryHover = Color3.fromRGB(80, 255, 120),
                PrimaryPressed = Color3.fromRGB(0, 200, 50),
                PrimaryFaded = Color3.fromRGB(0, 80, 25),

                Secondary = Color3.fromRGB(60, 60, 60),
                SecondaryHover = Color3.fromRGB(90, 90, 90),
                SecondaryPressed = Color3.fromRGB(40, 40, 40),

                Accent = Color3.fromRGB(0, 180, 50),
                AccentHover = Color3.fromRGB(0, 220, 70),
                AccentPressed = Color3.fromRGB(0, 140, 40),

                Background = Color3.fromRGB(0, 0, 0),
                BackgroundAlt = Color3.fromRGB(8, 12, 8),
                BackgroundElevated = Color3.fromRGB(12, 18, 12),
                BackgroundFloating = Color3.fromRGB(16, 24, 16),

                Surface = Color3.fromRGB(8, 12, 8),
                SurfaceHover = Color3.fromRGB(16, 24, 16),
                SurfaceActive = Color3.fromRGB(24, 36, 24),

                Border = Color3.fromRGB(0, 80, 25),
                BorderFocused = Color3.fromRGB(0, 255, 65),
                BorderError = Color3.fromRGB(255, 50, 50),

                Text = Color3.fromRGB(0, 255, 65),
                TextSecondary = Color3.fromRGB(0, 200, 50),
                TextMuted = Color3.fromRGB(0, 140, 35),
                TextInverse = Color3.fromRGB(0, 0, 0),

                Success = Color3.fromRGB(0, 255, 65),
                SuccessHover = Color3.fromRGB(80, 255, 120),
                Warning = Color3.fromRGB(255, 230, 0),
                WarningHover = Color3.fromRGB(255, 240, 80),
                Error = Color3.fromRGB(255, 50, 50),
                ErrorHover = Color3.fromRGB(255, 100, 100),
                Info = Color3.fromRGB(0, 200, 255),
                InfoHover = Color3.fromRGB(80, 220, 255),

                Overlay = Color3.fromRGB(0, 0, 0),
                OverlayTransparency = 0.3,
                Shadow = Color3.fromRGB(0, 255, 65),
                ShadowTransparency = 0.9,
                Glow = Color3.fromRGB(0, 255, 65),
                GlowTransparency = 0.4,

                ScrollbarTrack = Color3.fromRGB(12, 18, 12),
                ScrollbarThumb = Color3.fromRGB(0, 255, 65),
                ScrollbarThumbHover = Color3.fromRGB(80, 255, 120),
            },

            -- Matrix-specific custom properties
            MatrixRain = true,
            GlitchEffect = true,
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/TokyoNight
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/TokyoNight"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/TokyoNight")

        --[[
            NexusUI Tokyo Night Theme
            Inspired by Tokyo city lights at night
        ]]

        return {
            Name = "TokyoNight",

            Colors = {
                Primary = Color3.fromRGB(122, 162, 247),
                PrimaryHover = Color3.fromRGB(157, 188, 255),
                PrimaryPressed = Color3.fromRGB(95, 135, 220),
                PrimaryFaded = Color3.fromRGB(65, 85, 135),

                Secondary = Color3.fromRGB(86, 95, 137),
                SecondaryHover = Color3.fromRGB(115, 125, 170),
                SecondaryPressed = Color3.fromRGB(65, 72, 104),

                Accent = Color3.fromRGB(187, 154, 247),
                AccentHover = Color3.fromRGB(210, 185, 255),
                AccentPressed = Color3.fromRGB(150, 120, 210),

                Background = Color3.fromRGB(26, 27, 38),
                BackgroundAlt = Color3.fromRGB(36, 40, 59),
                BackgroundElevated = Color3.fromRGB(41, 46, 66),
                BackgroundFloating = Color3.fromRGB(52, 59, 88),

                Surface = Color3.fromRGB(36, 40, 59),
                SurfaceHover = Color3.fromRGB(52, 59, 88),
                SurfaceActive = Color3.fromRGB(65, 72, 104),

                Border = Color3.fromRGB(52, 59, 88),
                BorderFocused = Color3.fromRGB(122, 162, 247),
                BorderError = Color3.fromRGB(247, 118, 142),

                Text = Color3.fromRGB(192, 202, 245),
                TextSecondary = Color3.fromRGB(169, 177, 214),
                TextMuted = Color3.fromRGB(86, 95, 137),
                TextInverse = Color3.fromRGB(26, 27, 38),

                Success = Color3.fromRGB(158, 206, 106),
                SuccessHover = Color3.fromRGB(185, 225, 145),
                Warning = Color3.fromRGB(224, 175, 104),
                WarningHover = Color3.fromRGB(245, 200, 140),
                Error = Color3.fromRGB(247, 118, 142),
                ErrorHover = Color3.fromRGB(255, 155, 175),
                Info = Color3.fromRGB(125, 207, 255),
                InfoHover = Color3.fromRGB(165, 225, 255),

                Overlay = Color3.fromRGB(18, 19, 28),
                OverlayTransparency = 0.4,
                Shadow = Color3.fromRGB(18, 19, 28),
                ShadowTransparency = 0.5,
                Glow = Color3.fromRGB(122, 162, 247),
                GlowTransparency = 0.7,

                ScrollbarTrack = Color3.fromRGB(41, 46, 66),
                ScrollbarThumb = Color3.fromRGB(122, 162, 247),
                ScrollbarThumbHover = Color3.fromRGB(187, 154, 247),
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Volcanic
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Volcanic"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Volcanic")

        --[[
            NexusUI Volcanic Theme
            Hot volcanic orange and dark theme
        ]]

        return {
            Name = "Volcanic",

            Colors = {
                Primary = Color3.fromRGB(251, 146, 60),
                PrimaryHover = Color3.fromRGB(253, 186, 116),
                PrimaryPressed = Color3.fromRGB(249, 115, 22),
                PrimaryFaded = Color3.fromRGB(154, 52, 18),

                Secondary = Color3.fromRGB(87, 83, 78),
                SecondaryHover = Color3.fromRGB(120, 113, 108),
                SecondaryPressed = Color3.fromRGB(68, 64, 60),

                Accent = Color3.fromRGB(239, 68, 68),
                AccentHover = Color3.fromRGB(248, 113, 113),
                AccentPressed = Color3.fromRGB(220, 38, 38),

                Background = Color3.fromRGB(15, 10, 8),
                BackgroundAlt = Color3.fromRGB(28, 18, 14),
                BackgroundElevated = Color3.fromRGB(42, 28, 22),
                BackgroundFloating = Color3.fromRGB(58, 38, 30),

                Surface = Color3.fromRGB(28, 18, 14),
                SurfaceHover = Color3.fromRGB(58, 38, 30),
                SurfaceActive = Color3.fromRGB(78, 52, 42),

                Border = Color3.fromRGB(100, 65, 52),
                BorderFocused = Color3.fromRGB(251, 146, 60),
                BorderError = Color3.fromRGB(239, 68, 68),

                Text = Color3.fromRGB(255, 247, 237),
                TextSecondary = Color3.fromRGB(254, 215, 170),
                TextMuted = Color3.fromRGB(253, 186, 116),
                TextInverse = Color3.fromRGB(15, 10, 8),

                Success = Color3.fromRGB(34, 197, 94),
                SuccessHover = Color3.fromRGB(74, 222, 128),
                Warning = Color3.fromRGB(251, 146, 60),
                WarningHover = Color3.fromRGB(253, 186, 116),
                Error = Color3.fromRGB(239, 68, 68),
                ErrorHover = Color3.fromRGB(248, 113, 113),
                Info = Color3.fromRGB(59, 130, 246),
                InfoHover = Color3.fromRGB(96, 165, 250),

                Overlay = Color3.fromRGB(8, 5, 4),
                OverlayTransparency = 0.5,
                Shadow = Color3.fromRGB(8, 5, 4),
                ShadowTransparency = 0.4,
                Glow = Color3.fromRGB(251, 146, 60),
                GlowTransparency = 0.5,

                ScrollbarTrack = Color3.fromRGB(58, 38, 30),
                ScrollbarThumb = Color3.fromRGB(251, 146, 60),
                ScrollbarThumbHover = Color3.fromRGB(253, 186, 116),
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Coral
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Coral"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Coral")

        --[[
            NexusUI Coral Theme
            Warm coral pink theme
        ]]

        return {
            Name = "Coral",

            Colors = {
                Primary = Color3.fromRGB(251, 113, 133),
                PrimaryHover = Color3.fromRGB(253, 164, 175),
                PrimaryPressed = Color3.fromRGB(244, 63, 94),
                PrimaryFaded = Color3.fromRGB(136, 19, 55),

                Secondary = Color3.fromRGB(120, 113, 108),
                SecondaryHover = Color3.fromRGB(168, 162, 158),
                SecondaryPressed = Color3.fromRGB(87, 83, 78),

                Accent = Color3.fromRGB(249, 115, 22),
                AccentHover = Color3.fromRGB(251, 146, 60),
                AccentPressed = Color3.fromRGB(234, 88, 12),

                Background = Color3.fromRGB(22, 16, 16),
                BackgroundAlt = Color3.fromRGB(35, 25, 25),
                BackgroundElevated = Color3.fromRGB(48, 34, 34),
                BackgroundFloating = Color3.fromRGB(62, 44, 44),

                Surface = Color3.fromRGB(35, 25, 25),
                SurfaceHover = Color3.fromRGB(62, 44, 44),
                SurfaceActive = Color3.fromRGB(80, 58, 58),

                Border = Color3.fromRGB(100, 70, 70),
                BorderFocused = Color3.fromRGB(251, 113, 133),
                BorderError = Color3.fromRGB(239, 68, 68),

                Text = Color3.fromRGB(255, 241, 242),
                TextSecondary = Color3.fromRGB(254, 205, 211),
                TextMuted = Color3.fromRGB(253, 164, 175),
                TextInverse = Color3.fromRGB(22, 16, 16),

                Success = Color3.fromRGB(34, 197, 94),
                SuccessHover = Color3.fromRGB(74, 222, 128),
                Warning = Color3.fromRGB(234, 179, 8),
                WarningHover = Color3.fromRGB(250, 204, 21),
                Error = Color3.fromRGB(239, 68, 68),
                ErrorHover = Color3.fromRGB(248, 113, 113),
                Info = Color3.fromRGB(59, 130, 246),
                InfoHover = Color3.fromRGB(96, 165, 250),

                Overlay = Color3.fromRGB(11, 8, 8),
                OverlayTransparency = 0.5,
                Shadow = Color3.fromRGB(11, 8, 8),
                ShadowTransparency = 0.4,
                Glow = Color3.fromRGB(251, 113, 133),
                GlowTransparency = 0.6,

                ScrollbarTrack = Color3.fromRGB(62, 44, 44),
                ScrollbarThumb = Color3.fromRGB(251, 113, 133),
                ScrollbarThumbHover = Color3.fromRGB(253, 164, 175),
            },
        }


    end


    -- ============================================================================
    -- Module: NexusUI/Themes/Presets/Arctic
    -- ============================================================================
    NexusUI_Modules["NexusUI/Themes/Presets/Arctic"] = function()
        local script = CreateMockScript("NexusUI/Themes/Presets/Arctic")

        --[[
            NexusUI Arctic Theme
            Cold icy blue theme
        ]]

        return {
            Name = "Arctic",

            Colors = {
                Primary = Color3.fromRGB(147, 197, 253),
                PrimaryHover = Color3.fromRGB(191, 219, 254),
                PrimaryPressed = Color3.fromRGB(96, 165, 250),
                PrimaryFaded = Color3.fromRGB(30, 58, 138),

                Secondary = Color3.fromRGB(148, 163, 184),
                SecondaryHover = Color3.fromRGB(203, 213, 225),
                SecondaryPressed = Color3.fromRGB(100, 116, 139),

                Accent = Color3.fromRGB(125, 211, 252),
                AccentHover = Color3.fromRGB(186, 230, 253),
                AccentPressed = Color3.fromRGB(56, 189, 248),

                Background = Color3.fromRGB(8, 15, 25),
                BackgroundAlt = Color3.fromRGB(12, 24, 40),
                BackgroundElevated = Color3.fromRGB(18, 35, 58),
                BackgroundFloating = Color3.fromRGB(24, 48, 78),

                Surface = Color3.fromRGB(12, 24, 40),
                SurfaceHover = Color3.fromRGB(24, 48, 78),
                SurfaceActive = Color3.fromRGB(35, 65, 100),

                Border = Color3.fromRGB(45, 80, 120),
                BorderFocused = Color3.fromRGB(147, 197, 253),
                BorderError = Color3.fromRGB(239, 68, 68),

                Text = Color3.fromRGB(240, 249, 255),
                TextSecondary = Color3.fromRGB(186, 230, 253),
                TextMuted = Color3.fromRGB(125, 211, 252),
                TextInverse = Color3.fromRGB(8, 15, 25),

                Success = Color3.fromRGB(34, 197, 94),
                SuccessHover = Color3.fromRGB(74, 222, 128),
                Warning = Color3.fromRGB(234, 179, 8),
                WarningHover = Color3.fromRGB(250, 204, 21),
                Error = Color3.fromRGB(239, 68, 68),
                ErrorHover = Color3.fromRGB(248, 113, 113),
                Info = Color3.fromRGB(147, 197, 253),
                InfoHover = Color3.fromRGB(191, 219, 254),

                Overlay = Color3.fromRGB(4, 8, 13),
                OverlayTransparency = 0.5,
                Shadow = Color3.fromRGB(4, 8, 13),
                ShadowTransparency = 0.4,
                Glow = Color3.fromRGB(147, 197, 253),
                GlowTransparency = 0.6,

                ScrollbarTrack = Color3.fromRGB(24, 48, 78),
                ScrollbarThumb = Color3.fromRGB(147, 197, 253),
                ScrollbarThumbHover = Color3.fromRGB(191, 219, 254),
            },
        }


    end


    -- ============================================================================
    -- Return the main NexusUI library
    -- ============================================================================

    return NexusRequire("NexusUI/init")


end


-- ============================================================================
-- Module: NexusUI/API
-- ============================================================================
NexusUI_Modules["NexusUI/API"] = function()
    local script = CreateMockScript("NexusUI/API")
    
    --[[
        NexusUI API Reference
        Complete API documentation and type definitions
    ]]

    --[[
    =============================================================================
                                NexusUI API Reference
    =============================================================================

    This file provides comprehensive documentation for the NexusUI library API.
    All public methods, properties, and types are documented here.

    =============================================================================
                                  MAIN LIBRARY
    =============================================================================

    NexusUI:CreateWindow(config)
        Creates a new window instance.

        Parameters:
            config (table):
                Title (string): Window title
                Theme (string): Theme name (default: "Dark")
                Size (UDim2): Window size
                Position (UDim2): Window position
                Draggable (boolean): Allow dragging
                Resizable (boolean): Allow resizing
                Minimizable (boolean): Show minimize button
                Closeable (boolean): Show close button

        Returns: Window instance

        Example:
            local Window = NexusUI:CreateWindow({
                Title = "My Script",
                Theme = "LiquidGlass",
                Size = UDim2.new(0, 500, 0, 400)
            })

    -----------------------------------------------------------------------------

    NexusUI:SetTheme(themeName)
        Changes the current theme.

        Parameters:
            themeName (string): Name of theme to apply

        Example:
            NexusUI:SetTheme("Ocean")

    -----------------------------------------------------------------------------

    NexusUI:CreateTheme(name, colors)
        Creates a custom theme.

        Parameters:
            name (string): Theme name
            colors (table): Color definitions

        Example:
            NexusUI:CreateTheme("MyTheme", {
                Primary = Color3.fromRGB(100, 150, 255),
                Background = Color3.fromRGB(20, 20, 30)
            })

    -----------------------------------------------------------------------------

    NexusUI:Notify(config)
        Shows a notification toast.

        Parameters:
            config (table):
                Title (string): Notification title
                Content (string): Notification message
                Type (string): "Info", "Success", "Warning", "Error"
                Duration (number): Seconds to show (default: 5)
                Icon (string): Optional icon name

        Example:
            NexusUI:Notify({
                Title = "Success",
                Content = "Operation completed!",
                Type = "Success"
            })

    -----------------------------------------------------------------------------

    NexusUI:SaveConfig(name, data)
        Saves configuration data.

        Parameters:
            name (string): Config name
            data (table): Data to save

        Example:
            NexusUI:SaveConfig("Settings", { Enabled = true })

    -----------------------------------------------------------------------------

    NexusUI:LoadConfig(name)
        Loads configuration data.

        Parameters:
            name (string): Config name

        Returns: table or nil

        Example:
            local config = NexusUI:LoadConfig("Settings")

    -----------------------------------------------------------------------------

    NexusUI:RegisterHotkey(name, key, callback)
        Registers a global hotkey.

        Parameters:
            name (string): Hotkey identifier
            key (Enum.KeyCode): Key to bind
            callback (function): Function to call when pressed

        Example:
            NexusUI:RegisterHotkey("Toggle", Enum.KeyCode.RightControl, function()
                Window:Toggle()
            end)

    -----------------------------------------------------------------------------

    NexusUI:PlaySound(soundName, volume)
        Plays a UI sound.

        Parameters:
            soundName (string): Sound name
            volume (number): Volume (0-1)

        Example:
            NexusUI:PlaySound("Click", 0.5)

    -----------------------------------------------------------------------------

    NexusUI:EnableFPSMonitor(config)
        Enables the FPS monitor overlay.

        Parameters:
            config (table):
                Position (string): "TopLeft", "TopRight", etc.
                ShowGraph (boolean): Show FPS graph
                ShowMemory (boolean): Show memory usage
                ShowPing (boolean): Show network ping

        Example:
            NexusUI:EnableFPSMonitor({ Position = "TopRight" })

    -----------------------------------------------------------------------------

    NexusUI:Destroy()
        Destroys the UI and cleans up resources.

    =============================================================================
                                  WINDOW
    =============================================================================

    Window:AddTab(config)
        Adds a tab to the window.

        Parameters:
            config (table):
                Name (string): Tab name
                Icon (string): Tab icon

        Returns: Tab instance

        Example:
            local Tab = Window:AddTab({ Name = "Main", Icon = "Home" })

    -----------------------------------------------------------------------------

    Window:Show()
        Shows the window.

    Window:Hide()
        Hides the window.

    Window:Toggle()
        Toggles window visibility.

    Window:SetTitle(title)
        Sets the window title.

    Window:Minimize()
        Minimizes the window.

    Window:Maximize()
        Maximizes the window.

    Window:Close()
        Closes and destroys the window.

    Window:AutoSaveConfig(name)
        Enables auto-saving of UI state.

    =============================================================================
                                  TAB
    =============================================================================

    Tab:AddButton(config)
        Adds a button to the tab.

        Parameters:
            config (table):
                Text (string): Button text
                Callback (function): Click handler
                Icon (string): Optional icon

        Returns: Button instance

    -----------------------------------------------------------------------------

    Tab:AddToggle(config)
        Adds a toggle to the tab.

        Parameters:
            config (table):
                Text (string): Toggle label
                Default (boolean): Initial value
                Callback (function): Change handler

        Returns: Toggle instance

    -----------------------------------------------------------------------------

    Tab:AddSlider(config)
        Adds a slider to the tab.

        Parameters:
            config (table):
                Text (string): Slider label
                Min (number): Minimum value
                Max (number): Maximum value
                Default (number): Initial value
                Step (number): Value step
                Callback (function): Change handler

        Returns: Slider instance

    -----------------------------------------------------------------------------

    Tab:AddInput(config)
        Adds a text input to the tab.

        Parameters:
            config (table):
                Text (string): Input label
                Placeholder (string): Placeholder text
                Default (string): Initial value
                Callback (function): Change handler

        Returns: Input instance

    -----------------------------------------------------------------------------

    Tab:AddDropdown(config)
        Adds a dropdown to the tab.

        Parameters:
            config (table):
                Text (string): Dropdown label
                Options (table): Array of options
                Default (string): Initial selection
                Multi (boolean): Allow multiple selection
                Callback (function): Change handler

        Returns: Dropdown instance

    -----------------------------------------------------------------------------

    Tab:AddColorPicker(config)
        Adds a color picker to the tab.

        Parameters:
            config (table):
                Text (string): Picker label
                Default (Color3): Initial color
                Callback (function): Change handler

        Returns: ColorPicker instance

    -----------------------------------------------------------------------------

    Tab:AddKeybind(config)
        Adds a keybind input to the tab.

        Parameters:
            config (table):
                Text (string): Keybind label
                Default (Enum.KeyCode): Initial key
                Callback (function): Handler when key pressed
                ChangedCallback (function): Handler when keybind changed

        Returns: Keybind instance

    -----------------------------------------------------------------------------

    Tab:AddSection(name)
        Adds a visual section divider.

        Parameters:
            name (string): Section title

        Returns: Section instance

    -----------------------------------------------------------------------------

    Tab:AddLabel(text)
        Adds a text label.

        Parameters:
            text (string): Label text

        Returns: Label instance

    Tab:AddParagraph(title, content)
        Adds a paragraph with title and content.

        Returns: Paragraph instance

    =============================================================================
                               COMPONENTS
    =============================================================================

    Button:SetText(text)
        Sets button text.

    Button:SetCallback(callback)
        Sets click handler.

    Button:Fire()
        Programmatically clicks the button.

    -----------------------------------------------------------------------------

    Toggle:SetValue(value)
        Sets toggle state.

    Toggle:GetValue()
        Gets current toggle state.

    Toggle:OnChanged(callback)
        Sets change handler.

    -----------------------------------------------------------------------------

    Slider:SetValue(value)
        Sets slider value.

    Slider:GetValue()
        Gets current slider value.

    Slider:SetMin(min)
        Sets minimum value.

    Slider:SetMax(max)
        Sets maximum value.

    -----------------------------------------------------------------------------

    Input:SetValue(text)
        Sets input text.

    Input:GetValue()
        Gets current input text.

    Input:SetPlaceholder(text)
        Sets placeholder text.

    -----------------------------------------------------------------------------

    Dropdown:SetOptions(options)
        Sets available options.

    Dropdown:AddOption(option)
        Adds an option.

    Dropdown:RemoveOption(option)
        Removes an option.

    Dropdown:SetValue(value)
        Sets selected value(s).

    Dropdown:GetValue()
        Gets current selection.

    -----------------------------------------------------------------------------

    ColorPicker:SetColor(color)
        Sets current color.

    ColorPicker:GetColor()
        Gets current color.

    -----------------------------------------------------------------------------

    Keybind:SetKey(key)
        Sets bound key.

    Keybind:GetKey()
        Gets current bound key.

    =============================================================================
                               BUILDERS
    =============================================================================

    WindowBuilder.Create()
        Creates a new window builder.

        Example:
            local window = NexusUI.Builders.Window.Create()
                :Title("My Window")
                :Size(500, 400)
                :Theme("Ocean")
                :Draggable(true)
                :Build(parent)

    -----------------------------------------------------------------------------

    FormBuilder.Create()
        Creates a new form builder.

        Example:
            local form = NexusUI.Builders.Form.Create()
                :Title("Login")
                :AddTextInput("username", "Username")
                :AddTextInput("password", "Password", { Password = true })
                :OnSubmit(function(values) end)
                :Build(parent)

    -----------------------------------------------------------------------------

    MenuBuilder.Context()
        Creates a context menu builder.

    MenuBuilder.Dropdown()
        Creates a dropdown menu builder.

    -----------------------------------------------------------------------------

    CardBuilder.Create()
        Creates a card builder.

    ListBuilder.Create()
        Creates a list builder.

    =============================================================================
                               THEMES
    =============================================================================

    Available Themes:
        - Dark
        - Light
        - LiquidGlass
        - Ocean
        - Forest
        - Sunset
        - Midnight
        - Neon
        - Cyberpunk
        - Dracula
        - Nord
        - Monokai
        - Synthwave
        - Material
        - Catppuccin
        - Rose
        - Aqua
        - Crimson
        - Emerald
        - Obsidian
        - Lavender
        - Amber
        - Slate
        - Cherry
        - Coffee

    Theme Colors:
        - Primary: Main accent color
        - Secondary: Secondary accent
        - Background: Main background
        - Surface: Card/panel backgrounds
        - Text: Primary text color
        - TextSecondary: Secondary text
        - Border: Border color
        - Success: Success state
        - Warning: Warning state
        - Error: Error state
        - Info: Info state

    =============================================================================
                               EFFECTS
    =============================================================================

    NexusUI.Effects.LiquidGlass
        Creates liquid glass effect with blur and refraction.

    NexusUI.Effects.Glassmorphism
        Creates frosted glass effect.

    NexusUI.Effects.Blur
        Applies blur effect to element.

    NexusUI.Effects.Glow
        Adds glow effect.

    NexusUI.Effects.Shadow
        Adds drop shadow.

    NexusUI.Effects.Gradient
        Creates gradient background.

    NexusUI.Effects.Particles
        Adds particle effects.

    NexusUI.Effects.Ripple
        Adds ripple click effect.

    =============================================================================
                               VISUALIZERS
    =============================================================================

    LineChart:SetData(data)
    BarChart:SetData(data)
    PieChart:SetData(data)
    Gauge:SetValue(value)
    FPSGraph:Enable()
    MemoryGraph:Enable()
    NetworkGraph:Enable()
    PerformancePanel:Show()

    =============================================================================
                               SPECIAL
    =============================================================================

    Console:Log(message)
    Console:Error(message)
    Console:Clear()

    CodeEditor:SetCode(code)
    CodeEditor:GetCode()

    ESP:Enable()
    ESP:Disable()
    ESP:Configure(config)

    Watermark:SetText(text)
    Watermark:Show()
    Watermark:Hide()

    =============================================================================
    ]]

    return {
        Version = "1.0.0",
        Documentation = "See comments above for full API reference"
    }


end


-- ============================================================================
-- Module: NexusUI/Compiler
-- ============================================================================
NexusUI_Modules["NexusUI/Compiler"] = function()
    local script = CreateMockScript("NexusUI/Compiler")
    
    --[[
        NexusUI Compiler
        Utility to compile the library into a single file for executor distribution

        Usage: Run this script in Roblox Studio to generate a compiled single-file version
    ]]

    local Compiler = {}

    --// Configuration
    Compiler.Config = {
        OutputFileName = "NexusUI_Compiled.lua",
        Minify = false, -- Set true for production
        IncludeComments = true,
        BundleAssets = true,
    }

    --// Module order for compilation (dependencies first)
    Compiler.ModuleOrder = {
        -- Core
        "NexusUI/Core/Services",
        "NexusUI/Core/SignalClass",
        "NexusUI/Core/Maid",
        "NexusUI/Core/Promise",
        "NexusUI/Core/EventSystem",
        "NexusUI/Core/StateManager",
        "NexusUI/Core/Types",
        "NexusUI/Core/Constants",
        "NexusUI/Core/InstancePool",
        "NexusUI/Core/ScreenGui",
        "NexusUI/Core/Utility/Math",
        "NexusUI/Core/Utility/String",
        "NexusUI/Core/Utility/Table",
        "NexusUI/Core/Utility/Color",
        "NexusUI/Core/Utility/Bezier",
        "NexusUI/Core/Utility/UUID",
        "NexusUI/Core/Utility/Debounce",
        "NexusUI/Core/Utility/DeepCopy",
        "NexusUI/Core/Utility/Lerp",
        "NexusUI/Core/Utility/Validate",
        "NexusUI/Core/Utility/init",
        "NexusUI/Core/Initialization",
        "NexusUI/Core/init",

        -- Animation
        "NexusUI/Animation/SpringPhysics",
        "NexusUI/Animation/EasingFunctions",
        "NexusUI/Animation/Sequence",
        "NexusUI/Animation/Timeline",
        "NexusUI/Animation/Keyframes",
        "NexusUI/Animation/Tween",
        "NexusUI/Animation/Parallel",
        "NexusUI/Animation/Morph",
        "NexusUI/Animation/Transition",
        "NexusUI/Animation/Controller",
        "NexusUI/Animation/Effects",
        "NexusUI/Animation/Stagger",
        "NexusUI/Animation/Interpolate",
        "NexusUI/Animation/init",

        -- Themes
        "NexusUI/Themes/Palette",
        "NexusUI/Themes/Effects",
        "NexusUI/Themes/Builder",
        "NexusUI/Themes/Presets/Dark",
        "NexusUI/Themes/Presets/Light",
        -- ... all other theme presets
        "NexusUI/Themes/Manager",
        "NexusUI/Themes/init",

        -- Effects
        "NexusUI/Effects/LiquidGlass",
        "NexusUI/Effects/Glassmorphism",
        "NexusUI/Effects/Blur",
        "NexusUI/Effects/Glow",
        "NexusUI/Effects/Shadow",
        "NexusUI/Effects/Gradient",
        "NexusUI/Effects/Particles",
        "NexusUI/Effects/Ripple",
        "NexusUI/Effects/init",

        -- Components (base first, then all others)
        "NexusUI/Components/Base",
        "NexusUI/Components/Container",
        -- ... all components
        "NexusUI/Components/init",

        -- Features
        "NexusUI/Features/Sound",
        "NexusUI/Features/Config",
        "NexusUI/Features/Hotkey",
        "NexusUI/Features/DragDrop",
        "NexusUI/Features/init",

        -- Layout
        "NexusUI/Layout/Flex",
        "NexusUI/Layout/Grid",
        "NexusUI/Layout/Stack",
        "NexusUI/Layout/Center",
        "NexusUI/Layout/Spacer",
        "NexusUI/Layout/Responsive",
        "NexusUI/Layout/Container",
        "NexusUI/Layout/Utils",
        "NexusUI/Layout/init",

        -- Assets
        "NexusUI/Assets/Icons",
        "NexusUI/Assets/Images",
        "NexusUI/Assets/Fonts",
        "NexusUI/Assets/Sounds",
        "NexusUI/Assets/Sprites",
        "NexusUI/Assets/Loader",
        "NexusUI/Assets/Cache",
        "NexusUI/Assets/init",

        -- Builders
        "NexusUI/Builders/UI",
        "NexusUI/Builders/Window",
        "NexusUI/Builders/Tab",
        "NexusUI/Builders/Section",
        "NexusUI/Builders/Form",
        "NexusUI/Builders/Menu",
        "NexusUI/Builders/Toolbar",
        "NexusUI/Builders/Dialog",
        "NexusUI/Builders/Card",
        "NexusUI/Builders/List",
        "NexusUI/Builders/init",

        -- Notifications
        "NexusUI/Notifications/Toast",
        "NexusUI/Notifications/Notification",
        "NexusUI/Notifications/Alert",
        "NexusUI/Notifications/Manager",
        "NexusUI/Notifications/Banner",
        "NexusUI/Notifications/Snackbar",
        "NexusUI/Notifications/init",

        -- Visualizers
        "NexusUI/Visualizers/LineChart",
        "NexusUI/Visualizers/BarChart",
        "NexusUI/Visualizers/PieChart",
        "NexusUI/Visualizers/AreaChart",
        "NexusUI/Visualizers/RadarChart",
        "NexusUI/Visualizers/DonutChart",
        "NexusUI/Visualizers/Sparkline",
        "NexusUI/Visualizers/Gauge",
        "NexusUI/Visualizers/Heatmap",
        "NexusUI/Visualizers/FPSGraph",
        "NexusUI/Visualizers/MemoryGraph",
        "NexusUI/Visualizers/NetworkGraph",
        "NexusUI/Visualizers/PerformancePanel",
        "NexusUI/Visualizers/init",

        -- Special
        "NexusUI/Special/Console",
        "NexusUI/Special/CodeEditor",
        "NexusUI/Special/Terminal",
        "NexusUI/Special/ESP",
        "NexusUI/Special/Watermark",
        "NexusUI/Special/Crosshair",
        "NexusUI/Special/Aimbot",
        "NexusUI/Special/Playerlist",
        "NexusUI/Special/Killfeed",
        "NexusUI/Special/Minimap",
        "NexusUI/Special/Spectate",
        "NexusUI/Special/init",

        -- Main
        "NexusUI/init",
    }

    --// Generate header
    function Compiler.GenerateHeader()
        return [[
    --[[
        ╔═══════════════════════════════════════════════════════════════╗
        ║                         NexusUI                                ║
        ║              Premium UI Library for Roblox                     ║
        ╠═══════════════════════════════════════════════════════════════╣
        ║  Version: 1.0.0                                                ║
        ║  Author: NexusUI Team                                          ║
        ║  License: MIT                                                  ║
        ╚═══════════════════════════════════════════════════════════════╝

        Features:
        • 25+ Beautiful Themes with Liquid Glass Effects
        • Advanced Animation Engine with Springs & Easing
        • Comprehensive Component Library
        • Performance Monitoring (FPS, Memory, Network)
        • ESP, Aimbot, and Executor Components
        • Builder Patterns for Easy UI Creation
        • Sound System & Hotkey Management
        • Config Save/Load with Cloud Sync

        Usage:
            local NexusUI = loadstring(game:HttpGet("URL_HERE"))()
            local Window = NexusUI:CreateWindow({
                Title = "My Script",
                Theme = "LiquidGlass"
            })
    --]]

    ]]
    end

    --// Generate module wrapper
    function Compiler.WrapModule(moduleName, moduleCode)
        return string.format([[
    -- Module: %s
    _G.NexusUI_Modules["%s"] = (function()
    %s
    end)()

    ]], moduleName, moduleName, moduleCode)
    end

    --// Generate runtime require replacement
    function Compiler.GenerateRuntime()
        return [[
    -- Runtime module system
    _G.NexusUI_Modules = _G.NexusUI_Modules or {}

    local function NexusRequire(modulePath)
        if _G.NexusUI_Modules[modulePath] then
            return _G.NexusUI_Modules[modulePath]
        end
        warn("[NexusUI] Module not found:", modulePath)
        return nil
    end

    -- Replace script.Parent references
    local script = {
        Parent = { Parent = { Parent = nil } }
    }

    ]]
    end

    --// Generate footer
    function Compiler.GenerateFooter()
        return [[

    -- Return the library
    return _G.NexusUI_Modules["NexusUI/init"]
    ]]
    end

    --// Main compile function (for use in Roblox Studio)
    function Compiler.Compile()
        local output = {}

        -- Add header
        table.insert(output, Compiler.GenerateHeader())
        table.insert(output, Compiler.GenerateRuntime())

        -- Add modules (this would read actual module source in Studio)
        for _, modulePath in ipairs(Compiler.ModuleOrder) do
            -- In actual use, this would read the module source
            local moduleCode = "-- Module code would be inserted here"
            table.insert(output, Compiler.WrapModule(modulePath, moduleCode))
        end

        -- Add footer
        table.insert(output, Compiler.GenerateFooter())

        return table.concat(output, "\n")
    end

    --// Export for CLI usage
    function Compiler.ExportToFile(filePath)
        local compiled = Compiler.Compile()
        -- Would write to file system
        print("[Compiler] Would export to:", filePath)
        print("[Compiler] Total size:", #compiled, "characters")
        return compiled
    end

    return Compiler


end


-- ============================================================================
-- Module: NexusUI/Animation/TweenEngine
-- ============================================================================
NexusUI_Modules["NexusUI/Animation/TweenEngine"] = function()
    local script = CreateMockScript("NexusUI/Animation/TweenEngine")
    
    --[[
        NexusUI Tween Engine
        Custom high-performance tweening system

        Features:
        - Multi-property tweening
        - Custom easing support
        - Tween grouping
        - Batched updates
        - Memory-efficient pooling
        - Callback system
    ]]

    --// Services
    local RunService = game:GetService("RunService")
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local EasingFunctions = nil

    --// Tween Engine
    local TweenEngine = {}
    TweenEngine.__index = TweenEngine
    TweenEngine.ClassName = "TweenEngine"

    --// Configuration
    local Config = {
        UseNativeTween = false, -- Use Roblox TweenService when possible
        DefaultDuration = 0.3,
        DefaultEasing = "QuadOut",
        PoolSize = 100,
        BatchUpdates = true,
    }

    --// Tween Pool
    local TweenPool = {}
    local ActiveTweens = {}
    local TweenIdCounter = 0

    --// Tween State
    local TweenState = {
        Pending = "Pending",
        Playing = "Playing",
        Paused = "Paused",
        Completed = "Completed",
        Cancelled = "Cancelled",
    }

    --// Generate Tween ID
    local function GenerateTweenId()
        TweenIdCounter = TweenIdCounter + 1
        return "tween_" .. TweenIdCounter
    end

    --// Get or Load Easing Module
    local function GetEasing(name)
        if not EasingFunctions then
            EasingFunctions = script.Parent:FindFirstChild("EasingFunctions")
            if EasingFunctions then
                EasingFunctions = require(EasingFunctions)
            end
        end

        if EasingFunctions and EasingFunctions[name] then
            return EasingFunctions[name]
        end

        -- Fallback easings
        local fallback = {
            Linear = function(t) return t end,
            QuadIn = function(t) return t * t end,
            QuadOut = function(t) return 1 - (1 - t) * (1 - t) end,
            QuadInOut = function(t)
                return t < 0.5 and 2 * t * t or 1 - (-2 * t + 2) ^ 2 / 2
            end,
        }

        return fallback[name] or fallback.Linear
    end

    --// Value Interpolation
    local function LerpValue(startValue, endValue, t)
        local valueType = typeof(startValue)

        if valueType == "number" then
            return startValue + (endValue - startValue) * t
        elseif valueType == "Color3" then
            return Color3.new(
                startValue.R + (endValue.R - startValue.R) * t,
                startValue.G + (endValue.G - startValue.G) * t,
                startValue.B + (endValue.B - startValue.B) * t
            )
        elseif valueType == "Vector2" then
            return Vector2.new(
                startValue.X + (endValue.X - startValue.X) * t,
                startValue.Y + (endValue.Y - startValue.Y) * t
            )
        elseif valueType == "Vector3" then
            return Vector3.new(
                startValue.X + (endValue.X - startValue.X) * t,
                startValue.Y + (endValue.Y - startValue.Y) * t,
                startValue.Z + (endValue.Z - startValue.Z) * t
            )
        elseif valueType == "UDim" then
            return UDim.new(
                startValue.Scale + (endValue.Scale - startValue.Scale) * t,
                startValue.Offset + (endValue.Offset - startValue.Offset) * t
            )
        elseif valueType == "UDim2" then
            return UDim2.new(
                startValue.X.Scale + (endValue.X.Scale - startValue.X.Scale) * t,
                startValue.X.Offset + (endValue.X.Offset - startValue.X.Offset) * t,
                startValue.Y.Scale + (endValue.Y.Scale - startValue.Y.Scale) * t,
                startValue.Y.Offset + (endValue.Y.Offset - startValue.Y.Offset) * t
            )
        elseif valueType == "CFrame" then
            return startValue:Lerp(endValue, t)
        elseif valueType == "NumberRange" then
            return NumberRange.new(
                startValue.Min + (endValue.Min - startValue.Min) * t,
                startValue.Max + (endValue.Max - startValue.Max) * t
            )
        elseif valueType == "Rect" then
            return Rect.new(
                startValue.Min.X + (endValue.Min.X - startValue.Min.X) * t,
                startValue.Min.Y + (endValue.Min.Y - startValue.Min.Y) * t,
                startValue.Max.X + (endValue.Max.X - startValue.Max.X) * t,
                startValue.Max.Y + (endValue.Max.Y - startValue.Max.Y) * t
            )
        elseif valueType == "NumberSequence" then
            -- Interpolate keypoints
            local keypoints = {}
            local startKeypoints = startValue.Keypoints
            local endKeypoints = endValue.Keypoints

            for i, startKp in ipairs(startKeypoints) do
                local endKp = endKeypoints[i] or startKp
                table.insert(keypoints, NumberSequenceKeypoint.new(
                    startKp.Time,
                    startKp.Value + (endKp.Value - startKp.Value) * t,
                    startKp.Envelope + (endKp.Envelope - startKp.Envelope) * t
                ))
            end

            return NumberSequence.new(keypoints)
        elseif valueType == "ColorSequence" then
            -- Interpolate keypoints
            local keypoints = {}
            local startKeypoints = startValue.Keypoints
            local endKeypoints = endValue.Keypoints

            for i, startKp in ipairs(startKeypoints) do
                local endKp = endKeypoints[i] or startKp
                table.insert(keypoints, ColorSequenceKeypoint.new(
                    startKp.Time,
                    Color3.new(
                        startKp.Value.R + (endKp.Value.R - startKp.Value.R) * t,
                        startKp.Value.G + (endKp.Value.G - startKp.Value.G) * t,
                        startKp.Value.B + (endKp.Value.B - startKp.Value.B) * t
                    )
                ))
            end

            return ColorSequence.new(keypoints)
        end

        -- Default: return end value at halfway point
        return t >= 0.5 and endValue or startValue
    end

    --// Tween Object
    local Tween = {}
    Tween.__index = Tween

    function Tween.new(config)
        local self = setmetatable({}, Tween)

        self.Id = GenerateTweenId()
        self.Target = config.Target
        self.Properties = config.Properties or {}
        self.Duration = config.Duration or Config.DefaultDuration
        self.Easing = config.Easing or Config.DefaultEasing
        self.Delay = config.Delay or 0
        self.RepeatCount = config.RepeatCount or 0
        self.Reverse = config.Reverse or false
        self.Yoyo = config.Yoyo or false

        -- Callbacks
        self.OnStart = config.OnStart
        self.OnUpdate = config.OnUpdate
        self.OnComplete = config.OnComplete
        self.OnRepeat = config.OnRepeat

        -- State
        self.State = TweenState.Pending
        self.ElapsedTime = 0
        self.DelayRemaining = self.Delay
        self.RepeatsDone = 0
        self.Direction = 1 -- 1 = forward, -1 = backward

        -- Store start values
        self.StartValues = {}
        self.EndValues = {}

        return self
    end

    function Tween:_captureStartValues()
        if not self.Target then return end

        for property, endValue in pairs(self.Properties) do
            local success, startValue = pcall(function()
                return self.Target[property]
            end)

            if success then
                self.StartValues[property] = startValue
                self.EndValues[property] = endValue
            end
        end
    end

    function Tween:Play()
        if self.State == TweenState.Playing then
            return self
        end

        self:_captureStartValues()

        self.State = TweenState.Playing
        self.ElapsedTime = 0
        self.DelayRemaining = self.Delay
        self.RepeatsDone = 0
        self.Direction = 1

        if self.OnStart then
            pcall(self.OnStart, self)
        end

        ActiveTweens[self.Id] = self

        return self
    end

    function Tween:Pause()
        if self.State == TweenState.Playing then
            self.State = TweenState.Paused
        end
        return self
    end

    function Tween:Resume()
        if self.State == TweenState.Paused then
            self.State = TweenState.Playing
        end
        return self
    end

    function Tween:Stop()
        self.State = TweenState.Cancelled
        ActiveTweens[self.Id] = nil
        return self
    end

    function Tween:Cancel()
        return self:Stop()
    end

    function Tween:Restart()
        self:Stop()
        self:Play()
        return self
    end

    function Tween:Reset()
        if not self.Target then return self end

        for property, startValue in pairs(self.StartValues) do
            pcall(function()
                self.Target[property] = startValue
            end)
        end

        return self
    end

    function Tween:Complete()
        if not self.Target then return self end

        for property, endValue in pairs(self.EndValues) do
            pcall(function()
                self.Target[property] = endValue
            end)
        end

        self.State = TweenState.Completed
        ActiveTweens[self.Id] = nil

        if self.OnComplete then
            pcall(self.OnComplete, self)
        end

        return self
    end

    function Tween:Update(deltaTime)
        if self.State ~= TweenState.Playing then
            return self.State == TweenState.Completed or self.State == TweenState.Cancelled
        end

        -- Handle delay
        if self.DelayRemaining > 0 then
            self.DelayRemaining = self.DelayRemaining - deltaTime
            return false
        end

        -- Update elapsed time
        self.ElapsedTime = self.ElapsedTime + deltaTime

        -- Calculate progress
        local rawProgress = math.min(self.ElapsedTime / self.Duration, 1)
        local progress = self.Direction == 1 and rawProgress or (1 - rawProgress)

        -- Apply easing
        local easingFunc = GetEasing(self.Easing)
        local easedProgress = easingFunc(progress)

        -- Apply values to target
        if self.Target then
            for property, endValue in pairs(self.EndValues) do
                local startValue = self.StartValues[property]

                if startValue ~= nil then
                    local currentValue = LerpValue(startValue, endValue, easedProgress)

                    pcall(function()
                        self.Target[property] = currentValue
                    end)
                end
            end
        end

        -- Callback
        if self.OnUpdate then
            pcall(self.OnUpdate, easedProgress, self)
        end

        -- Check completion
        if rawProgress >= 1 then
            -- Handle repeating
            if self.RepeatCount == -1 or self.RepeatsDone < self.RepeatCount then
                self.RepeatsDone = self.RepeatsDone + 1
                self.ElapsedTime = 0

                if self.Yoyo then
                    self.Direction = self.Direction * -1
                end

                if self.OnRepeat then
                    pcall(self.OnRepeat, self.RepeatsDone, self)
                end

                return false
            end

            self.State = TweenState.Completed

            if self.OnComplete then
                pcall(self.OnComplete, self)
            end

            return true
        end

        return false
    end

    function Tween:SetEasing(easing)
        self.Easing = easing
        return self
    end

    function Tween:SetDuration(duration)
        self.Duration = duration
        return self
    end

    function Tween:SetDelay(delay)
        self.Delay = delay
        self.DelayRemaining = delay
        return self
    end

    function Tween:SetRepeat(count)
        self.RepeatCount = count
        return self
    end

    function Tween:SetYoyo(yoyo)
        self.Yoyo = yoyo
        return self
    end

    function Tween:Then(callback)
        local originalOnComplete = self.OnComplete

        self.OnComplete = function(tween)
            if originalOnComplete then
                originalOnComplete(tween)
            end
            callback(tween)
        end

        return self
    end

    function Tween:Await()
        while self.State == TweenState.Playing or self.State == TweenState.Paused do
            task.wait()
        end
        return self
    end

    function Tween:GetProgress()
        if self.Duration == 0 then return 1 end
        return math.min(self.ElapsedTime / self.Duration, 1)
    end

    function Tween:GetState()
        return self.State
    end

    function Tween:IsPlaying()
        return self.State == TweenState.Playing
    end

    function Tween:IsPaused()
        return self.State == TweenState.Paused
    end

    function Tween:IsComplete()
        return self.State == TweenState.Completed
    end

    --// Tween Engine API
    function TweenEngine.Create(target, properties, duration, easing, options)
        options = options or {}

        -- Check if we can use native tween
        if Config.UseNativeTween and typeof(target) == "Instance" then
            local tweenInfo = TweenInfo.new(
                duration or Config.DefaultDuration,
                Enum.EasingStyle.Quad,
                Enum.EasingDirection.Out,
                options.RepeatCount or 0,
                options.Reverse or false,
                options.Delay or 0
            )

            return TweenService:Create(target, tweenInfo, properties)
        end

        return Tween.new({
            Target = target,
            Properties = properties,
            Duration = duration or Config.DefaultDuration,
            Easing = easing or Config.DefaultEasing,
            Delay = options.Delay,
            RepeatCount = options.RepeatCount,
            Reverse = options.Reverse,
            Yoyo = options.Yoyo,
            OnStart = options.OnStart,
            OnUpdate = options.OnUpdate,
            OnComplete = options.OnComplete,
            OnRepeat = options.OnRepeat,
        })
    end

    function TweenEngine.To(target, duration, properties, easing)
        return TweenEngine.Create(target, properties, duration, easing):Play()
    end

    function TweenEngine.From(target, duration, properties, easing)
        if not target then return nil end

        -- Swap start and end values
        local endValues = {}

        for property, startValue in pairs(properties) do
            local success, currentValue = pcall(function()
                return target[property]
            end)

            if success then
                endValues[property] = currentValue

                pcall(function()
                    target[property] = startValue
                end)
            end
        end

        return TweenEngine.Create(target, endValues, duration, easing):Play()
    end

    function TweenEngine.FromTo(target, duration, fromProperties, toProperties, easing)
        if not target then return nil end

        -- Set starting values
        for property, value in pairs(fromProperties) do
            pcall(function()
                target[property] = value
            end)
        end

        return TweenEngine.Create(target, toProperties, duration, easing):Play()
    end

    --// Batch Operations
    function TweenEngine.StaggerTo(targets, duration, properties, staggerDelay, easing)
        staggerDelay = staggerDelay or 0.1
        local tweens = {}

        for i, target in ipairs(targets) do
            local tween = TweenEngine.Create(target, properties, duration, easing, {
                Delay = (i - 1) * staggerDelay
            })
            table.insert(tweens, tween)
        end

        for _, tween in ipairs(tweens) do
            tween:Play()
        end

        return tweens
    end

    function TweenEngine.KillAll()
        for id, tween in pairs(ActiveTweens) do
            tween:Cancel()
        end
        ActiveTweens = {}
    end

    function TweenEngine.KillTweensOf(target)
        for id, tween in pairs(ActiveTweens) do
            if tween.Target == target then
                tween:Cancel()
                ActiveTweens[id] = nil
            end
        end
    end

    function TweenEngine.GetTweensOf(target)
        local tweens = {}
        for id, tween in pairs(ActiveTweens) do
            if tween.Target == target then
                table.insert(tweens, tween)
            end
        end
        return tweens
    end

    function TweenEngine.GetActiveCount()
        local count = 0
        for _ in pairs(ActiveTweens) do
            count = count + 1
        end
        return count
    end

    --// Update Loop (called from Animation module)
    function TweenEngine.Update(deltaTime)
        local toRemove = {}

        for id, tween in pairs(ActiveTweens) do
            local completed = tween:Update(deltaTime)

            if completed then
                table.insert(toRemove, id)
            end
        end

        for _, id in ipairs(toRemove) do
            ActiveTweens[id] = nil
        end
    end

    --// Configuration
    function TweenEngine.SetConfig(key, value)
        if Config[key] ~= nil then
            Config[key] = value
        end
    end

    function TweenEngine.GetConfig(key)
        return Config[key]
    end

    --// Export State
    TweenEngine.State = TweenState

    return TweenEngine


end


-- ============================================================================
-- Module: NexusUI/Components/Keybind
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Keybind"] = function()
    local script = CreateMockScript("NexusUI/Components/Keybind")
    
    --[[
        NexusUI Keybind Component
        Keyboard binding input
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")
    local UserInputService = game:GetService("UserInputService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Keybind Component Module
    local Keybind = setmetatable({}, { __index = Base })
    Keybind.__index = Keybind
    Keybind.ClassName = "Keybind"

    --// Key display names
    local KeyNames = {
        [Enum.KeyCode.LeftShift] = "L Shift",
        [Enum.KeyCode.RightShift] = "R Shift",
        [Enum.KeyCode.LeftControl] = "L Ctrl",
        [Enum.KeyCode.RightControl] = "R Ctrl",
        [Enum.KeyCode.LeftAlt] = "L Alt",
        [Enum.KeyCode.RightAlt] = "R Alt",
        [Enum.KeyCode.CapsLock] = "Caps",
        [Enum.KeyCode.Tab] = "Tab",
        [Enum.KeyCode.Space] = "Space",
        [Enum.KeyCode.Return] = "Enter",
        [Enum.KeyCode.Backspace] = "Backspace",
        [Enum.KeyCode.Delete] = "Delete",
        [Enum.KeyCode.Insert] = "Insert",
        [Enum.KeyCode.Home] = "Home",
        [Enum.KeyCode.End] = "End",
        [Enum.KeyCode.PageUp] = "Page Up",
        [Enum.KeyCode.PageDown] = "Page Down",
        [Enum.KeyCode.Up] = "↑",
        [Enum.KeyCode.Down] = "↓",
        [Enum.KeyCode.Left] = "←",
        [Enum.KeyCode.Right] = "→",
        [Enum.KeyCode.Escape] = "Esc",
        [Enum.KeyCode.Tilde] = "~",
        [Enum.KeyCode.Minus] = "-",
        [Enum.KeyCode.Equals] = "=",
        [Enum.KeyCode.LeftBracket] = "[",
        [Enum.KeyCode.RightBracket] = "]",
        [Enum.KeyCode.Backslash] = "\\",
        [Enum.KeyCode.Semicolon] = ";",
        [Enum.KeyCode.Quote] = "'",
        [Enum.KeyCode.Comma] = ",",
        [Enum.KeyCode.Period] = ".",
        [Enum.KeyCode.Slash] = "/",
    }

    --// Constructor
    function Keybind.new(config)
        local self = setmetatable(Base.new(config), Keybind)

        config = config or {}

        self.Key = config.Key or Enum.KeyCode.Unknown
        self.Label = config.Label
        self.AllowModifiers = config.AllowModifiers or false
        self.BlacklistedKeys = config.BlacklistedKeys or {
            Enum.KeyCode.Escape,
            Enum.KeyCode.W, Enum.KeyCode.A, Enum.KeyCode.S, Enum.KeyCode.D, -- Movement
        }

        -- Callbacks
        self.OnKeyChanged = config.OnKeyChanged
        self.OnKeyPressed = config.OnKeyPressed

        -- State
        self._isListening = false
        self._inputConnection = nil

        return self
    end

    --// Get key display name
    function Keybind:_getKeyName(keyCode)
        if keyCode == Enum.KeyCode.Unknown then
            return "None"
        end

        return KeyNames[keyCode] or string.upper(keyCode.Name)
    end

    --// Create keybind
    function Keybind:Create(parent)
        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(1, 0, 0, 36)
        container.BackgroundTransparency = 1

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Layout
        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.HorizontalAlignment = Enum.HorizontalAlignment.SpaceBetween
        layout.Parent = container

        -- Label
        if self.Label then
            local label = Instance.new("TextLabel")
            label.Name = "Label"
            label.Size = UDim2.new(0.5, 0, 1, 0)
            label.BackgroundTransparency = 1
            label.Font = Enum.Font.Gotham
            label.Text = self.Label
            label.TextColor3 = Color3.fromRGB(250, 250, 250)
            label.TextSize = 14
            label.TextXAlignment = Enum.TextXAlignment.Left
            label.LayoutOrder = 1
            label.Parent = container
            self._label = label
        end

        -- Keybind button
        local keyButton = Instance.new("TextButton")
        keyButton.Name = "KeyButton"
        keyButton.Size = UDim2.new(0, 100, 0, 30)
        keyButton.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
        keyButton.BorderSizePixel = 0
        keyButton.Font = Enum.Font.GothamMedium
        keyButton.Text = self:_getKeyName(self.Key)
        keyButton.TextColor3 = Color3.fromRGB(250, 250, 250)
        keyButton.TextSize = 13
        keyButton.AutoButtonColor = false
        keyButton.LayoutOrder = 2
        keyButton.Parent = container
        self._keyButton = keyButton

        -- Corner
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 6)
        corner.Parent = keyButton

        -- Border
        local stroke = Instance.new("UIStroke")
        stroke.Color = Color3.fromRGB(63, 63, 70)
        stroke.Thickness = 1
        stroke.Parent = keyButton
        self._stroke = stroke

        -- Setup interactions
        self:_setupInteractions()

        -- Start listening for key presses (for callbacks)
        self:_startKeyListener()

        return self
    end

    --// Setup interactions
    function Keybind:_setupInteractions()
        local keyButton = self._keyButton

        -- Click to start listening
        self:_connect(keyButton.MouseButton1Click, function()
            if self._isListening then
                self:_stopListening()
            else
                self:_startListening()
            end
        end)

        -- Hover
        self:_connect(keyButton.MouseEnter, function()
            if not self._isListening then
                TweenService:Create(self._stroke, TweenInfo.new(0.15), {
                    Color = Color3.fromRGB(82, 82, 91),
                }):Play()
            end
        end)

        self:_connect(keyButton.MouseLeave, function()
            if not self._isListening then
                TweenService:Create(self._stroke, TweenInfo.new(0.15), {
                    Color = Color3.fromRGB(63, 63, 70),
                }):Play()
            end
        end)
    end

    --// Start listening for new keybind
    function Keybind:_startListening()
        self._isListening = true

        self._keyButton.Text = "..."
        self._keyButton.BackgroundColor3 = Color3.fromRGB(99, 102, 241)
        self._stroke.Color = Color3.fromRGB(99, 102, 241)

        -- Listen for input
        if self._listenConnection then
            self._listenConnection:Disconnect()
        end

        self._listenConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if input.UserInputType == Enum.UserInputType.Keyboard then
                -- Check blacklist
                for _, key in ipairs(self.BlacklistedKeys) do
                    if input.KeyCode == key then
                        return
                    end
                end

                -- Set new key
                self:SetKey(input.KeyCode)
                self:_stopListening()
            elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
                -- Cancel on click outside
                task.defer(function()
                    self:_stopListening()
                end)
            end
        end)
    end

    --// Stop listening
    function Keybind:_stopListening()
        self._isListening = false

        if self._listenConnection then
            self._listenConnection:Disconnect()
            self._listenConnection = nil
        end

        self._keyButton.Text = self:_getKeyName(self.Key)

        TweenService:Create(self._keyButton, TweenInfo.new(0.15), {
            BackgroundColor3 = Color3.fromRGB(39, 39, 42),
        }):Play()

        TweenService:Create(self._stroke, TweenInfo.new(0.15), {
            Color = Color3.fromRGB(63, 63, 70),
        }):Play()
    end

    --// Start key listener (for callbacks)
    function Keybind:_startKeyListener()
        self._inputConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end

            if input.UserInputType == Enum.UserInputType.Keyboard then
                if input.KeyCode == self.Key then
                    if self.OnKeyPressed then
                        self.OnKeyPressed()
                    end

                    self:_fire("KeyPressed")
                end
            end
        end)
    end

    --// Set key
    function Keybind:SetKey(keyCode)
        local oldKey = self.Key
        self.Key = keyCode

        if self._keyButton then
            self._keyButton.Text = self:_getKeyName(keyCode)
        end

        if self.OnKeyChanged then
            self.OnKeyChanged(keyCode, oldKey)
        end

        self:_fire("KeyChanged", keyCode, oldKey)

        return self
    end

    --// Get key
    function Keybind:GetKey()
        return self.Key
    end

    --// Clear key
    function Keybind:ClearKey()
        return self:SetKey(Enum.KeyCode.Unknown)
    end

    --// Destroy override
    function Keybind:Destroy()
        if self._listenConnection then
            self._listenConnection:Disconnect()
        end

        if self._inputConnection then
            self._inputConnection:Disconnect()
        end

        Base.Destroy(self)
    end

    return Keybind


end


-- ============================================================================
-- Module: NexusUI/Components/Tabs
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Tabs"] = function()
    local script = CreateMockScript("NexusUI/Components/Tabs")
    
    --[[
        NexusUI Tabs Component
        Tabbed content navigation
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Tabs Component Module
    local Tabs = setmetatable({}, { __index = Base })
    Tabs.__index = Tabs
    Tabs.ClassName = "Tabs"

    --// Tab Variants
    Tabs.Variant = {
        Default = "Default",
        Pills = "Pills",
        Underline = "Underline",
        Bordered = "Bordered",
    }

    --// Constructor
    function Tabs.new(config)
        local self = setmetatable(Base.new(config), Tabs)

        config = config or {}

        self.TabItems = config.Tabs or {} -- Array of {Id, Text, Icon, Disabled, Content}
        self.SelectedIndex = config.SelectedIndex or 1
        self.Variant = config.Variant or Tabs.Variant.Default
        self.FullWidth = config.FullWidth or false

        -- Callbacks
        self.OnTabChange = config.OnTabChange

        -- State
        self._tabButtons = {}
        self._contentFrames = {}

        return self
    end

    --// Create tabs
    function Tabs:Create(parent)
        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(1, 0, 1, 0)
        container.BackgroundTransparency = 1

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Tab header
        local header = Instance.new("Frame")
        header.Name = "Header"
        header.Size = UDim2.new(1, 0, 0, 40)
        header.BackgroundTransparency = 1
        header.Parent = container
        self._header = header

        if self.Variant == Tabs.Variant.Bordered then
            header.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
            header.BackgroundTransparency = 0

            local headerCorner = Instance.new("UICorner")
            headerCorner.CornerRadius = UDim.new(0, 8)
            headerCorner.Parent = header

            local headerStroke = Instance.new("UIStroke")
            headerStroke.Color = Color3.fromRGB(63, 63, 70)
            headerStroke.Thickness = 1
            headerStroke.Parent = header
        end

        local headerPadding = Instance.new("UIPadding")
        headerPadding.PaddingLeft = UDim.new(0, 4)
        headerPadding.PaddingRight = UDim.new(0, 4)
        headerPadding.Parent = header

        local headerLayout = Instance.new("UIListLayout")
        headerLayout.FillDirection = Enum.FillDirection.Horizontal
        headerLayout.VerticalAlignment = Enum.VerticalAlignment.Center
        headerLayout.Padding = UDim.new(0, 4)
        headerLayout.Parent = header

        -- Underline indicator
        if self.Variant == Tabs.Variant.Underline then
            local underline = Instance.new("Frame")
            underline.Name = "Underline"
            underline.Size = UDim2.new(0, 50, 0, 2)
            underline.Position = UDim2.new(0, 0, 1, -2)
            underline.BackgroundColor3 = Color3.fromRGB(99, 102, 241)
            underline.BorderSizePixel = 0
            underline.ZIndex = 10
            underline.Parent = header
            self._underline = underline

            -- Bottom line
            local bottomLine = Instance.new("Frame")
            bottomLine.Size = UDim2.new(1, 0, 0, 1)
            bottomLine.Position = UDim2.new(0, 0, 1, -1)
            bottomLine.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
            bottomLine.BorderSizePixel = 0
            bottomLine.Parent = header
        end

        -- Content container
        local content = Instance.new("Frame")
        content.Name = "Content"
        content.Size = UDim2.new(1, 0, 1, -48)
        content.Position = UDim2.new(0, 0, 0, 48)
        content.BackgroundTransparency = 1
        content.Parent = container
        self._content = content

        -- Create tabs
        self:_createTabs()

        return self
    end

    --// Create tabs
    function Tabs:_createTabs()
        -- Clear existing
        for _, btn in ipairs(self._tabButtons) do
            btn:Destroy()
        end
        self._tabButtons = {}

        for _, frame in ipairs(self._contentFrames) do
            frame:Destroy()
        end
        self._contentFrames = {}

        for i, tab in ipairs(self.TabItems) do
            local isSelected = i == self.SelectedIndex
            local isDisabled = tab.Disabled

            -- Tab button
            local btn = Instance.new("TextButton")
            btn.Name = "Tab" .. i
            btn.Size = self.FullWidth and UDim2.new(1 / #self.TabItems, -8, 0, 32) or UDim2.new(0, 0, 0, 32)
            btn.AutomaticSize = not self.FullWidth and Enum.AutomaticSize.X or Enum.AutomaticSize.None
            btn.BorderSizePixel = 0
            btn.Text = ""
            btn.AutoButtonColor = false
            btn.LayoutOrder = i
            btn.Parent = self._header

            -- Style based on variant
            if self.Variant == Tabs.Variant.Pills then
                btn.BackgroundColor3 = isSelected and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(39, 39, 42)
                btn.BackgroundTransparency = isSelected and 0 or 1

                local btnCorner = Instance.new("UICorner")
                btnCorner.CornerRadius = UDim.new(0, 6)
                btnCorner.Parent = btn
            elseif self.Variant == Tabs.Variant.Underline then
                btn.BackgroundTransparency = 1
            elseif self.Variant == Tabs.Variant.Bordered then
                btn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
                btn.BackgroundTransparency = isSelected and 0 or 1

                local btnCorner = Instance.new("UICorner")
                btnCorner.CornerRadius = UDim.new(0, 6)
                btnCorner.Parent = btn
            else -- Default
                btn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
                btn.BackgroundTransparency = isSelected and 0 or 1

                local btnCorner = Instance.new("UICorner")
                btnCorner.CornerRadius = UDim.new(0, 6)
                btnCorner.Parent = btn
            end

            local btnPadding = Instance.new("UIPadding")
            btnPadding.PaddingLeft = UDim.new(0, 12)
            btnPadding.PaddingRight = UDim.new(0, 12)
            btnPadding.Parent = btn

            local btnLayout = Instance.new("UIListLayout")
            btnLayout.FillDirection = Enum.FillDirection.Horizontal
            btnLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            btnLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            btnLayout.Padding = UDim.new(0, 6)
            btnLayout.Parent = btn

            -- Icon
            if tab.Icon then
                local icon = Instance.new("ImageLabel")
                icon.Size = UDim2.new(0, 14, 0, 14)
                icon.BackgroundTransparency = 1
                icon.Image = tab.Icon
                icon.ImageColor3 = isSelected and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(161, 161, 170)
                icon.ImageTransparency = isDisabled and 0.5 or 0
                icon.LayoutOrder = 1
                icon.Parent = btn
            end

            -- Text
            local text = Instance.new("TextLabel")
            text.Size = UDim2.new(0, 0, 0, 0)
            text.AutomaticSize = Enum.AutomaticSize.XY
            text.BackgroundTransparency = 1
            text.Font = Enum.Font.GothamMedium
            text.Text = tab.Text
            text.TextColor3 = isSelected and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(161, 161, 170)
            text.TextSize = 13
            text.TextTransparency = isDisabled and 0.5 or 0
            text.LayoutOrder = 2
            text.Parent = btn

            -- Interactions
            if not isDisabled then
                self:_connect(btn.MouseButton1Click, function()
                    self:SetSelectedIndex(i)
                end)

                self:_connect(btn.MouseEnter, function()
                    if i ~= self.SelectedIndex then
                        TweenService:Create(btn, TweenInfo.new(0.1), {
                            BackgroundTransparency = self.Variant == Tabs.Variant.Underline and 1 or 0.7,
                        }):Play()
                    end
                end)

                self:_connect(btn.MouseLeave, function()
                    if i ~= self.SelectedIndex then
                        TweenService:Create(btn, TweenInfo.new(0.1), {
                            BackgroundTransparency = 1,
                        }):Play()
                    end
                end)
            end

            table.insert(self._tabButtons, btn)

            -- Content frame
            local contentFrame = Instance.new("Frame")
            contentFrame.Name = "TabContent" .. i
            contentFrame.Size = UDim2.new(1, 0, 1, 0)
            contentFrame.BackgroundTransparency = 1
            contentFrame.Visible = isSelected
            contentFrame.Parent = self._content

            table.insert(self._contentFrames, contentFrame)
        end

        -- Update underline position
        if self.Variant == Tabs.Variant.Underline then
            self:_updateUnderline(false)
        end
    end

    --// Update underline
    function Tabs:_updateUnderline(animate)
        if not self._underline then return end

        local btn = self._tabButtons[self.SelectedIndex]
        if not btn then return end

        local duration = animate ~= false and 0.2 or 0

        TweenService:Create(self._underline, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            Size = UDim2.new(0, btn.AbsoluteSize.X, 0, 2),
            Position = UDim2.new(0, btn.AbsolutePosition.X - self._header.AbsolutePosition.X, 1, -2),
        }):Play()
    end

    --// Set selected index
    function Tabs:SetSelectedIndex(index)
        if index == self.SelectedIndex then return self end
        if index < 1 or index > #self.TabItems then return self end

        local tab = self.TabItems[index]
        if tab.Disabled then return self end

        local oldIndex = self.SelectedIndex
        self.SelectedIndex = index

        -- Update tab buttons
        for i, btn in ipairs(self._tabButtons) do
            local isSelected = i == index

            if self.Variant == Tabs.Variant.Underline then
                local text = btn:FindFirstChild("TextLabel") or btn:FindFirstChildWhichIsA("TextLabel")
                if text then
                    TweenService:Create(text, TweenInfo.new(0.15), {
                        TextColor3 = isSelected and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(161, 161, 170),
                    }):Play()
                end
            else
                TweenService:Create(btn, TweenInfo.new(0.15), {
                    BackgroundTransparency = isSelected and 0 or 1,
                }):Play()

                -- Update text and icon colors
                for _, child in ipairs(btn:GetChildren()) do
                    if child:IsA("TextLabel") then
                        TweenService:Create(child, TweenInfo.new(0.15), {
                            TextColor3 = isSelected and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(161, 161, 170),
                        }):Play()
                    elseif child:IsA("ImageLabel") then
                        TweenService:Create(child, TweenInfo.new(0.15), {
                            ImageColor3 = isSelected and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(161, 161, 170),
                        }):Play()
                    end
                end
            end
        end

        -- Update content visibility
        for i, frame in ipairs(self._contentFrames) do
            frame.Visible = i == index
        end

        -- Update underline
        if self.Variant == Tabs.Variant.Underline then
            self:_updateUnderline(true)
        end

        if self.OnTabChange then
            self.OnTabChange(index, tab, oldIndex)
        end

        self:_fire("TabChange", index, tab, oldIndex)

        return self
    end

    --// Get content frame
    function Tabs:GetContentFrame(index)
        return self._contentFrames[index or self.SelectedIndex]
    end

    --// Set tabs
    function Tabs:SetTabs(tabs)
        self.TabItems = tabs
        self.SelectedIndex = 1
        self:_createTabs()
        return self
    end

    --// Add tab
    function Tabs:AddTab(tab)
        table.insert(self.TabItems, tab)
        self:_createTabs()
        return self
    end

    --// Remove tab
    function Tabs:RemoveTab(index)
        table.remove(self.TabItems, index)

        if self.SelectedIndex >= index then
            self.SelectedIndex = math.max(1, self.SelectedIndex - 1)
        end

        self:_createTabs()
        return self
    end

    return Tabs


end


-- ============================================================================
-- Module: NexusUI/Components/TopBar
-- ============================================================================
NexusUI_Modules["NexusUI/Components/TopBar"] = function()
    local script = CreateMockScript("NexusUI/Components/TopBar")
    
    --[[
        NexusUI TopBar Component
        Application top bar/header
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// TopBar Component Module
    local TopBar = setmetatable({}, { __index = Base })
    TopBar.__index = TopBar
    TopBar.ClassName = "TopBar"

    --// Constructor
    function TopBar.new(config)
        local self = setmetatable(Base.new(config), TopBar)

        config = config or {}

        self.Title = config.Title
        self.Logo = config.Logo
        self.Height = config.Height or 50
        self.LeftItems = config.LeftItems or {} -- Array of {Type, ...props}
        self.RightItems = config.RightItems or {}
        self.CenterItems = config.CenterItems or {}

        return self
    end

    --// Create top bar
    function TopBar:Create(parent)
        -- Container
        local topBar = Instance.new("Frame")
        topBar.Name = self.Name
        topBar.Size = UDim2.new(1, 0, 0, self.Height)
        topBar.BackgroundColor3 = Color3.fromRGB(24, 24, 27)
        topBar.BorderSizePixel = 0

        if parent then
            topBar.Parent = parent
        end

        self.Instance = topBar

        -- Border bottom
        local border = Instance.new("Frame")
        border.Size = UDim2.new(1, 0, 0, 1)
        border.Position = UDim2.new(0, 0, 1, -1)
        border.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
        border.BorderSizePixel = 0
        border.Parent = topBar

        local padding = Instance.new("UIPadding")
        padding.PaddingLeft = UDim.new(0, 16)
        padding.PaddingRight = UDim.new(0, 16)
        padding.Parent = topBar

        -- Layout
        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.HorizontalAlignment = Enum.HorizontalAlignment.SpaceBetween
        layout.Parent = topBar

        -- Left section
        local leftSection = Instance.new("Frame")
        leftSection.Name = "Left"
        leftSection.Size = UDim2.new(0, 0, 1, 0)
        leftSection.AutomaticSize = Enum.AutomaticSize.X
        leftSection.BackgroundTransparency = 1
        leftSection.LayoutOrder = 1
        leftSection.Parent = topBar
        self._leftSection = leftSection

        local leftLayout = Instance.new("UIListLayout")
        leftLayout.FillDirection = Enum.FillDirection.Horizontal
        leftLayout.VerticalAlignment = Enum.VerticalAlignment.Center
        leftLayout.Padding = UDim.new(0, 12)
        leftLayout.Parent = leftSection

        -- Logo
        if self.Logo then
            local logo = Instance.new("ImageLabel")
            logo.Size = UDim2.new(0, 28, 0, 28)
            logo.BackgroundTransparency = 1
            logo.Image = self.Logo
            logo.LayoutOrder = 1
            logo.Parent = leftSection
        end

        -- Title
        if self.Title then
            local title = Instance.new("TextLabel")
            title.Size = UDim2.new(0, 0, 1, 0)
            title.AutomaticSize = Enum.AutomaticSize.X
            title.BackgroundTransparency = 1
            title.Font = Enum.Font.GothamBold
            title.Text = self.Title
            title.TextColor3 = Color3.fromRGB(250, 250, 250)
            title.TextSize = 16
            title.LayoutOrder = 2
            title.Parent = leftSection
            self._title = title
        end

        -- Left items
        for i, itemConfig in ipairs(self.LeftItems) do
            self:_createItem(itemConfig, leftSection, i + 10)
        end

        -- Center section
        local centerSection = Instance.new("Frame")
        centerSection.Name = "Center"
        centerSection.Size = UDim2.new(0, 0, 1, 0)
        centerSection.AutomaticSize = Enum.AutomaticSize.X
        centerSection.BackgroundTransparency = 1
        centerSection.LayoutOrder = 2
        centerSection.Parent = topBar
        self._centerSection = centerSection

        local centerLayout = Instance.new("UIListLayout")
        centerLayout.FillDirection = Enum.FillDirection.Horizontal
        centerLayout.VerticalAlignment = Enum.VerticalAlignment.Center
        centerLayout.Padding = UDim.new(0, 8)
        centerLayout.Parent = centerSection

        for i, itemConfig in ipairs(self.CenterItems) do
            self:_createItem(itemConfig, centerSection, i)
        end

        -- Right section
        local rightSection = Instance.new("Frame")
        rightSection.Name = "Right"
        rightSection.Size = UDim2.new(0, 0, 1, 0)
        rightSection.AutomaticSize = Enum.AutomaticSize.X
        rightSection.BackgroundTransparency = 1
        rightSection.LayoutOrder = 3
        rightSection.Parent = topBar
        self._rightSection = rightSection

        local rightLayout = Instance.new("UIListLayout")
        rightLayout.FillDirection = Enum.FillDirection.Horizontal
        rightLayout.VerticalAlignment = Enum.VerticalAlignment.Center
        rightLayout.Padding = UDim.new(0, 8)
        rightLayout.Parent = rightSection

        for i, itemConfig in ipairs(self.RightItems) do
            self:_createItem(itemConfig, rightSection, i)
        end

        return self
    end

    --// Create item
    function TopBar:_createItem(config, parent, order)
        if config.Type == "Button" then
            local btn = Instance.new("TextButton")
            btn.Size = UDim2.new(0, 0, 0, 32)
            btn.AutomaticSize = Enum.AutomaticSize.X
            btn.BackgroundColor3 = config.Primary and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(63, 63, 70)
            btn.BackgroundTransparency = config.Primary and 0 or 1
            btn.BorderSizePixel = 0
            btn.Font = Enum.Font.GothamMedium
            btn.Text = config.Text or ""
            btn.TextColor3 = Color3.fromRGB(250, 250, 250)
            btn.TextSize = 13
            btn.AutoButtonColor = false
            btn.LayoutOrder = order
            btn.Parent = parent

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 6)
            corner.Parent = btn

            local padding = Instance.new("UIPadding")
            padding.PaddingLeft = UDim.new(0, 12)
            padding.PaddingRight = UDim.new(0, 12)
            padding.Parent = btn

            if config.OnClick then
                self:_connect(btn.MouseButton1Click, config.OnClick)
            end

            self:_connect(btn.MouseEnter, function()
                TweenService:Create(btn, TweenInfo.new(0.1), {
                    BackgroundTransparency = 0,
                }):Play()
            end)

            self:_connect(btn.MouseLeave, function()
                TweenService:Create(btn, TweenInfo.new(0.1), {
                    BackgroundTransparency = config.Primary and 0 or 1,
                }):Play()
            end)

            return btn

        elseif config.Type == "IconButton" then
            local btn = Instance.new("ImageButton")
            btn.Size = UDim2.new(0, 32, 0, 32)
            btn.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
            btn.BackgroundTransparency = 1
            btn.BorderSizePixel = 0
            btn.Image = config.Icon
            btn.ImageColor3 = Color3.fromRGB(161, 161, 170)
            btn.AutoButtonColor = false
            btn.LayoutOrder = order
            btn.Parent = parent

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 6)
            corner.Parent = btn

            if config.OnClick then
                self:_connect(btn.MouseButton1Click, config.OnClick)
            end

            self:_connect(btn.MouseEnter, function()
                TweenService:Create(btn, TweenInfo.new(0.1), {
                    BackgroundTransparency = 0,
                    ImageColor3 = Color3.fromRGB(250, 250, 250),
                }):Play()
            end)

            self:_connect(btn.MouseLeave, function()
                TweenService:Create(btn, TweenInfo.new(0.1), {
                    BackgroundTransparency = 1,
                    ImageColor3 = Color3.fromRGB(161, 161, 170),
                }):Play()
            end)

            return btn

        elseif config.Type == "Divider" then
            local divider = Instance.new("Frame")
            divider.Size = UDim2.new(0, 1, 0.6, 0)
            divider.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
            divider.BorderSizePixel = 0
            divider.LayoutOrder = order
            divider.Parent = parent

            return divider

        elseif config.Type == "Custom" and config.Create then
            local element = config.Create()
            if element then
                element.LayoutOrder = order
                element.Parent = parent
            end
            return element
        end
    end

    --// Set title
    function TopBar:SetTitle(title)
        self.Title = title
        if self._title then
            self._title.Text = title
        end
        return self
    end

    --// Get section
    function TopBar:GetLeftSection()
        return self._leftSection
    end

    function TopBar:GetCenterSection()
        return self._centerSection
    end

    function TopBar:GetRightSection()
        return self._rightSection
    end

    return TopBar


end


-- ============================================================================
-- Module: NexusUI/Components/ScrollView
-- ============================================================================
NexusUI_Modules["NexusUI/Components/ScrollView"] = function()
    local script = CreateMockScript("NexusUI/Components/ScrollView")
    
    --[[
        NexusUI ScrollView Component
        Scrollable content container
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// ScrollView Component Module
    local ScrollView = setmetatable({}, { __index = Base })
    ScrollView.__index = ScrollView
    ScrollView.ClassName = "ScrollView"

    --// Scroll Direction
    ScrollView.Direction = {
        Vertical = "Vertical",
        Horizontal = "Horizontal",
        Both = "Both",
    }

    --// Constructor
    function ScrollView.new(config)
        local self = setmetatable(Base.new(config), ScrollView)

        config = config or {}

        self.ScrollDirection = config.Direction or ScrollView.Direction.Vertical
        self.ShowScrollBar = config.ShowScrollBar ~= false
        self.ScrollBarWidth = config.ScrollBarWidth or 6
        self.ScrollBarColor = config.ScrollBarColor or Color3.fromRGB(82, 82, 91)
        self.Padding = config.Padding or 0
        self.AutoLayout = config.AutoLayout or false
        self.LayoutPadding = config.LayoutPadding or 8

        -- Callbacks
        self.OnScroll = config.OnScroll

        return self
    end

    --// Create scroll view
    function ScrollView:Create(parent)
        -- Container
        local container = Instance.new("ScrollingFrame")
        container.Name = self.Name
        container.Size = UDim2.new(1, 0, 1, 0)
        container.BackgroundTransparency = 1
        container.BorderSizePixel = 0
        container.ScrollBarThickness = self.ShowScrollBar and self.ScrollBarWidth or 0
        container.ScrollBarImageColor3 = self.ScrollBarColor
        container.CanvasSize = UDim2.new(0, 0, 0, 0)
        container.AutomaticCanvasSize = self:_getAutoCanvasSize()
        container.ScrollingDirection = self:_getScrollingDirection()

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Padding
        if self.Padding > 0 then
            local padding = Instance.new("UIPadding")
            padding.PaddingTop = UDim.new(0, self.Padding)
            padding.PaddingBottom = UDim.new(0, self.Padding)
            padding.PaddingLeft = UDim.new(0, self.Padding)
            padding.PaddingRight = UDim.new(0, self.Padding)
            padding.Parent = container
        end

        -- Auto layout
        if self.AutoLayout then
            local layout = Instance.new("UIListLayout")
            layout.SortOrder = Enum.SortOrder.LayoutOrder
            layout.Padding = UDim.new(0, self.LayoutPadding)

            if self.ScrollDirection == ScrollView.Direction.Horizontal then
                layout.FillDirection = Enum.FillDirection.Horizontal
                layout.VerticalAlignment = Enum.VerticalAlignment.Center
            else
                layout.FillDirection = Enum.FillDirection.Vertical
            end

            layout.Parent = container
            self._layout = layout
        end

        -- Scroll callback
        if self.OnScroll then
            self:_connect(container:GetPropertyChangedSignal("CanvasPosition"), function()
                self.OnScroll(container.CanvasPosition)
            end)
        end

        return self
    end

    --// Get auto canvas size
    function ScrollView:_getAutoCanvasSize()
        if self.ScrollDirection == ScrollView.Direction.Vertical then
            return Enum.AutomaticSize.Y
        elseif self.ScrollDirection == ScrollView.Direction.Horizontal then
            return Enum.AutomaticSize.X
        else
            return Enum.AutomaticSize.XY
        end
    end

    --// Get scrolling direction
    function ScrollView:_getScrollingDirection()
        if self.ScrollDirection == ScrollView.Direction.Vertical then
            return Enum.ScrollingDirection.Y
        elseif self.ScrollDirection == ScrollView.Direction.Horizontal then
            return Enum.ScrollingDirection.X
        else
            return Enum.ScrollingDirection.XY
        end
    end

    --// Scroll to position
    function ScrollView:ScrollTo(position, animate)
        if animate ~= false then
            TweenService:Create(self.Instance, TweenInfo.new(0.3), {
                CanvasPosition = position,
            }):Play()
        else
            self.Instance.CanvasPosition = position
        end
        return self
    end

    --// Scroll to top
    function ScrollView:ScrollToTop(animate)
        return self:ScrollTo(Vector2.new(self.Instance.CanvasPosition.X, 0), animate)
    end

    --// Scroll to bottom
    function ScrollView:ScrollToBottom(animate)
        local maxY = self.Instance.AbsoluteCanvasSize.Y - self.Instance.AbsoluteSize.Y
        return self:ScrollTo(Vector2.new(self.Instance.CanvasPosition.X, maxY), animate)
    end

    --// Scroll to element
    function ScrollView:ScrollToElement(element, animate)
        if not element or not element:IsDescendantOf(self.Instance) then return self end

        local elementPos = element.AbsolutePosition
        local containerPos = self.Instance.AbsolutePosition
        local relativePos = elementPos - containerPos + self.Instance.CanvasPosition

        return self:ScrollTo(relativePos, animate)
    end

    --// Get scroll position
    function ScrollView:GetScrollPosition()
        return self.Instance.CanvasPosition
    end

    --// Get scroll percentage
    function ScrollView:GetScrollPercentage()
        local canvasSize = self.Instance.AbsoluteCanvasSize
        local viewSize = self.Instance.AbsoluteSize
        local position = self.Instance.CanvasPosition

        local percentX = canvasSize.X > viewSize.X and position.X / (canvasSize.X - viewSize.X) or 0
        local percentY = canvasSize.Y > viewSize.Y and position.Y / (canvasSize.Y - viewSize.Y) or 0

        return Vector2.new(percentX, percentY)
    end

    --// Set canvas size
    function ScrollView:SetCanvasSize(size)
        self.Instance.CanvasSize = size
        return self
    end

    return ScrollView


end


-- ============================================================================
-- Module: NexusUI/Components/Section
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Section"] = function()
    local script = CreateMockScript("NexusUI/Components/Section")
    
    --[[
        NexusUI Section Component
        Collapsible content section
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Section Component Module
    local Section = setmetatable({}, { __index = Base })
    Section.__index = Section
    Section.ClassName = "Section"

    --// Constructor
    function Section.new(config)
        local self = setmetatable(Base.new(config), Section)

        config = config or {}

        self.Title = config.Title or "Section"
        self.Collapsible = config.Collapsible ~= false
        self.DefaultExpanded = config.DefaultExpanded ~= false
        self.Padding = config.Padding or 12
        self.ShowBorder = config.ShowBorder or false

        -- Callbacks
        self.OnExpand = config.OnExpand
        self.OnCollapse = config.OnCollapse

        -- State
        self._isExpanded = self.DefaultExpanded

        return self
    end

    --// Create section
    function Section:Create(parent)
        -- Container
        local section = Instance.new("Frame")
        section.Name = self.Name
        section.Size = UDim2.new(1, 0, 0, 0)
        section.AutomaticSize = Enum.AutomaticSize.Y
        section.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        section.BorderSizePixel = 0

        if parent then
            section.Parent = parent
        end

        self.Instance = section

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = section

        if self.ShowBorder then
            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(63, 63, 70)
            stroke.Thickness = 1
            stroke.Parent = section
        end

        -- Header
        local header
        if self.Collapsible then
            header = Instance.new("TextButton")
            header.Text = ""
            header.AutoButtonColor = false
        else
            header = Instance.new("Frame")
        end

        header.Name = "Header"
        header.Size = UDim2.new(1, 0, 0, 40)
        header.BackgroundTransparency = 1
        header.Parent = section
        self._header = header

        local headerPadding = Instance.new("UIPadding")
        headerPadding.PaddingLeft = UDim.new(0, self.Padding)
        headerPadding.PaddingRight = UDim.new(0, self.Padding)
        headerPadding.Parent = header

        local headerLayout = Instance.new("UIListLayout")
        headerLayout.FillDirection = Enum.FillDirection.Horizontal
        headerLayout.VerticalAlignment = Enum.VerticalAlignment.Center
        headerLayout.HorizontalAlignment = Enum.HorizontalAlignment.SpaceBetween
        headerLayout.Parent = header

        -- Title
        local title = Instance.new("TextLabel")
        title.Name = "Title"
        title.Size = UDim2.new(1, -30, 1, 0)
        title.BackgroundTransparency = 1
        title.Font = Enum.Font.GothamMedium
        title.Text = self.Title
        title.TextColor3 = Color3.fromRGB(250, 250, 250)
        title.TextSize = 14
        title.TextXAlignment = Enum.TextXAlignment.Left
        title.LayoutOrder = 1
        title.Parent = header
        self._title = title

        -- Arrow (if collapsible)
        if self.Collapsible then
            local arrow = Instance.new("ImageLabel")
            arrow.Name = "Arrow"
            arrow.Size = UDim2.new(0, 16, 0, 16)
            arrow.BackgroundTransparency = 1
            arrow.Image = "rbxassetid://7072706223"
            arrow.ImageColor3 = Color3.fromRGB(161, 161, 170)
            arrow.Rotation = self._isExpanded and 180 or 0
            arrow.LayoutOrder = 2
            arrow.Parent = header
            self._arrow = arrow

            self:_connect(header.MouseButton1Click, function()
                self:Toggle()
            end)

            self:_connect(header.MouseEnter, function()
                TweenService:Create(arrow, TweenInfo.new(0.15), {
                    ImageColor3 = Color3.fromRGB(250, 250, 250),
                }):Play()
            end)

            self:_connect(header.MouseLeave, function()
                TweenService:Create(arrow, TweenInfo.new(0.15), {
                    ImageColor3 = Color3.fromRGB(161, 161, 170),
                }):Play()
            end)
        end

        -- Content
        local content = Instance.new("Frame")
        content.Name = "Content"
        content.Size = UDim2.new(1, 0, 0, 0)
        content.AutomaticSize = self._isExpanded and Enum.AutomaticSize.Y or Enum.AutomaticSize.None
        content.Position = UDim2.new(0, 0, 0, 40)
        content.BackgroundTransparency = 1
        content.ClipsDescendants = true
        content.Parent = section
        self._content = content

        local contentPadding = Instance.new("UIPadding")
        contentPadding.PaddingLeft = UDim.new(0, self.Padding)
        contentPadding.PaddingRight = UDim.new(0, self.Padding)
        contentPadding.PaddingBottom = self._isExpanded and UDim.new(0, self.Padding) or UDim.new(0, 0)
        contentPadding.Parent = content
        self._contentPadding = contentPadding

        return self
    end

    --// Expand
    function Section:Expand(animate)
        if self._isExpanded then return self end

        self._isExpanded = true
        animate = animate ~= false

        if animate then
            TweenService:Create(self._arrow, TweenInfo.new(0.2), {
                Rotation = 180,
            }):Play()
        else
            self._arrow.Rotation = 180
        end

        self._contentPadding.PaddingBottom = UDim.new(0, self.Padding)
        self._content.AutomaticSize = Enum.AutomaticSize.Y

        if self.OnExpand then
            self.OnExpand()
        end

        self:_fire("Expand")

        return self
    end

    --// Collapse
    function Section:Collapse(animate)
        if not self._isExpanded then return self end

        self._isExpanded = false
        animate = animate ~= false

        if animate then
            TweenService:Create(self._arrow, TweenInfo.new(0.2), {
                Rotation = 0,
            }):Play()
        else
            self._arrow.Rotation = 0
        end

        self._contentPadding.PaddingBottom = UDim.new(0, 0)
        self._content.AutomaticSize = Enum.AutomaticSize.None
        self._content.Size = UDim2.new(1, 0, 0, 0)

        if self.OnCollapse then
            self.OnCollapse()
        end

        self:_fire("Collapse")

        return self
    end

    --// Toggle
    function Section:Toggle()
        if self._isExpanded then
            self:Collapse()
        else
            self:Expand()
        end
        return self
    end

    --// Is expanded
    function Section:IsExpanded()
        return self._isExpanded
    end

    --// Set title
    function Section:SetTitle(title)
        self.Title = title
        if self._title then
            self._title.Text = title
        end
        return self
    end

    --// Get content
    function Section:GetContent()
        return self._content
    end

    return Section


end


-- ============================================================================
-- Module: NexusUI/Components/List
-- ============================================================================
NexusUI_Modules["NexusUI/Components/List"] = function()
    local script = CreateMockScript("NexusUI/Components/List")
    
    --[[
        NexusUI List Component
        Scrollable list with items
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// List Component Module
    local List = setmetatable({}, { __index = Base })
    List.__index = List
    List.ClassName = "List"

    --// Constructor
    function List.new(config)
        local self = setmetatable(Base.new(config), List)

        config = config or {}

        self.Items = config.Items or {}
        self.Selectable = config.Selectable or false
        self.MultiSelect = config.MultiSelect or false
        self.ItemHeight = config.ItemHeight or 40
        self.Dividers = config.Dividers or false
        self.HoverEffect = config.HoverEffect ~= false

        -- Callbacks
        self.OnItemClick = config.OnItemClick
        self.OnSelectionChange = config.OnSelectionChange
        self.RenderItem = config.RenderItem -- Custom render function

        -- State
        self._selectedItems = {}
        self._itemElements = {}

        return self
    end

    --// Create list
    function List:Create(parent)
        -- Container
        local container = Instance.new("ScrollingFrame")
        container.Name = self.Name
        container.Size = UDim2.new(1, 0, 0, 300)
        container.BackgroundColor3 = Color3.fromRGB(24, 24, 27)
        container.BorderSizePixel = 0
        container.ScrollBarThickness = 4
        container.ScrollBarImageColor3 = Color3.fromRGB(82, 82, 91)
        container.CanvasSize = UDim2.new(0, 0, 0, 0)
        container.AutomaticCanvasSize = Enum.AutomaticSize.Y

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = container

        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, 4)
        padding.PaddingBottom = UDim.new(0, 4)
        padding.PaddingLeft = UDim.new(0, 4)
        padding.PaddingRight = UDim.new(0, 4)
        padding.Parent = container

        local layout = Instance.new("UIListLayout")
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Padding = UDim.new(0, self.Dividers and 1 or 2)
        layout.Parent = container

        -- Build items
        self:_buildItems()

        return self
    end

    --// Build items
    function List:_buildItems()
        -- Clear existing
        for _, element in pairs(self._itemElements) do
            element:Destroy()
        end
        self._itemElements = {}

        for i, item in ipairs(self.Items) do
            local itemData = type(item) == "table" and item or { Text = item }
            local isSelected = table.find(self._selectedItems, i) ~= nil

            local itemFrame = Instance.new("TextButton")
            itemFrame.Name = "Item" .. i
            itemFrame.Size = UDim2.new(1, 0, 0, self.ItemHeight)
            itemFrame.BackgroundColor3 = isSelected and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(30, 30, 35)
            itemFrame.BackgroundTransparency = isSelected and 0.8 or (self.HoverEffect and 1 or 0)
            itemFrame.BorderSizePixel = 0
            itemFrame.Text = ""
            itemFrame.AutoButtonColor = false
            itemFrame.LayoutOrder = i
            itemFrame.Parent = self.Instance

            local itemCorner = Instance.new("UICorner")
            itemCorner.CornerRadius = UDim.new(0, 6)
            itemCorner.Parent = itemFrame

            local itemPadding = Instance.new("UIPadding")
            itemPadding.PaddingLeft = UDim.new(0, 12)
            itemPadding.PaddingRight = UDim.new(0, 12)
            itemPadding.Parent = itemFrame

            if self.RenderItem then
                -- Custom render
                self.RenderItem(itemFrame, itemData, i, isSelected)
            else
                -- Default render
                local itemLayout = Instance.new("UIListLayout")
                itemLayout.FillDirection = Enum.FillDirection.Horizontal
                itemLayout.VerticalAlignment = Enum.VerticalAlignment.Center
                itemLayout.Padding = UDim.new(0, 10)
                itemLayout.Parent = itemFrame

                -- Icon
                if itemData.Icon then
                    local icon = Instance.new("ImageLabel")
                    icon.Size = UDim2.new(0, 18, 0, 18)
                    icon.BackgroundTransparency = 1
                    icon.Image = itemData.Icon
                    icon.ImageColor3 = Color3.fromRGB(161, 161, 170)
                    icon.LayoutOrder = 1
                    icon.Parent = itemFrame
                end

                -- Text container
                local textContainer = Instance.new("Frame")
                textContainer.Size = UDim2.new(1, itemData.Icon and -28 or 0, 1, 0)
                textContainer.BackgroundTransparency = 1
                textContainer.LayoutOrder = 2
                textContainer.Parent = itemFrame

                local textLayout = Instance.new("UIListLayout")
                textLayout.FillDirection = Enum.FillDirection.Vertical
                textLayout.VerticalAlignment = Enum.VerticalAlignment.Center
                textLayout.Padding = UDim.new(0, 2)
                textLayout.Parent = textContainer

                -- Primary text
                local text = Instance.new("TextLabel")
                text.Size = UDim2.new(1, 0, 0, 0)
                text.AutomaticSize = Enum.AutomaticSize.Y
                text.BackgroundTransparency = 1
                text.Font = Enum.Font.Gotham
                text.Text = itemData.Text or ""
                text.TextColor3 = Color3.fromRGB(250, 250, 250)
                text.TextSize = 13
                text.TextXAlignment = Enum.TextXAlignment.Left
                text.TextTruncate = Enum.TextTruncate.AtEnd
                text.LayoutOrder = 1
                text.Parent = textContainer

                -- Secondary text
                if itemData.SecondaryText then
                    local secondaryText = Instance.new("TextLabel")
                    secondaryText.Size = UDim2.new(1, 0, 0, 0)
                    secondaryText.AutomaticSize = Enum.AutomaticSize.Y
                    secondaryText.BackgroundTransparency = 1
                    secondaryText.Font = Enum.Font.Gotham
                    secondaryText.Text = itemData.SecondaryText
                    secondaryText.TextColor3 = Color3.fromRGB(113, 113, 122)
                    secondaryText.TextSize = 11
                    secondaryText.TextXAlignment = Enum.TextXAlignment.Left
                    secondaryText.LayoutOrder = 2
                    secondaryText.Parent = textContainer
                end

                -- Trailing content
                if itemData.Trailing then
                    local trailing = Instance.new("TextLabel")
                    trailing.Size = UDim2.new(0, 0, 0, 0)
                    trailing.AutomaticSize = Enum.AutomaticSize.XY
                    trailing.Position = UDim2.new(1, -12, 0.5, 0)
                    trailing.AnchorPoint = Vector2.new(1, 0.5)
                    trailing.BackgroundTransparency = 1
                    trailing.Font = Enum.Font.Gotham
                    trailing.Text = itemData.Trailing
                    trailing.TextColor3 = Color3.fromRGB(113, 113, 122)
                    trailing.TextSize = 12
                    trailing.Parent = itemFrame
                end
            end

            -- Interactions
            self:_connect(itemFrame.MouseButton1Click, function()
                if self.Selectable then
                    self:_toggleSelection(i)
                end

                if self.OnItemClick then
                    self.OnItemClick(i, itemData)
                end

                self:_fire("ItemClick", i, itemData)
            end)

            if self.HoverEffect then
                self:_connect(itemFrame.MouseEnter, function()
                    if not isSelected then
                        TweenService:Create(itemFrame, TweenInfo.new(0.1), {
                            BackgroundTransparency = 0.8,
                        }):Play()
                    end
                end)

                self:_connect(itemFrame.MouseLeave, function()
                    if not isSelected then
                        TweenService:Create(itemFrame, TweenInfo.new(0.1), {
                            BackgroundTransparency = 1,
                        }):Play()
                    end
                end)
            end

            self._itemElements[i] = itemFrame

            -- Divider
            if self.Dividers and i < #self.Items then
                local divider = Instance.new("Frame")
                divider.Name = "Divider" .. i
                divider.Size = UDim2.new(1, -24, 0, 1)
                divider.Position = UDim2.new(0.5, 0, 0, 0)
                divider.AnchorPoint = Vector2.new(0.5, 0)
                divider.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
                divider.BorderSizePixel = 0
                divider.LayoutOrder = i * 2
                divider.Parent = self.Instance
            end
        end
    end

    --// Toggle selection
    function List:_toggleSelection(index)
        local existingPos = table.find(self._selectedItems, index)

        if existingPos then
            table.remove(self._selectedItems, existingPos)
        else
            if self.MultiSelect then
                table.insert(self._selectedItems, index)
            else
                self._selectedItems = { index }
            end
        end

        self:_buildItems()

        if self.OnSelectionChange then
            self.OnSelectionChange(self._selectedItems)
        end

        self:_fire("SelectionChange", self._selectedItems)
    end

    --// Set items
    function List:SetItems(items)
        self.Items = items
        self._selectedItems = {}
        self:_buildItems()
        return self
    end

    --// Add item
    function List:AddItem(item)
        table.insert(self.Items, item)
        self:_buildItems()
        return self
    end

    --// Remove item
    function List:RemoveItem(index)
        table.remove(self.Items, index)

        for i, selectedIndex in ipairs(self._selectedItems) do
            if selectedIndex == index then
                table.remove(self._selectedItems, i)
            elseif selectedIndex > index then
                self._selectedItems[i] = selectedIndex - 1
            end
        end

        self:_buildItems()
        return self
    end

    --// Get selected items
    function List:GetSelectedItems()
        local items = {}
        for _, index in ipairs(self._selectedItems) do
            table.insert(items, self.Items[index])
        end
        return items
    end

    --// Clear selection
    function List:ClearSelection()
        self._selectedItems = {}
        self:_buildItems()
        return self
    end

    return List


end


-- ============================================================================
-- Module: NexusUI/Components/VirtualList
-- ============================================================================
NexusUI_Modules["NexusUI/Components/VirtualList"] = function()
    local script = CreateMockScript("NexusUI/Components/VirtualList")
    
    --[[
        NexusUI VirtualList Component
        Virtualized list for large datasets
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")
    local RunService = game:GetService("RunService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// VirtualList Component Module
    local VirtualList = setmetatable({}, { __index = Base })
    VirtualList.__index = VirtualList
    VirtualList.ClassName = "VirtualList"

    --// Constructor
    function VirtualList.new(config)
        local self = setmetatable(Base.new(config), VirtualList)

        config = config or {}

        self.ItemCount = config.ItemCount or 0
        self.ItemHeight = config.ItemHeight or 40
        self.OverscanCount = config.OverscanCount or 3
        self.RenderItem = config.RenderItem -- Required: function(frame, index) -> void

        -- Callbacks
        self.OnScroll = config.OnScroll
        self.OnItemClick = config.OnItemClick

        -- State
        self._visibleItems = {}
        self._scrollPos = 0
        self._containerHeight = 0

        return self
    end

    --// Create virtual list
    function VirtualList:Create(parent)
        -- Container
        local container = Instance.new("ScrollingFrame")
        container.Name = self.Name
        container.Size = UDim2.new(1, 0, 1, 0)
        container.BackgroundColor3 = Color3.fromRGB(24, 24, 27)
        container.BorderSizePixel = 0
        container.ScrollBarThickness = 6
        container.ScrollBarImageColor3 = Color3.fromRGB(82, 82, 91)
        container.CanvasSize = UDim2.new(0, 0, 0, self.ItemCount * self.ItemHeight)
        container.ScrollingDirection = Enum.ScrollingDirection.Y

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = container

        -- Inner container for items
        local inner = Instance.new("Frame")
        inner.Name = "Inner"
        inner.Size = UDim2.new(1, -12, 1, 0)
        inner.Position = UDim2.new(0, 0, 0, 0)
        inner.BackgroundTransparency = 1
        inner.Parent = container
        self._inner = inner

        -- Track scroll position
        self:_connect(container:GetPropertyChangedSignal("CanvasPosition"), function()
            self._scrollPos = container.CanvasPosition.Y
            self:_updateVisibleItems()

            if self.OnScroll then
                self.OnScroll(self._scrollPos)
            end
        end)

        -- Track size changes
        self:_connect(container:GetPropertyChangedSignal("AbsoluteSize"), function()
            self._containerHeight = container.AbsoluteSize.Y
            self:_updateVisibleItems()
        end)

        -- Initial render
        task.defer(function()
            self._containerHeight = container.AbsoluteSize.Y
            self:_updateVisibleItems()
        end)

        return self
    end

    --// Update visible items
    function VirtualList:_updateVisibleItems()
        if not self.RenderItem then return end

        -- Calculate visible range
        local startIndex = math.floor(self._scrollPos / self.ItemHeight) - self.OverscanCount
        startIndex = math.max(1, startIndex)

        local visibleCount = math.ceil(self._containerHeight / self.ItemHeight) + self.OverscanCount * 2
        local endIndex = math.min(self.ItemCount, startIndex + visibleCount)

        -- Track which indices need items
        local neededIndices = {}
        for i = startIndex, endIndex do
            neededIndices[i] = true
        end

        -- Remove items that are no longer visible
        for index, itemFrame in pairs(self._visibleItems) do
            if not neededIndices[index] then
                itemFrame:Destroy()
                self._visibleItems[index] = nil
            end
        end

        -- Add new items
        for index, _ in pairs(neededIndices) do
            if not self._visibleItems[index] then
                self:_createItem(index)
            end
        end
    end

    --// Create item
    function VirtualList:_createItem(index)
        local itemFrame = Instance.new("TextButton")
        itemFrame.Name = "Item" .. index
        itemFrame.Size = UDim2.new(1, 0, 0, self.ItemHeight)
        itemFrame.Position = UDim2.new(0, 0, 0, (index - 1) * self.ItemHeight)
        itemFrame.BackgroundTransparency = 1
        itemFrame.BorderSizePixel = 0
        itemFrame.Text = ""
        itemFrame.AutoButtonColor = false
        itemFrame.Parent = self._inner

        -- Call render function
        self.RenderItem(itemFrame, index)

        -- Click handler
        self:_connect(itemFrame.MouseButton1Click, function()
            if self.OnItemClick then
                self.OnItemClick(index)
            end

            self:_fire("ItemClick", index)
        end)

        self._visibleItems[index] = itemFrame
    end

    --// Set item count
    function VirtualList:SetItemCount(count)
        self.ItemCount = count
        self.Instance.CanvasSize = UDim2.new(0, 0, 0, count * self.ItemHeight)

        -- Clear and re-render
        for _, itemFrame in pairs(self._visibleItems) do
            itemFrame:Destroy()
        end
        self._visibleItems = {}

        self:_updateVisibleItems()
        return self
    end

    --// Scroll to index
    function VirtualList:ScrollToIndex(index, animate)
        local targetPos = (index - 1) * self.ItemHeight

        if animate ~= false then
            TweenService:Create(self.Instance, TweenInfo.new(0.3), {
                CanvasPosition = Vector2.new(0, targetPos),
            }):Play()
        else
            self.Instance.CanvasPosition = Vector2.new(0, targetPos)
        end

        return self
    end

    --// Scroll to top
    function VirtualList:ScrollToTop(animate)
        return self:ScrollToIndex(1, animate)
    end

    --// Scroll to bottom
    function VirtualList:ScrollToBottom(animate)
        return self:ScrollToIndex(self.ItemCount, animate)
    end

    --// Refresh all items
    function VirtualList:Refresh()
        for index, itemFrame in pairs(self._visibleItems) do
            -- Clear children
            for _, child in ipairs(itemFrame:GetChildren()) do
                child:Destroy()
            end

            -- Re-render
            self.RenderItem(itemFrame, index)
        end

        return self
    end

    --// Refresh specific item
    function VirtualList:RefreshItem(index)
        local itemFrame = self._visibleItems[index]
        if itemFrame then
            -- Clear children
            for _, child in ipairs(itemFrame:GetChildren()) do
                child:Destroy()
            end

            -- Re-render
            self.RenderItem(itemFrame, index)
        end

        return self
    end

    --// Get visible range
    function VirtualList:GetVisibleRange()
        local startIndex = math.floor(self._scrollPos / self.ItemHeight) + 1
        local endIndex = math.ceil((self._scrollPos + self._containerHeight) / self.ItemHeight)
        return startIndex, math.min(endIndex, self.ItemCount)
    end

    return VirtualList


end


-- ============================================================================
-- Module: NexusUI/Components/RangeSlider
-- ============================================================================
NexusUI_Modules["NexusUI/Components/RangeSlider"] = function()
    local script = CreateMockScript("NexusUI/Components/RangeSlider")
    
    --[[
        NexusUI RangeSlider Component
        Dual-handle range selection slider
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// RangeSlider Component Module
    local RangeSlider = setmetatable({}, { __index = Base })
    RangeSlider.__index = RangeSlider
    RangeSlider.ClassName = "RangeSlider"

    --// Constructor
    function RangeSlider.new(config)
        local self = setmetatable(Base.new(config), RangeSlider)

        config = config or {}

        self.MinValue = config.MinValue or config.Min or 0
        self.MaxValue = config.MaxValue or config.Max or 100
        self.StartValue = config.StartValue or self.MinValue
        self.EndValue = config.EndValue or self.MaxValue
        self.Step = config.Step or 1
        self.Label = config.Label
        self.ShowValues = config.ShowValues ~= false
        self.ValueFormat = config.ValueFormat or "%.0f"
        self.TrackColor = config.TrackColor or Color3.fromRGB(63, 63, 70)
        self.FillColor = config.FillColor or Color3.fromRGB(99, 102, 241)
        self.KnobColor = config.KnobColor or Color3.fromRGB(255, 255, 255)

        -- Callbacks
        self.OnRangeChange = config.OnRangeChange
        self.OnDragStart = config.OnDragStart
        self.OnDragEnd = config.OnDragEnd

        -- State
        self._draggingKnob = nil -- "start" or "end"

        return self
    end

    --// Create range slider
    function RangeSlider:Create(parent)
        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(1, 0, 0, 50)
        container.BackgroundTransparency = 1

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Header
        if self.Label or self.ShowValues then
            local header = Instance.new("Frame")
            header.Name = "Header"
            header.Size = UDim2.new(1, 0, 0, 20)
            header.BackgroundTransparency = 1
            header.Parent = container

            if self.Label then
                local label = Instance.new("TextLabel")
                label.Size = UDim2.new(0.5, 0, 1, 0)
                label.BackgroundTransparency = 1
                label.Font = Enum.Font.Gotham
                label.Text = self.Label
                label.TextColor3 = Color3.fromRGB(250, 250, 250)
                label.TextSize = 14
                label.TextXAlignment = Enum.TextXAlignment.Left
                label.Parent = header
            end

            if self.ShowValues then
                local valuesLabel = Instance.new("TextLabel")
                valuesLabel.Name = "Values"
                valuesLabel.Size = UDim2.new(0.5, 0, 1, 0)
                valuesLabel.Position = UDim2.new(0.5, 0, 0, 0)
                valuesLabel.BackgroundTransparency = 1
                valuesLabel.Font = Enum.Font.GothamMedium
                valuesLabel.TextColor3 = Color3.fromRGB(161, 161, 170)
                valuesLabel.TextSize = 14
                valuesLabel.TextXAlignment = Enum.TextXAlignment.Right
                valuesLabel.Parent = header
                self._valuesLabel = valuesLabel

                self:_updateValuesLabel()
            end
        end

        -- Track container
        local trackContainer = Instance.new("Frame")
        trackContainer.Name = "TrackContainer"
        trackContainer.Size = UDim2.new(1, 0, 0, 20)
        trackContainer.Position = UDim2.new(0, 0, 1, -20)
        trackContainer.BackgroundTransparency = 1
        trackContainer.Parent = container

        -- Track
        local track = Instance.new("Frame")
        track.Name = "Track"
        track.Size = UDim2.new(1, 0, 0, 6)
        track.Position = UDim2.new(0, 0, 0.5, 0)
        track.AnchorPoint = Vector2.new(0, 0.5)
        track.BackgroundColor3 = self.TrackColor
        track.BorderSizePixel = 0
        track.Parent = trackContainer
        self._track = track

        local trackCorner = Instance.new("UICorner")
        trackCorner.CornerRadius = UDim.new(1, 0)
        trackCorner.Parent = track

        -- Fill (range indicator)
        local fill = Instance.new("Frame")
        fill.Name = "Fill"
        fill.BackgroundColor3 = self.FillColor
        fill.BorderSizePixel = 0
        fill.Parent = track
        self._fill = fill

        local fillCorner = Instance.new("UICorner")
        fillCorner.CornerRadius = UDim.new(1, 0)
        fillCorner.Parent = fill

        -- Start knob
        local startKnob = self:_createKnob("StartKnob", trackContainer)
        self._startKnob = startKnob

        -- End knob
        local endKnob = self:_createKnob("EndKnob", trackContainer)
        self._endKnob = endKnob

        -- Click area
        local clickArea = Instance.new("TextButton")
        clickArea.Name = "ClickArea"
        clickArea.Size = UDim2.new(1, 0, 1, 0)
        clickArea.BackgroundTransparency = 1
        clickArea.Text = ""
        clickArea.ZIndex = 3
        clickArea.Parent = trackContainer
        self._clickArea = clickArea

        -- Setup interactions
        self:_setupInteractions()

        -- Initial update
        self:_updateVisuals()

        return self
    end

    --// Create knob
    function RangeSlider:_createKnob(name, parent)
        local knob = Instance.new("Frame")
        knob.Name = name
        knob.Size = UDim2.new(0, 18, 0, 18)
        knob.AnchorPoint = Vector2.new(0.5, 0.5)
        knob.BackgroundColor3 = self.KnobColor
        knob.BorderSizePixel = 0
        knob.ZIndex = 5
        knob.Parent = parent

        local knobCorner = Instance.new("UICorner")
        knobCorner.CornerRadius = UDim.new(1, 0)
        knobCorner.Parent = knob

        -- Shadow
        local shadow = Instance.new("ImageLabel")
        shadow.Size = UDim2.new(1, 12, 1, 12)
        shadow.Position = UDim2.new(0.5, 0, 0.5, 2)
        shadow.AnchorPoint = Vector2.new(0.5, 0.5)
        shadow.BackgroundTransparency = 1
        shadow.Image = "rbxassetid://6015897843"
        shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
        shadow.ImageTransparency = 0.6
        shadow.ScaleType = Enum.ScaleType.Slice
        shadow.SliceCenter = Rect.new(49, 49, 450, 450)
        shadow.ZIndex = 4
        shadow.Parent = knob

        return knob
    end

    --// Update values label
    function RangeSlider:_updateValuesLabel()
        if self._valuesLabel then
            local startText = string.format(self.ValueFormat, self.StartValue)
            local endText = string.format(self.ValueFormat, self.EndValue)
            self._valuesLabel.Text = startText .. " - " .. endText
        end
    end

    --// Update visuals
    function RangeSlider:_updateVisuals()
        local range = self.MaxValue - self.MinValue
        local startProgress = (self.StartValue - self.MinValue) / range
        local endProgress = (self.EndValue - self.MinValue) / range

        -- Update fill
        self._fill.Position = UDim2.new(startProgress, 0, 0, 0)
        self._fill.Size = UDim2.new(endProgress - startProgress, 0, 1, 0)

        -- Update knobs
        self._startKnob.Position = UDim2.new(startProgress, 0, 0.5, 0)
        self._endKnob.Position = UDim2.new(endProgress, 0, 0.5, 0)

        self:_updateValuesLabel()
    end

    --// Setup interactions
    function RangeSlider:_setupInteractions()
        local function getValueFromMouse()
            local mousePos = UserInputService:GetMouseLocation()
            local trackPos = self._track.AbsolutePosition
            local trackSize = self._track.AbsoluteSize

            local relativeX = mousePos.X - trackPos.X
            local progress = math.clamp(relativeX / trackSize.X, 0, 1)
            local rawValue = self.MinValue + (self.MaxValue - self.MinValue) * progress

            -- Apply step
            if self.Step > 0 then
                rawValue = math.floor(rawValue / self.Step + 0.5) * self.Step
            end

            return math.clamp(rawValue, self.MinValue, self.MaxValue)
        end

        local function updateDrag()
            local value = getValueFromMouse()

            if self._draggingKnob == "start" then
                self.StartValue = math.min(value, self.EndValue - self.Step)
            elseif self._draggingKnob == "end" then
                self.EndValue = math.max(value, self.StartValue + self.Step)
            end

            self:_updateVisuals()
        end

        -- Click on track
        self:_connect(self._clickArea.MouseButton1Down, function()
            local value = getValueFromMouse()

            -- Determine which knob is closer
            local startDist = math.abs(value - self.StartValue)
            local endDist = math.abs(value - self.EndValue)

            if startDist < endDist then
                self._draggingKnob = "start"
                self.StartValue = math.min(value, self.EndValue - self.Step)
            else
                self._draggingKnob = "end"
                self.EndValue = math.max(value, self.StartValue + self.Step)
            end

            self:_updateVisuals()

            if self.OnDragStart then
                self.OnDragStart()
            end
        end)

        -- Mouse move
        local moveConnection
        self:_connect(self._clickArea.MouseButton1Down, function()
            if moveConnection then
                moveConnection:Disconnect()
            end

            moveConnection = RunService.Heartbeat:Connect(function()
                if self._draggingKnob then
                    updateDrag()
                end
            end)
        end)

        -- Mouse up
        self:_connect(UserInputService.InputEnded, function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 and self._draggingKnob then
                self._draggingKnob = nil

                if moveConnection then
                    moveConnection:Disconnect()
                    moveConnection = nil
                end

                if self.OnRangeChange then
                    self.OnRangeChange(self.StartValue, self.EndValue)
                end

                if self.OnDragEnd then
                    self.OnDragEnd()
                end

                self:_fire("RangeChange", self.StartValue, self.EndValue)
            end
        end)

        -- Knob hover effects
        for _, knob in ipairs({self._startKnob, self._endKnob}) do
            -- Create invisible button for interaction
            local btn = Instance.new("TextButton")
            btn.Size = UDim2.new(1, 6, 1, 6)
            btn.Position = UDim2.new(0.5, 0, 0.5, 0)
            btn.AnchorPoint = Vector2.new(0.5, 0.5)
            btn.BackgroundTransparency = 1
            btn.Text = ""
            btn.ZIndex = 6
            btn.Parent = knob

            self:_connect(btn.MouseEnter, function()
                TweenService:Create(knob, TweenInfo.new(0.15), {
                    Size = UDim2.new(0, 22, 0, 22),
                }):Play()
            end)

            self:_connect(btn.MouseLeave, function()
                if not self._draggingKnob then
                    TweenService:Create(knob, TweenInfo.new(0.15), {
                        Size = UDim2.new(0, 18, 0, 18),
                    }):Play()
                end
            end)
        end
    end

    --// Set range
    function RangeSlider:SetRange(startValue, endValue)
        self.StartValue = math.clamp(startValue, self.MinValue, self.MaxValue)
        self.EndValue = math.clamp(endValue, self.MinValue, self.MaxValue)

        if self.StartValue > self.EndValue then
            self.StartValue, self.EndValue = self.EndValue, self.StartValue
        end

        self:_updateVisuals()
        return self
    end

    --// Get range
    function RangeSlider:GetRange()
        return self.StartValue, self.EndValue
    end

    --// Set min/max
    function RangeSlider:SetBounds(min, max)
        self.MinValue = min
        self.MaxValue = max

        self.StartValue = math.clamp(self.StartValue, min, max)
        self.EndValue = math.clamp(self.EndValue, min, max)

        self:_updateVisuals()
        return self
    end

    return RangeSlider


end


-- ============================================================================
-- Module: NexusUI/Components/Switch
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Switch"] = function()
    local script = CreateMockScript("NexusUI/Components/Switch")
    
    --[[
        NexusUI Switch Component
        iOS-style switch with labels
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Switch Component Module
    local Switch = setmetatable({}, { __index = Base })
    Switch.__index = Switch
    Switch.ClassName = "Switch"

    --// Constructor
    function Switch.new(config)
        local self = setmetatable(Base.new(config), Switch)

        config = config or {}

        self.Value = config.Value or false
        self.Label = config.Label
        self.Description = config.Description
        self.OnLabel = config.OnLabel or "On"
        self.OffLabel = config.OffLabel or "Off"
        self.ShowLabels = config.ShowLabels or false
        self.ColorOn = config.ColorOn or Color3.fromRGB(34, 197, 94)
        self.ColorOff = config.ColorOff or Color3.fromRGB(63, 63, 70)

        -- Callbacks
        self.OnChange = config.OnChange

        return self
    end

    --// Create switch
    function Switch:Create(parent)
        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(1, 0, 0, self.Description and 50 or 36)
        container.BackgroundTransparency = 1

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Main layout
        local mainLayout = Instance.new("UIListLayout")
        mainLayout.FillDirection = Enum.FillDirection.Horizontal
        mainLayout.VerticalAlignment = Enum.VerticalAlignment.Center
        mainLayout.HorizontalAlignment = Enum.HorizontalAlignment.SpaceBetween
        mainLayout.Parent = container

        -- Text container (label + description)
        local textContainer = Instance.new("Frame")
        textContainer.Name = "TextContainer"
        textContainer.Size = UDim2.new(1, -70, 1, 0)
        textContainer.BackgroundTransparency = 1
        textContainer.LayoutOrder = 1
        textContainer.Parent = container

        local textLayout = Instance.new("UIListLayout")
        textLayout.FillDirection = Enum.FillDirection.Vertical
        textLayout.VerticalAlignment = Enum.VerticalAlignment.Center
        textLayout.Padding = UDim.new(0, 4)
        textLayout.Parent = textContainer

        -- Label
        if self.Label then
            local label = Instance.new("TextLabel")
            label.Name = "Label"
            label.Size = UDim2.new(1, 0, 0, 0)
            label.AutomaticSize = Enum.AutomaticSize.Y
            label.BackgroundTransparency = 1
            label.Font = Enum.Font.GothamMedium
            label.Text = self.Label
            label.TextColor3 = Color3.fromRGB(250, 250, 250)
            label.TextSize = 14
            label.TextXAlignment = Enum.TextXAlignment.Left
            label.TextWrapped = true
            label.LayoutOrder = 1
            label.Parent = textContainer
            self._label = label
        end

        -- Description
        if self.Description then
            local description = Instance.new("TextLabel")
            description.Name = "Description"
            description.Size = UDim2.new(1, 0, 0, 0)
            description.AutomaticSize = Enum.AutomaticSize.Y
            description.BackgroundTransparency = 1
            description.Font = Enum.Font.Gotham
            description.Text = self.Description
            description.TextColor3 = Color3.fromRGB(113, 113, 122)
            description.TextSize = 12
            description.TextXAlignment = Enum.TextXAlignment.Left
            description.TextWrapped = true
            description.LayoutOrder = 2
            description.Parent = textContainer
            self._description = description
        end

        -- Switch container
        local switchContainer = Instance.new("Frame")
        switchContainer.Name = "SwitchContainer"
        switchContainer.Size = UDim2.new(0, 0, 0, 26)
        switchContainer.AutomaticSize = Enum.AutomaticSize.X
        switchContainer.BackgroundTransparency = 1
        switchContainer.LayoutOrder = 2
        switchContainer.Parent = container

        local switchLayout = Instance.new("UIListLayout")
        switchLayout.FillDirection = Enum.FillDirection.Horizontal
        switchLayout.VerticalAlignment = Enum.VerticalAlignment.Center
        switchLayout.Padding = UDim.new(0, 8)
        switchLayout.Parent = switchContainer

        -- Off label (if shown)
        if self.ShowLabels then
            local offLabel = Instance.new("TextLabel")
            offLabel.Name = "OffLabel"
            offLabel.Size = UDim2.new(0, 0, 0, 0)
            offLabel.AutomaticSize = Enum.AutomaticSize.XY
            offLabel.BackgroundTransparency = 1
            offLabel.Font = Enum.Font.Gotham
            offLabel.Text = self.OffLabel
            offLabel.TextColor3 = self.Value and Color3.fromRGB(113, 113, 122) or Color3.fromRGB(250, 250, 250)
            offLabel.TextSize = 12
            offLabel.LayoutOrder = 1
            offLabel.Parent = switchContainer
            self._offLabel = offLabel
        end

        -- Switch track
        local track = Instance.new("TextButton")
        track.Name = "Track"
        track.Size = UDim2.new(0, 48, 0, 26)
        track.BackgroundColor3 = self.Value and self.ColorOn or self.ColorOff
        track.BorderSizePixel = 0
        track.Text = ""
        track.AutoButtonColor = false
        track.LayoutOrder = 2
        track.Parent = switchContainer
        self._track = track

        local trackCorner = Instance.new("UICorner")
        trackCorner.CornerRadius = UDim.new(1, 0)
        trackCorner.Parent = track

        -- Knob
        local knob = Instance.new("Frame")
        knob.Name = "Knob"
        knob.Size = UDim2.new(0, 22, 0, 22)
        knob.Position = self.Value and UDim2.new(1, -24, 0.5, 0) or UDim2.new(0, 2, 0.5, 0)
        knob.AnchorPoint = Vector2.new(0, 0.5)
        knob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        knob.BorderSizePixel = 0
        knob.Parent = track
        self._knob = knob

        local knobCorner = Instance.new("UICorner")
        knobCorner.CornerRadius = UDim.new(1, 0)
        knobCorner.Parent = knob

        -- Knob shadow
        local shadow = Instance.new("ImageLabel")
        shadow.Name = "Shadow"
        shadow.Size = UDim2.new(1, 8, 1, 8)
        shadow.Position = UDim2.new(0.5, 0, 0.5, 2)
        shadow.AnchorPoint = Vector2.new(0.5, 0.5)
        shadow.BackgroundTransparency = 1
        shadow.Image = "rbxassetid://6015897843"
        shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
        shadow.ImageTransparency = 0.7
        shadow.ScaleType = Enum.ScaleType.Slice
        shadow.SliceCenter = Rect.new(49, 49, 450, 450)
        shadow.ZIndex = knob.ZIndex - 1
        shadow.Parent = knob

        -- On label (if shown)
        if self.ShowLabels then
            local onLabel = Instance.new("TextLabel")
            onLabel.Name = "OnLabel"
            onLabel.Size = UDim2.new(0, 0, 0, 0)
            onLabel.AutomaticSize = Enum.AutomaticSize.XY
            onLabel.BackgroundTransparency = 1
            onLabel.Font = Enum.Font.Gotham
            onLabel.Text = self.OnLabel
            onLabel.TextColor3 = self.Value and Color3.fromRGB(250, 250, 250) or Color3.fromRGB(113, 113, 122)
            onLabel.TextSize = 12
            onLabel.LayoutOrder = 3
            onLabel.Parent = switchContainer
            self._onLabel = onLabel
        end

        -- Setup interactions
        self:_setupInteractions()

        return self
    end

    --// Setup interactions
    function Switch:_setupInteractions()
        local track = self._track

        -- Click
        self:_connect(track.MouseButton1Click, function()
            if not self.IsEnabled then return end
            self:Toggle()
        end)

        -- Hover
        self:_connect(track.MouseEnter, function()
            if not self.IsEnabled then return end

            TweenService:Create(self._knob, TweenInfo.new(0.15), {
                Size = UDim2.new(0, 24, 0, 24),
            }):Play()
        end)

        self:_connect(track.MouseLeave, function()
            TweenService:Create(self._knob, TweenInfo.new(0.15), {
                Size = UDim2.new(0, 22, 0, 22),
            }):Play()
        end)
    end

    --// Toggle
    function Switch:Toggle()
        self:SetValue(not self.Value)
        return self
    end

    --// Set value
    function Switch:SetValue(value, animate)
        if self.Value == value then return self end

        local oldValue = self.Value
        self.Value = value
        animate = animate ~= false

        local duration = animate and 0.2 or 0

        -- Animate track
        TweenService:Create(self._track, TweenInfo.new(duration), {
            BackgroundColor3 = value and self.ColorOn or self.ColorOff,
        }):Play()

        -- Animate knob
        TweenService:Create(self._knob, TweenInfo.new(duration, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
            Position = value and UDim2.new(1, -24, 0.5, 0) or UDim2.new(0, 2, 0.5, 0),
        }):Play()

        -- Update labels
        if self.ShowLabels then
            if self._onLabel then
                TweenService:Create(self._onLabel, TweenInfo.new(duration), {
                    TextColor3 = value and Color3.fromRGB(250, 250, 250) or Color3.fromRGB(113, 113, 122),
                }):Play()
            end

            if self._offLabel then
                TweenService:Create(self._offLabel, TweenInfo.new(duration), {
                    TextColor3 = value and Color3.fromRGB(113, 113, 122) or Color3.fromRGB(250, 250, 250),
                }):Play()
            end
        end

        -- Callback
        if self.OnChange then
            self.OnChange(value, oldValue)
        end

        self:_fire("Change", value, oldValue)

        return self
    end

    --// Get value
    function Switch:GetValue()
        return self.Value
    end

    return Switch


end


-- ============================================================================
-- Module: NexusUI/Components/Calendar
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Calendar"] = function()
    local script = CreateMockScript("NexusUI/Components/Calendar")
    
    --[[
        NexusUI Calendar Component
        Date selection calendar
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Calendar Component Module
    local Calendar = setmetatable({}, { __index = Base })
    Calendar.__index = Calendar
    Calendar.ClassName = "Calendar"

    --// Month names
    local MONTHS = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"}
    local DAYS = {"Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"}

    --// Constructor
    function Calendar.new(config)
        local self = setmetatable(Base.new(config), Calendar)

        config = config or {}

        local now = os.date("*t")
        self.SelectedDate = config.SelectedDate
        self.ViewMonth = config.ViewMonth or now.month
        self.ViewYear = config.ViewYear or now.year
        self.MinDate = config.MinDate
        self.MaxDate = config.MaxDate
        self.DisabledDates = config.DisabledDates or {}

        -- Callbacks
        self.OnDateSelect = config.OnDateSelect
        self.OnMonthChange = config.OnMonthChange

        -- State
        self._dayButtons = {}

        return self
    end

    --// Get days in month
    function Calendar:_getDaysInMonth(month, year)
        local days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}

        -- Leap year
        if month == 2 and ((year % 4 == 0 and year % 100 ~= 0) or year % 400 == 0) then
            return 29
        end

        return days[month]
    end

    --// Get first day of month (0 = Sunday)
    function Calendar:_getFirstDayOfMonth(month, year)
        local t = os.time({year = year, month = month, day = 1})
        return tonumber(os.date("%w", t))
    end

    --// Check if date is disabled
    function Calendar:_isDateDisabled(day, month, year)
        local timestamp = os.time({year = year, month = month, day = day})

        if self.MinDate and timestamp < self.MinDate then
            return true
        end

        if self.MaxDate and timestamp > self.MaxDate then
            return true
        end

        for _, disabled in ipairs(self.DisabledDates) do
            if disabled.day == day and disabled.month == month and disabled.year == year then
                return true
            end
        end

        return false
    end

    --// Create calendar
    function Calendar:Create(parent)
        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(0, 280, 0, 320)
        container.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        container.BorderSizePixel = 0

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 10)
        corner.Parent = container

        local stroke = Instance.new("UIStroke")
        stroke.Color = Color3.fromRGB(63, 63, 70)
        stroke.Thickness = 1
        stroke.Parent = container

        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, 12)
        padding.PaddingBottom = UDim.new(0, 12)
        padding.PaddingLeft = UDim.new(0, 12)
        padding.PaddingRight = UDim.new(0, 12)
        padding.Parent = container

        -- Header
        local header = Instance.new("Frame")
        header.Name = "Header"
        header.Size = UDim2.new(1, 0, 0, 36)
        header.BackgroundTransparency = 1
        header.Parent = container

        -- Previous button
        local prevBtn = Instance.new("TextButton")
        prevBtn.Name = "PrevBtn"
        prevBtn.Size = UDim2.new(0, 32, 0, 32)
        prevBtn.Position = UDim2.new(0, 0, 0.5, 0)
        prevBtn.AnchorPoint = Vector2.new(0, 0.5)
        prevBtn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
        prevBtn.BackgroundTransparency = 1
        prevBtn.BorderSizePixel = 0
        prevBtn.Font = Enum.Font.GothamBold
        prevBtn.Text = "‹"
        prevBtn.TextColor3 = Color3.fromRGB(250, 250, 250)
        prevBtn.TextSize = 20
        prevBtn.AutoButtonColor = false
        prevBtn.Parent = header

        local prevCorner = Instance.new("UICorner")
        prevCorner.CornerRadius = UDim.new(0, 6)
        prevCorner.Parent = prevBtn

        self:_connect(prevBtn.MouseButton1Click, function()
            self:PrevMonth()
        end)

        self:_connect(prevBtn.MouseEnter, function()
            TweenService:Create(prevBtn, TweenInfo.new(0.1), {
                BackgroundTransparency = 0,
            }):Play()
        end)

        self:_connect(prevBtn.MouseLeave, function()
            TweenService:Create(prevBtn, TweenInfo.new(0.1), {
                BackgroundTransparency = 1,
            }):Play()
        end)

        -- Next button
        local nextBtn = Instance.new("TextButton")
        nextBtn.Name = "NextBtn"
        nextBtn.Size = UDim2.new(0, 32, 0, 32)
        nextBtn.Position = UDim2.new(1, 0, 0.5, 0)
        nextBtn.AnchorPoint = Vector2.new(1, 0.5)
        nextBtn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
        nextBtn.BackgroundTransparency = 1
        nextBtn.BorderSizePixel = 0
        nextBtn.Font = Enum.Font.GothamBold
        nextBtn.Text = "›"
        nextBtn.TextColor3 = Color3.fromRGB(250, 250, 250)
        nextBtn.TextSize = 20
        nextBtn.AutoButtonColor = false
        nextBtn.Parent = header

        local nextCorner = Instance.new("UICorner")
        nextCorner.CornerRadius = UDim.new(0, 6)
        nextCorner.Parent = nextBtn

        self:_connect(nextBtn.MouseButton1Click, function()
            self:NextMonth()
        end)

        self:_connect(nextBtn.MouseEnter, function()
            TweenService:Create(nextBtn, TweenInfo.new(0.1), {
                BackgroundTransparency = 0,
            }):Play()
        end)

        self:_connect(nextBtn.MouseLeave, function()
            TweenService:Create(nextBtn, TweenInfo.new(0.1), {
                BackgroundTransparency = 1,
            }):Play()
        end)

        -- Month/Year label
        local monthLabel = Instance.new("TextLabel")
        monthLabel.Name = "MonthLabel"
        monthLabel.Size = UDim2.new(1, -80, 1, 0)
        monthLabel.Position = UDim2.new(0.5, 0, 0, 0)
        monthLabel.AnchorPoint = Vector2.new(0.5, 0)
        monthLabel.BackgroundTransparency = 1
        monthLabel.Font = Enum.Font.GothamBold
        monthLabel.TextColor3 = Color3.fromRGB(250, 250, 250)
        monthLabel.TextSize = 16
        monthLabel.Parent = header
        self._monthLabel = monthLabel

        -- Day headers
        local dayHeaders = Instance.new("Frame")
        dayHeaders.Name = "DayHeaders"
        dayHeaders.Size = UDim2.new(1, 0, 0, 30)
        dayHeaders.Position = UDim2.new(0, 0, 0, 44)
        dayHeaders.BackgroundTransparency = 1
        dayHeaders.Parent = container

        local dayHeaderLayout = Instance.new("UIListLayout")
        dayHeaderLayout.FillDirection = Enum.FillDirection.Horizontal
        dayHeaderLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        dayHeaderLayout.Parent = dayHeaders

        for i, day in ipairs(DAYS) do
            local dayLabel = Instance.new("TextLabel")
            dayLabel.Size = UDim2.new(0, 36, 1, 0)
            dayLabel.BackgroundTransparency = 1
            dayLabel.Font = Enum.Font.GothamMedium
            dayLabel.Text = day
            dayLabel.TextColor3 = Color3.fromRGB(113, 113, 122)
            dayLabel.TextSize = 12
            dayLabel.LayoutOrder = i
            dayLabel.Parent = dayHeaders
        end

        -- Days grid
        local daysGrid = Instance.new("Frame")
        daysGrid.Name = "DaysGrid"
        daysGrid.Size = UDim2.new(1, 0, 0, 216)
        daysGrid.Position = UDim2.new(0, 0, 0, 78)
        daysGrid.BackgroundTransparency = 1
        daysGrid.Parent = container
        self._daysGrid = daysGrid

        local gridLayout = Instance.new("UIGridLayout")
        gridLayout.CellSize = UDim2.new(0, 36, 0, 36)
        gridLayout.CellPadding = UDim2.new(0, 0, 0, 0)
        gridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        gridLayout.SortOrder = Enum.SortOrder.LayoutOrder
        gridLayout.Parent = daysGrid

        -- Build calendar
        self:_buildCalendar()

        return self
    end

    --// Build calendar
    function Calendar:_buildCalendar()
        -- Clear existing
        for _, btn in ipairs(self._dayButtons) do
            btn:Destroy()
        end
        self._dayButtons = {}

        -- Update month label
        self._monthLabel.Text = MONTHS[self.ViewMonth] .. " " .. self.ViewYear

        local daysInMonth = self:_getDaysInMonth(self.ViewMonth, self.ViewYear)
        local firstDay = self:_getFirstDayOfMonth(self.ViewMonth, self.ViewYear)

        local today = os.date("*t")
        local layoutOrder = 0

        -- Empty cells before first day
        for i = 1, firstDay do
            layoutOrder = layoutOrder + 1
            local empty = Instance.new("Frame")
            empty.Size = UDim2.new(0, 36, 0, 36)
            empty.BackgroundTransparency = 1
            empty.LayoutOrder = layoutOrder
            empty.Parent = self._daysGrid
            table.insert(self._dayButtons, empty)
        end

        -- Day buttons
        for day = 1, daysInMonth do
            layoutOrder = layoutOrder + 1

            local isToday = day == today.day and self.ViewMonth == today.month and self.ViewYear == today.year
            local isSelected = self.SelectedDate and 
                day == self.SelectedDate.day and 
                self.ViewMonth == self.SelectedDate.month and 
                self.ViewYear == self.SelectedDate.year
            local isDisabled = self:_isDateDisabled(day, self.ViewMonth, self.ViewYear)

            local btn = Instance.new("TextButton")
            btn.Name = "Day" .. day
            btn.Size = UDim2.new(0, 36, 0, 36)
            btn.BackgroundColor3 = isSelected and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(39, 39, 42)
            btn.BackgroundTransparency = isSelected and 0 or 1
            btn.BorderSizePixel = 0
            btn.Font = isToday and Enum.Font.GothamBold or Enum.Font.Gotham
            btn.Text = tostring(day)
            btn.TextColor3 = isDisabled and Color3.fromRGB(63, 63, 70) or 
                (isSelected and Color3.fromRGB(255, 255, 255) or 
                (isToday and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(250, 250, 250)))
            btn.TextSize = 13
            btn.AutoButtonColor = false
            btn.LayoutOrder = layoutOrder
            btn.Parent = self._daysGrid

            local btnCorner = Instance.new("UICorner")
            btnCorner.CornerRadius = UDim.new(0, 6)
            btnCorner.Parent = btn

            -- Today indicator
            if isToday and not isSelected then
                local indicator = Instance.new("Frame")
                indicator.Size = UDim2.new(0, 4, 0, 4)
                indicator.Position = UDim2.new(0.5, 0, 1, -6)
                indicator.AnchorPoint = Vector2.new(0.5, 0)
                indicator.BackgroundColor3 = Color3.fromRGB(99, 102, 241)
                indicator.BorderSizePixel = 0
                indicator.Parent = btn

                local indicatorCorner = Instance.new("UICorner")
                indicatorCorner.CornerRadius = UDim.new(1, 0)
                indicatorCorner.Parent = indicator
            end

            if not isDisabled then
                self:_connect(btn.MouseButton1Click, function()
                    self:SelectDate(day, self.ViewMonth, self.ViewYear)
                end)

                self:_connect(btn.MouseEnter, function()
                    if not isSelected then
                        TweenService:Create(btn, TweenInfo.new(0.1), {
                            BackgroundTransparency = 0.5,
                        }):Play()
                    end
                end)

                self:_connect(btn.MouseLeave, function()
                    if not isSelected then
                        TweenService:Create(btn, TweenInfo.new(0.1), {
                            BackgroundTransparency = 1,
                        }):Play()
                    end
                end)
            end

            table.insert(self._dayButtons, btn)
        end
    end

    --// Select date
    function Calendar:SelectDate(day, month, year)
        self.SelectedDate = { day = day, month = month, year = year }
        self:_buildCalendar()

        if self.OnDateSelect then
            self.OnDateSelect(self.SelectedDate)
        end

        self:_fire("DateSelect", self.SelectedDate)

        return self
    end

    --// Next month
    function Calendar:NextMonth()
        self.ViewMonth = self.ViewMonth + 1
        if self.ViewMonth > 12 then
            self.ViewMonth = 1
            self.ViewYear = self.ViewYear + 1
        end

        self:_buildCalendar()

        if self.OnMonthChange then
            self.OnMonthChange(self.ViewMonth, self.ViewYear)
        end

        return self
    end

    --// Previous month
    function Calendar:PrevMonth()
        self.ViewMonth = self.ViewMonth - 1
        if self.ViewMonth < 1 then
            self.ViewMonth = 12
            self.ViewYear = self.ViewYear - 1
        end

        self:_buildCalendar()

        if self.OnMonthChange then
            self.OnMonthChange(self.ViewMonth, self.ViewYear)
        end

        return self
    end

    --// Go to today
    function Calendar:GoToToday()
        local now = os.date("*t")
        self.ViewMonth = now.month
        self.ViewYear = now.year
        self:SelectDate(now.day, now.month, now.year)
        return self
    end

    --// Get selected date
    function Calendar:GetSelectedDate()
        return self.SelectedDate
    end

    return Calendar


end


-- ============================================================================
-- Module: NexusUI/Components/TreeView
-- ============================================================================
NexusUI_Modules["NexusUI/Components/TreeView"] = function()
    local script = CreateMockScript("NexusUI/Components/TreeView")
    
    --[[
        NexusUI TreeView Component
        Hierarchical tree structure display
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// TreeView Component Module
    local TreeView = setmetatable({}, { __index = Base })
    TreeView.__index = TreeView
    TreeView.ClassName = "TreeView"

    --// Constructor
    function TreeView.new(config)
        local self = setmetatable(Base.new(config), TreeView)

        config = config or {}

        self.Nodes = config.Nodes or {} -- Array of {Id, Text, Icon, Children, Expanded, Data}
        self.Selectable = config.Selectable ~= false
        self.MultiSelect = config.MultiSelect or false
        self.ShowLines = config.ShowLines or false
        self.IndentSize = config.IndentSize or 20

        -- Callbacks
        self.OnNodeClick = config.OnNodeClick
        self.OnNodeExpand = config.OnNodeExpand
        self.OnNodeCollapse = config.OnNodeCollapse
        self.OnSelectionChange = config.OnSelectionChange

        -- State
        self._selectedNodes = {}
        self._expandedNodes = {}
        self._nodeElements = {}

        return self
    end

    --// Create tree view
    function TreeView:Create(parent)
        -- Container
        local container = Instance.new("ScrollingFrame")
        container.Name = self.Name
        container.Size = UDim2.new(1, 0, 0, 300)
        container.BackgroundColor3 = Color3.fromRGB(24, 24, 27)
        container.BorderSizePixel = 0
        container.ScrollBarThickness = 4
        container.ScrollBarImageColor3 = Color3.fromRGB(82, 82, 91)
        container.CanvasSize = UDim2.new(0, 0, 0, 0)
        container.AutomaticCanvasSize = Enum.AutomaticSize.Y

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = container

        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, 4)
        padding.PaddingBottom = UDim.new(0, 4)
        padding.PaddingLeft = UDim.new(0, 4)
        padding.PaddingRight = UDim.new(0, 4)
        padding.Parent = container

        local layout = Instance.new("UIListLayout")
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Padding = UDim.new(0, 1)
        layout.Parent = container

        -- Build tree
        self:_buildTree()

        return self
    end

    --// Build tree
    function TreeView:_buildTree()
        -- Clear existing
        for _, element in pairs(self._nodeElements) do
            if element.Instance then
                element.Instance:Destroy()
            end
        end
        self._nodeElements = {}

        local layoutOrder = 0

        local function buildNode(node, depth)
            layoutOrder = layoutOrder + 1
            local hasChildren = node.Children and #node.Children > 0
            local isExpanded = self._expandedNodes[node.Id]
            local isSelected = table.find(self._selectedNodes, node.Id) ~= nil

            local nodeFrame = Instance.new("TextButton")
            nodeFrame.Name = "Node_" .. node.Id
            nodeFrame.Size = UDim2.new(1, 0, 0, 28)
            nodeFrame.BackgroundColor3 = isSelected and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(39, 39, 42)
            nodeFrame.BackgroundTransparency = isSelected and 0.8 or 1
            nodeFrame.BorderSizePixel = 0
            nodeFrame.Text = ""
            nodeFrame.AutoButtonColor = false
            nodeFrame.LayoutOrder = layoutOrder
            nodeFrame.Parent = self.Instance

            local nodeCorner = Instance.new("UICorner")
            nodeCorner.CornerRadius = UDim.new(0, 4)
            nodeCorner.Parent = nodeFrame

            local nodePadding = Instance.new("UIPadding")
            nodePadding.PaddingLeft = UDim.new(0, depth * self.IndentSize + 4)
            nodePadding.PaddingRight = UDim.new(0, 4)
            nodePadding.Parent = nodeFrame

            local nodeLayout = Instance.new("UIListLayout")
            nodeLayout.FillDirection = Enum.FillDirection.Horizontal
            nodeLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            nodeLayout.Padding = UDim.new(0, 6)
            nodeLayout.Parent = nodeFrame

            -- Expand/collapse arrow
            if hasChildren then
                local arrow = Instance.new("ImageButton")
                arrow.Name = "Arrow"
                arrow.Size = UDim2.new(0, 14, 0, 14)
                arrow.BackgroundTransparency = 1
                arrow.Image = "rbxassetid://7072706620"
                arrow.ImageColor3 = Color3.fromRGB(161, 161, 170)
                arrow.Rotation = isExpanded and 90 or 0
                arrow.LayoutOrder = 1
                arrow.Parent = nodeFrame

                self:_connect(arrow.MouseButton1Click, function()
                    self:_toggleNode(node.Id)
                end)
            else
                -- Spacer
                local spacer = Instance.new("Frame")
                spacer.Size = UDim2.new(0, 14, 0, 14)
                spacer.BackgroundTransparency = 1
                spacer.LayoutOrder = 1
                spacer.Parent = nodeFrame
            end

            -- Icon
            if node.Icon then
                local icon = Instance.new("ImageLabel")
                icon.Size = UDim2.new(0, 16, 0, 16)
                icon.BackgroundTransparency = 1
                icon.Image = node.Icon
                icon.ImageColor3 = Color3.fromRGB(161, 161, 170)
                icon.LayoutOrder = 2
                icon.Parent = nodeFrame
            end

            -- Text
            local text = Instance.new("TextLabel")
            text.Size = UDim2.new(1, -40, 1, 0)
            text.BackgroundTransparency = 1
            text.Font = Enum.Font.Gotham
            text.Text = node.Text
            text.TextColor3 = Color3.fromRGB(250, 250, 250)
            text.TextSize = 13
            text.TextXAlignment = Enum.TextXAlignment.Left
            text.TextTruncate = Enum.TextTruncate.AtEnd
            text.LayoutOrder = 3
            text.Parent = nodeFrame

            -- Interactions
            self:_connect(nodeFrame.MouseButton1Click, function()
                if self.Selectable then
                    self:_selectNode(node.Id)
                end

                if self.OnNodeClick then
                    self.OnNodeClick(node)
                end

                self:_fire("NodeClick", node)
            end)

            self:_connect(nodeFrame.MouseEnter, function()
                if not isSelected then
                    TweenService:Create(nodeFrame, TweenInfo.new(0.1), {
                        BackgroundTransparency = 0.8,
                    }):Play()
                end
            end)

            self:_connect(nodeFrame.MouseLeave, function()
                if not isSelected then
                    TweenService:Create(nodeFrame, TweenInfo.new(0.1), {
                        BackgroundTransparency = 1,
                    }):Play()
                end
            end)

            self._nodeElements[node.Id] = {
                Instance = nodeFrame,
                Node = node,
                Depth = depth,
            }

            -- Build children if expanded
            if hasChildren and isExpanded then
                for _, child in ipairs(node.Children) do
                    buildNode(child, depth + 1)
                end
            end
        end

        for _, node in ipairs(self.Nodes) do
            buildNode(node, 0)
        end
    end

    --// Toggle node expansion
    function TreeView:_toggleNode(nodeId)
        if self._expandedNodes[nodeId] then
            self._expandedNodes[nodeId] = nil

            local element = self._nodeElements[nodeId]
            if element and self.OnNodeCollapse then
                self.OnNodeCollapse(element.Node)
            end

            self:_fire("NodeCollapse", element and element.Node)
        else
            self._expandedNodes[nodeId] = true

            local element = self._nodeElements[nodeId]
            if element and self.OnNodeExpand then
                self.OnNodeExpand(element.Node)
            end

            self:_fire("NodeExpand", element and element.Node)
        end

        self:_buildTree()
    end

    --// Select node
    function TreeView:_selectNode(nodeId)
        local existingPos = table.find(self._selectedNodes, nodeId)

        if existingPos then
            if self.MultiSelect then
                table.remove(self._selectedNodes, existingPos)
            end
        else
            if self.MultiSelect then
                table.insert(self._selectedNodes, nodeId)
            else
                self._selectedNodes = { nodeId }
            end
        end

        self:_buildTree()

        if self.OnSelectionChange then
            self.OnSelectionChange(self._selectedNodes)
        end

        self:_fire("SelectionChange", self._selectedNodes)
    end

    --// Expand all
    function TreeView:ExpandAll()
        local function expand(nodes)
            for _, node in ipairs(nodes) do
                self._expandedNodes[node.Id] = true
                if node.Children then
                    expand(node.Children)
                end
            end
        end

        expand(self.Nodes)
        self:_buildTree()
        return self
    end

    --// Collapse all
    function TreeView:CollapseAll()
        self._expandedNodes = {}
        self:_buildTree()
        return self
    end

    --// Set nodes
    function TreeView:SetNodes(nodes)
        self.Nodes = nodes
        self._selectedNodes = {}
        self._expandedNodes = {}
        self:_buildTree()
        return self
    end

    --// Get selected nodes
    function TreeView:GetSelectedNodes()
        local nodes = {}
        for _, nodeId in ipairs(self._selectedNodes) do
            local element = self._nodeElements[nodeId]
            if element then
                table.insert(nodes, element.Node)
            end
        end
        return nodes
    end

    --// Expand node
    function TreeView:ExpandNode(nodeId)
        self._expandedNodes[nodeId] = true
        self:_buildTree()
        return self
    end

    --// Collapse node
    function TreeView:CollapseNode(nodeId)
        self._expandedNodes[nodeId] = nil
        self:_buildTree()
        return self
    end

    return TreeView


end


-- ============================================================================
-- Module: NexusUI/Components/RadioButton
-- ============================================================================
NexusUI_Modules["NexusUI/Components/RadioButton"] = function()
    local script = CreateMockScript("NexusUI/Components/RadioButton")
    
    --[[
        NexusUI RadioButton Component
        Radio button for single selection from group
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// RadioButton Component Module
    local RadioButton = setmetatable({}, { __index = Base })
    RadioButton.__index = RadioButton
    RadioButton.ClassName = "RadioButton"

    --// Radio Groups (shared state)
    local _radioGroups = {}

    --// Constructor
    function RadioButton.new(config)
        local self = setmetatable(Base.new(config), RadioButton)

        config = config or {}

        self.Value = config.Value
        self.Selected = config.Selected or false
        self.Group = config.Group or "default"
        self.Label = config.Label
        self.LabelPosition = config.LabelPosition or "Right"
        self.Size = config.Size or 20
        self.ColorSelected = config.ColorSelected or Color3.fromRGB(99, 102, 241)
        self.ColorUnselected = config.ColorUnselected or Color3.fromRGB(63, 63, 70)

        -- Callbacks
        self.OnSelect = config.OnSelect

        -- Register in group
        if not _radioGroups[self.Group] then
            _radioGroups[self.Group] = {}
        end
        table.insert(_radioGroups[self.Group], self)

        return self
    end

    --// Create radio button
    function RadioButton:Create(parent)
        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(0, 0, 0, self.Size)
        container.AutomaticSize = Enum.AutomaticSize.X
        container.BackgroundTransparency = 1

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Layout
        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.Padding = UDim.new(0, 8)
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Parent = container

        -- Label (left)
        if self.Label and self.LabelPosition == "Left" then
            local label = Instance.new("TextLabel")
            label.Name = "Label"
            label.Size = UDim2.new(0, 0, 0, self.Size)
            label.AutomaticSize = Enum.AutomaticSize.X
            label.BackgroundTransparency = 1
            label.Font = Enum.Font.Gotham
            label.Text = self.Label
            label.TextColor3 = Color3.fromRGB(250, 250, 250)
            label.TextSize = 14
            label.LayoutOrder = 1
            label.Parent = container
            self._label = label
        end

        -- Radio circle
        local circle = Instance.new("TextButton")
        circle.Name = "Circle"
        circle.Size = UDim2.new(0, self.Size, 0, self.Size)
        circle.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        circle.BorderSizePixel = 0
        circle.Text = ""
        circle.AutoButtonColor = false
        circle.LayoutOrder = 2
        circle.Parent = container
        self._circle = circle

        -- Circle corner
        local circleCorner = Instance.new("UICorner")
        circleCorner.CornerRadius = UDim.new(1, 0)
        circleCorner.Parent = circle

        -- Border
        local stroke = Instance.new("UIStroke")
        stroke.Color = self.Selected and self.ColorSelected or Color3.fromRGB(82, 82, 91)
        stroke.Thickness = 2
        stroke.Parent = circle
        self._stroke = stroke

        -- Inner dot (selection indicator)
        local dot = Instance.new("Frame")
        dot.Name = "Dot"
        dot.Size = self.Selected and UDim2.new(0.5, 0, 0.5, 0) or UDim2.new(0, 0, 0, 0)
        dot.Position = UDim2.new(0.5, 0, 0.5, 0)
        dot.AnchorPoint = Vector2.new(0.5, 0.5)
        dot.BackgroundColor3 = self.ColorSelected
        dot.BorderSizePixel = 0
        dot.Parent = circle
        self._dot = dot

        local dotCorner = Instance.new("UICorner")
        dotCorner.CornerRadius = UDim.new(1, 0)
        dotCorner.Parent = dot

        -- Label (right)
        if self.Label and self.LabelPosition == "Right" then
            local label = Instance.new("TextLabel")
            label.Name = "Label"
            label.Size = UDim2.new(0, 0, 0, self.Size)
            label.AutomaticSize = Enum.AutomaticSize.X
            label.BackgroundTransparency = 1
            label.Font = Enum.Font.Gotham
            label.Text = self.Label
            label.TextColor3 = Color3.fromRGB(250, 250, 250)
            label.TextSize = 14
            label.LayoutOrder = 3
            label.Parent = container
            self._label = label
        end

        -- Setup interactions
        self:_setupInteractions()

        -- Set initial state if selected
        if self.Selected then
            self:Select(false)
        end

        return self
    end

    --// Setup interactions
    function RadioButton:_setupInteractions()
        local circle = self._circle

        -- Click
        self:_connect(circle.MouseButton1Click, function()
            if not self.IsEnabled or self.Selected then return end
            self:Select()
        end)

        -- Hover
        self:_connect(circle.MouseEnter, function()
            if not self.IsEnabled then return end

            TweenService:Create(self._stroke, TweenInfo.new(0.15), {
                Color = self.Selected and self.ColorSelected or Color3.fromRGB(113, 113, 122),
            }):Play()

            TweenService:Create(circle, TweenInfo.new(0.15), {
                Size = UDim2.new(0, self.Size + 2, 0, self.Size + 2),
            }):Play()
        end)

        self:_connect(circle.MouseLeave, function()
            TweenService:Create(self._stroke, TweenInfo.new(0.15), {
                Color = self.Selected and self.ColorSelected or Color3.fromRGB(82, 82, 91),
            }):Play()

            TweenService:Create(circle, TweenInfo.new(0.15), {
                Size = UDim2.new(0, self.Size, 0, self.Size),
            }):Play()
        end)
    end

    --// Select
    function RadioButton:Select(animate)
        if self.Selected then return self end

        animate = animate ~= false

        -- Deselect others in group
        local group = _radioGroups[self.Group]
        if group then
            for _, radio in ipairs(group) do
                if radio ~= self and radio.Selected then
                    radio:Deselect(animate)
                end
            end
        end

        self.Selected = true

        local duration = animate and 0.2 or 0

        -- Animate dot
        TweenService:Create(self._dot, TweenInfo.new(duration, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
            Size = UDim2.new(0.5, 0, 0.5, 0),
        }):Play()

        TweenService:Create(self._stroke, TweenInfo.new(duration * 0.5), {
            Color = self.ColorSelected,
        }):Play()

        -- Callback
        if self.OnSelect then
            self.OnSelect(self.Value)
        end

        self:_fire("Select", self.Value)

        return self
    end

    --// Deselect
    function RadioButton:Deselect(animate)
        if not self.Selected then return self end

        self.Selected = false
        animate = animate ~= false

        local duration = animate and 0.15 or 0

        TweenService:Create(self._dot, TweenInfo.new(duration), {
            Size = UDim2.new(0, 0, 0, 0),
        }):Play()

        TweenService:Create(self._stroke, TweenInfo.new(duration), {
            Color = Color3.fromRGB(82, 82, 91),
        }):Play()

        return self
    end

    --// Get selected value from group
    function RadioButton.GetGroupValue(groupName)
        local group = _radioGroups[groupName]
        if group then
            for _, radio in ipairs(group) do
                if radio.Selected then
                    return radio.Value
                end
            end
        end
        return nil
    end

    --// Set group value
    function RadioButton.SetGroupValue(groupName, value)
        local group = _radioGroups[groupName]
        if group then
            for _, radio in ipairs(group) do
                if radio.Value == value then
                    radio:Select()
                    return
                end
            end
        end
    end

    --// Destroy override
    function RadioButton:Destroy()
        -- Remove from group
        local group = _radioGroups[self.Group]
        if group then
            for i, radio in ipairs(group) do
                if radio == self then
                    table.remove(group, i)
                    break
                end
            end
        end

        Base.Destroy(self)
    end

    return RadioButton


end


-- ============================================================================
-- Module: NexusUI/Components/ContextMenu
-- ============================================================================
NexusUI_Modules["NexusUI/Components/ContextMenu"] = function()
    local script = CreateMockScript("NexusUI/Components/ContextMenu")
    
    --[[
        NexusUI ContextMenu Component
        Right-click context menu
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")
    local UserInputService = game:GetService("UserInputService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// ContextMenu Component Module
    local ContextMenu = setmetatable({}, { __index = Base })
    ContextMenu.__index = ContextMenu
    ContextMenu.ClassName = "ContextMenu"

    --// Constructor
    function ContextMenu.new(config)
        local self = setmetatable(Base.new(config), ContextMenu)

        config = config or {}

        self.Items = config.Items or {} -- Array of {Text, Icon, Shortcut, Disabled, Separator, SubItems, OnClick}
        self.Target = config.Target
        self.Width = config.Width or 180

        -- Callbacks
        self.OnItemClick = config.OnItemClick
        self.OnOpen = config.OnOpen
        self.OnClose = config.OnClose

        -- State
        self._isOpen = false

        return self
    end

    --// Create context menu
    function ContextMenu:Create(parent)
        -- Get screen gui
        local screenGui = parent
        while screenGui and not screenGui:IsA("ScreenGui") do
            screenGui = screenGui.Parent
        end

        if not screenGui then
            screenGui = Instance.new("ScreenGui")
            screenGui.Parent = game:GetService("CoreGui")
        end

        -- Menu container
        local menu = Instance.new("Frame")
        menu.Name = self.Name
        menu.Size = UDim2.new(0, self.Width, 0, 0)
        menu.AutomaticSize = Enum.AutomaticSize.Y
        menu.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        menu.BorderSizePixel = 0
        menu.Visible = false
        menu.ZIndex = 9999
        menu.Parent = screenGui
        self.Instance = menu

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = menu

        local stroke = Instance.new("UIStroke")
        stroke.Color = Color3.fromRGB(63, 63, 70)
        stroke.Thickness = 1
        stroke.Parent = menu

        -- Shadow
        local shadow = Instance.new("ImageLabel")
        shadow.Size = UDim2.new(1, 20, 1, 20)
        shadow.Position = UDim2.new(0.5, 0, 0.5, 6)
        shadow.AnchorPoint = Vector2.new(0.5, 0.5)
        shadow.BackgroundTransparency = 1
        shadow.Image = "rbxassetid://6015897843"
        shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
        shadow.ImageTransparency = 0.4
        shadow.ScaleType = Enum.ScaleType.Slice
        shadow.SliceCenter = Rect.new(49, 49, 450, 450)
        shadow.ZIndex = menu.ZIndex - 1
        shadow.Parent = menu

        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, 4)
        padding.PaddingBottom = UDim.new(0, 4)
        padding.PaddingLeft = UDim.new(0, 4)
        padding.PaddingRight = UDim.new(0, 4)
        padding.Parent = menu

        local layout = Instance.new("UIListLayout")
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Padding = UDim.new(0, 1)
        layout.Parent = menu

        -- Build items
        self:_buildItems()

        -- Bind to target
        if self.Target then
            self:BindTo(self.Target)
        end

        -- Global click to close
        self:_connect(UserInputService.InputBegan, function(input)
            if self._isOpen and input.UserInputType == Enum.UserInputType.MouseButton1 then
                -- Check if click is outside menu
                local mousePos = UserInputService:GetMouseLocation()
                local menuPos = menu.AbsolutePosition
                local menuSize = menu.AbsoluteSize

                if mousePos.X < menuPos.X or mousePos.X > menuPos.X + menuSize.X or
                   mousePos.Y < menuPos.Y or mousePos.Y > menuPos.Y + menuSize.Y then
                    task.defer(function()
                        self:Close()
                    end)
                end
            end
        end)

        return self
    end

    --// Build items
    function ContextMenu:_buildItems()
        -- Clear existing items
        for _, child in ipairs(self.Instance:GetChildren()) do
            if child:IsA("TextButton") or child:IsA("Frame") and child.Name ~= "Shadow" then
                if not child:IsA("UICorner") and not child:IsA("UIStroke") and not child:IsA("UIPadding") and not child:IsA("UIListLayout") then
                    child:Destroy()
                end
            end
        end

        for i, item in ipairs(self.Items) do
            if item.Separator then
                -- Separator
                local separator = Instance.new("Frame")
                separator.Name = "Separator" .. i
                separator.Size = UDim2.new(1, -8, 0, 1)
                separator.Position = UDim2.new(0.5, 0, 0, 0)
                separator.AnchorPoint = Vector2.new(0.5, 0)
                separator.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
                separator.BorderSizePixel = 0
                separator.LayoutOrder = i
                separator.Parent = self.Instance

                local sepPadding = Instance.new("Frame")
                sepPadding.Size = UDim2.new(1, 0, 0, 8)
                sepPadding.BackgroundTransparency = 1
                sepPadding.LayoutOrder = i
                sepPadding.Parent = self.Instance
            else
                local btn = Instance.new("TextButton")
                btn.Name = "Item" .. i
                btn.Size = UDim2.new(1, 0, 0, 32)
                btn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
                btn.BackgroundTransparency = 1
                btn.BorderSizePixel = 0
                btn.Text = ""
                btn.AutoButtonColor = false
                btn.LayoutOrder = i
                btn.ZIndex = self.Instance.ZIndex
                btn.Parent = self.Instance

                local btnCorner = Instance.new("UICorner")
                btnCorner.CornerRadius = UDim.new(0, 4)
                btnCorner.Parent = btn

                local btnPadding = Instance.new("UIPadding")
                btnPadding.PaddingLeft = UDim.new(0, 8)
                btnPadding.PaddingRight = UDim.new(0, 8)
                btnPadding.Parent = btn

                local btnLayout = Instance.new("UIListLayout")
                btnLayout.FillDirection = Enum.FillDirection.Horizontal
                btnLayout.VerticalAlignment = Enum.VerticalAlignment.Center
                btnLayout.Padding = UDim.new(0, 8)
                btnLayout.Parent = btn

                -- Icon
                if item.Icon then
                    local icon = Instance.new("ImageLabel")
                    icon.Size = UDim2.new(0, 14, 0, 14)
                    icon.BackgroundTransparency = 1
                    icon.Image = item.Icon
                    icon.ImageColor3 = item.Disabled and Color3.fromRGB(82, 82, 91) or Color3.fromRGB(161, 161, 170)
                    icon.ZIndex = btn.ZIndex
                    icon.LayoutOrder = 1
                    icon.Parent = btn
                end

                -- Text
                local text = Instance.new("TextLabel")
                text.Size = UDim2.new(1, -40, 1, 0)
                text.BackgroundTransparency = 1
                text.Font = Enum.Font.Gotham
                text.Text = item.Text
                text.TextColor3 = item.Disabled and Color3.fromRGB(82, 82, 91) or Color3.fromRGB(250, 250, 250)
                text.TextSize = 13
                text.TextXAlignment = Enum.TextXAlignment.Left
                text.ZIndex = btn.ZIndex
                text.LayoutOrder = 2
                text.Parent = btn

                -- Shortcut
                if item.Shortcut then
                    local shortcut = Instance.new("TextLabel")
                    shortcut.Size = UDim2.new(0, 0, 0, 0)
                    shortcut.AutomaticSize = Enum.AutomaticSize.XY
                    shortcut.Position = UDim2.new(1, -8, 0.5, 0)
                    shortcut.AnchorPoint = Vector2.new(1, 0.5)
                    shortcut.BackgroundTransparency = 1
                    shortcut.Font = Enum.Font.Gotham
                    shortcut.Text = item.Shortcut
                    shortcut.TextColor3 = Color3.fromRGB(82, 82, 91)
                    shortcut.TextSize = 11
                    shortcut.ZIndex = btn.ZIndex
                    shortcut.Parent = btn
                end

                -- SubItems indicator
                if item.SubItems and #item.SubItems > 0 then
                    local arrow = Instance.new("ImageLabel")
                    arrow.Size = UDim2.new(0, 10, 0, 10)
                    arrow.Position = UDim2.new(1, -8, 0.5, 0)
                    arrow.AnchorPoint = Vector2.new(1, 0.5)
                    arrow.BackgroundTransparency = 1
                    arrow.Image = "rbxassetid://7072706620"
                    arrow.ImageColor3 = Color3.fromRGB(113, 113, 122)
                    arrow.Rotation = 180
                    arrow.ZIndex = btn.ZIndex
                    arrow.Parent = btn
                end

                -- Interactions
                if not item.Disabled then
                    self:_connect(btn.MouseButton1Click, function()
                        if item.OnClick then
                            item.OnClick()
                        end

                        if self.OnItemClick then
                            self.OnItemClick(i, item)
                        end

                        self:_fire("ItemClick", i, item)
                        self:Close()
                    end)

                    self:_connect(btn.MouseEnter, function()
                        TweenService:Create(btn, TweenInfo.new(0.1), {
                            BackgroundTransparency = 0,
                        }):Play()
                    end)

                    self:_connect(btn.MouseLeave, function()
                        TweenService:Create(btn, TweenInfo.new(0.1), {
                            BackgroundTransparency = 1,
                        }):Play()
                    end)
                end
            end
        end
    end

    --// Bind to target
    function ContextMenu:BindTo(target)
        self.Target = target

        self:_connect(target.MouseButton2Click, function()
            local mousePos = UserInputService:GetMouseLocation()
            self:Show(mousePos.X, mousePos.Y)
        end)

        return self
    end

    --// Show at position
    function ContextMenu:Show(x, y)
        self._isOpen = true
        self.Instance.Visible = true

        -- Position menu
        local viewportSize = workspace.CurrentCamera.ViewportSize
        local menuSize = self.Instance.AbsoluteSize

        -- Adjust if going off screen
        if x + menuSize.X > viewportSize.X then
            x = viewportSize.X - menuSize.X - 4
        end

        if y + menuSize.Y > viewportSize.Y then
            y = viewportSize.Y - menuSize.Y - 4
        end

        self.Instance.Position = UDim2.new(0, x, 0, y)

        -- Animate in
        self.Instance.BackgroundTransparency = 1
        TweenService:Create(self.Instance, TweenInfo.new(0.1), {
            BackgroundTransparency = 0,
        }):Play()

        if self.OnOpen then
            self.OnOpen()
        end

        self:_fire("Open")

        return self
    end

    --// Close
    function ContextMenu:Close()
        if not self._isOpen then return self end

        self._isOpen = false

        TweenService:Create(self.Instance, TweenInfo.new(0.1), {
            BackgroundTransparency = 1,
        }):Play()

        task.delay(0.1, function()
            if not self._isOpen then
                self.Instance.Visible = false
            end
        end)

        if self.OnClose then
            self.OnClose()
        end

        self:_fire("Close")

        return self
    end

    --// Set items
    function ContextMenu:SetItems(items)
        self.Items = items
        self:_buildItems()
        return self
    end

    return ContextMenu


end


-- ============================================================================
-- Module: NexusUI/Components/SegmentedControl
-- ============================================================================
NexusUI_Modules["NexusUI/Components/SegmentedControl"] = function()
    local script = CreateMockScript("NexusUI/Components/SegmentedControl")
    
    --[[
        NexusUI SegmentedControl Component
        Tab-like segmented button group
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// SegmentedControl Component Module
    local SegmentedControl = setmetatable({}, { __index = Base })
    SegmentedControl.__index = SegmentedControl
    SegmentedControl.ClassName = "SegmentedControl"

    --// Constructor
    function SegmentedControl.new(config)
        local self = setmetatable(Base.new(config), SegmentedControl)

        config = config or {}

        self.Segments = config.Segments or {} -- Array of {Text = "", Value = "", Icon = ""}
        self.SelectedIndex = config.SelectedIndex or 1
        self.FullWidth = config.FullWidth or false

        -- Callbacks
        self.OnChange = config.OnChange

        -- Internal
        self._segmentButtons = {}

        return self
    end

    --// Create segmented control
    function SegmentedControl:Create(parent)
        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = self.FullWidth and UDim2.new(1, 0, 0, 36) or UDim2.new(0, 0, 0, 36)
        container.AutomaticSize = not self.FullWidth and Enum.AutomaticSize.X or Enum.AutomaticSize.None
        container.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        container.BorderSizePixel = 0

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Corner
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = container

        -- Border
        local stroke = Instance.new("UIStroke")
        stroke.Color = Color3.fromRGB(63, 63, 70)
        stroke.Thickness = 1
        stroke.Parent = container

        -- Padding
        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, 3)
        padding.PaddingBottom = UDim.new(0, 3)
        padding.PaddingLeft = UDim.new(0, 3)
        padding.PaddingRight = UDim.new(0, 3)
        padding.Parent = container

        -- Layout
        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.Padding = UDim.new(0, 2)
        layout.Parent = container

        -- Create segments
        for i, segment in ipairs(self.Segments) do
            self:_createSegment(i, segment)
        end

        -- Update selection
        self:_updateSelection(false)

        return self
    end

    --// Create segment button
    function SegmentedControl:_createSegment(index, segment)
        local button = Instance.new("TextButton")
        button.Name = "Segment" .. index
        button.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
        button.BackgroundTransparency = 1
        button.BorderSizePixel = 0
        button.AutoButtonColor = false
        button.LayoutOrder = index
        button.Parent = self.Instance

        if self.FullWidth then
            button.Size = UDim2.new(1 / #self.Segments, -4, 1, 0)
        else
            button.Size = UDim2.new(0, 0, 1, 0)
            button.AutomaticSize = Enum.AutomaticSize.X
        end

        -- Corner
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 6)
        corner.Parent = button

        -- Padding
        local padding = Instance.new("UIPadding")
        padding.PaddingLeft = UDim.new(0, 12)
        padding.PaddingRight = UDim.new(0, 12)
        padding.Parent = button

        -- Content layout
        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        layout.Padding = UDim.new(0, 6)
        layout.Parent = button

        -- Icon (if provided)
        if segment.Icon then
            local icon = Instance.new("ImageLabel")
            icon.Name = "Icon"
            icon.Size = UDim2.new(0, 14, 0, 14)
            icon.BackgroundTransparency = 1
            icon.Image = segment.Icon
            icon.ImageColor3 = Color3.fromRGB(161, 161, 170)
            icon.LayoutOrder = 1
            icon.Parent = button
        end

        -- Text
        local text = Instance.new("TextLabel")
        text.Name = "Text"
        text.Size = UDim2.new(0, 0, 0, 0)
        text.AutomaticSize = Enum.AutomaticSize.XY
        text.BackgroundTransparency = 1
        text.Font = Enum.Font.GothamMedium
        text.Text = segment.Text or ""
        text.TextColor3 = Color3.fromRGB(161, 161, 170)
        text.TextSize = 13
        text.LayoutOrder = 2
        text.Parent = button

        -- Invisible click label
        local clickLabel = Instance.new("TextLabel")
        clickLabel.Name = "ClickLabel"
        clickLabel.Size = UDim2.new(1, 0, 1, 0)
        clickLabel.BackgroundTransparency = 1
        clickLabel.Text = ""
        clickLabel.Parent = button

        -- Click handler
        self:_connect(button.MouseButton1Click, function()
            self:SetSelectedIndex(index)
        end)

        -- Hover
        self:_connect(button.MouseEnter, function()
            if index ~= self.SelectedIndex then
                TweenService:Create(button, TweenInfo.new(0.15), {
                    BackgroundTransparency = 0.7,
                }):Play()
            end
        end)

        self:_connect(button.MouseLeave, function()
            if index ~= self.SelectedIndex then
                TweenService:Create(button, TweenInfo.new(0.15), {
                    BackgroundTransparency = 1,
                }):Play()
            end
        end)

        self._segmentButtons[index] = button
    end

    --// Update selection visual
    function SegmentedControl:_updateSelection(animate)
        animate = animate ~= false
        local duration = animate and 0.2 or 0

        for i, button in ipairs(self._segmentButtons) do
            local isSelected = i == self.SelectedIndex

            TweenService:Create(button, TweenInfo.new(duration), {
                BackgroundTransparency = isSelected and 0 or 1,
            }):Play()

            -- Update text color
            local text = button:FindFirstChild("Text")
            if text then
                TweenService:Create(text, TweenInfo.new(duration), {
                    TextColor3 = isSelected and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(161, 161, 170),
                }):Play()
            end

            -- Update icon color
            local icon = button:FindFirstChild("Icon")
            if icon then
                TweenService:Create(icon, TweenInfo.new(duration), {
                    ImageColor3 = isSelected and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(161, 161, 170),
                }):Play()
            end
        end
    end

    --// Set selected index
    function SegmentedControl:SetSelectedIndex(index)
        if index < 1 or index > #self.Segments then return self end
        if index == self.SelectedIndex then return self end

        local oldIndex = self.SelectedIndex
        self.SelectedIndex = index

        self:_updateSelection(true)

        local segment = self.Segments[index]

        if self.OnChange then
            self.OnChange(index, segment.Value or segment.Text, oldIndex)
        end

        self:_fire("Change", index, segment.Value or segment.Text, oldIndex)

        return self
    end

    --// Get selected index
    function SegmentedControl:GetSelectedIndex()
        return self.SelectedIndex
    end

    --// Get selected value
    function SegmentedControl:GetSelectedValue()
        local segment = self.Segments[self.SelectedIndex]
        return segment and (segment.Value or segment.Text)
    end

    --// Set segments
    function SegmentedControl:SetSegments(segments)
        -- Clear existing
        for _, button in ipairs(self._segmentButtons) do
            button:Destroy()
        end
        self._segmentButtons = {}

        self.Segments = segments
        self.SelectedIndex = 1

        -- Create new segments
        for i, segment in ipairs(segments) do
            self:_createSegment(i, segment)
        end

        self:_updateSelection(false)

        return self
    end

    return SegmentedControl


end


-- ============================================================================
-- Module: NexusUI/Components/TextArea
-- ============================================================================
NexusUI_Modules["NexusUI/Components/TextArea"] = function()
    local script = CreateMockScript("NexusUI/Components/TextArea")
    
    --[[
        NexusUI TextArea Component
        Multi-line text input
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// TextArea Component Module
    local TextArea = setmetatable({}, { __index = Base })
    TextArea.__index = TextArea
    TextArea.ClassName = "TextArea"

    --// Constructor
    function TextArea.new(config)
        local self = setmetatable(Base.new(config), TextArea)

        config = config or {}

        self.Text = config.Text or ""
        self.Placeholder = config.Placeholder or "Enter text..."
        self.MaxLength = config.MaxLength or -1
        self.MinLines = config.MinLines or 3
        self.MaxLines = config.MaxLines or 10
        self.ResizableY = config.ResizableY or false
        self.ShowCharCount = config.ShowCharCount or false
        self.ReadOnly = config.ReadOnly or false

        -- Callbacks
        self.OnTextChanged = config.OnTextChanged
        self.OnFocus = config.OnFocus
        self.OnFocusLost = config.OnFocusLost

        -- State
        self._isFocused = false

        return self
    end

    --// Create text area
    function TextArea:Create(parent)
        -- Calculate height based on min lines
        local lineHeight = 20
        local padding = 24
        local height = self.MinLines * lineHeight + padding

        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(1, 0, 0, height)
        container.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        container.BorderSizePixel = 0
        container.ClipsDescendants = true

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Corner
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = container

        -- Border
        local stroke = Instance.new("UIStroke")
        stroke.Color = Color3.fromRGB(63, 63, 70)
        stroke.Thickness = 1
        stroke.Parent = container
        self._stroke = stroke

        -- Padding
        local uiPadding = Instance.new("UIPadding")
        uiPadding.PaddingTop = UDim.new(0, 12)
        uiPadding.PaddingBottom = UDim.new(0, 12)
        uiPadding.PaddingLeft = UDim.new(0, 12)
        uiPadding.PaddingRight = UDim.new(0, 12)
        uiPadding.Parent = container

        -- Scrolling frame for text
        local scrollFrame = Instance.new("ScrollingFrame")
        scrollFrame.Name = "Scroll"
        scrollFrame.Size = UDim2.new(1, 0, 1, self.ShowCharCount and -20 or 0)
        scrollFrame.BackgroundTransparency = 1
        scrollFrame.BorderSizePixel = 0
        scrollFrame.ScrollBarThickness = 4
        scrollFrame.ScrollBarImageColor3 = Color3.fromRGB(82, 82, 91)
        scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
        scrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
        scrollFrame.Parent = container
        self._scrollFrame = scrollFrame

        -- Text box
        local textBox = Instance.new("TextBox")
        textBox.Name = "Input"
        textBox.Size = UDim2.new(1, -8, 0, 0)
        textBox.AutomaticSize = Enum.AutomaticSize.Y
        textBox.BackgroundTransparency = 1
        textBox.Font = Enum.Font.Gotham
        textBox.Text = self.Text
        textBox.PlaceholderText = self.Placeholder
        textBox.PlaceholderColor3 = Color3.fromRGB(113, 113, 122)
        textBox.TextColor3 = Color3.fromRGB(250, 250, 250)
        textBox.TextSize = 14
        textBox.TextXAlignment = Enum.TextXAlignment.Left
        textBox.TextYAlignment = Enum.TextYAlignment.Top
        textBox.TextWrapped = true
        textBox.MultiLine = true
        textBox.ClearTextOnFocus = false
        textBox.TextEditable = not self.ReadOnly
        textBox.Parent = scrollFrame
        self._textBox = textBox

        -- Character count
        if self.ShowCharCount then
            local charCount = Instance.new("TextLabel")
            charCount.Name = "CharCount"
            charCount.Size = UDim2.new(1, 0, 0, 16)
            charCount.Position = UDim2.new(0, 0, 1, -16)
            charCount.BackgroundTransparency = 1
            charCount.Font = Enum.Font.Gotham
            charCount.TextColor3 = Color3.fromRGB(113, 113, 122)
            charCount.TextSize = 11
            charCount.TextXAlignment = Enum.TextXAlignment.Right
            charCount.Parent = container
            self._charCount = charCount

            self:_updateCharCount()
        end

        -- Resize handle (if resizable)
        if self.ResizableY then
            local handle = Instance.new("Frame")
            handle.Name = "ResizeHandle"
            handle.Size = UDim2.new(1, 0, 0, 8)
            handle.Position = UDim2.new(0, 0, 1, 0)
            handle.AnchorPoint = Vector2.new(0, 1)
            handle.BackgroundTransparency = 1
            handle.Parent = container
            self._resizeHandle = handle

            -- Resize grip
            local grip = Instance.new("Frame")
            grip.Size = UDim2.new(0, 30, 0, 3)
            grip.Position = UDim2.new(0.5, 0, 0.5, 0)
            grip.AnchorPoint = Vector2.new(0.5, 0.5)
            grip.BackgroundColor3 = Color3.fromRGB(82, 82, 91)
            grip.BorderSizePixel = 0
            grip.Parent = handle

            local gripCorner = Instance.new("UICorner")
            gripCorner.CornerRadius = UDim.new(1, 0)
            gripCorner.Parent = grip
        end

        -- Setup interactions
        self:_setupInteractions()

        return self
    end

    --// Update character count
    function TextArea:_updateCharCount()
        if not self._charCount then return end

        local len = #self.Text

        if self.MaxLength > 0 then
            self._charCount.Text = len .. "/" .. self.MaxLength
            self._charCount.TextColor3 = len >= self.MaxLength and 
                Color3.fromRGB(239, 68, 68) or Color3.fromRGB(113, 113, 122)
        else
            self._charCount.Text = tostring(len)
        end
    end

    --// Setup interactions
    function TextArea:_setupInteractions()
        local textBox = self._textBox
        local stroke = self._stroke

        -- Focus
        self:_connect(textBox.Focused, function()
            self._isFocused = true

            TweenService:Create(stroke, TweenInfo.new(0.15), {
                Color = Color3.fromRGB(99, 102, 241),
            }):Play()

            TweenService:Create(self.Instance, TweenInfo.new(0.15), {
                BackgroundColor3 = Color3.fromRGB(35, 35, 42),
            }):Play()

            if self.OnFocus then
                self.OnFocus()
            end

            self:_fire("Focus")
        end)

        -- Focus lost
        self:_connect(textBox.FocusLost, function(enterPressed)
            self._isFocused = false

            TweenService:Create(stroke, TweenInfo.new(0.15), {
                Color = Color3.fromRGB(63, 63, 70),
            }):Play()

            TweenService:Create(self.Instance, TweenInfo.new(0.15), {
                BackgroundColor3 = Color3.fromRGB(30, 30, 35),
            }):Play()

            if self.OnFocusLost then
                self.OnFocusLost(enterPressed)
            end

            self:_fire("FocusLost", enterPressed)
        end)

        -- Text changed
        self:_connect(textBox:GetPropertyChangedSignal("Text"), function()
            local text = textBox.Text

            -- Max length
            if self.MaxLength > 0 and #text > self.MaxLength then
                textBox.Text = string.sub(text, 1, self.MaxLength)
                return
            end

            self.Text = text
            self:_updateCharCount()

            if self.OnTextChanged then
                self.OnTextChanged(text)
            end

            self:_fire("TextChanged", text)
        end)

        -- Hover
        self:_connect(self.Instance.MouseEnter, function()
            if not self._isFocused then
                TweenService:Create(stroke, TweenInfo.new(0.15), {
                    Color = Color3.fromRGB(82, 82, 91),
                }):Play()
            end
        end)

        self:_connect(self.Instance.MouseLeave, function()
            if not self._isFocused then
                TweenService:Create(stroke, TweenInfo.new(0.15), {
                    Color = Color3.fromRGB(63, 63, 70),
                }):Play()
            end
        end)
    end

    --// Set text
    function TextArea:SetText(text)
        self.Text = text

        if self._textBox then
            self._textBox.Text = text
        end

        self:_updateCharCount()

        return self
    end

    --// Get text
    function TextArea:GetText()
        return self.Text
    end

    --// Set placeholder
    function TextArea:SetPlaceholder(placeholder)
        self.Placeholder = placeholder

        if self._textBox then
            self._textBox.PlaceholderText = placeholder
        end

        return self
    end

    --// Focus
    function TextArea:Focus()
        if self._textBox then
            self._textBox:CaptureFocus()
        end
        return self
    end

    --// Clear
    function TextArea:Clear()
        return self:SetText("")
    end

    --// Set read only
    function TextArea:SetReadOnly(readOnly)
        self.ReadOnly = readOnly

        if self._textBox then
            self._textBox.TextEditable = not readOnly
        end

        return self
    end

    --// Get line count
    function TextArea:GetLineCount()
        local _, count = string.gsub(self.Text, "\n", "\n")
        return count + 1
    end

    return TextArea


end


-- ============================================================================
-- Module: NexusUI/Components/SearchInput
-- ============================================================================
NexusUI_Modules["NexusUI/Components/SearchInput"] = function()
    local script = CreateMockScript("NexusUI/Components/SearchInput")
    
    --[[
        NexusUI SearchInput Component
        Search input with icon and clear button
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// SearchInput Component Module
    local SearchInput = setmetatable({}, { __index = Base })
    SearchInput.__index = SearchInput
    SearchInput.ClassName = "SearchInput"

    --// Constructor
    function SearchInput.new(config)
        local self = setmetatable(Base.new(config), SearchInput)

        config = config or {}

        self.Text = config.Text or ""
        self.Placeholder = config.Placeholder or "Search..."
        self.DebounceTime = config.DebounceTime or 0.3
        self.ClearButton = config.ClearButton ~= false

        -- Callbacks
        self.OnSearch = config.OnSearch
        self.OnTextChanged = config.OnTextChanged
        self.OnClear = config.OnClear

        -- State
        self._debounceThread = nil

        return self
    end

    --// Create search input
    function SearchInput:Create(parent)
        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(1, 0, 0, 36)
        container.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        container.BorderSizePixel = 0

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Corner
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = container

        -- Border
        local stroke = Instance.new("UIStroke")
        stroke.Color = Color3.fromRGB(63, 63, 70)
        stroke.Thickness = 1
        stroke.Parent = container
        self._stroke = stroke

        -- Padding
        local padding = Instance.new("UIPadding")
        padding.PaddingLeft = UDim.new(0, 12)
        padding.PaddingRight = UDim.new(0, 12)
        padding.Parent = container

        -- Layout
        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.Padding = UDim.new(0, 8)
        layout.Parent = container

        -- Search icon
        local searchIcon = Instance.new("ImageLabel")
        searchIcon.Name = "SearchIcon"
        searchIcon.Size = UDim2.new(0, 16, 0, 16)
        searchIcon.BackgroundTransparency = 1
        searchIcon.Image = "rbxassetid://7072718929"
        searchIcon.ImageColor3 = Color3.fromRGB(113, 113, 122)
        searchIcon.LayoutOrder = 1
        searchIcon.Parent = container
        self._searchIcon = searchIcon

        -- Text box
        local textBox = Instance.new("TextBox")
        textBox.Name = "Input"
        textBox.Size = UDim2.new(1, -50, 1, 0)
        textBox.BackgroundTransparency = 1
        textBox.Font = Enum.Font.Gotham
        textBox.Text = self.Text
        textBox.PlaceholderText = self.Placeholder
        textBox.PlaceholderColor3 = Color3.fromRGB(113, 113, 122)
        textBox.TextColor3 = Color3.fromRGB(250, 250, 250)
        textBox.TextSize = 14
        textBox.TextXAlignment = Enum.TextXAlignment.Left
        textBox.ClearTextOnFocus = false
        textBox.LayoutOrder = 2
        textBox.Parent = container
        self._textBox = textBox

        -- Clear button
        if self.ClearButton then
            local clearBtn = Instance.new("ImageButton")
            clearBtn.Name = "ClearButton"
            clearBtn.Size = UDim2.new(0, 16, 0, 16)
            clearBtn.BackgroundTransparency = 1
            clearBtn.Image = "rbxassetid://7072725342"
            clearBtn.ImageColor3 = Color3.fromRGB(113, 113, 122)
            clearBtn.Visible = #self.Text > 0
            clearBtn.LayoutOrder = 3
            clearBtn.Parent = container
            self._clearButton = clearBtn

            self:_connect(clearBtn.MouseButton1Click, function()
                self:Clear()
                textBox:CaptureFocus()
            end)

            self:_connect(clearBtn.MouseEnter, function()
                TweenService:Create(clearBtn, TweenInfo.new(0.1), {
                    ImageColor3 = Color3.fromRGB(250, 250, 250),
                }):Play()
            end)

            self:_connect(clearBtn.MouseLeave, function()
                TweenService:Create(clearBtn, TweenInfo.new(0.1), {
                    ImageColor3 = Color3.fromRGB(113, 113, 122),
                }):Play()
            end)
        end

        -- Loading spinner (hidden by default)
        local spinner = Instance.new("ImageLabel")
        spinner.Name = "Spinner"
        spinner.Size = UDim2.new(0, 16, 0, 16)
        spinner.BackgroundTransparency = 1
        spinner.Image = "rbxassetid://6034818372"
        spinner.ImageColor3 = Color3.fromRGB(99, 102, 241)
        spinner.Visible = false
        spinner.LayoutOrder = 4
        spinner.Parent = container
        self._spinner = spinner

        -- Setup interactions
        self:_setupInteractions()

        return self
    end

    --// Setup interactions
    function SearchInput:_setupInteractions()
        local textBox = self._textBox
        local stroke = self._stroke

        -- Focus
        self:_connect(textBox.Focused, function()
            TweenService:Create(stroke, TweenInfo.new(0.15), {
                Color = Color3.fromRGB(99, 102, 241),
            }):Play()

            TweenService:Create(self._searchIcon, TweenInfo.new(0.15), {
                ImageColor3 = Color3.fromRGB(99, 102, 241),
            }):Play()
        end)

        -- Focus lost
        self:_connect(textBox.FocusLost, function(enterPressed)
            TweenService:Create(stroke, TweenInfo.new(0.15), {
                Color = Color3.fromRGB(63, 63, 70),
            }):Play()

            TweenService:Create(self._searchIcon, TweenInfo.new(0.15), {
                ImageColor3 = Color3.fromRGB(113, 113, 122),
            }):Play()

            -- Trigger search on enter
            if enterPressed and self.OnSearch then
                self.OnSearch(self.Text)
            end
        end)

        -- Text changed
        self:_connect(textBox:GetPropertyChangedSignal("Text"), function()
            local text = textBox.Text
            self.Text = text

            -- Update clear button
            if self._clearButton then
                self._clearButton.Visible = #text > 0
            end

            -- Callback
            if self.OnTextChanged then
                self.OnTextChanged(text)
            end

            -- Debounced search
            if self._debounceThread then
                task.cancel(self._debounceThread)
            end

            if self.OnSearch and #text > 0 then
                self._debounceThread = task.delay(self.DebounceTime, function()
                    self.OnSearch(text)
                end)
            end

            self:_fire("TextChanged", text)
        end)

        -- Hover
        self:_connect(self.Instance.MouseEnter, function()
            TweenService:Create(stroke, TweenInfo.new(0.15), {
                Color = Color3.fromRGB(82, 82, 91),
            }):Play()
        end)

        self:_connect(self.Instance.MouseLeave, function()
            if not textBox:IsFocused() then
                TweenService:Create(stroke, TweenInfo.new(0.15), {
                    Color = Color3.fromRGB(63, 63, 70),
                }):Play()
            end
        end)
    end

    --// Set text
    function SearchInput:SetText(text)
        self.Text = text

        if self._textBox then
            self._textBox.Text = text
        end

        return self
    end

    --// Get text
    function SearchInput:GetText()
        return self.Text
    end

    --// Clear
    function SearchInput:Clear()
        self.Text = ""

        if self._textBox then
            self._textBox.Text = ""
        end

        if self.OnClear then
            self.OnClear()
        end

        self:_fire("Clear")

        return self
    end

    --// Show loading
    function SearchInput:ShowLoading(show)
        if self._spinner then
            self._spinner.Visible = show

            if show then
                -- Spin animation
                task.spawn(function()
                    while self._spinner and self._spinner.Visible do
                        self._spinner.Rotation = self._spinner.Rotation + 10
                        task.wait(0.02)
                    end
                end)
            end
        end

        return self
    end

    --// Focus
    function SearchInput:Focus()
        if self._textBox then
            self._textBox:CaptureFocus()
        end
        return self
    end

    --// Destroy override
    function SearchInput:Destroy()
        if self._debounceThread then
            task.cancel(self._debounceThread)
        end

        Base.Destroy(self)
    end

    return SearchInput


end


-- ============================================================================
-- Module: NexusUI/Components/Sidebar
-- ============================================================================
NexusUI_Modules["NexusUI/Components/Sidebar"] = function()
    local script = CreateMockScript("NexusUI/Components/Sidebar")
    
    --[[
        NexusUI Sidebar Component
        Navigation sidebar with items
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// Sidebar Component Module
    local Sidebar = setmetatable({}, { __index = Base })
    Sidebar.__index = Sidebar
    Sidebar.ClassName = "Sidebar"

    --// Constructor
    function Sidebar.new(config)
        local self = setmetatable(Base.new(config), Sidebar)

        config = config or {}

        self.Items = config.Items or {} -- Array of {Id, Text, Icon, Badge, Disabled, SubItems}
        self.SelectedId = config.SelectedId
        self.Width = config.Width or 240
        self.Collapsible = config.Collapsible or false
        self.IsCollapsed = config.IsCollapsed or false
        self.CollapsedWidth = config.CollapsedWidth or 60
        self.Header = config.Header -- {Title, Logo}
        self.Footer = config.Footer -- Content for footer

        -- Callbacks
        self.OnItemSelect = config.OnItemSelect
        self.OnCollapse = config.OnCollapse

        -- State
        self._itemButtons = {}

        return self
    end

    --// Create sidebar
    function Sidebar:Create(parent)
        -- Container
        local sidebar = Instance.new("Frame")
        sidebar.Name = self.Name
        sidebar.Size = UDim2.new(0, self.IsCollapsed and self.CollapsedWidth or self.Width, 1, 0)
        sidebar.BackgroundColor3 = Color3.fromRGB(24, 24, 27)
        sidebar.BorderSizePixel = 0
        sidebar.ClipsDescendants = true

        if parent then
            sidebar.Parent = parent
        end

        self.Instance = sidebar

        -- Border
        local stroke = Instance.new("UIStroke")
        stroke.Color = Color3.fromRGB(63, 63, 70)
        stroke.Thickness = 1
        stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        stroke.Parent = sidebar

        -- Header
        if self.Header then
            local header = Instance.new("Frame")
            header.Name = "Header"
            header.Size = UDim2.new(1, 0, 0, 60)
            header.BackgroundTransparency = 1
            header.Parent = sidebar

            local headerPadding = Instance.new("UIPadding")
            headerPadding.PaddingLeft = UDim.new(0, 16)
            headerPadding.PaddingRight = UDim.new(0, 16)
            headerPadding.Parent = header

            local headerLayout = Instance.new("UIListLayout")
            headerLayout.FillDirection = Enum.FillDirection.Horizontal
            headerLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            headerLayout.Padding = UDim.new(0, 12)
            headerLayout.Parent = header

            if self.Header.Logo then
                local logo = Instance.new("ImageLabel")
                logo.Size = UDim2.new(0, 28, 0, 28)
                logo.BackgroundTransparency = 1
                logo.Image = self.Header.Logo
                logo.LayoutOrder = 1
                logo.Parent = header
                self._logo = logo
            end

            if self.Header.Title then
                local title = Instance.new("TextLabel")
                title.Name = "Title"
                title.Size = UDim2.new(1, -40, 1, 0)
                title.BackgroundTransparency = 1
                title.Font = Enum.Font.GothamBold
                title.Text = self.Header.Title
                title.TextColor3 = Color3.fromRGB(250, 250, 250)
                title.TextSize = 16
                title.TextXAlignment = Enum.TextXAlignment.Left
                title.TextTruncate = Enum.TextTruncate.AtEnd
                title.LayoutOrder = 2
                title.Visible = not self.IsCollapsed
                title.Parent = header
                self._title = title
            end

            -- Divider
            local divider = Instance.new("Frame")
            divider.Size = UDim2.new(1, -32, 0, 1)
            divider.Position = UDim2.new(0.5, 0, 0, 60)
            divider.AnchorPoint = Vector2.new(0.5, 0)
            divider.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
            divider.BorderSizePixel = 0
            divider.Parent = sidebar
        end

        -- Items container
        local itemsContainer = Instance.new("ScrollingFrame")
        itemsContainer.Name = "Items"
        itemsContainer.Size = UDim2.new(1, 0, 1, self.Header and -70 or -10)
        itemsContainer.Position = UDim2.new(0, 0, 0, self.Header and 70 or 10)
        itemsContainer.BackgroundTransparency = 1
        itemsContainer.BorderSizePixel = 0
        itemsContainer.ScrollBarThickness = 4
        itemsContainer.ScrollBarImageColor3 = Color3.fromRGB(82, 82, 91)
        itemsContainer.CanvasSize = UDim2.new(0, 0, 0, 0)
        itemsContainer.AutomaticCanvasSize = Enum.AutomaticSize.Y
        itemsContainer.Parent = sidebar
        self._itemsContainer = itemsContainer

        local itemsPadding = Instance.new("UIPadding")
        itemsPadding.PaddingTop = UDim.new(0, 4)
        itemsPadding.PaddingBottom = UDim.new(0, 4)
        itemsPadding.PaddingLeft = UDim.new(0, 8)
        itemsPadding.PaddingRight = UDim.new(0, 8)
        itemsPadding.Parent = itemsContainer

        local itemsLayout = Instance.new("UIListLayout")
        itemsLayout.Padding = UDim.new(0, 2)
        itemsLayout.SortOrder = Enum.SortOrder.LayoutOrder
        itemsLayout.Parent = itemsContainer

        -- Build items
        self:_buildItems()

        -- Collapse button
        if self.Collapsible then
            local collapseBtn = Instance.new("TextButton")
            collapseBtn.Name = "CollapseBtn"
            collapseBtn.Size = UDim2.new(0, 32, 0, 32)
            collapseBtn.Position = UDim2.new(1, -40, 0, 14)
            collapseBtn.BackgroundColor3 = Color3.fromRGB(63, 63, 70)
            collapseBtn.BackgroundTransparency = 1
            collapseBtn.BorderSizePixel = 0
            collapseBtn.Font = Enum.Font.GothamBold
            collapseBtn.Text = self.IsCollapsed and "›" or "‹"
            collapseBtn.TextColor3 = Color3.fromRGB(161, 161, 170)
            collapseBtn.TextSize = 18
            collapseBtn.AutoButtonColor = false
            collapseBtn.Parent = sidebar
            self._collapseBtn = collapseBtn

            local collapseBtnCorner = Instance.new("UICorner")
            collapseBtnCorner.CornerRadius = UDim.new(0, 6)
            collapseBtnCorner.Parent = collapseBtn

            self:_connect(collapseBtn.MouseButton1Click, function()
                self:ToggleCollapse()
            end)

            self:_connect(collapseBtn.MouseEnter, function()
                TweenService:Create(collapseBtn, TweenInfo.new(0.1), {
                    BackgroundTransparency = 0,
                }):Play()
            end)

            self:_connect(collapseBtn.MouseLeave, function()
                TweenService:Create(collapseBtn, TweenInfo.new(0.1), {
                    BackgroundTransparency = 1,
                }):Play()
            end)
        end

        return self
    end

    --// Build items
    function Sidebar:_buildItems()
        -- Clear existing
        for _, btn in ipairs(self._itemButtons) do
            btn:Destroy()
        end
        self._itemButtons = {}

        local function createItem(item, layoutOrder, depth)
            local isSelected = item.Id == self.SelectedId
            local isDisabled = item.Disabled

            local btn = Instance.new("TextButton")
            btn.Name = "Item_" .. item.Id
            btn.Size = UDim2.new(1, 0, 0, 40)
            btn.BackgroundColor3 = isSelected and Color3.fromRGB(99, 102, 241) or Color3.fromRGB(39, 39, 42)
            btn.BackgroundTransparency = isSelected and 0.9 or 1
            btn.BorderSizePixel = 0
            btn.Text = ""
            btn.AutoButtonColor = false
            btn.LayoutOrder = layoutOrder
            btn.Parent = self._itemsContainer

            local btnCorner = Instance.new("UICorner")
            btnCorner.CornerRadius = UDim.new(0, 6)
            btnCorner.Parent = btn

            local btnPadding = Instance.new("UIPadding")
            btnPadding.PaddingLeft = UDim.new(0, 12 + depth * 16)
            btnPadding.PaddingRight = UDim.new(0, 12)
            btnPadding.Parent = btn

            local btnLayout = Instance.new("UIListLayout")
            btnLayout.FillDirection = Enum.FillDirection.Horizontal
            btnLayout.VerticalAlignment = Enum.VerticalAlignment.Center
            btnLayout.Padding = UDim.new(0, 10)
            btnLayout.Parent = btn

            -- Icon
            if item.Icon then
                local icon = Instance.new("ImageLabel")
                icon.Size = UDim2.new(0, 18, 0, 18)
                icon.BackgroundTransparency = 1
                icon.Image = item.Icon
                icon.ImageColor3 = isSelected and Color3.fromRGB(99, 102, 241) or 
                    (isDisabled and Color3.fromRGB(82, 82, 91) or Color3.fromRGB(161, 161, 170))
                icon.LayoutOrder = 1
                icon.Parent = btn
            end

            -- Text
            if not self.IsCollapsed then
                local text = Instance.new("TextLabel")
                text.Size = UDim2.new(1, item.Badge and -46 or -18, 1, 0)
                text.BackgroundTransparency = 1
                text.Font = Enum.Font.GothamMedium
                text.Text = item.Text
                text.TextColor3 = isSelected and Color3.fromRGB(99, 102, 241) or 
                    (isDisabled and Color3.fromRGB(82, 82, 91) or Color3.fromRGB(250, 250, 250))
                text.TextSize = 13
                text.TextXAlignment = Enum.TextXAlignment.Left
                text.TextTruncate = Enum.TextTruncate.AtEnd
                text.LayoutOrder = 2
                text.Parent = btn

                -- Badge
                if item.Badge then
                    local badge = Instance.new("Frame")
                    badge.Size = UDim2.new(0, 0, 0, 18)
                    badge.AutomaticSize = Enum.AutomaticSize.X
                    badge.BackgroundColor3 = Color3.fromRGB(239, 68, 68)
                    badge.BorderSizePixel = 0
                    badge.LayoutOrder = 3
                    badge.Parent = btn

                    local badgeCorner = Instance.new("UICorner")
                    badgeCorner.CornerRadius = UDim.new(1, 0)
                    badgeCorner.Parent = badge

                    local badgePadding = Instance.new("UIPadding")
                    badgePadding.PaddingLeft = UDim.new(0, 6)
                    badgePadding.PaddingRight = UDim.new(0, 6)
                    badgePadding.Parent = badge

                    local badgeText = Instance.new("TextLabel")
                    badgeText.Size = UDim2.new(0, 0, 1, 0)
                    badgeText.AutomaticSize = Enum.AutomaticSize.X
                    badgeText.BackgroundTransparency = 1
                    badgeText.Font = Enum.Font.GothamBold
                    badgeText.Text = tostring(item.Badge)
                    badgeText.TextColor3 = Color3.fromRGB(255, 255, 255)
                    badgeText.TextSize = 10
                    badgeText.Parent = badge
                end
            end

            -- Interactions
            if not isDisabled then
                self:_connect(btn.MouseButton1Click, function()
                    self:SelectItem(item.Id)
                end)

                self:_connect(btn.MouseEnter, function()
                    if not isSelected then
                        TweenService:Create(btn, TweenInfo.new(0.1), {
                            BackgroundTransparency = 0.8,
                        }):Play()
                    end
                end)

                self:_connect(btn.MouseLeave, function()
                    if not isSelected then
                        TweenService:Create(btn, TweenInfo.new(0.1), {
                            BackgroundTransparency = 1,
                        }):Play()
                    end
                end)
            end

            table.insert(self._itemButtons, btn)

            return layoutOrder + 1
        end

        local layoutOrder = 0
        for _, item in ipairs(self.Items) do
            layoutOrder = createItem(item, layoutOrder, 0)

            -- Sub items
            if item.SubItems then
                for _, subItem in ipairs(item.SubItems) do
                    layoutOrder = createItem(subItem, layoutOrder, 1)
                end
            end
        end
    end

    --// Select item
    function Sidebar:SelectItem(itemId)
        if itemId == self.SelectedId then return self end

        local oldId = self.SelectedId
        self.SelectedId = itemId

        self:_buildItems()

        -- Find item data
        local itemData
        for _, item in ipairs(self.Items) do
            if item.Id == itemId then
                itemData = item
                break
            end
            if item.SubItems then
                for _, subItem in ipairs(item.SubItems) do
                    if subItem.Id == itemId then
                        itemData = subItem
                        break
                    end
                end
            end
        end

        if self.OnItemSelect then
            self.OnItemSelect(itemId, itemData, oldId)
        end

        self:_fire("ItemSelect", itemId, itemData, oldId)

        return self
    end

    --// Toggle collapse
    function Sidebar:ToggleCollapse()
        self.IsCollapsed = not self.IsCollapsed

        local targetWidth = self.IsCollapsed and self.CollapsedWidth or self.Width

        TweenService:Create(self.Instance, TweenInfo.new(0.2), {
            Size = UDim2.new(0, targetWidth, 1, 0),
        }):Play()

        if self._title then
            self._title.Visible = not self.IsCollapsed
        end

        if self._collapseBtn then
            self._collapseBtn.Text = self.IsCollapsed and "›" or "‹"
        end

        self:_buildItems()

        if self.OnCollapse then
            self.OnCollapse(self.IsCollapsed)
        end

        self:_fire("Collapse", self.IsCollapsed)

        return self
    end

    --// Set items
    function Sidebar:SetItems(items)
        self.Items = items
        self:_buildItems()
        return self
    end

    return Sidebar


end


-- ============================================================================
-- Module: NexusUI/Components/NumberInput
-- ============================================================================
NexusUI_Modules["NexusUI/Components/NumberInput"] = function()
    local script = CreateMockScript("NexusUI/Components/NumberInput")
    
    --[[
        NexusUI NumberInput Component
        Number input with increment/decrement buttons
    ]]

    --// Services
    local TweenService = game:GetService("TweenService")

    --// Dependencies
    local Base = NexusRequire("NexusUI/Base")

    --// NumberInput Component Module
    local NumberInput = setmetatable({}, { __index = Base })
    NumberInput.__index = NumberInput
    NumberInput.ClassName = "NumberInput"

    --// Constructor
    function NumberInput.new(config)
        local self = setmetatable(Base.new(config), NumberInput)

        config = config or {}

        self.Value = config.Value or 0
        self.Min = config.Min or -math.huge
        self.Max = config.Max or math.huge
        self.Step = config.Step or 1
        self.Precision = config.Precision or 0 -- Decimal places
        self.Label = config.Label
        self.Prefix = config.Prefix or ""
        self.Suffix = config.Suffix or ""
        self.ShowButtons = config.ShowButtons ~= false

        -- Callbacks
        self.OnValueChanged = config.OnValueChanged

        -- State
        self._holdThread = nil

        return self
    end

    --// Format value
    function NumberInput:_formatValue(value)
        local formatted = string.format("%." .. self.Precision .. "f", value)
        return self.Prefix .. formatted .. self.Suffix
    end

    --// Create number input
    function NumberInput:Create(parent)
        -- Container
        local container = Instance.new("Frame")
        container.Name = self.Name
        container.Size = UDim2.new(1, 0, 0, 40)
        container.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        container.BorderSizePixel = 0

        if parent then
            container.Parent = parent
        end

        self.Instance = container

        -- Corner
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = container

        -- Border
        local stroke = Instance.new("UIStroke")
        stroke.Color = Color3.fromRGB(63, 63, 70)
        stroke.Thickness = 1
        stroke.Parent = container
        self._stroke = stroke

        -- Layout
        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.Parent = container

        -- Decrement button
        if self.ShowButtons then
            local decrementBtn = Instance.new("TextButton")
            decrementBtn.Name = "Decrement"
            decrementBtn.Size = UDim2.new(0, 40, 1, 0)
            decrementBtn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
            decrementBtn.BorderSizePixel = 0
            decrementBtn.Font = Enum.Font.GothamBold
            decrementBtn.Text = "-"
            decrementBtn.TextColor3 = Color3.fromRGB(250, 250, 250)
            decrementBtn.TextSize = 18
            decrementBtn.AutoButtonColor = false
            decrementBtn.LayoutOrder = 1
            decrementBtn.Parent = container
            self._decrementBtn = decrementBtn

            local decCorner = Instance.new("UICorner")
            decCorner.CornerRadius = UDim.new(0, 8)
            decCorner.Parent = decrementBtn

            -- Only round left corners
            local decFix = Instance.new("Frame")
            decFix.Size = UDim2.new(0.5, 0, 1, 0)
            decFix.Position = UDim2.new(0.5, 0, 0, 0)
            decFix.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
            decFix.BorderSizePixel = 0
            decFix.ZIndex = decrementBtn.ZIndex - 1
            decFix.Parent = decrementBtn
        end

        -- Text input
        local textBox = Instance.new("TextBox")
        textBox.Name = "Input"
        textBox.Size = self.ShowButtons and UDim2.new(1, -80, 1, 0) or UDim2.new(1, 0, 1, 0)
        textBox.BackgroundTransparency = 1
        textBox.Font = Enum.Font.GothamMedium
        textBox.Text = self:_formatValue(self.Value)
        textBox.TextColor3 = Color3.fromRGB(250, 250, 250)
        textBox.TextSize = 14
        textBox.ClearTextOnFocus = false
        textBox.LayoutOrder = 2
        textBox.Parent = container
        self._textBox = textBox

        -- Increment button
        if self.ShowButtons then
            local incrementBtn = Instance.new("TextButton")
            incrementBtn.Name = "Increment"
            incrementBtn.Size = UDim2.new(0, 40, 1, 0)
            incrementBtn.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
            incrementBtn.BorderSizePixel = 0
            incrementBtn.Font = Enum.Font.GothamBold
            incrementBtn.Text = "+"
            incrementBtn.TextColor3 = Color3.fromRGB(250, 250, 250)
            incrementBtn.TextSize = 18
            incrementBtn.AutoButtonColor = false
            incrementBtn.LayoutOrder = 3
            incrementBtn.Parent = container
            self._incrementBtn = incrementBtn

            local incCorner = Instance.new("UICorner")
            incCorner.CornerRadius = UDim.new(0, 8)
            incCorner.Parent = incrementBtn

            -- Only round right corners
            local incFix = Instance.new("Frame")
            incFix.Size = UDim2.new(0.5, 0, 1, 0)
            incFix.Position = UDim2.new(0, 0, 0, 0)
            incFix.BackgroundColor3 = Color3.fromRGB(39, 39, 42)
            incFix.BorderSizePixel = 0
            incFix.ZIndex = incrementBtn.ZIndex - 1
            incFix.Parent = incrementBtn
        end

        -- Setup interactions
        self:_setupInteractions()

        return self
    end

    --// Setup interactions
    function NumberInput:_setupInteractions()
        local textBox = self._textBox

        -- Text box focus lost
        self:_connect(textBox.FocusLost, function(enterPressed)
            local text = textBox.Text

            -- Remove prefix/suffix and parse
            text = string.gsub(text, "^" .. self.Prefix, "")
            text = string.gsub(text, self.Suffix .. "$", "")

            local num = tonumber(text)
            if num then
                self:SetValue(num)
            else
                textBox.Text = self:_formatValue(self.Value)
            end
        end)

        -- Button interactions
        if self.ShowButtons then
            -- Decrement
            self:_connect(self._decrementBtn.MouseButton1Click, function()
                self:Decrement()
            end)

            self:_connect(self._decrementBtn.MouseButton1Down, function()
                self:_startHold(-1)
            end)

            self:_connect(self._decrementBtn.MouseButton1Up, function()
                self:_stopHold()
            end)

            self:_connect(self._decrementBtn.MouseLeave, function()
                self:_stopHold()
            end)

            -- Increment
            self:_connect(self._incrementBtn.MouseButton1Click, function()
                self:Increment()
            end)

            self:_connect(self._incrementBtn.MouseButton1Down, function()
                self:_startHold(1)
            end)

            self:_connect(self._incrementBtn.MouseButton1Up, function()
                self:_stopHold()
            end)

            self:_connect(self._incrementBtn.MouseLeave, function()
                self:_stopHold()
            end)

            -- Hover effects
            local function setupButtonHover(btn)
                self:_connect(btn.MouseEnter, function()
                    TweenService:Create(btn, TweenInfo.new(0.15), {
                        BackgroundColor3 = Color3.fromRGB(52, 52, 58),
                    }):Play()
                end)

                self:_connect(btn.MouseLeave, function()
                    TweenService:Create(btn, TweenInfo.new(0.15), {
                        BackgroundColor3 = Color3.fromRGB(39, 39, 42),
                    }):Play()
                end)
            end

            setupButtonHover(self._decrementBtn)
            setupButtonHover(self._incrementBtn)
        end
    end

    --// Start hold (for continuous increment/decrement)
    function NumberInput:_startHold(direction)
        self:_stopHold()

        self._holdThread = task.spawn(function()
            task.wait(0.5) -- Initial delay

            while self._holdThread do
                if direction > 0 then
                    self:Increment()
                else
                    self:Decrement()
                end
                task.wait(0.1) -- Repeat rate
            end
        end)
    end

    --// Stop hold
    function NumberInput:_stopHold()
        if self._holdThread then
            task.cancel(self._holdThread)
            self._holdThread = nil
        end
    end

    --// Set value
    function NumberInput:SetValue(value, animate)
        value = math.clamp(value, self.Min, self.Max)

        -- Round to precision
        local multiplier = 10 ^ self.Precision
        value = math.round(value * multiplier) / multiplier

        if self.Value == value then return self end

        local oldValue = self.Value
        self.Value = value

        if self._textBox then
            self._textBox.Text = self:_formatValue(value)
        end

        if self.OnValueChanged then
            self.OnValueChanged(value, oldValue)
        end

        self:_fire("ValueChanged", value, oldValue)

        return self
    end

    --// Get value
    function NumberInput:GetValue()
        return self.Value
    end

    --// Increment
    function NumberInput:Increment(amount)
        return self:SetValue(self.Value + (amount or self.Step))
    end

    --// Decrement
    function NumberInput:Decrement(amount)
        return self:SetValue(self.Value - (amount or self.Step))
    end

    --// Set range
    function NumberInput:SetRange(min, max)
        self.Min = min
        self.Max = max
        self:SetValue(math.clamp(self.Value, min, max))
        return self
    end

    --// Destroy override
    function NumberInput:Destroy()
        self:_stopHold()
        Base.Destroy(self)
    end

    return NumberInput


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/init
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/init"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/init")
    
    --[[
        NexusUI Theme Presets
        25+ beautiful pre-built themes
    ]]

    --// Presets Module
    local Presets = {}

    -- Load all preset themes
    Presets.Dark = NexusRequire("NexusUI/Themes/Presets/Dark")
    Presets.Light = NexusRequire("NexusUI/Themes/Presets/Light")
    Presets.Midnight = NexusRequire("NexusUI/Themes/Presets/Midnight")
    Presets.Ocean = NexusRequire("NexusUI/Themes/Presets/Ocean")
    Presets.Forest = NexusRequire("NexusUI/Themes/Presets/Forest")
    Presets.Sunset = NexusRequire("NexusUI/Themes/Presets/Sunset")
    Presets.Neon = NexusRequire("NexusUI/Themes/Presets/Neon")
    Presets.Cyberpunk = NexusRequire("NexusUI/Themes/Presets/Cyberpunk")
    Presets.Synthwave = NexusRequire("NexusUI/Themes/Presets/Synthwave")
    Presets.Nord = NexusRequire("NexusUI/Themes/Presets/Nord")
    Presets.Dracula = NexusRequire("NexusUI/Themes/Presets/Dracula")
    Presets.Monokai = NexusRequire("NexusUI/Themes/Presets/Monokai")
    Presets.Gruvbox = NexusRequire("NexusUI/Themes/Presets/Gruvbox")
    Presets.TokyoNight = NexusRequire("NexusUI/Themes/Presets/TokyoNight")
    Presets.OneDark = NexusRequire("NexusUI/Themes/Presets/OneDark")
    Presets.Catppuccin = NexusRequire("NexusUI/Themes/Presets/Catppuccin")
    Presets.Rose = NexusRequire("NexusUI/Themes/Presets/Rose")
    Presets.Lavender = NexusRequire("NexusUI/Themes/Presets/Lavender")
    Presets.Mint = NexusRequire("NexusUI/Themes/Presets/Mint")
    Presets.Coral = NexusRequire("NexusUI/Themes/Presets/Coral")
    Presets.Golden = NexusRequire("NexusUI/Themes/Presets/Golden")
    Presets.Crimson = NexusRequire("NexusUI/Themes/Presets/Crimson")
    Presets.Arctic = NexusRequire("NexusUI/Themes/Presets/Arctic")
    Presets.Volcanic = NexusRequire("NexusUI/Themes/Presets/Volcanic")
    Presets.Matrix = NexusRequire("NexusUI/Themes/Presets/Matrix")

    -- Register all themes with manager
    function Presets.RegisterAll()
        local Manager = NexusRequire("NexusUI/Themes/Manager")

        for name, theme in pairs(Presets) do
            if type(theme) == "table" and theme.Name then
                Manager.RegisterTheme(theme)
            end
        end
    end

    -- Get all preset names
    function Presets.GetNames()
        local names = {}

        for name, theme in pairs(Presets) do
            if type(theme) == "table" and theme.Name then
                table.insert(names, name)
            end
        end

        return names
    end

    -- Get preset by name
    function Presets.Get(name)
        return Presets[name]
    end

    return Presets


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Gruvbox
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Gruvbox"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Gruvbox")
    
    --[[
        NexusUI Gruvbox Theme
        Retro groove color scheme
    ]]

    return {
        Name = "Gruvbox",

        Colors = {
            Primary = Color3.fromRGB(215, 153, 33),
            PrimaryHover = Color3.fromRGB(250, 189, 47),
            PrimaryPressed = Color3.fromRGB(180, 125, 25),
            PrimaryFaded = Color3.fromRGB(102, 92, 84),

            Secondary = Color3.fromRGB(146, 131, 116),
            SecondaryHover = Color3.fromRGB(168, 153, 132),
            SecondaryPressed = Color3.fromRGB(124, 111, 100),

            Accent = Color3.fromRGB(211, 134, 155),
            AccentHover = Color3.fromRGB(230, 165, 185),
            AccentPressed = Color3.fromRGB(177, 98, 134),

            Background = Color3.fromRGB(40, 40, 40),
            BackgroundAlt = Color3.fromRGB(50, 48, 47),
            BackgroundElevated = Color3.fromRGB(60, 56, 54),
            BackgroundFloating = Color3.fromRGB(80, 73, 69),

            Surface = Color3.fromRGB(50, 48, 47),
            SurfaceHover = Color3.fromRGB(80, 73, 69),
            SurfaceActive = Color3.fromRGB(102, 92, 84),

            Border = Color3.fromRGB(80, 73, 69),
            BorderFocused = Color3.fromRGB(215, 153, 33),
            BorderError = Color3.fromRGB(204, 36, 29),

            Text = Color3.fromRGB(235, 219, 178),
            TextSecondary = Color3.fromRGB(189, 174, 147),
            TextMuted = Color3.fromRGB(146, 131, 116),
            TextInverse = Color3.fromRGB(40, 40, 40),

            Success = Color3.fromRGB(152, 151, 26),
            SuccessHover = Color3.fromRGB(184, 187, 38),
            Warning = Color3.fromRGB(215, 153, 33),
            WarningHover = Color3.fromRGB(250, 189, 47),
            Error = Color3.fromRGB(204, 36, 29),
            ErrorHover = Color3.fromRGB(251, 73, 52),
            Info = Color3.fromRGB(69, 133, 136),
            InfoHover = Color3.fromRGB(131, 165, 152),

            Overlay = Color3.fromRGB(28, 28, 28),
            OverlayTransparency = 0.4,
            Shadow = Color3.fromRGB(28, 28, 28),
            ShadowTransparency = 0.5,
            Glow = Color3.fromRGB(215, 153, 33),
            GlowTransparency = 0.7,

            ScrollbarTrack = Color3.fromRGB(60, 56, 54),
            ScrollbarThumb = Color3.fromRGB(215, 153, 33),
            ScrollbarThumbHover = Color3.fromRGB(250, 189, 47),
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Golden
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Golden"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Golden")
    
    --[[
        NexusUI Golden Theme
        Luxurious gold and black theme
    ]]

    return {
        Name = "Golden",

        Colors = {
            Primary = Color3.fromRGB(245, 158, 11),
            PrimaryHover = Color3.fromRGB(251, 191, 36),
            PrimaryPressed = Color3.fromRGB(217, 119, 6),
            PrimaryFaded = Color3.fromRGB(120, 53, 15),

            Secondary = Color3.fromRGB(113, 113, 122),
            SecondaryHover = Color3.fromRGB(161, 161, 170),
            SecondaryPressed = Color3.fromRGB(82, 82, 91),

            Accent = Color3.fromRGB(252, 211, 77),
            AccentHover = Color3.fromRGB(253, 224, 71),
            AccentPressed = Color3.fromRGB(234, 179, 8),

            Background = Color3.fromRGB(12, 10, 8),
            BackgroundAlt = Color3.fromRGB(22, 18, 14),
            BackgroundElevated = Color3.fromRGB(32, 26, 20),
            BackgroundFloating = Color3.fromRGB(44, 36, 28),

            Surface = Color3.fromRGB(22, 18, 14),
            SurfaceHover = Color3.fromRGB(44, 36, 28),
            SurfaceActive = Color3.fromRGB(60, 50, 38),

            Border = Color3.fromRGB(80, 65, 50),
            BorderFocused = Color3.fromRGB(245, 158, 11),
            BorderError = Color3.fromRGB(239, 68, 68),

            Text = Color3.fromRGB(255, 251, 235),
            TextSecondary = Color3.fromRGB(254, 243, 199),
            TextMuted = Color3.fromRGB(253, 230, 138),
            TextInverse = Color3.fromRGB(12, 10, 8),

            Success = Color3.fromRGB(34, 197, 94),
            SuccessHover = Color3.fromRGB(74, 222, 128),
            Warning = Color3.fromRGB(245, 158, 11),
            WarningHover = Color3.fromRGB(251, 191, 36),
            Error = Color3.fromRGB(239, 68, 68),
            ErrorHover = Color3.fromRGB(248, 113, 113),
            Info = Color3.fromRGB(59, 130, 246),
            InfoHover = Color3.fromRGB(96, 165, 250),

            Overlay = Color3.fromRGB(6, 5, 4),
            OverlayTransparency = 0.5,
            Shadow = Color3.fromRGB(6, 5, 4),
            ShadowTransparency = 0.4,
            Glow = Color3.fromRGB(245, 158, 11),
            GlowTransparency = 0.5,

            ScrollbarTrack = Color3.fromRGB(44, 36, 28),
            ScrollbarThumb = Color3.fromRGB(245, 158, 11),
            ScrollbarThumbHover = Color3.fromRGB(251, 191, 36),
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Mint
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Mint"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Mint")
    
    --[[
        NexusUI Mint Theme
        Fresh mint green theme
    ]]

    return {
        Name = "Mint",

        Colors = {
            Primary = Color3.fromRGB(52, 211, 153),
            PrimaryHover = Color3.fromRGB(110, 231, 183),
            PrimaryPressed = Color3.fromRGB(16, 185, 129),
            PrimaryFaded = Color3.fromRGB(6, 95, 70),

            Secondary = Color3.fromRGB(100, 116, 139),
            SecondaryHover = Color3.fromRGB(148, 163, 184),
            SecondaryPressed = Color3.fromRGB(71, 85, 105),

            Accent = Color3.fromRGB(45, 212, 191),
            AccentHover = Color3.fromRGB(94, 234, 212),
            AccentPressed = Color3.fromRGB(20, 184, 166),

            Background = Color3.fromRGB(12, 20, 18),
            BackgroundAlt = Color3.fromRGB(18, 32, 28),
            BackgroundElevated = Color3.fromRGB(24, 44, 38),
            BackgroundFloating = Color3.fromRGB(32, 58, 50),

            Surface = Color3.fromRGB(18, 32, 28),
            SurfaceHover = Color3.fromRGB(32, 58, 50),
            SurfaceActive = Color3.fromRGB(45, 75, 65),

            Border = Color3.fromRGB(55, 90, 78),
            BorderFocused = Color3.fromRGB(52, 211, 153),
            BorderError = Color3.fromRGB(239, 68, 68),

            Text = Color3.fromRGB(236, 253, 245),
            TextSecondary = Color3.fromRGB(167, 243, 208),
            TextMuted = Color3.fromRGB(110, 231, 183),
            TextInverse = Color3.fromRGB(12, 20, 18),

            Success = Color3.fromRGB(52, 211, 153),
            SuccessHover = Color3.fromRGB(110, 231, 183),
            Warning = Color3.fromRGB(234, 179, 8),
            WarningHover = Color3.fromRGB(250, 204, 21),
            Error = Color3.fromRGB(239, 68, 68),
            ErrorHover = Color3.fromRGB(248, 113, 113),
            Info = Color3.fromRGB(59, 130, 246),
            InfoHover = Color3.fromRGB(96, 165, 250),

            Overlay = Color3.fromRGB(6, 10, 9),
            OverlayTransparency = 0.5,
            Shadow = Color3.fromRGB(6, 10, 9),
            ShadowTransparency = 0.4,
            Glow = Color3.fromRGB(52, 211, 153),
            GlowTransparency = 0.6,

            ScrollbarTrack = Color3.fromRGB(32, 58, 50),
            ScrollbarThumb = Color3.fromRGB(52, 211, 153),
            ScrollbarThumbHover = Color3.fromRGB(110, 231, 183),
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/OneDark
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/OneDark"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/OneDark")
    
    --[[
        NexusUI One Dark Theme
        Atom's iconic dark color scheme
    ]]

    return {
        Name = "OneDark",

        Colors = {
            Primary = Color3.fromRGB(97, 175, 239),
            PrimaryHover = Color3.fromRGB(135, 200, 255),
            PrimaryPressed = Color3.fromRGB(70, 145, 210),
            PrimaryFaded = Color3.fromRGB(50, 90, 130),

            Secondary = Color3.fromRGB(92, 99, 112),
            SecondaryHover = Color3.fromRGB(125, 135, 150),
            SecondaryPressed = Color3.fromRGB(70, 75, 85),

            Accent = Color3.fromRGB(198, 120, 221),
            AccentHover = Color3.fromRGB(220, 160, 245),
            AccentPressed = Color3.fromRGB(165, 90, 185),

            Background = Color3.fromRGB(40, 44, 52),
            BackgroundAlt = Color3.fromRGB(49, 54, 64),
            BackgroundElevated = Color3.fromRGB(56, 62, 73),
            BackgroundFloating = Color3.fromRGB(66, 72, 85),

            Surface = Color3.fromRGB(49, 54, 64),
            SurfaceHover = Color3.fromRGB(66, 72, 85),
            SurfaceActive = Color3.fromRGB(80, 88, 102),

            Border = Color3.fromRGB(66, 72, 85),
            BorderFocused = Color3.fromRGB(97, 175, 239),
            BorderError = Color3.fromRGB(224, 108, 117),

            Text = Color3.fromRGB(171, 178, 191),
            TextSecondary = Color3.fromRGB(152, 159, 172),
            TextMuted = Color3.fromRGB(92, 99, 112),
            TextInverse = Color3.fromRGB(40, 44, 52),

            Success = Color3.fromRGB(152, 195, 121),
            SuccessHover = Color3.fromRGB(180, 215, 155),
            Warning = Color3.fromRGB(229, 192, 123),
            WarningHover = Color3.fromRGB(245, 215, 160),
            Error = Color3.fromRGB(224, 108, 117),
            ErrorHover = Color3.fromRGB(245, 145, 155),
            Info = Color3.fromRGB(86, 182, 194),
            InfoHover = Color3.fromRGB(125, 205, 215),

            Overlay = Color3.fromRGB(28, 31, 37),
            OverlayTransparency = 0.4,
            Shadow = Color3.fromRGB(28, 31, 37),
            ShadowTransparency = 0.5,
            Glow = Color3.fromRGB(97, 175, 239),
            GlowTransparency = 0.7,

            ScrollbarTrack = Color3.fromRGB(56, 62, 73),
            ScrollbarThumb = Color3.fromRGB(97, 175, 239),
            ScrollbarThumbHover = Color3.fromRGB(198, 120, 221),
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Matrix
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Matrix"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Matrix")
    
    --[[
        NexusUI Matrix Theme
        Iconic green-on-black matrix aesthetic
    ]]

    return {
        Name = "Matrix",

        Colors = {
            Primary = Color3.fromRGB(0, 255, 65),
            PrimaryHover = Color3.fromRGB(80, 255, 120),
            PrimaryPressed = Color3.fromRGB(0, 200, 50),
            PrimaryFaded = Color3.fromRGB(0, 80, 25),

            Secondary = Color3.fromRGB(60, 60, 60),
            SecondaryHover = Color3.fromRGB(90, 90, 90),
            SecondaryPressed = Color3.fromRGB(40, 40, 40),

            Accent = Color3.fromRGB(0, 180, 50),
            AccentHover = Color3.fromRGB(0, 220, 70),
            AccentPressed = Color3.fromRGB(0, 140, 40),

            Background = Color3.fromRGB(0, 0, 0),
            BackgroundAlt = Color3.fromRGB(8, 12, 8),
            BackgroundElevated = Color3.fromRGB(12, 18, 12),
            BackgroundFloating = Color3.fromRGB(16, 24, 16),

            Surface = Color3.fromRGB(8, 12, 8),
            SurfaceHover = Color3.fromRGB(16, 24, 16),
            SurfaceActive = Color3.fromRGB(24, 36, 24),

            Border = Color3.fromRGB(0, 80, 25),
            BorderFocused = Color3.fromRGB(0, 255, 65),
            BorderError = Color3.fromRGB(255, 50, 50),

            Text = Color3.fromRGB(0, 255, 65),
            TextSecondary = Color3.fromRGB(0, 200, 50),
            TextMuted = Color3.fromRGB(0, 140, 35),
            TextInverse = Color3.fromRGB(0, 0, 0),

            Success = Color3.fromRGB(0, 255, 65),
            SuccessHover = Color3.fromRGB(80, 255, 120),
            Warning = Color3.fromRGB(255, 230, 0),
            WarningHover = Color3.fromRGB(255, 240, 80),
            Error = Color3.fromRGB(255, 50, 50),
            ErrorHover = Color3.fromRGB(255, 100, 100),
            Info = Color3.fromRGB(0, 200, 255),
            InfoHover = Color3.fromRGB(80, 220, 255),

            Overlay = Color3.fromRGB(0, 0, 0),
            OverlayTransparency = 0.3,
            Shadow = Color3.fromRGB(0, 255, 65),
            ShadowTransparency = 0.9,
            Glow = Color3.fromRGB(0, 255, 65),
            GlowTransparency = 0.4,

            ScrollbarTrack = Color3.fromRGB(12, 18, 12),
            ScrollbarThumb = Color3.fromRGB(0, 255, 65),
            ScrollbarThumbHover = Color3.fromRGB(80, 255, 120),
        },

        -- Matrix-specific custom properties
        MatrixRain = true,
        GlitchEffect = true,
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/TokyoNight
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/TokyoNight"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/TokyoNight")
    
    --[[
        NexusUI Tokyo Night Theme
        Inspired by Tokyo city lights at night
    ]]

    return {
        Name = "TokyoNight",

        Colors = {
            Primary = Color3.fromRGB(122, 162, 247),
            PrimaryHover = Color3.fromRGB(157, 188, 255),
            PrimaryPressed = Color3.fromRGB(95, 135, 220),
            PrimaryFaded = Color3.fromRGB(65, 85, 135),

            Secondary = Color3.fromRGB(86, 95, 137),
            SecondaryHover = Color3.fromRGB(115, 125, 170),
            SecondaryPressed = Color3.fromRGB(65, 72, 104),

            Accent = Color3.fromRGB(187, 154, 247),
            AccentHover = Color3.fromRGB(210, 185, 255),
            AccentPressed = Color3.fromRGB(150, 120, 210),

            Background = Color3.fromRGB(26, 27, 38),
            BackgroundAlt = Color3.fromRGB(36, 40, 59),
            BackgroundElevated = Color3.fromRGB(41, 46, 66),
            BackgroundFloating = Color3.fromRGB(52, 59, 88),

            Surface = Color3.fromRGB(36, 40, 59),
            SurfaceHover = Color3.fromRGB(52, 59, 88),
            SurfaceActive = Color3.fromRGB(65, 72, 104),

            Border = Color3.fromRGB(52, 59, 88),
            BorderFocused = Color3.fromRGB(122, 162, 247),
            BorderError = Color3.fromRGB(247, 118, 142),

            Text = Color3.fromRGB(192, 202, 245),
            TextSecondary = Color3.fromRGB(169, 177, 214),
            TextMuted = Color3.fromRGB(86, 95, 137),
            TextInverse = Color3.fromRGB(26, 27, 38),

            Success = Color3.fromRGB(158, 206, 106),
            SuccessHover = Color3.fromRGB(185, 225, 145),
            Warning = Color3.fromRGB(224, 175, 104),
            WarningHover = Color3.fromRGB(245, 200, 140),
            Error = Color3.fromRGB(247, 118, 142),
            ErrorHover = Color3.fromRGB(255, 155, 175),
            Info = Color3.fromRGB(125, 207, 255),
            InfoHover = Color3.fromRGB(165, 225, 255),

            Overlay = Color3.fromRGB(18, 19, 28),
            OverlayTransparency = 0.4,
            Shadow = Color3.fromRGB(18, 19, 28),
            ShadowTransparency = 0.5,
            Glow = Color3.fromRGB(122, 162, 247),
            GlowTransparency = 0.7,

            ScrollbarTrack = Color3.fromRGB(41, 46, 66),
            ScrollbarThumb = Color3.fromRGB(122, 162, 247),
            ScrollbarThumbHover = Color3.fromRGB(187, 154, 247),
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Volcanic
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Volcanic"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Volcanic")
    
    --[[
        NexusUI Volcanic Theme
        Hot volcanic orange and dark theme
    ]]

    return {
        Name = "Volcanic",

        Colors = {
            Primary = Color3.fromRGB(251, 146, 60),
            PrimaryHover = Color3.fromRGB(253, 186, 116),
            PrimaryPressed = Color3.fromRGB(249, 115, 22),
            PrimaryFaded = Color3.fromRGB(154, 52, 18),

            Secondary = Color3.fromRGB(87, 83, 78),
            SecondaryHover = Color3.fromRGB(120, 113, 108),
            SecondaryPressed = Color3.fromRGB(68, 64, 60),

            Accent = Color3.fromRGB(239, 68, 68),
            AccentHover = Color3.fromRGB(248, 113, 113),
            AccentPressed = Color3.fromRGB(220, 38, 38),

            Background = Color3.fromRGB(15, 10, 8),
            BackgroundAlt = Color3.fromRGB(28, 18, 14),
            BackgroundElevated = Color3.fromRGB(42, 28, 22),
            BackgroundFloating = Color3.fromRGB(58, 38, 30),

            Surface = Color3.fromRGB(28, 18, 14),
            SurfaceHover = Color3.fromRGB(58, 38, 30),
            SurfaceActive = Color3.fromRGB(78, 52, 42),

            Border = Color3.fromRGB(100, 65, 52),
            BorderFocused = Color3.fromRGB(251, 146, 60),
            BorderError = Color3.fromRGB(239, 68, 68),

            Text = Color3.fromRGB(255, 247, 237),
            TextSecondary = Color3.fromRGB(254, 215, 170),
            TextMuted = Color3.fromRGB(253, 186, 116),
            TextInverse = Color3.fromRGB(15, 10, 8),

            Success = Color3.fromRGB(34, 197, 94),
            SuccessHover = Color3.fromRGB(74, 222, 128),
            Warning = Color3.fromRGB(251, 146, 60),
            WarningHover = Color3.fromRGB(253, 186, 116),
            Error = Color3.fromRGB(239, 68, 68),
            ErrorHover = Color3.fromRGB(248, 113, 113),
            Info = Color3.fromRGB(59, 130, 246),
            InfoHover = Color3.fromRGB(96, 165, 250),

            Overlay = Color3.fromRGB(8, 5, 4),
            OverlayTransparency = 0.5,
            Shadow = Color3.fromRGB(8, 5, 4),
            ShadowTransparency = 0.4,
            Glow = Color3.fromRGB(251, 146, 60),
            GlowTransparency = 0.5,

            ScrollbarTrack = Color3.fromRGB(58, 38, 30),
            ScrollbarThumb = Color3.fromRGB(251, 146, 60),
            ScrollbarThumbHover = Color3.fromRGB(253, 186, 116),
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Coral
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Coral"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Coral")
    
    --[[
        NexusUI Coral Theme
        Warm coral pink theme
    ]]

    return {
        Name = "Coral",

        Colors = {
            Primary = Color3.fromRGB(251, 113, 133),
            PrimaryHover = Color3.fromRGB(253, 164, 175),
            PrimaryPressed = Color3.fromRGB(244, 63, 94),
            PrimaryFaded = Color3.fromRGB(136, 19, 55),

            Secondary = Color3.fromRGB(120, 113, 108),
            SecondaryHover = Color3.fromRGB(168, 162, 158),
            SecondaryPressed = Color3.fromRGB(87, 83, 78),

            Accent = Color3.fromRGB(249, 115, 22),
            AccentHover = Color3.fromRGB(251, 146, 60),
            AccentPressed = Color3.fromRGB(234, 88, 12),

            Background = Color3.fromRGB(22, 16, 16),
            BackgroundAlt = Color3.fromRGB(35, 25, 25),
            BackgroundElevated = Color3.fromRGB(48, 34, 34),
            BackgroundFloating = Color3.fromRGB(62, 44, 44),

            Surface = Color3.fromRGB(35, 25, 25),
            SurfaceHover = Color3.fromRGB(62, 44, 44),
            SurfaceActive = Color3.fromRGB(80, 58, 58),

            Border = Color3.fromRGB(100, 70, 70),
            BorderFocused = Color3.fromRGB(251, 113, 133),
            BorderError = Color3.fromRGB(239, 68, 68),

            Text = Color3.fromRGB(255, 241, 242),
            TextSecondary = Color3.fromRGB(254, 205, 211),
            TextMuted = Color3.fromRGB(253, 164, 175),
            TextInverse = Color3.fromRGB(22, 16, 16),

            Success = Color3.fromRGB(34, 197, 94),
            SuccessHover = Color3.fromRGB(74, 222, 128),
            Warning = Color3.fromRGB(234, 179, 8),
            WarningHover = Color3.fromRGB(250, 204, 21),
            Error = Color3.fromRGB(239, 68, 68),
            ErrorHover = Color3.fromRGB(248, 113, 113),
            Info = Color3.fromRGB(59, 130, 246),
            InfoHover = Color3.fromRGB(96, 165, 250),

            Overlay = Color3.fromRGB(11, 8, 8),
            OverlayTransparency = 0.5,
            Shadow = Color3.fromRGB(11, 8, 8),
            ShadowTransparency = 0.4,
            Glow = Color3.fromRGB(251, 113, 133),
            GlowTransparency = 0.6,

            ScrollbarTrack = Color3.fromRGB(62, 44, 44),
            ScrollbarThumb = Color3.fromRGB(251, 113, 133),
            ScrollbarThumbHover = Color3.fromRGB(253, 164, 175),
        },
    }


end


-- ============================================================================
-- Module: NexusUI/Themes/Presets/Arctic
-- ============================================================================
NexusUI_Modules["NexusUI/Themes/Presets/Arctic"] = function()
    local script = CreateMockScript("NexusUI/Themes/Presets/Arctic")
    
    --[[
        NexusUI Arctic Theme
        Cold icy blue theme
    ]]

    return {
        Name = "Arctic",

        Colors = {
            Primary = Color3.fromRGB(147, 197, 253),
            PrimaryHover = Color3.fromRGB(191, 219, 254),
            PrimaryPressed = Color3.fromRGB(96, 165, 250),
            PrimaryFaded = Color3.fromRGB(30, 58, 138),

            Secondary = Color3.fromRGB(148, 163, 184),
            SecondaryHover = Color3.fromRGB(203, 213, 225),
            SecondaryPressed = Color3.fromRGB(100, 116, 139),

            Accent = Color3.fromRGB(125, 211, 252),
            AccentHover = Color3.fromRGB(186, 230, 253),
            AccentPressed = Color3.fromRGB(56, 189, 248),

            Background = Color3.fromRGB(8, 15, 25),
            BackgroundAlt = Color3.fromRGB(12, 24, 40),
            BackgroundElevated = Color3.fromRGB(18, 35, 58),
            BackgroundFloating = Color3.fromRGB(24, 48, 78),

            Surface = Color3.fromRGB(12, 24, 40),
            SurfaceHover = Color3.fromRGB(24, 48, 78),
            SurfaceActive = Color3.fromRGB(35, 65, 100),

            Border = Color3.fromRGB(45, 80, 120),
            BorderFocused = Color3.fromRGB(147, 197, 253),
            BorderError = Color3.fromRGB(239, 68, 68),

            Text = Color3.fromRGB(240, 249, 255),
            TextSecondary = Color3.fromRGB(186, 230, 253),
            TextMuted = Color3.fromRGB(125, 211, 252),
            TextInverse = Color3.fromRGB(8, 15, 25),

            Success = Color3.fromRGB(34, 197, 94),
            SuccessHover = Color3.fromRGB(74, 222, 128),
            Warning = Color3.fromRGB(234, 179, 8),
            WarningHover = Color3.fromRGB(250, 204, 21),
            Error = Color3.fromRGB(239, 68, 68),
            ErrorHover = Color3.fromRGB(248, 113, 113),
            Info = Color3.fromRGB(147, 197, 253),
            InfoHover = Color3.fromRGB(191, 219, 254),

            Overlay = Color3.fromRGB(4, 8, 13),
            OverlayTransparency = 0.5,
            Shadow = Color3.fromRGB(4, 8, 13),
            ShadowTransparency = 0.4,
            Glow = Color3.fromRGB(147, 197, 253),
            GlowTransparency = 0.6,

            ScrollbarTrack = Color3.fromRGB(24, 48, 78),
            ScrollbarThumb = Color3.fromRGB(147, 197, 253),
            ScrollbarThumbHover = Color3.fromRGB(191, 219, 254),
        },
    }


end


-- ============================================================================
-- Return the main NexusUI library
-- ============================================================================

return NexusRequire("NexusUI/init")
